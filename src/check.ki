import ast;
import parse;
import replacegenerics;
import tok;
import shp;
import u8ast;

deftype checkstate struct {
  im *identmap;
  loader fn[sym, opt[array[u8]]];

  modules array[shp[module]];
  modules_by_name hash[sym, module_id];

  instantiations array[shp[def_inst]];
  type_instantiations array[shp[deftype_inst]];

  deftypes array[shp[deftype_entry]];
  deftypes_by_name hash[sym, array[deftype_entry_id]];

  aliases array[shp[alias_entry]];
  aliases_by_name hash[sym, array[alias_entry_id]];

  defs array[shp[def_entry]];
  defs_by_name hash[sym, array[def_entry_id]];
};

// An index into checkstate's modules array.
deftype module_id size;
def `~` fn[size, module_id] = wrapconvert;

// An index into checkstate's instantiations array.
deftype def_inst_id size;

// An index into checkstate's type_instantiations array.
deftype deftype_inst_id size;
def `~` fn[size, deftype_inst_id] = wrapconvert;

// An index into checkstate's defs array.
deftype def_entry_id size;
def `~` fn[size, def_entry_id] = wrapconvert;

// An index into checkstate's deftypes array.
deftype deftype_entry_id size;
def `~` fn[size, deftype_entry_id] = wrapconvert;

// An index into checkstate's aliases array.
deftype alias_entry_id size;
def `~` fn[size, alias_entry_id] = wrapconvert;

func ref_module(cs *checkstate, id module_id) *module {
  return oo(ref(&cs->modules, id.~));
}

func ref_def_entry(cs *checkstate, id def_entry_id) *def_entry {
  return oo(ref(&cs->defs, id.~));
}

func ref_deftype_entry(cs *checkstate, id deftype_entry_id) *deftype_entry {
  return oo(ref(&cs->deftypes, id.~));
}

func ref_alias_entry(cs *checkstate, id alias_entry_id) *alias_entry {
  return oo(ref(&cs->aliases, id.~));
}

func ref_inst(cs *checkstate, id def_inst_id) *def_inst {
  return oo(ref(&cs->instantiations, id.~));
}

defenum module_process_state {
  Unprocessed void;
  Processing void;
  DoneProcessing void;
};

func `==`(a module_process_state, b module_process_state) bool {
  return enumnum(&a) == enumnum(&b);
}

deftype module struct {
  module_name sym;
  file ast_file;
  buf array[u8];
  process_state module_process_state;
  // vvv  Valid when process_state == DoneProcessing.  vvv
  defs array[def_entry_id];
  deftypes array[deftype_entry_id];
  aliases array[alias_entry_id];
};

deftype deftype_inst struct {
};

deftype deftype_entry struct {
  module_name sym;
  name sym;
  tl *ast_type_def;

  insts array[deftype_inst_id];
};

func mk(module_name sym, name sym, tl *ast_type_def) deftype_entry {
  return {module_name, name, tl, default()};
}

deftype alias_entry struct {
  module_name sym;
  alias_name sym;
  tl *ast_toplevel;
};

deftype def_inst struct {
  parms genparms;
};

deftype def_entry struct {
  module_name sym;
  def_name sym;
  tl *ast_toplevel;

  insts array[def_inst_id];
};

func mk(module_name sym, def_name sym, tl *ast_toplevel) def_entry {
  return {module_name, def_name, tl, default()};
}

func check_module(cs *checkstate, mod_name sym) bool {
  switch process_module(cs, mod_name) {
    case None(v): {
      return false;
    }
    case Has(id module_id): {
      mod *module = ref_module(cs, id);
      ndefs size = count(&mod->defs);
      for i size = 0; i < ndefs; i = i + 1 {
        if !ensure_def_checked(cs, get(&mod->defs, i)) {
          return false;
        }
      }

      ndeftypes size = count(&mod->deftypes);
      for i size = 0; i < ndeftypes; i = i + 1 {
        if !ensure_deftype_checked(cs, get(&mod->deftypes, i)) {
          return false;
        }
      }

      naliases size = count(&mod->aliases);
      for i size = 0; i < naliases; i = i + 1 {
        if !ensure_alias_checked(cs, get(&mod->aliases, i)) {
          return false;
        }
      }

      // I guess that's everything.
      // TODO: Check that access blocks point to an actual type?
      return true;
    }
  }
}

func find_matching_inst(cs *checkstate, insts *array[def_inst_id], parms *genparms) opt[def_inst_id] {
  n size = count(insts);
  for i size = 0; i < n; i = i + 1 {
    id def_inst_id = get(insts, i);
    inst *def_inst = ref_inst(cs, id);
    if parms_equal(cs, parms, &inst->parms) {
      return Has(id);
    }
  }
  return None();
}

func parms_equal(cs *checkstate, a *genparms, b *genparms) bool {
  return TODO();
}

func ensure_def_checked_with_parms(cs *checkstate, ent *def_entry, a *ast_def, parms genparms) bool {
  if case Has(id) = find_matching_inst(cs, &ent->insts, &parms) {
    return TODO();
  } else {
    return TODO();
  }
}

func ensure_def_checked(cs *checkstate, id def_entry_id) bool {
  ent *def_entry = ref_def_entry(cs, id);
  switch ent->tl {
    case &Def(a ast_def): {
      switch &a.generics {
        case &NoGenerics(v): {
          return ensure_def_checked_with_parms(cs, ent, &a, NoParms(void));
        }
        case &HasGenerics(v): {
          // We declare success -- we check non-generic defs.
          return true;
        }
      }
    }
    case &ExternDef(a ast_extern_def): {
      return TODO();
    }
    default: {
      ice(_u8("def_entry has invalid toplevel\n"));
      return fake();
    }
  }
}

func ensure_deftype_checked(cs *checkstate, id deftype_entry_id) bool {
  return TODO();
}

func ensure_alias_checked(cs *checkstate, id alias_entry_id) bool {
  return TODO();
}

func load_module(cs *checkstate, mod_name sym) opt[module_id] {
  switch lookup(&cs->modules_by_name, mod_name) {
    case Has(id module_id): {
      return Has(id);
    }
    case None(v): {
      switch (cs->loader)(mod_name) {
        case None(v2): {
          ERR(_u8("Could not open file for module "), lookup(cs->im, mod_name));
          return None();
        }
        case Has(arr array[u8]): {
          mod shp[module];
          oo(&mod)->process_state = Unprocessed(void);
          oo(&mod)->module_name = mod_name;
          oo(&mod)->buf = arr;
          p ps = make_ps(cs->im, data(&oo(&mod)->buf), count(&oo(&mod)->buf));
          if !parse_file(&p, &oo(&mod)->file) {
            ERR(_u8("Trouble parsing module "), lookup(cs->im, mod_name));
            return None();
          }
          mod_id module_id = ~count(&cs->modules);
          push(&cs->modules, mod);
          if !try_insert(&cs->modules_by_name, mod_name, mod_id) {
            ERR(_u8("ICE: modules_by_name already has name "), lookup(cs->im, mod_name));
            return None();
          }
          return Has(mod_id);
        }
      }
    }
  }
}

func process_module(cs *checkstate, mod_name sym) opt[module_id] {
  switch load_module(cs, mod_name) {
    case None(v): {
      return None();
    }
    case Has(id module_id): {
      mod *module = ref_module(cs, id);
      if mod->process_state == Unprocessed(void) {
         if !process_defs(cs, mod) {
           return None();
         }
      }
      return Has(id);
    }
  }
}

func process_defs(cs *checkstate, mod *module) bool {
  check_mutate(&mod->process_state, Unprocessed(void), Processing(void));
  if !process_toplevels(cs, mod, &mod->file.toplevels) {
    return false;
  }
  check_mutate(&mod->process_state, Processing(void), DoneProcessing(void));
  return true;
}

func add_def_entry(cs *checkstate,
                   module_name sym,
                   module_defs *array[def_entry_id],
                   ent shp[def_entry]) void {
  id def_entry_id = ~count(&cs->defs);
  push(&cs->defs, ent);
  arr *array[def_entry_id] = try_insert_lookup(
    &cs->defs_by_name, oo(ent)->def_name, default());
  push(arr, id);
  push(module_defs, id);
}

func process_toplevels(cs *checkstate,
                       mod *module,
                       toplevels *array[ast_toplevel]) bool {
  for i size = 0; i < count(toplevels); i = i + 1 {
    toplevel *ast_toplevel = ref(toplevels, i);
    switch toplevel {
      case &Import(a ast_import): {
        switch process_module(cs, a.name.value) {
          case None(v): {
            return false;
          }
          case Has(id module_id): {
            // Do nothing!  We've processed the module successfully.
          }
        }
      }
      case &Def(a ast_def): {
        ent shp[def_entry] = emshp(mk(mod->module_name, a.name.value, toplevel));
        add_def_entry(cs, mod->module_name, &mod->defs, ent);
      }
      case &ExternDef(a ast_extern_def): {
        ent shp[def_entry] = emshp(mk(mod->module_name, a.name.value, toplevel));
        add_def_entry(cs, mod->module_name, &mod->defs, ent);
      }
      case &TypeDef(a ast_type_def): {
        ent shp[deftype_entry] = emshp(mk(mod->module_name, a.name.value, &a));
        id deftype_entry_id = ~count(&cs->deftypes);
        push(&cs->deftypes, ent);
        arr *array[deftype_entry_id] = try_insert_lookup(
          &cs->deftypes_by_name, oo(ent)->name, default());
        push(arr, id);
        push(&mod->deftypes, id);
      }
      case &TypeAlias(a ast_type_alias): {
        ent shp[alias_entry] = emshp({mod->module_name, a.name.value, toplevel});
        id alias_entry_id = ~count(&cs->aliases);
        push(&cs->aliases, ent);
        arr *array[alias_entry_id] = try_insert_lookup(
          &cs->aliases_by_name, oo(ent)->alias_name, default());
        push(arr, id);
        push(&mod->aliases, id);
      }
      case &Access(a ast_access): {
        if !process_toplevels(cs, mod, &a.toplevels) {
          return false;
        }
      }
    }
  }
  return true;
}

func check_alias(cs *checkstate, ent *alias_entry) bool {
  // TODO: Everything.
  return faketrue;
}

func check_def(cs *checkstate, ent *def_entry) bool {
  // TODO: Finish implementing:
  //   - check def for name conflicts (if that's not handled elsehow)
  //   - check uniqueness of generic variable names
  //   - check that name/arity combination is unique

  switch ent->tl {
    case &Def(a ast_def): {
      if !check_generics_shadowing(cs, &a.generics) {
        return false;
      }

      /* TODO: Check for perfect def shadowing... _after_ we typecheck
      the rhs, because the type signature of the def is optional. */

      // TODO: Implement.
      //   - check sanity of typeexpr.
      //   - check rhs expr.
      //   - check that rhs expr can be statically evaled?
      //   - compute static eval dependency relationships?
      return faketrue;
    }
    case &ExternDef(a ast_extern_def): {
      // TODO: Implement.
      //   - Check sanity of typeexpr.
      //   - Check for shadowing.
      return faketrue;
    }
    default: {
      crash(_u8("check_def sees unexpected toplevel in def_entry."));
      return fake();
    }
  }
}

func check_generics_shadowing(cs *checkstate, g *ast_generics) bool {
  switch g {
    case &NoGenerics(v): { return true; }
    case &HasGenerics(a array[ast_ident]): {
      for i size = 0; i < count(&a); i = i + 1 {
        ival sym = ref(&a, i)->value;
        for j size = 0; j < i; j = j + 1 {
          if ival == ref(&a, j)->value {
            ERR(_u8("Generic params have duplicate name "), ival);
            return false;
          }
        }
        if scope_shadows(cs, ival) {
          ERR(_u8("Generic param externally shadows "), ival);
        }
      }
      return true;
    }
  }
}

func scope_shadows(cs *checkstate, name sym) bool {
  return has_key(&cs->defs_by_name, name) || has_key(&cs->deftypes_by_name, name)
    || has_key(&cs->aliases_by_name, name);
}

// TODO: Remove faketrue.
def faketrue bool = true;

func[T, U, V, W] ERR(x T, y U, z V, p W) void {
  ERR(cons(cons(x, y), cons(z, p)));
}

func[T, U, V] ERR(x T, y U, z V) void {
  ERR(cons(cons(x, y), z));
}

func[T, U] ERR(x T, y U) void {
  ERR(cons(x, y));
}

func[T] ERR(x T) void {
  print(Stderr(), to_u8str(x));
  print(Stderr(), _u8("\n"));
  fflush(Stderr());
}

func ice(msg array[u8]) void {
  x _ = _u8("ICE: ");
  append(&x, &msg);
  crash(x);
}