import ast;
import parse;
import tok;
import shp;

deftype checkstate struct {
  im *identmap;
  loader fn[sym, opt[array[u8]]];

  modules array[shp[module]];
  modules_by_name hash[sym, module_id];

  instantiations array[shp[def_inst]];

  defs array[shp[def_entry]];
  defs_by_name hash[sym, array[def_entry_id]];

  aliases array[shp[alias_entry]];
};

// An index into checkstate's modules array.
deftype module_id size;
def `~` fn[size, module_id] = wrapconvert;

// An index into checkstate's instantiations array.
deftype def_inst_id size;

// An index into checkstate's defs array.
deftype def_entry_id size;
def `~` fn[size, def_entry_id] = wrapconvert;

// An index into checkstate's aliases array.
deftype alias_entry_id size;
def `~` fn[size, alias_entry_id] = wrapconvert;

defenum module_process_state {
  Unprocessed void;
  Processing void;
  DoneProcessing void;
};

func `==`(a module_process_state, b module_process_state) bool {
  return enumnum(&a) == enumnum(&b);
}

deftype module struct {
  module_name sym;
  file ast_file;
  buf array[u8];
  process_state module_process_state;
  // vvv  Valid when process_state == DoneProcessing.  vvv
  defs array[def_entry_id];
  aliases array[alias_entry_id];
};

deftype def_inst struct {

};

deftype def_entry struct {
  module_name sym;
  def_name sym;
  tl *ast_toplevel;


  is_checked bool;
};

deftype alias_entry struct {
  module_name sym;
  defined_name sym;
};



func check_module(cs *checkstate, mod_name sym) bool {
  switch process_module(cs, mod_name) {
    case None(v): {
      return false;
    }
    case Has(id module_id): {
      mod *module = oo(ref(&cs->modules, id.~));
      for i size = 0; i < count(&mod->defs); i = i + 1 {
        ent *def_entry = oo(ref(&cs->defs, get(&mod->defs, i).~));
        if !check_def(cs, ent) {
          return false;
        }
      }
      // TODO: Check aliases too?  Or would they have been checked when we put them in a big table?
      return false;
    }
  }
}

func load_module(cs *checkstate, mod_name sym) opt[module_id] {
  switch lookup(&cs->modules_by_name, mod_name) {
    case Has(id module_id): {
      return Has(id);
    }
    case None(v): {
      switch (cs->loader)(mod_name) {
        case None(v2): {
          ERR(_u8("Could not open file for module "), lookup(cs->im, mod_name));
          return None();
        }
        case Has(arr array[u8]): {
          mod shp[module];
          oo(&mod)->process_state = Unprocessed(void);
          oo(&mod)->module_name = mod_name;
          oo(&mod)->buf = arr;
          p ps = make_ps(cs->im, data(&oo(&mod)->buf), count(&oo(&mod)->buf));
          if !parse_file(&p, &oo(&mod)->file) {
            ERR(_u8("Trouble parsing module "), lookup(cs->im, mod_name));
            return None();
          }
          mod_id module_id = ~count(&cs->modules);
          push(&cs->modules, mod);
          if !try_insert(&cs->modules_by_name, mod_name, mod_id) {
            ERR(_u8("ICE: modules_by_name already has name "), lookup(cs->im, mod_name));
            return None();
          }
          return Has(mod_id);
        }
      }
    }
  }
}

func process_module(cs *checkstate, mod_name sym) opt[module_id] {
  switch load_module(cs, mod_name) {
    case None(v): {
      return None();
    }
    case Has(id module_id): {
      mod *module = oo(get(&cs->modules, id.~));
      if mod->process_state == Unprocessed(void) {
         if !process_defs(cs, mod) {
           return None();
         }
      }
      return Has(id);
    }
  }
}

func process_defs(cs *checkstate, mod *module) bool {
  check_mutate(&mod->process_state, Unprocessed(void), Processing(void));
  if !process_toplevels(cs, mod, &mod->file.toplevels) {
    return false;
  }
  check_mutate(&mod->process_state, Processing(void), DoneProcessing(void));
  return true;
}

func add_def_entry(cs *checkstate,
                   module_name sym,
                   module_defs *array[def_entry_id],
                   ent shp[def_entry]) void {
  id def_entry_id = ~count(&cs->defs);
  push(&cs->defs, ent);
  arr *array[def_entry_id] = try_insert_lookup(
    &cs->defs_by_name, oo(ent)->def_name, default());
  push(arr, id);
  push(module_defs, id);
}

func process_toplevels(cs *checkstate,
                       mod *module,
                       toplevels *array[ast_toplevel]) bool {
  for i size = 0; i < count(toplevels); i = i + 1 {
    toplevel *ast_toplevel = ref(toplevels, i);
    switch toplevel {
      case &Import(a ast_import): {
        switch process_module(cs, a.name.value) {
          case None(v): {
            return false;
          }
          case Has(id module_id): {
            // Do nothing!  We've processed the module successfully.
          }
        }
      }
      case &Def(a ast_def): {
        ent shp[def_entry] = emshp({mod->module_name, a.name.value, toplevel, false});
        add_def_entry(cs, mod->module_name, &mod->defs, ent);
      }
      case &ExternDef(a ast_extern_def): {
        ent shp[def_entry] = emshp({mod->module_name, a.name.value, toplevel, false});
        add_def_entry(cs, mod->module_name, &mod->defs, ent);
      }
      case &TypeDef(a ast_type_def): {
        ent shp[def_entry] = emshp({mod->module_name, a.name.value, toplevel, false});
        add_def_entry(cs, mod->module_name, &mod->defs, ent);
      }
      case &TypeAlias(a ast_type_alias): {
        ent shp[alias_entry] = emshp({mod->module_name, a.name.value});
        id alias_entry_id = ~count(&cs->aliases);
        push(&cs->aliases, ent);
        push(&mod->aliases, id);
      }
      case &Access(a ast_access): {
        if !process_toplevels(cs, mod, &a.toplevels) {
          return false;
        }
      }
    }
  }
  return true;
}

func check_def(cs *checkstate, ent *def_entry) bool {
  // TODO: Finish implementing:
  //   - check def for name conflicts (if that's not handled elsehow)
  //   - check uniqueness of generic variable names
  //   - check that name/arity combination is unique

  switch ent->tl {
    case &Def(a ast_def): {
      if !check_generics(cs, &a.generics) {
        return false;
      }

      // TODO: Implement.
      //   - check sanity of typeexpr.
      //   - check rhs expr.
      //   - check that rhs expr can be statically evaled?
      //   - compute static eval dependency relationships?
      return faketrue;
    }
    case &ExternDef(a ast_extern_def): {
      // TODO: Implement.
      //   - Check sanity of typeexpr.
      return faketrue;
    }
    case &TypeDef(a ast_type_def): {
      if !check_generics(cs, &a.generics) {
        return false;
      }

      // TODO: Implement.
      //   - check rhs "type expr".
      //   - check that rhs "type expr" can be statically evaled.
      //   - compute static eval dependency relationships?
      return faketrue;
    }
    default: {
      crash(_u8("check_def sees unexpected toplevel in def_entry."));
      return fake();
    }
  }
}

func check_generics(cs *checkstate, g *ast_generics) bool {
  // TODO: Should we check generics for external name shadowing?
  switch g {
    case &NoGenerics(v): { return true; }
    case &HasGenerics(a array[ast_ident]): {
      for i size = 0; i < count(&a); i = i + 1 {
        ival sym = ref(&a, i)->value;
        for j size = 0; j < i; j = j + 1 {
          if ival == ref(&a, j)->value {
            ERR(_u8("Generics have duplicate name "), ival);
            return false;
          }
        }
      }
      return true;
    }
  }
}

// TODO: Remove faketrue.
def faketrue bool = true;

func[T, U] ERR(x T, y U) void {
  ERR(cons(x, y));
}

func[T] ERR(x T) void {
  print(Stderr(), to_u8str(x));
  print(Stderr(), _u8("\n"));
  fflush(Stderr());
}
