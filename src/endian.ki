deftype le_u32 struct {
  buf [4]u8;
};

func `~`(x u32) le_u32 {
  ret le_u32;
  ret.buf[0] = ~ (x & 0xFF);
  ret.buf[1] = ~ ((x >> 8) & 0xFF);
  ret.buf[2] = ~ ((x >> 16) & 0xFF);
  ret.buf[3] = ~ ((x >> 24) & 0xFF);
  return ret;
}

func `~`(x le_u32) u32 {
  ret u32 = ((~x.buf[0] | (@[u32]~x.buf[1] << 8)) | (@[u32]~x.buf[2] << 16)) | (@[u32]~x.buf[3] << 24);
  return ret;
}

deftype le_i32 struct {
  buf [4]u8;
};

func `~`(x i32) le_i32 {
  ret le_i32;
  ret.buf[0] = ~ (x & 0xFF);
  ret.buf[1] = ~ ((x >> 8) & 0xFF);
  ret.buf[2] = ~ ((x >> 16) & 0xFF);
  ret.buf[3] = ~ ((x >> 24) & 0xFF);
  return ret;
}

deftype le_u16 struct {
  buf [2]u8;
};

func `~`(x u16) le_u16 {
  ret le_u16;
  // TODO: s1 can't codegen a u16 numeric literal.  Likewise below.
  ff u16 = ~ @[u8] 0xFF;
  ret.buf[0] = ~ (x & ff);
  ret.buf[1] = ~ ((x >> ~ @[u8] 8) & ff);
  return ret;
}
