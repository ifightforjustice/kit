        Kit v0.00.2A.x

Current status:  "proto-Kit"

Definitions:
   s1: A compiler, written in C.  It can compile s2.  Located in trc/.
   s2: A compiler, written in proto-Kit-v0.00.1.x.  It can
       compile itself and s3.  Located in urc/.
   s3: A compiler, written in proto-Kit-v0.00.2.x.  It can
       compile itself.  Located in src/.
   s2-by-s1: s2, as compiled by s1.
   s2-self: s2, as compiled by s2.
   s3-by-s2: s3, as compiled by s2.
   s3-self: s3, as compiled by s3.

  BUILD INSTRUCTIONS

# Prerequisites: An x86 CPU.  Windows or Linux.  On Windows, MSVC
# 2013 or 2015 (something with basic C99 support) -- for example,
# run these commands from a "Developer Command Prompt for VS2015".
# On Linux, gcc with 32-bit support, which usually means some
# gcc-multilib package.  Maybe clang works too.

# Step 1. Build s1 -- creates executable "out.exe" (or "out")
   windows_build.bat  (or ./linux_build.sh)
# Step 2. Build s2 -- creates executable "s2.exe" (or "s2")
   windows_build_s2.bat  (or ./linux_build_s2.sh)
# Step 3. Build s3-by-s2
   cd src
   ..\s2 main && cl main.obj dummy.c /Fes3b /link /stack:0x100000,0x100000
     (or ../s2 --linux main && gcc -m32 main.o dummy.c -o s3b)
# Step 4. Build s3-self
   s3b main && cl main.obj dummy.c /Fes3 /link /stack:0x100000,0x100000
     (or ../s3 --linux main && gcc -m32 main.o dummy.c -o s3)
# Run parsing/typechecking+codegen tests.
   s3 --build  (or ./s3 --build)
# Step 5. If you wish, run s3-self on itself
   move main.obj old_main.obj
   s3 main
   sha1sum old_main.obj main.obj
# The sha1sums should match.

  DIRECTORY STRUCTURE

The current directory structure is:

   trc - s1, implemented in C.  Compiles s2.
   urc - s2, implemented in proto-Kit, v0.00.1.x.  Compiles s2 and s3.
   src - s3, implemented in proto-Kit, v0.00.2.x.  Compiles s3.
   examples - examples to run, disorganized junk

  COMMAND USAGE

"out" is the name of the s1 executable, "s2" is the name of the s2 executable, and "s3" is the name of the s3 executable.

   out --test    # runs tests.
   out <modulename>    # builds <modulename>.ki and its imports.
   s2    # runs parsing/typechecking tests without codegen.
   s2 --build    # runs parsing/typechecking tests with codegen.
   s2 <modulename>  # builds <modulename>.ki and its imports.
   s3 ...    # same as s2.

  PROJECT TIMELINE

Here's the project timeline:

   1. Parsing.  (DONE)
   2. Typechecking/name-resolving.  (DONE)
   3. Generate code, i.e. have a working compiler.  (DONE)
   4. Cleanup error messages to have useful source information. (BETTER)
   5. Cleanup the language to make it more usable. (GOOD ENOUGH)
      Wishlist (waiting for these features specifically needed):
       A. Structure / array initialization syntax. (DONE)
       B. Packed struct types.  (DON'T CARE for now -- use le_u32)
       C. Destructuring assignment.
       D. Incr/decr and "+="-type operators. (DONE in s2 but user-defined)
   6. Linux support. (DONE)
   7. Make a self-hosted implementation (adding improvements and
      fixes to the C implementation when useful). (DONE)
   8. Give the self-hosted implementation "respectable" codegen.
   9. Basic cleanup of the language.
      Wishlist:
       A. defstruct, no more naked structs.
       B. type aliases.
       C. a non-truncative conversion operator (prefix +).  (DONE in s2)
       D. negative integer literals.
       E. var keyword after variable.  (DONE)
       F. o8, o16, o32.  (DONE in s2)
       G. u64, i64, o64.
       H. a signed size type ("diff").  (DONE in s2)
       I. negation for o-verflow types.  (DONE in s2)
       J. smart move/allocate-in-the-spot semantics.
       K. scoped types or scoped vars.
       L. better syntax for defining copy/init/move/destroy.
       M. defer statements (or scoped statements).
       N. handlers for overflow errors.
       O. enum types with "default" values instead of zero-tag.
       P. cute enum syntax for voids.  (DONE in s2)
       Q. better type-checking, see-through-negation.
       R. explicit overloading/specialization.
       S. support for multiple calling conventions.
       T. cross-function goto statements of the IInd kind.
       U. capturing closures.
       V. actual modules/namespaces.
       W. pretentious quotes in the binaries.
       X. removal of pretentious quotes in the binaries.
       Y. field names in struct literals.
       Z. array literals (struct literals in an array place).  (DONE)

  ABOUT THE VERSIONS

s1's language, v0.00.1.x, is merely "C, with templates,
constructors and destructors, elementary encapsulation, tagged enum
types, no implicit conversions."  s2's, v0.00.2.x, is the same as
s1's, but with some basic convenience enhancements that should be
easy to backport to s1 -- the differences are described in
FEATURES.  s3's should soon become quite different from s2's.  The
expectation is that someday, s1 will be able to compile s3, and we
can skip s2.  (By that time, there might be an s4.)


