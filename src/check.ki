import ast;
import deferred;
import kitutil;
import parse;
import tok;
import typeexpr;
import shp;
import state;
import u8ast;

// This code does some typechecking.  See state.ki for types that maintain typechecking state.

func finish_checking(cs *checkstate, clq *clqueue) bool {
  while case Has(entry clqueue_entry) = popval(&clq->entries) {
    switch &entry {
      case &ClqDeftypeEntry(e clqueue_deftype_entry): {
        if !ensure_deftype_inst_checked(cs, clq, ref_deftype_entry(cs, e.ent_id), e.inst_id) {
          return false;
        }
      }
    }
  }
  return true;
}

func check_module(cs *checkstate, mod_name sym) bool {
  switch process_module(cs, mod_name) {
    case None(v): {
      return false;
    }
    case Has(id module_id): {
      mod *module = ref_module(cs, id);
      ndefs size = count(&mod->defs);
      for i size = 0; i < ndefs; i = i + 1 {
        if !ensure_def_checked(cs, get(&mod->defs, i)) {
          return false;
        }
      }

      ndeftypes size = count(&mod->deftypes);
      for i size = 0; i < ndeftypes; i = i + 1 {
        if !ensure_deftype_checked(cs, get(&mod->deftypes, i)) {
          return false;
        }
      }

      naliases size = count(&mod->aliases);
      for i size = 0; i < naliases; i = i + 1 {
        if !ensure_alias_checked(cs, get(&mod->aliases, i)) {
          return false;
        }
      }

      // I guess that's everything.
      // TODO: Check that access blocks point to an actual type?
      return true;
    }
  }
}

func find_matching_inst(cs *checkstate, insts *array[def_inst_id], parms *genparms) opt[def_inst_id] {
  n size = count(insts);
  for i size = 0; i < n; i = i + 1 {
    id def_inst_id = get(insts, i);
    inst *def_inst = ref_inst(cs, id);
    if parms_equal(cs, parms, &inst->parms) {
      return Has(id);
    }
  }
  return None();
}

func parms_equal(cs *checkstate, a *genparms, b *genparms) bool {
  if enumnum(a) != enumnum(b) {
    return false;
  }
  switch a {
    case &NoParms(v void): { return true; }
    case &HasParms(ah array[te_typeexpr]): {
      switch b {
        case &HasParms(bh array[te_typeexpr]): {
          return typeexpr_list_equal(cs, &ah, &bh);
        }
      }
    }
  }
}

func arity(parms *genparms) generics_arity {
  switch parms {
    case &NoParms(v void): { return NoParamsArity(void); }
    case &HasParms(arr array[te_typeexpr]): { return FiniteArity(~count(&arr)); }
  }
}

func convert_typefunc(cs *checkstate, a *ast_typeexpr, out *te_puretype) bool {
  switch a {
    case &Name(b ast_ident): {
      *out = TePureName(b.value);
      return true;
    }
    case &Unknown(b ast_unknown): {
      *out = TePureUnknown(void);
      return true;
    }
    default: {
      ERR(_u8("Fancy type expression '"), to_u8str(a), _u8("' in typefunc"));
      return false;
    }
  }
}

func convert_typeexpr_list(cs *checkstate, arr *array[ast_typeexpr], out *array[te_typeexpr]) bool {
  build array[te_typeexpr];
  n size = count(arr);
  for i size = 0; i < n; i = i + 1 {
    t te_typeexpr;
    if !convert_typeexpr(cs, ref(arr, i), &t) {
      return false;
    }
    push(&build, t);
  }
  *out = build;
  return true;
}

func convert_vardecl_list(cs *checkstate, arr *array[ast_vardecl], out *array[te_vardecl]) bool {
  build array[te_vardecl];
  n size = count(arr);
  for i size = 0; i < n; i = i + 1 {
    vd te_vardecl;
    if !convert_vardecl(cs, ref(arr, i), &vd) {
      return false;
    }
    push(&build, vd);
  }
  *out = build;
  return true;
}

func convert_vardecl(cs *checkstate, a *ast_vardecl, out *te_vardecl) bool {
  type te_typeexpr;
  if !convert_typeexpr(cs, &a->type, &type) {
    return false;
  }
  *out = {a->name.value, type};
  return true;
}

// TODO: Callers of this might expect this function to also lookup names, check arity, etc.  Or they need to do such things themselves.
func convert_typeexpr(cs *checkstate, a *ast_typeexpr, out *te_typeexpr) bool {
  switch a {
    case &Name(b ast_ident): {
      *out = TeName({b.value, None()});
      return true;
    }
    case &App(b ast_typeapp): {
      typefunc te_puretype;
      params array[te_typeexpr];
      if !(convert_typefunc(cs, oo(&b.typefunc), &typefunc)
           && convert_typeexpr_list(cs, &b.params, &params)) {
        return false;
      }
      *out = TeApp({embox(typefunc), params, None()});
      return true;
    }
    case &Struct(b ast_struct): {
      fields array[te_vardecl];
      if !convert_vardecl_list(cs, &b.fields, &fields) {
        return false;
      }
      *out = TeStruct({fields});
      return true;
    }
    case &Enum(b ast_enum): {
      constructors array[te_vardecl];
      if !convert_vardecl_list(cs, &b.constructors, &constructors) {
        return false;
      }
      *out = TeEnum({constructors});
      return true;
    }
    case &Union(b ast_union): {
      fields array[te_vardecl];
      if !convert_vardecl_list(cs, &b.fields, &fields) {
        return false;
      }
      *out = TeUnion({fields});
      return true;
    }
    case &Arraytype(b ast_arraytype): {
      count opt[u32];
      if case &Has(bo box[ast_expr]) = &b.count {
        num u32;
        if !fake_eval_arraytype_count(oo(&bo), &num) {
          return false;
        }
        count = Has(num);
      } else {
        count = None();
      }
      param box[te_typeexpr];
      if !convert_typeexpr(cs, oo(&b.param), oo(&param)) {
        return false;
      }
      *out = TeArraytype({count, param});
      return true;
    }
    case &Unknown(b ast_unknown): {
      *out = TeUnknown(void);
      return true;
    }
  }
}

func def_converted_typeexpr(cs *checkstate, ent *def_entry, out **te_typeexpr) bool {
  switch &ent->converted_typeexpr {
    case &NotComputed(v void): {
      ent->converted_typeexpr = BeganComputing();
      converted te_typeexpr;
      if !convert_typeexpr(cs, &ent->quick_typeexpr, &converted) {
        ent->converted_typeexpr = FailedComputation();
        return false;
      }
      ent->converted_typeexpr = Computed(converted);
      if case &Computed(te te_typeexpr) = &ent->converted_typeexpr {
        *out = &te;
      } else {
        crash(_u8("impossible converted_typeexpr"));
      }
      return true;
    }
    case &BeganComputing(v void): {
      ERR(_u8("recursively computing def's typeexpr"));
      return false;
    }
    case &FailedComputation(v void): {
      ERR(_u8("repeat of error in def_converted_typeexpr"));
      return false;
    }
    case &Computed(x te_typeexpr): {
      *out = &x;
      return true;
    }
  }
}

func deftype_converted_rhs(cs *checkstate, ent *deftype_entry, out **te_typeexpr) bool {
  switch &ent->rhs {
    case &NotComputed(v void): {
      ent->rhs = BeganComputing();
      a *ast_typeexpr = deftype_rhs_type(&ent->tl->rhs);
      converted te_typeexpr;
      if !convert_typeexpr(cs, a, &converted) {
        ent->rhs = FailedComputation();
        return false;
      }
      ent->rhs = Computed(converted);
      if case &Computed(te te_typeexpr) = &ent->rhs {
        *out = &te;
      } else {
        crash(_u8("impossible rhs"));
      }
      return true;
    }
    case &BeganComputing(v void): {
      ERR(_u8("recursively computing deftype's rhs"));
      return false;
    }
    case &FailedComputation(v void): {
      ERR(_u8("repeat of error in deftype_converted_rhs"));
      return false;
    }
    case &Computed(x te_typeexpr): {
      *out = &x;
      return true;
    }
  }
}

func alias_converted_rhs(cs *checkstate, ent *alias_entry, out **te_typeexpr) bool {
  return TODO();
}

func ensure_def_checked_with_parms(cs *checkstate, clq *clqueue, ent *def_entry, a *ast_def, parms *genparms) bool {
  // TODO: Do we know that the def's generics don't shadow something?
  check(arity(&a->generics) == arity(parms));

  if case Has(id) = find_matching_inst(cs, &ent->insts, parms) {
    // If we already have an inst, that means we made an inst.

    inst *def_inst = ref_inst(cs, id);
    if !inst->computed_type_computed {
      ERR(_u8("computing def's type arouses cyclic dependency"), lookup(cs->im, ent->def_name));
      return false;
    }

    return true;
  }

  id def_inst_id = add_inst(cs, mk(*parms, *a));
  inst *def_inst = ref_inst(cs, id);
  // TODO: We ignore is_export entirely.  Is it relevant at all?
  a = &inst->ast;

  ent_typeexpr *te_typeexpr;
  if !def_converted_typeexpr(cs, ent, &ent_typeexpr) {
    return false;
  }
  // TODO: We need to check exact name shadowing(?), typeexpr, and rhs.

  // Important:  We check the typeexpr first.  If that typeexpr cyclically refers to this def, we fail.  If there is no typeexpr, we need to compute it from the rhs (and that also needs to not depend cyclically on this def's own typeexpr).
  computed_complete bool;
  computed te_typeexpr;
  if !check_and_compute_typeexpr(cs, clq, &a->generics, &inst->parms, ent_typeexpr, &computed, &computed_complete) {
    return false;
  }
  check(computed_complete);
  props type_properties;
  if !compute_type_properties(cs, clq, &computed, &props) {
    return false;
  }
  inst->computed_type_computed = true;
  inst->computed_type = computed;
  inst->computed_type_properties = Has(props);

  // TODO: How do we know that a->generics doesn't shadow, doesn't self-shadow?
  complete_type te_typeexpr;
  if !check_expr(cs, &a->generics, &inst->parms, &inst->computed_type, &a->rhs, &complete_type) {
    return false;
  }
  return true;
}

func check_and_compute_typeexpr(cs *checkstate, clq *clqueue, g *ast_generics, parms *genparms, t *te_typeexpr, computed_out *te_typeexpr, computed_complete_out *bool) bool {
  switch t {
    case &TeName(a te_name): {
      if !check_and_compute_name_type(cs, clq, g, parms, &a, computed_out) {
        return false;
      }
      *computed_complete_out = true;
      return true;
    }
    case &TeApp(a te_typeapp): {
      return check_and_compute_app_type(cs, clq, g, parms, &a, computed_out, computed_complete_out);
    }
    case &TeStruct(a te_struct): {
      computed_fields_complete bool;
      computed_fields array[te_vardecl];
      if !help_check_fields(cs, clq, g, parms, &a.fields, &computed_fields, &computed_fields_complete) {
        return false;
      }
      *computed_out = TeStruct({computed_fields});
      *computed_complete_out = computed_fields_complete;
      return true;
    }
    case &TeEnum(a te_enum): {
      // TODO: For enums, field names are constructors.  Check shadowing?
      computed_constructors_complete bool;
      computed_constructors array[te_vardecl];
      if !help_check_fields(cs, clq, g, parms, &a.constructors, &computed_constructors, &computed_constructors_complete) {
        return false;
      }
      *computed_out = TeEnum({computed_constructors});
      *computed_complete_out = computed_constructors_complete;
      return true;
    }
    case &TeUnion(a te_union): {
      computed_fields_complete bool;
      computed_fields array[te_vardecl];
      if !help_check_fields(cs, clq, g, parms, &a.fields, &computed_fields, &computed_fields_complete) {
        return false;
      }
      *computed_out = TeUnion({computed_fields});
      *computed_complete_out = computed_fields_complete;
      return true;
    }
    case &TeArraytype(a te_arraytype): {
      param box[te_typeexpr];
      param_complete bool;
      if !check_and_compute_typeexpr(cs, clq, g, parms, oo(&a.param), oo(&param), &param_complete) {
        return false;
      }
      if case &Has(count u32) = &a.count {
        *computed_out = TeArraytype({Has(count), param});
        *computed_complete_out = param_complete;
        return true;
      } else {
        *computed_out = TeArraytype({None(), param});
        *computed_complete_out = false;
        return true;
      }
    }
    case &TeUnknown(v void): {
      *computed_out = TeUnknown(void);
      *computed_complete_out = false;
      return true;
    }
  }
}

func numeric_literal_to_u32(x *ast_numeric_literal, out *u32) bool {
  switch x {
    case &HexLiteral(a ast_hex_literal): {
      return convert_to_u32(16, &a.digits, out);
    }
    case &DecLiteral(a ast_dec_literal): {
      return convert_to_u32(10, &a.digits, out);
    }
  }
}

func convert_to_u32(base i8, digits *array[i8], out *u32) bool {
  check(base > 0);
  acc u32 = 0;
  n size = count(digits);
  for i size = 0; i < n; i = i + 1 {
    if !try_mul(acc, @[u32]~base, &acc) {
      return false;
    }
    if !try_add(acc, @[u32]~get(digits, i), &acc) {
      return false;
    }
  }
  *out = acc;
  return true;
}

func fake_eval_arraytype_count(x *ast_expr, count_out *u32) bool {
  // TODO: Remove this function and really evaluate an array's count expression.
  switch x {
    case &NumericLiteral(a ast_numeric_literal): {
      return numeric_literal_to_u32(&a, count_out);
    }
    default: {
      ERR(_u8("Array types (for now) must have a numeric literal for length (or _)."));
      return false;
    }
  }
}

func help_check_fields(cs *checkstate, clq *clqueue, g *ast_generics, parms *genparms, a *array[te_vardecl], computed_fields_out *array[te_vardecl], computed_fields_complete_out *bool) bool {
  n size = count(a);
  all_complete bool = true;
  all_computed array[te_vardecl];
  for i size = 0; i < n; i = i + 1 {
    decl *te_vardecl = ref(a, i);
    for j size = 0; j < i; j = j + 1 {
      if ref(a, j)->name == decl->name {
        ERR(_u8("Duplicate field name "), lookup(cs->im, decl->name));
        return false;
      }
    }
    complete bool;
    computed te_typeexpr;
    if !check_and_compute_typeexpr(cs, clq, g, parms, &decl->type, &computed, &complete) {
      return false;
    }
    all_complete = all_complete & complete;
    push(&all_computed, {decl->name, computed});
  }
  *computed_fields_out = all_computed;
  *computed_fields_complete_out = all_complete;
  return true;
}

func check_and_compute_name_type(cs *checkstate, clq *clqueue, g *ast_generics, parms *genparms, a *te_name, computed_out *te_typeexpr) bool {
  // Generic parameters have already been checked.  (I hope so.)
  if lookup_generic(g, parms, a->value, computed_out) {
    return true;
  }

  matching_alias opt[alias_entry_id];
  if !match_alias(cs, a->value, None(), &matching_alias) {
    // An error happened when looking up an alias (multiple matches?).
    return false;
  }
  matching_deftype opt[deftype_entry_id];
  if !match_deftype(cs, a->value, None(), &matching_deftype) {
    // An error happened when looking up a deftype (multiple matches?).
    return false;
  }

  if case Has(id) = matching_alias {
    if case Has(deftype_id) = matching_deftype {
      ERR(_u8("Both an alias and deftype match for name "), lookup(cs->im, a->value));
      return false;
    }
    np genparms = NoParms(void);
    return check_and_compute_alias_with_parms(cs, clq, ref_alias_entry(cs, id), &np, computed_out);
  } else {
    if case Has(id) = matching_deftype {
      np genparms = NoParms(void);
      inst_id deftype_inst_id = enqueue_deftype_inst(cs, clq, id, &np);
      *computed_out = TeName({a->value, Has({id, inst_id})});
      return true;
    } else {
      ERR(_u8("type name has no match "), lookup(cs->im, a->value));
      return false;
    }
  }
}

func check_and_compute_typeexpr_array(cs *checkstate, clq *clqueue, g *ast_generics, parms *genparms, t *array[te_typeexpr], computed_out *array[te_typeexpr], computed_complete_out *bool) bool {
  complete bool = true;
  computed array[te_typeexpr];
  n size = count(t);
  for i size = 0; i < n; i = i + 1 {
    c te_typeexpr;
    c_complete bool;
    if !check_and_compute_typeexpr(cs, clq, g, parms, ref(t, i), &c, &c_complete) {
      return false;
    }
    push(&computed, c);
    complete = complete & c_complete;
  }
  *computed_out = computed;
  *computed_complete_out = complete;
  return true;
}

func check_and_compute_app_type(cs *checkstate, clq *clqueue, g *ast_generics, parms *genparms, a *te_typeapp, computed_out *te_typeexpr, computed_complete_out *bool) bool {
  params_complete bool;
  params array[te_typeexpr];
  if !check_and_compute_typeexpr_array(cs, clq, g, parms, &a->params, &params, &params_complete) {
    return false;
  }

  switch oo(&a->typefunc) {
    case &TePureName(value sym): {
      matching_alias opt[alias_entry_id];
      if !match_alias(cs, value, Has(&params), &matching_alias) {
        return false;
      }
      matching_deftype opt[deftype_entry_id];
      if !match_deftype(cs, value, Has(&params), &matching_deftype) {
        return false;
      }

      if case Has(id) = matching_alias {
        if case Has(deftype_id) = matching_deftype {
          ERR(_u8("Both an alias and deftype match for name/params "), lookup(cs->im, value));
          return false;
        }
        if params_complete {
          hp genparms = HasParms(params);
          if !check_and_compute_alias_with_parms(cs, clq, ref_alias_entry(cs, id), &hp, computed_out) {
            return false;
          }
          *computed_complete_out = true;
          return true;
        } else {
          *computed_out = TeApp({embox(TePureName(value)), params, None()});
          *computed_complete_out = false;
          return true;
        }
      } else {
        if case Has(id) = matching_deftype {
          if params_complete {
            hp genparms = HasParms(params);
            inst_id deftype_inst_id = enqueue_deftype_inst(cs, clq, id, &hp);
            *computed_out = TeApp({embox(TePureName(value)), params, Has({id, inst_id})});
          } else {
            *computed_out = TeApp({embox(TePureName(value)), params, None()});
          }
          *computed_complete_out = params_complete;
          return true;
        } else {
          ERR(_u8("type name/params has no match "), lookup(cs->im, value));
          return false;
        }
      }
    }
    case &TePureUnknown(v void): {
      *computed_out = TeApp({embox(TePureUnknown(void)), params, None()});
      *computed_complete_out = false;
      return true;
    }
  }
}

func find_matching_alias_inst(cs *checkstate, insts *array[alias_inst_id], parms *genparms) opt[alias_inst_id] {
  n size = count(insts);
  for i size = 0; i < n; i = i + 1 {
    id alias_inst_id = get(insts, i);
    inst *alias_inst = ref_alias_inst(cs, id);
    if parms_equal(cs, parms, &inst->parms) {
      return Has(id);
    }
  }
  return None();
}

func check_and_compute_alias_with_parms(cs *checkstate, clq *clqueue, ent *alias_entry, parms *genparms, computed_out *te_typeexpr) bool {
  // TODO: How do we know the alias's generic parameters don't self-shadow, or shadow something else?

  if case Has(id) = find_matching_alias_inst(cs, &ent->insts, parms) {
    inst *alias_inst = ref_alias_inst(cs, id);
    // If we already have an inst, that means we made an inst.
    if case &Has(computed te_typeexpr) = &inst->expanded {
      // We already computed the expansion for these types!
      *computed_out = computed;
      return true;
    } else {
      // We're in the process of expanding this type.  We recursively expanded.
      ERR(_u8("Recursively expanding alias "), lookup(cs->im, ent->alias_name));
      return false;
    }
  }

  id alias_inst_id = add_alias_inst(cs, {*parms, None()});
  inst *alias_inst = ref_alias_inst(cs, id);

  ent_rhs *te_typeexpr;
  if !alias_converted_rhs(cs, ent, &ent_rhs) {
    return false;
  }

  complete bool;
  computed te_typeexpr;
  if !check_and_compute_typeexpr(cs, clq, &ent->tl->generics, &inst->parms, ent_rhs, &computed, &complete) {
    return false;
  }
  // There's no way an alias expansion can't be complete, because ast_unknown is disallowed when parsing its RHS (and the parms must be complete).
  check(complete);
  check(isNone(&inst->expanded));
  inst->expanded = Has(computed);
  *computed_out = computed;
  return true;
}

func arity_matches(a *ast_generics, params opt[*array[te_typeexpr]]) bool {
  ar generics_arity;
  if case Has(p) = params {
    ar = FiniteArity(~count(p));
  } else {
    ar = NoParamsArity(void);
  }
  lhs_arity generics_arity = arity(a);
  return lhs_arity == ar;
}

func match_deftype(cs *checkstate, name sym, params opt[*array[te_typeexpr]], out *opt[deftype_entry_id]) bool {
  if case Has(arr *array[deftype_entry_id]) = lookup_ref(&cs->deftypes_by_name, name) {
    n size = count(arr);
    match opt[deftype_entry_id];
    for i size = 0; i < n; i = i + 1 {
      id deftype_entry_id = get(arr, i);
      ent *_ = ref_deftype_entry(cs, id);
      if arity_matches(&ent->tl->generics, params) {
        if case Has(alt_id) = match {
          ERR(_u8("Multiple deftypes named '"), lookup(cs->im, name), _u8("' match arity"));
          return false;
        }
        match = Has(id);
      }
    }
    if case Has(id) = match {
      *out = match;
      return true;
    } else {
      return false;
    }
  } else {
    return false;
  }
}

func match_alias(cs *checkstate, name sym, params opt[*array[te_typeexpr]], out *opt[alias_entry_id]) bool {
  if case Has(arr *array[alias_entry_id]) = lookup_ref(&cs->aliases_by_name, name) {
    n size = count(arr);
    match opt[alias_entry_id];
    for i size = 0; i < n; i = i + 1 {
      id alias_entry_id = get(arr, i);
      ent *_ = ref_alias_entry(cs, id);
      if arity_matches(&ent->tl->generics, params) {
        if case Has(alt_id) = match {
          ERR(_u8("Multiple aliases named '"), lookup(cs->im, name), _u8("' match arity"));
          return false;
        }
        match = Has(id);
      }
    }
    if case Has(id) = match {
      *out = match;
      return true;
    } else {
      return false;
    }
  } else {
    return false;
  }
}

func find_generic(g *ast_generics, name sym) opt[size] {
  switch g {
    case &NoGenerics(v void): { return None(); }
    case &HasGenerics(a array[ast_ident]): {
      n size = count(&a);
      for i size = 0; i < n; i = i + 1 {
        if ref(&a, i)->value == name {
          return Has(i);
        }
      }
      return None();
    }
  }
}

// TODO: Does anybody use this?
func lookup_generic(g *ast_generics, parms *genparms, name sym, out *te_typeexpr) bool {
  switch g {
    case &NoGenerics(v): { return false; }
    case &HasGenerics(a array[ast_ident]): {
      n size = count(&a);
      for i size = 0; i < n; i = i + 1 {
        if ref(&a, i)->value == name {
          if case &HasParms(ps) = parms {
            *out = *ref(&ps, i);
            return true;
          } else {
            crash(_u8("non-matching parms"));
          }
        }
      }
      return false;
    }
  }
}

func check_expr(cs *checkstate, g *ast_generics, parms *genparms, pt *te_typeexpr, x *ast_expr, computed_out *te_typeexpr) bool {
  return TODO();
}

func ensure_def_checked(cs *checkstate, id def_entry_id) bool {
  ent *def_entry = ref_def_entry(cs, id);
  switch ent->tl {
    case &Def(a ast_def): {
      switch &a.generics {
        case &NoGenerics(v): {
          parms genparms = NoParms(void);
          clq clqueue;
          if !ensure_def_checked_with_parms(cs, &clq, ent, &a, &parms) {
            return false;
          }
          return finish_checking(cs, &clq);
        }
        case &HasGenerics(ig): {
          discard *te_typeexpr;
          if !def_converted_typeexpr(cs, ent, &discard) {
            return false;
          }
          // We declare success -- we check non-generic defs.
          // TODO: Somewhere we have to check def generics shadowing.
          return true;
        }
      }
    }
    case &ExternDef(a ast_extern_def): {
      ent_typeexpr *te_typeexpr;
      if !def_converted_typeexpr(cs, ent, &ent_typeexpr) {
        return false;
      }
      // TODO: We could check that function args for C calling convention functions are primitively copyable.
      // TODO: It is unclear that ast_extern_def defs should have a def_entry.
      np genparms = NoParms(void);
      ng ast_generics = NoGenerics(void);
      clq clqueue;
      computed_complete bool;
      computed te_typeexpr;
      if !check_and_compute_typeexpr(cs, &clq, &ng, &np, ent_typeexpr, &computed, &computed_complete) {
        return false;
      }
      // The parser shouldn't allow incomplete types.
      check(computed_complete);
      return finish_checking(cs, &clq);
    }
    default: {
      ice(_u8("def_entry has invalid toplevel\n"));
      return fake();
    }
  }
}

func find_matching_deftype_inst(cs *checkstate, insts *array[deftype_inst_id], parms *genparms) opt[deftype_inst_id] {
  n size = count(insts);
  for i size = 0; i < n; i = i + 1 {
    id deftype_inst_id = get(insts, i);
    inst *deftype_inst = ref_deftype_inst(cs, id);
    if parms_equal(cs, parms, &inst->parms) {
      return Has(id);
    }
  }
  return None();
}

func deftype_rhs_type(rhs *ast_type_def_rhs) *ast_typeexpr {
  switch rhs {
    case &TypeexprRhs(a): { return &a; }
    case &ClassexprRhs(a): { return &a.rhs_type; }
  }
}

func enqueue_deftype_inst(cs *checkstate, clq *clqueue, id deftype_entry_id, parms *genparms) deftype_inst_id {
  var res = ensure_deftype_inst(cs, ref_deftype_entry(cs, id), parms);
  if res.created {
    push(&clq->entries, ClqDeftypeEntry({id, res.id}));
  }
  return res.id;
}

func ensure_deftype_inst(cs *checkstate, ent *deftype_entry, parms *genparms) struct { id deftype_inst_id; created bool; } {
  check(arity(&ent->tl->generics) == arity(parms));
  if case Has(id) = find_matching_deftype_inst(cs, &ent->insts, parms) {
    return {id, false};
  }
  var id = add_deftype_inst(cs, {*parms, DidNotStartChecking(void), None()});
  return {id, true};
}

func compute_pack_properties(cs *checkstate, clq *clqueue, pack *te_instpack, out *type_properties) bool {
  if !ensure_deftype_inst_checked(cs, clq, ref_deftype_entry(cs, pack->ent_id), pack->inst_id) {
    return false;
  }
  inst *deftype_inst = ref_deftype_inst(cs, pack->inst_id);
  if case &Has(props) = &inst->properties {
    *out = props;
    return true;
  } else {
    ice(_u8("ensure_deftype_inst_checked did not compute properties."));
    return fake();
  }
}

// t had better be complete.
func compute_type_properties(cs *checkstate, clq *clqueue, t *te_typeexpr, out *type_properties) bool {
  switch t {
    case &TeName(a te_name): {
      if case &Has(p te_instpack) = &a.pack {
        return compute_pack_properties(cs, clq, &p, out);
      } else {
        crash(_u8("compute_type_properties called on packless name type."));
        return fake();
      }
    }
    case &TeApp(a te_typeapp): {
      if case &Has(pack te_instpack) = &a.pack {
        return compute_pack_properties(cs, clq, &pack, out);
      } else {
        ice(_u8("compute_type_properties called on packless app type."));
        return fake();
      }
    }
    case &TeStruct(a te_struct): {
      offset u32 = 0;
      max_alignment u32 = 1;
      init_trivial bool = true;
      move_trivial bool = true;
      copy_trivial bool = true;
      destroy_trivial bool = true;
      n size = count(&a.fields);
      for i size = 0; i < n; i = i + 1 {
        props type_properties;
        if !compute_type_properties(cs, clq, &ref(&a.fields, i)->type, &props) {
          return false;
        }
        offset = ceil_aligned(offset, props.flat_alignment);
        offset = offset + props.flat_size;
        max_alignment = max(max_alignment, props.flat_alignment);
        init_trivial = init_trivial & isTrivial(props.init_behavior);
        move_trivial = move_trivial & isTrivial(props.move_behavior);
        copy_trivial = copy_trivial & isTrivial(props.copy_behavior);
        destroy_trivial = destroy_trivial & isTrivial(props.destroy_behavior);
      }
      check(offset % max_alignment == 0);
      *out = {offset, max_alignment, trivialOrNot(init_trivial),
              trivialOrNot(move_trivial), trivialOrNot(copy_trivial),
              trivialOrNot(destroy_trivial)};
      return true;
    }
    case &TeEnum(a te_enum): {
      // TODO: This is deeply married to implementation-specific behavior.
      tag_size u32 = 4;
      max_size u32 = tag_size;
      max_alignment u32 = tag_size;
      init_trivial bool = true;
      move_trivial bool = true;
      copy_trivial bool = true;
      destroy_trivial bool = true;
      n size = count(&a.constructors);
      for i size = 0; i < n; i = i + 1 {
        props type_properties;
        if !compute_type_properties(cs, clq, &ref(&a.constructors, i)->type, &props) {
          return false;
        }
        tagged_size u32 = ceil_aligned(tag_size, props.flat_alignment) + props.flat_size;
        max_size = max(max_size, tagged_size);
        max_alignment = max(max_alignment, props.flat_alignment);
        init_trivial = init_trivial & isTrivial(props.init_behavior);
        move_trivial = move_trivial & isTrivial(props.move_behavior);
        copy_trivial = copy_trivial & isTrivial(props.copy_behavior);
        destroy_trivial = destroy_trivial & isTrivial(props.destroy_behavior);
      }
      // See TeUnion for explanation of final_size.
      final_size u32 = ceil_aligned(max_size, max_alignment);
      *out = {final_size, max_alignment, trivialOrNot(init_trivial),
              trivialOrNot(move_trivial), trivialOrNot(copy_trivial),
              trivialOrNot(destroy_trivial)};
      return true;
    }
    case &TeUnion(a te_union): {
      // This is very similar to TeEnum, but TeEnum will change and this will not.
      max_size u32 = 0;
      max_alignment u32 = 1;
      n size = count(&a.fields);
      for i size = 0; i < n; i = i + 1 {
        props type_properties;
        if !compute_type_properties(cs, clq, &ref(&a.fields, i)->type, &props) {
          return false;
        }
        max_size = max(max_size, props.flat_size);
        max_alignment = max(max_alignment, props.flat_alignment);
        if !(isTrivial(props.init_behavior) && isTrivial(props.move_behavior) && isTrivial(props.copy_behavior) && isTrivial(props.destroy_behavior)) {
          ERR(_u8("union type has non-trivial field"));
          return false;
        }
      }
      // Consider the case where you have a union of {uint32_t, uint32_t, uint32_t} and {uint64_t}.  We have alignment 8, thus we need size 16.
      final_size u32 = ceil_aligned(max_size, max_alignment);
      *out = {final_size, max_alignment, DerivedMethodTrivial(void),
              DerivedMethodTrivial(void), DerivedMethodTrivial(void),
              DerivedMethodTrivial(void)};
      return true;
    }
    case &TeArraytype(a te_arraytype): {
      if case Has(c u32) = a.count {
        props type_properties;
        if !compute_type_properties(cs, clq, oo(&a.param), &props) {
          return false;
        }

        // We _should_ maintain alignment for a zero-element array because the pointer to such an array might hack in tag-bit logic.
        *out = {props.flat_size * c, props.flat_alignment,
                trivialOrNot(isTrivial(props.init_behavior)),
                trivialOrNot(isTrivial(props.move_behavior)),
                trivialOrNot(isTrivial(props.copy_behavior)),
                trivialOrNot(isTrivial(props.destroy_behavior))};
        return true;
      } else {
        ice(_u8("compute_type_properties called on incomplete arraytype."));
        return fake();
      }
    }
    case &TeUnknown(a void): {
      ice(_u8("compute_type_properties called on incomplete type."));
      return fake();
    }
  }
}

func quick_typeexpr(cym *common_syms, a *ast_def, out *ast_typeexpr) bool {
  if case &Has(s ast_typeexpr) = &a->syntactic_typeexpr {
    *out = s;
    return true;
  } else {
    switch &a->rhs {
      case &Lambda(b ast_lambda): {
        type_params array[ast_typeexpr];
        n size = count(&b.args);
        for i size = 0; i < n; i = i + 1 {
          push(&type_params, ref(&b.args, i)->type);
        }
        push(&type_params, b.return_type);
        // TODO: Something about the meta value and zero literal.
        *out = App({embox(Name({@[ast_meta]~0, cym->fn})), type_params});
        return true;
      }
      default: {
        ERR(_u8("Def does not have immediately conceivable typeexpr."));
        return false;
      }
    }
  }
}

func ensure_deftype_inst_checked(cs *checkstate, clq *clqueue, ent *deftype_entry, id deftype_inst_id) bool {
  inst *deftype_inst = ref_deftype_inst(cs, id);

  switch inst->status {
    case DidNotStartChecking(v): {
      inst->status = StartedChecking(void);

      ent_rhs *te_typeexpr;
      if !deftype_converted_rhs(cs, ent, &ent_rhs) {
        return false;
      }

      rhs_computed te_typeexpr;
      rhs_complete bool;
      if !check_and_compute_typeexpr(cs, clq, &ent->tl->generics, &inst->parms, ent_rhs, &rhs_computed, &rhs_complete) {
        inst->status = FailedChecking(void);
        return false;
      }
      check(rhs_complete);

      check(isNone(&inst->properties));
      properties type_properties;
      if !compute_type_properties(cs, clq, &rhs_computed, &properties) {
        inst->status = FailedChecking(void);
        return false;
      }
      check(isNone(&inst->properties));
      switch &ent->tl->rhs {
        case &TypeexprRhs(a): {
          inst->properties = Has(properties);
        }
        case &ClassexprRhs(a): {
          inst->properties = Has(to_defclass_properties(properties));
        }
      }
      inst->status = FinishedChecking(void);
      return true;
    }
    case StartedChecking(v): {
      ERR(_u8("deftype for '"), lookup(cs->im, ent->name), _u8("' recursively checking"));
      return false;
    }
    case FinishedChecking(v): {
      check(isHas(&inst->properties));
      return true;
    }
    case FailedChecking(v): {
      ERR(_u8("deftype for '"), lookup(cs->im, ent->name), _u8("' already failed checking"));
      return false;
    }
  }
}

func ensure_deftype_checked(cs *checkstate, id deftype_entry_id) bool {
  ent *deftype_entry = ref_deftype_entry(cs, id);
  discard *te_typeexpr;
  if !deftype_converted_rhs(cs, ent, &discard) {
    return false;
  }
  switch &ent->tl->generics {
    case &NoGenerics(v): {
      parms genparms = NoParms(void);
      clq clqueue;
      discard_id deftype_inst_id = enqueue_deftype_inst(cs, &clq, id, &parms);
      return finish_checking(cs, &clq);
    }
    case &HasGenerics(ig): {
      // We declare success -- we check non-generic defs.
      // TODO: Somewhere we have to check deftype generics shadowing.
      return true;
    }
  }
}

func ensure_alias_checked(cs *checkstate, id alias_entry_id) bool {
  ent *alias_entry = ref_alias_entry(cs, id);
  discard *te_typeexpr;
  if !alias_converted_rhs(cs, ent, &discard) {
    return false;
  }
  switch &ent->tl->generics {
    case &NoGenerics(v): {
      np genparms = NoParms(void);
      clq clqueue;
      computed te_typeexpr;
      if !check_and_compute_alias_with_parms(cs, &clq, ent, &np, &computed) {
        return false;
      }
      return finish_checking(cs, &clq);
    }
    case &HasGenerics(ig): {
      // We declare success -- we check non-generic defs.
      // TODO: Somewhere we have to check alias generics shadowing.
      return true;
    }
  }
}

func load_module(cs *checkstate, mod_name sym) opt[module_id] {
  switch lookup(&cs->modules_by_name, mod_name) {
    case Has(id module_id): {
      return Has(id);
    }
    case None(v): {
      switch (cs->loader)(mod_name) {
        case None(v2): {
          ERR(_u8("Could not open file for module "), lookup(cs->im, mod_name));
          return None();
        }
        case Has(arr array[u8]): {
          mod shp[module];
          oo(&mod)->process_state = Unprocessed(void);
          oo(&mod)->module_name = mod_name;
          oo(&mod)->buf = arr;
          p ps = make_ps(cs->im, data(&oo(&mod)->buf), count(&oo(&mod)->buf));
          if !parse_file(&p, &oo(&mod)->file) {
            ERR(_u8("Trouble parsing module "), lookup(cs->im, mod_name));
            return None();
          }
          mod_id module_id = ~count(&cs->modules);
          push(&cs->modules, mod);
          if !try_insert(&cs->modules_by_name, mod_name, mod_id) {
            ERR(_u8("ICE: modules_by_name already has name "), lookup(cs->im, mod_name));
            return None();
          }
          return Has(mod_id);
        }
      }
    }
  }
}

func process_module(cs *checkstate, mod_name sym) opt[module_id] {
  switch load_module(cs, mod_name) {
    case None(v): {
      return None();
    }
    case Has(id module_id): {
      mod *module = ref_module(cs, id);
      if mod->process_state == Unprocessed(void) {
         if !process_module_toplevels(cs, mod) {
           return None();
         }
      }
      return Has(id);
    }
  }
}

func process_module_toplevels(cs *checkstate, mod *module) bool {
  check_mutate(&mod->process_state, Unprocessed(void), Processing(void));
  if !process_toplevels(cs, mod, &mod->file.toplevels) {
    return false;
  }
  check_mutate(&mod->process_state, Processing(void), DoneProcessing(void));
  return true;
}

func add_def_entry(cs *checkstate,
                   module_name sym,
                   module_defs *array[def_entry_id],
                   ent shp[def_entry]) void {
  id def_entry_id = ~count(&cs->defs);
  push(&cs->defs, ent);
  arr *array[def_entry_id] = try_insert_lookup(
    &cs->defs_by_name, oo(ent)->def_name, default());
  push(arr, id);
  push(module_defs, id);
}

func process_toplevels(cs *checkstate,
                       mod *module,
                       toplevels *array[ast_toplevel]) bool {
  for i size = 0; i < count(toplevels); i = i + 1 {
    toplevel *ast_toplevel = ref(toplevels, i);
    switch toplevel {
      case &Import(a ast_import): {
        switch process_module(cs, a.name.value) {
          case None(v): {
            return false;
          }
          case Has(id module_id): {
            // Do nothing!  We've processed the module successfully.
          }
        }
      }
      case &Def(a ast_def): {
        quick_te ast_typeexpr;
        if !quick_typeexpr(&cs->cym, &a, &quick_te) {
          return false;
        }
        ent shp[def_entry] = emshp(mk(mod->module_name, a.name.value, a.generics, quick_te, toplevel));
        add_def_entry(cs, mod->module_name, &mod->defs, ent);
      }
      case &ExternDef(a ast_extern_def): {
        ent shp[def_entry] = emshp(mk(mod->module_name, a.name.value, NoGenerics(void), a.type, toplevel));
        add_def_entry(cs, mod->module_name, &mod->defs, ent);
      }
      case &TypeDef(a ast_type_def): {
        ent shp[deftype_entry] = emshp(mk(mod->module_name, a.name.value, &a));
        id deftype_entry_id = ~count(&cs->deftypes);
        push(&cs->deftypes, ent);
        arr *array[deftype_entry_id] = try_insert_lookup(
          &cs->deftypes_by_name, oo(ent)->name, default());
        push(arr, id);
        push(&mod->deftypes, id);
      }
      case &TypeAlias(a ast_type_alias): {
        ent shp[alias_entry] = emshp(mk(mod->module_name, a.name.value, &a));
        id alias_entry_id = ~count(&cs->aliases);
        push(&cs->aliases, ent);
        arr *array[alias_entry_id] = try_insert_lookup(
          &cs->aliases_by_name, oo(ent)->alias_name, default());
        push(arr, id);
        push(&mod->aliases, id);
      }
      case &Access(a ast_access): {
        if !process_toplevels(cs, mod, &a.toplevels) {
          return false;
        }
      }
    }
  }
  return true;
}

defenum match_def_res {
  NoMatch void;
  MultiMatch void;
  // TODO: We'll want to include any simplification of the instantiated parms, or other type information, that we can get.
  OneMatch struct { ent def_entry_id; };
};

// Note that gp could be incomplete.
func match_def(cs *checkstate, name sym, gp *genparms, pt *te_typeexpr,
               res_out *match_def_res) bool {
  // TODO: What about defenum constructors?
  if case Has(arr *array[def_entry_id]) = lookup_ref(&cs->defs_by_name, name) {
    n size = count(arr);
    matches array[def_entry_id];
    for i size = 0; i < n; i = i + 1 {
      id def_entry_id = get(arr, i);
      ent *def_entry = ref_def_entry(cs, id);
      ent_typeexpr *te_typeexpr;
      if !def_converted_typeexpr(cs, ent, &ent_typeexpr) {
        return false;
      }
      match_result bool;
      if !entry_matches(cs, &ent->generics, gp, pt, ent_typeexpr, &match_result) {
        return false;
      }
      if match_result {
        push(&matches, id);
      }
    }
    num_matches size = count(&matches);
    if num_matches == 0 {
      *res_out = NoMatch(void);
      return true;
    } else if num_matches == 1 {
      *res_out = OneMatch({get(&matches, 0)});
      return true;
    } else {
      *res_out = MultiMatch(void);
      return true;
    }
  } else {
    *res_out = NoMatch(void);
    return true;
  }
}

func entry_matches(cs *checkstate, generics *ast_generics, gp *genparms, pt *te_typeexpr, typeexpr *te_typeexpr, matches_out *bool) bool {
  switch generics {
    case &NoGenerics(v void): {
      switch gp {
        case &HasParms(arr array[te_typeexpr]): {
          *matches_out = false;
          return true;
        }
        case &NoParms(u void): {
          if !unify_directionally(cs->im, pt, typeexpr) {
            *matches_out = false;
            return true;
          } else {
            *matches_out = true;
            return true;
          }
        }
      }
    }
    case &HasGenerics(names array[ast_ident]): {
      return TODO();
    }
  }
}

func unify_directionally(im *identmap, pt *te_typeexpr, t *te_typeexpr) bool {
  switch pt {
    case &TeName(pta te_name): {
      return TODO();
    }
    case &TeApp(pta te_typeapp): {
      return TODO();
    }
    case &TeStruct(pta te_struct): {
      return TODO();
    }
    case &TeEnum(pta te_enum): {
      return TODO();
    }
    case &TeUnion(pta te_union): {
      return TODO();
    }
    case &TeArraytype(pta te_arraytype): {
      return TODO();
    }
    case &TeUnknown(v void): {
      return true;
    }
  }
  return false;
}

