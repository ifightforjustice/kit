import ast;
import parse;
import tok;
import typeexpr;
import shp;
import u8ast;

deftype checkstate struct {
  im *identmap;
  loader fn[sym, opt[array[u8]]];

  modules array[shp[module]];
  modules_by_name hash[sym, module_id];

  instantiations array[shp[def_inst]];
  type_instantiations array[shp[deftype_inst]];
  alias_instantiations array[shp[alias_inst]];

  deftypes array[shp[deftype_entry]];
  deftypes_by_name hash[sym, array[deftype_entry_id]];

  aliases array[shp[alias_entry]];
  aliases_by_name hash[sym, array[alias_entry_id]];

  defs array[shp[def_entry]];
  defs_by_name hash[sym, array[def_entry_id]];
};

// An index into checkstate's modules array.
deftype module_id size;
def `~` fn[size, module_id] = wrapconvert;

// An index into checkstate's instantiations array.
deftype def_inst_id size;
def `~` fn[size, def_inst_id] = wrapconvert;

// An index into checkstate's type_instantiations array.
deftype deftype_inst_id size;
def `~` fn[size, deftype_inst_id] = wrapconvert;

// An index into checkstat's alias_instantiations array.
deftype alias_inst_id size;
def `~` fn[size, alias_inst_id] = wrapconvert;

// An index into checkstate's defs array.
deftype def_entry_id size;
def `~` fn[size, def_entry_id] = wrapconvert;

// An index into checkstate's deftypes array.
deftype deftype_entry_id size;
def `~` fn[size, deftype_entry_id] = wrapconvert;

// An index into checkstate's aliases array.
deftype alias_entry_id size;
def `~` fn[size, alias_entry_id] = wrapconvert;

func ref_module(cs *checkstate, id module_id) *module {
  return oo(ref(&cs->modules, id.~));
}

func ref_def_entry(cs *checkstate, id def_entry_id) *def_entry {
  return oo(ref(&cs->defs, id.~));
}

func ref_deftype_entry(cs *checkstate, id deftype_entry_id) *deftype_entry {
  return oo(ref(&cs->deftypes, id.~));
}

func ref_alias_entry(cs *checkstate, id alias_entry_id) *alias_entry {
  return oo(ref(&cs->aliases, id.~));
}

func ref_inst(cs *checkstate, id def_inst_id) *def_inst {
  return oo(ref(&cs->instantiations, id.~));
}

func ref_alias_inst(cs *checkstate, id alias_inst_id) *alias_inst {
  return oo(ref(&cs->alias_instantiations, id.~));
}

func add_inst(cs *checkstate, val def_inst) def_inst_id {
  id def_inst_id = ~count(&cs->instantiations);
  push(&cs->instantiations, emshp(val));
  return id;
}

func add_alias_inst(cs *checkstate, val alias_inst) alias_inst_id {
  id alias_inst_id = ~count(&cs->alias_instantiations);
  push(&cs->alias_instantiations, emshp(val));
  return id;
}

defenum module_process_state {
  Unprocessed void;
  Processing void;
  DoneProcessing void;
};

func `==`(a module_process_state, b module_process_state) bool {
  return enumnum(&a) == enumnum(&b);
}

deftype module struct {
  module_name sym;
  file ast_file;
  buf array[u8];
  process_state module_process_state;
  // vvv  Valid when process_state == DoneProcessing.  vvv
  defs array[def_entry_id];
  deftypes array[deftype_entry_id];
  aliases array[alias_entry_id];
};

deftype deftype_inst struct {
  parms genparms;
};

deftype deftype_entry struct {
  module_name sym;
  name sym;
  tl *ast_type_def;

  insts array[deftype_inst_id];
};

func mk(module_name sym, name sym, tl *ast_type_def) deftype_entry {
  return {module_name, name, tl, default()};
}

deftype alias_inst struct {
  parms genparms;
  // Is None() while we're in the process of expansion -- seeing None() means you're recursively expanding.
  expanded opt[te_typeexpr];
};

deftype alias_entry struct {
  module_name sym;
  alias_name sym;
  tl *ast_type_alias;

  insts array[alias_inst_id];
};

func mk(module_name sym, alias_name sym, tl *ast_type_alias) alias_entry {
  return {module_name, alias_name, tl, default()};
}

defenum genparms {
  NoParms void;
  HasParms array[te_typeexpr];
};

deftype def_inst struct {
  parms genparms;
  // Our own copy of the def, which we can annotate.  It does not have its generics replaced.
  ast ast_def;
  computed_type_complete bool;
  // Becomes the concrete type (with generics replaced) once we've computed it and checked it.
  computed_type te_typeexpr;
};

func mk(parms genparms, a ast_def) def_inst {
  return {parms, a, false, default()};
}

deftype def_entry struct {
  module_name sym;
  def_name sym;
  tl *ast_toplevel;

  insts array[def_inst_id];
};

func mk(module_name sym, def_name sym, tl *ast_toplevel) def_entry {
  return {module_name, def_name, tl, default()};
}

func check_module(cs *checkstate, mod_name sym) bool {
  switch process_module(cs, mod_name) {
    case None(v): {
      return false;
    }
    case Has(id module_id): {
      mod *module = ref_module(cs, id);
      ndefs size = count(&mod->defs);
      for i size = 0; i < ndefs; i = i + 1 {
        if !ensure_def_checked(cs, get(&mod->defs, i)) {
          return false;
        }
      }

      ndeftypes size = count(&mod->deftypes);
      for i size = 0; i < ndeftypes; i = i + 1 {
        if !ensure_deftype_checked(cs, get(&mod->deftypes, i)) {
          return false;
        }
      }

      naliases size = count(&mod->aliases);
      for i size = 0; i < naliases; i = i + 1 {
        if !ensure_alias_checked(cs, get(&mod->aliases, i)) {
          return false;
        }
      }

      // I guess that's everything.
      // TODO: Check that access blocks point to an actual type?
      return true;
    }
  }
}

func find_matching_inst(cs *checkstate, insts *array[def_inst_id], parms *genparms) opt[def_inst_id] {
  n size = count(insts);
  for i size = 0; i < n; i = i + 1 {
    id def_inst_id = get(insts, i);
    inst *def_inst = ref_inst(cs, id);
    if parms_equal(cs, parms, &inst->parms) {
      return Has(id);
    }
  }
  return None();
}

func parms_equal(cs *checkstate, a *genparms, b *genparms) bool {
  if enumnum(a) != enumnum(b) {
    return false;
  }
  switch a {
    case &NoParms(v void): { return true; }
    case &HasParms(ah array[te_typeexpr]): {
      switch b {
        case &HasParms(bh array[te_typeexpr]): {
          return typeexpr_list_equal(cs, &ah, &bh);
        }
      }
    }
  }
}

func arity(parms *genparms) generics_arity {
  switch parms {
    case &NoParms(v void): { return NoParamsArity(void); }
    case &HasParms(arr array[te_typeexpr]): { return FiniteArity(~count(&arr)); }
  }
}

func ensure_def_checked_with_parms(cs *checkstate, ent *def_entry, a *ast_def, parms *genparms) bool {
  // TODO: Do we know that the def's generics don't shadow something?
  check(arity(&a->generics) == arity(parms));

  if case Has(id) = find_matching_inst(cs, &ent->insts, parms) {
    // If we already have an inst, that means we made an inst.

    inst *def_inst = ref_inst(cs, id);
    if !inst->computed_type_complete {
      ERR(_u8("computing def's type arouses cyclic dependency"), lookup(cs->im, ent->def_name));
      return false;
    }

    return true;
  }

  id def_inst_id = add_inst(cs, mk(*parms, *a));
  inst *def_inst = ref_inst(cs, id);
  // TODO: We ignore is_export entirely.  Is it relevant at all?
  a = &inst->ast;

  // TODO: We need to check exact name shadowing(?), typeexpr, and rhs.

  // Important:  We check the typeexpr first.  If that typeexpr cyclically refers to this def, we fail.  If there is no typeexpr, we need to compute it from the rhs (and that also needs to not depend cyclically on this def's own typeexpr).
  if case &Has(t ast_typeexpr) = &a->typeexpr {
    computed_complete bool;
    computed te_typeexpr;
    if !check_and_compute_typeexpr(cs, &a->generics, &inst->parms, &t, &computed, &computed_complete) {
      return false;
    }
    inst->computed_type_complete = computed_complete;
    inst->computed_type = computed;
  } else {
    inst->computed_type_complete = false;
    inst->computed_type = TeUnknown(void);
  }

  // TODO: How do we know that a->generics doesn't shadow, doesn't self-shadow?
  complete_type te_typeexpr;
  if !check_expr(cs, &a->generics, &inst->parms, &inst->computed_type, &a->rhs, &complete_type) {
    return false;
  }
  inst->computed_type_complete = true;
  inst->computed_type = complete_type;
  return true;
}

func check_and_compute_typeexpr(cs *checkstate, g *ast_generics, parms *genparms, t *ast_typeexpr, computed_out *te_typeexpr, computed_complete_out *bool) bool {
  // TODO: We need some kind of proper flatness checking.
  switch t {
    case &Name(a ast_ident): {
      if !check_and_compute_name_type(cs, g, parms, &a, computed_out) {
        return false;
      }
      *computed_complete_out = true;
      return true;
    }
    case &App(a ast_typeapp): {
      return check_and_compute_app_type(cs, g, parms, &a, computed_out, computed_complete_out);
    }
    case &Struct(a ast_struct): {
      computed_fields_complete bool;
      computed_fields array[te_vardecl];
      if !help_check_fields(cs, g, parms, &a.fields, &computed_fields, &computed_fields_complete) {
        return false;
      }
      *computed_out = TeStruct({computed_fields});
      *computed_complete_out = computed_fields_complete;
      return true;
    }
    case &Enum(a ast_enum): {
      // TODO: For enums, field names are constructors.  Check shadowing?
      computed_constructors_complete bool;
      computed_constructors array[te_vardecl];
      if !help_check_fields(cs, g, parms, &a.constructors, &computed_constructors, &computed_constructors_complete) {
        return false;
      }
      *computed_out = TeEnum({computed_constructors});
      *computed_complete_out = computed_constructors_complete;
      return true;
    }
    case &Union(a ast_union): {
      // TODO: Unions will need to enforce that they have "primitive" types, no classes.
      computed_fields_complete bool;
      computed_fields array[te_vardecl];
      if !help_check_fields(cs, g, parms, &a.fields, &computed_fields, &computed_fields_complete) {
        return false;
      }
      *computed_out = TeUnion({computed_fields});
      *computed_complete_out = computed_fields_complete;
      return true;
    }
    case &Arraytype(a ast_arraytype): {
      param box[te_typeexpr];
      param_complete bool;
      if !check_and_compute_typeexpr(cs, g, parms, oo(&a.param), oo(&param), &param_complete) {
        return false;
      }
      if case &Has(b box[ast_expr]) = &a.count {
        // TODO: _really_ typecheck and statically eval count.
        count u32;
        if !fake_eval_arraytype_count(oo(&b), &count) {
          return false;
        }
        *computed_out = TeArraytype({Has(count), param});
        *computed_complete_out = param_complete;
        return true;
      } else {
        *computed_out = TeArraytype({None(), param});
        *computed_complete_out = false;
        return true;
      }
    }
    case &Unknown(a ast_unknown): {
      *computed_out = TeUnknown(void);
      *computed_complete_out = false;
      return true;
    }
  }
}

func numeric_literal_to_u32(x *ast_numeric_literal, out *u32) bool {
  switch x {
    case &HexLiteral(a ast_hex_literal): {
      return convert_to_u32(16, &a.digits, out);
    }
    case &DecLiteral(a ast_dec_literal): {
      return convert_to_u32(10, &a.digits, out);
    }
  }
}

func convert_to_u32(base i8, digits *array[i8], out *u32) bool {
  check(base > 0);
  acc u32 = 0;
  n size = count(digits);
  for i size = 0; i < n; i = i + 1 {
    if !try_mul(acc, @[u32]~base, &acc) {
      return false;
    }
    if !try_add(acc, @[u32]~get(digits, i), &acc) {
      return false;
    }
  }
  *out = acc;
  return true;
}

func fake_eval_arraytype_count(x *ast_expr, count_out *u32) bool {
  // TODO: Remove this function and really evaluate an array's count expression.
  switch x {
    case &NumericLiteral(a ast_numeric_literal): {
      return numeric_literal_to_u32(&a, count_out);
    }
    default: {
      ERR(_u8("Array types (for now) must have a numeric literal for length (or _)."));
      return false;
    }
  }
}

func help_check_fields(cs *checkstate, g *ast_generics, parms *genparms, a *array[ast_vardecl], computed_fields_out *array[te_vardecl], computed_fields_complete_out *bool) bool {
  n size = count(a);
  all_complete bool = true;
  all_computed array[te_vardecl];
  for i size = 0; i < n; i = i + 1 {
    decl *ast_vardecl = ref(a, i);
    for j size = 0; j < i; j = j + 1 {
      if ref(a, j)->name.value == decl->name.value {
        ERR(_u8("Duplicate field name "), lookup(cs->im, decl->name.value));
        return false;
      }
    }
    complete bool;
    computed te_typeexpr;
    if !check_and_compute_typeexpr(cs, g, parms, &decl->type, &computed, &complete) {
      return false;
    }
    all_complete = all_complete & complete;
    push(&all_computed, {decl->name.value, computed});
  }
  *computed_fields_out = all_computed;
  *computed_fields_complete_out = all_complete;
  return true;
}

func check_and_compute_name_type(cs *checkstate, g *ast_generics, parms *genparms, a *ast_ident, computed_out *te_typeexpr) bool {
  // Generic parameters have already been checked.  (I hope so.)
  if lookup_generic(g, parms, a->value, computed_out) {
    return true;
  }

  matching_alias opt[alias_entry_id];
  if !match_alias(cs, a->value, None(), &matching_alias) {
    // An error happened when looking up an alias (multiple matches?).
    return false;
  }
  matching_deftype opt[deftype_entry_id];
  if !match_deftype(cs, a->value, None(), &matching_deftype) {
    // An error happened when looking up a deftype (multiple matches?).
    return false;
  }

  if case Has(id) = matching_alias {
    if case Has(deftype_id) = matching_deftype {
      ERR(_u8("Both an alias and deftype match for name "), lookup(cs->im, a->value));
      return false;
    }
    np genparms = NoParms(void);
    return check_and_compute_alias_with_parms(cs, ref_alias_entry(cs, id), &np, computed_out);
  } else {
    if case Has(id) = matching_deftype {
      np genparms = NoParms(void);
      if !ensure_deftype_checked_with_parms(cs, ref_deftype_entry(cs, id), &np) {
        return false;
      }
      *computed_out = TeName(a->value);
      return true;
    } else {
      ERR(_u8("type name has no match "), lookup(cs->im, a->value));
      return false;
    }
  }
}

func check_and_compute_typeexpr_array(cs *checkstate, g *ast_generics, parms *genparms, t *array[ast_typeexpr], computed_out *array[te_typeexpr], computed_complete_out *bool) bool {
  complete bool = true;
  computed array[te_typeexpr];
  n size = count(t);
  for i size = 0; i < n; i = i + 1 {
    c te_typeexpr;
    c_complete bool;
    if !check_and_compute_typeexpr(cs, g, parms, ref(t, i), &c, &c_complete) {
      return false;
    }
    push(&computed, c);
    complete = complete & c_complete;
  }
  *computed_out = computed;
  *computed_complete_out = complete;
  return true;
}

func check_and_compute_app_type(cs *checkstate, g *ast_generics, parms *genparms, a *ast_typeapp, computed_out *te_typeexpr, computed_complete_out *bool) bool {
  params_complete bool;
  params array[te_typeexpr];
  if !check_and_compute_typeexpr_array(cs, g, parms, &a->params, &params, &params_complete) {
    return false;
  }

  if case &Name(f ast_ident) = oo(&a->typefunc) {
    matching_alias opt[alias_entry_id];
    if !match_alias(cs, f.value, Has(&params), &matching_alias) {
      return false;
    }
    matching_deftype opt[deftype_entry_id];
    if !match_deftype(cs, f.value, Has(&params), &matching_deftype) {
      return false;
    }

    if case Has(id) = matching_alias {
      if case Has(deftype_id) = matching_deftype {
        ERR(_u8("Both an alias and deftype match for name/params "), lookup(cs->im, f.value));
        return false;
      }
      if params_complete {
        hp genparms = HasParms(params);
        if !check_and_compute_alias_with_parms(cs, ref_alias_entry(cs, id), &hp, computed_out) {
          return false;
        }
        *computed_complete_out = true;
        return true;
      } else {
        *computed_out = TeApp({embox(TeName(f.value)), params});
        *computed_complete_out = false;
        return true;
      }
    } else {
      if case Has(id) = matching_deftype {
        if params_complete {
          hp genparms = HasParms(params);
          if !ensure_deftype_checked_with_parms(cs, ref_deftype_entry(cs, id), &hp) {
            return false;
          }
        }
        *computed_out = TeApp({embox(TeName(f.value)), params});
        *computed_complete_out = params_complete;
        return true;
      } else {
        ERR(_u8("type name/params has no match "), lookup(cs->im, f.value));
        return false;
      }
    }
  } else if case &Unknown(u ast_unknown) = oo(&a->typefunc) {
    *computed_out = TeApp({embox(TeUnknown(void)), params});
    *computed_complete_out = false;
    return true;
  } else {
    ERR(_u8("Fancy type expression '"), to_u8str(*oo(&a->typefunc)), _u8("' in typefunc position."));
    return false;
  }
}

func find_matching_alias_inst(cs *checkstate, insts *array[alias_inst_id], parms *genparms) opt[alias_inst_id] {
  n size = count(insts);
  for i size = 0; i < n; i = i + 1 {
    id alias_inst_id = get(insts, i);
    inst *alias_inst = ref_alias_inst(cs, id);
    if parms_equal(cs, parms, &inst->parms) {
      return Has(id);
    }
  }
  return None();
}

func check_and_compute_alias_with_parms(cs *checkstate, ent *alias_entry, parms *genparms, computed_out *te_typeexpr) bool {
  // TODO: How do we know the alias's generic parameters don't self-shadow, or shadow something else?

  if case Has(id) = find_matching_alias_inst(cs, &ent->insts, parms) {
    inst *alias_inst = ref_alias_inst(cs, id);
    // If we already have an inst, that means we made an inst.
    if case &Has(computed te_typeexpr) = &inst->expanded {
      // We already computed the expansion for these types!
      *computed_out = computed;
      return true;
    } else {
      // We're in the process of expanding this type.  We recursively expanded.
      ERR(_u8("Recursively expanding alias "), lookup(cs->im, ent->alias_name));
      return false;
    }
  }

  id alias_inst_id = add_alias_inst(cs, {*parms, None()});
  inst *alias_inst = ref_alias_inst(cs, id);

  complete bool;
  computed te_typeexpr;
  if !check_and_compute_typeexpr(cs, &ent->tl->generics, &inst->parms, &ent->tl->rhs, &computed, &complete) {
    return false;
  }
  // There's no way an alias expansion can't be complete, because ast_unknown is disallowed when parsing its RHS (and the parms must be complete).
  check(complete);
  check(isNone(&inst->expanded));
  inst->expanded = Has(computed);
  *computed_out = computed;
  return true;
}

func arity_matches(a *ast_generics, params opt[*array[te_typeexpr]]) bool {
  ar generics_arity;
  if case Has(p) = params {
    ar = FiniteArity(~count(p));
  } else {
    ar = NoParamsArity(void);
  }
  lhs_arity generics_arity = arity(a);
  return lhs_arity == ar;
}

func match_deftype(cs *checkstate, name sym, params opt[*array[te_typeexpr]], out *opt[deftype_entry_id]) bool {
  if case Has(arr *array[deftype_entry_id]) = lookup_ref(&cs->deftypes_by_name, name) {
    n size = count(arr);
    match opt[deftype_entry_id];
    for i size = 0; i < n; i = i + 1 {
      id deftype_entry_id = get(arr, i);
      ent *_ = ref_deftype_entry(cs, id);
      if arity_matches(&ent->tl->generics, params) {
        if case Has(alt_id) = match {
          ERR(_u8("Multiple deftypes named '"), lookup(cs->im, name), _u8("' match arity"));
          return false;
        }
        match = Has(id);
      }
    }
    if case Has(id) = match {
      *out = match;
      return true;
    } else {
      return false;
    }
  } else {
    return false;
  }
}

func match_alias(cs *checkstate, name sym, params opt[*array[te_typeexpr]], out *opt[alias_entry_id]) bool {
  if case Has(arr *array[alias_entry_id]) = lookup_ref(&cs->aliases_by_name, name) {
    n size = count(arr);
    match opt[alias_entry_id];
    for i size = 0; i < n; i = i + 1 {
      id alias_entry_id = get(arr, i);
      ent *_ = ref_alias_entry(cs, id);
      if arity_matches(&ent->tl->generics, params) {
        if case Has(alt_id) = match {
          ERR(_u8("Multiple aliases named '"), lookup(cs->im, name), _u8("' match arity"));
          return false;
        }
        match = Has(id);
      }
    }
    if case Has(id) = match {
      *out = match;
      return true;
    } else {
      return false;
    }
  } else {
    return false;
  }
}

func lookup_generic(g *ast_generics, parms *genparms, name sym, out *te_typeexpr) bool {
  switch g {
    case &NoGenerics(v): { return false; }
    case &HasGenerics(a array[ast_ident]): {
      n size = count(&a);
      for i size = 0; i < n; i = i + 1 {
        if ref(&a, i)->value == name {
          if case &HasParms(ps) = parms {
            *out = *ref(&ps, i);
            return true;
          } else {
            crash(_u8("non-matching parms"));
          }
        }
      }
      return false;
    }
  }
}

func check_expr(cs *checkstate, g *ast_generics, parms *genparms, pt *te_typeexpr, x *ast_expr, computed_out *te_typeexpr) bool {
  return TODO();
}

func ensure_def_checked(cs *checkstate, id def_entry_id) bool {
  ent *def_entry = ref_def_entry(cs, id);
  switch ent->tl {
    case &Def(a ast_def): {
      switch &a.generics {
        case &NoGenerics(v): {
          parms genparms = NoParms(void);
          return ensure_def_checked_with_parms(cs, ent, &a, &parms);
        }
        case &HasGenerics(ig): {
          // We declare success -- we check non-generic defs.
          // TODO: Somewhere we have to check def generics shadowing.
          return true;
        }
      }
    }
    case &ExternDef(a ast_extern_def): {
      return TODO();
    }
    default: {
      ice(_u8("def_entry has invalid toplevel\n"));
      return fake();
    }
  }
}

func ensure_deftype_checked_with_parms(cs *checkstate, ent *deftype_entry, parms *genparms) bool {
  return TODO();
}

func ensure_deftype_checked(cs *checkstate, id deftype_entry_id) bool {
  ent *deftype_entry = ref_deftype_entry(cs, id);
  switch &ent->tl->generics {
    case &NoGenerics(v): {
      parms genparms = NoParms(void);
      return ensure_deftype_checked_with_parms(cs, ent, &parms);
    }
    case &HasGenerics(ig): {
      // We declare success -- we check non-generic defs.
      // TODO: Somewhere we have to check deftype generics shadowing.
      return true;
    }
  }
}

func ensure_alias_checked(cs *checkstate, id alias_entry_id) bool {
  return TODO();
}

func load_module(cs *checkstate, mod_name sym) opt[module_id] {
  switch lookup(&cs->modules_by_name, mod_name) {
    case Has(id module_id): {
      return Has(id);
    }
    case None(v): {
      switch (cs->loader)(mod_name) {
        case None(v2): {
          ERR(_u8("Could not open file for module "), lookup(cs->im, mod_name));
          return None();
        }
        case Has(arr array[u8]): {
          mod shp[module];
          oo(&mod)->process_state = Unprocessed(void);
          oo(&mod)->module_name = mod_name;
          oo(&mod)->buf = arr;
          p ps = make_ps(cs->im, data(&oo(&mod)->buf), count(&oo(&mod)->buf));
          if !parse_file(&p, &oo(&mod)->file) {
            ERR(_u8("Trouble parsing module "), lookup(cs->im, mod_name));
            return None();
          }
          mod_id module_id = ~count(&cs->modules);
          push(&cs->modules, mod);
          if !try_insert(&cs->modules_by_name, mod_name, mod_id) {
            ERR(_u8("ICE: modules_by_name already has name "), lookup(cs->im, mod_name));
            return None();
          }
          return Has(mod_id);
        }
      }
    }
  }
}

func process_module(cs *checkstate, mod_name sym) opt[module_id] {
  switch load_module(cs, mod_name) {
    case None(v): {
      return None();
    }
    case Has(id module_id): {
      mod *module = ref_module(cs, id);
      if mod->process_state == Unprocessed(void) {
         if !process_defs(cs, mod) {
           return None();
         }
      }
      return Has(id);
    }
  }
}

func process_defs(cs *checkstate, mod *module) bool {
  check_mutate(&mod->process_state, Unprocessed(void), Processing(void));
  if !process_toplevels(cs, mod, &mod->file.toplevels) {
    return false;
  }
  check_mutate(&mod->process_state, Processing(void), DoneProcessing(void));
  return true;
}

func add_def_entry(cs *checkstate,
                   module_name sym,
                   module_defs *array[def_entry_id],
                   ent shp[def_entry]) void {
  id def_entry_id = ~count(&cs->defs);
  push(&cs->defs, ent);
  arr *array[def_entry_id] = try_insert_lookup(
    &cs->defs_by_name, oo(ent)->def_name, default());
  push(arr, id);
  push(module_defs, id);
}

func process_toplevels(cs *checkstate,
                       mod *module,
                       toplevels *array[ast_toplevel]) bool {
  for i size = 0; i < count(toplevels); i = i + 1 {
    toplevel *ast_toplevel = ref(toplevels, i);
    switch toplevel {
      case &Import(a ast_import): {
        switch process_module(cs, a.name.value) {
          case None(v): {
            return false;
          }
          case Has(id module_id): {
            // Do nothing!  We've processed the module successfully.
          }
        }
      }
      case &Def(a ast_def): {
        ent shp[def_entry] = emshp(mk(mod->module_name, a.name.value, toplevel));
        add_def_entry(cs, mod->module_name, &mod->defs, ent);
      }
      case &ExternDef(a ast_extern_def): {
        ent shp[def_entry] = emshp(mk(mod->module_name, a.name.value, toplevel));
        add_def_entry(cs, mod->module_name, &mod->defs, ent);
      }
      case &TypeDef(a ast_type_def): {
        ent shp[deftype_entry] = emshp(mk(mod->module_name, a.name.value, &a));
        id deftype_entry_id = ~count(&cs->deftypes);
        push(&cs->deftypes, ent);
        arr *array[deftype_entry_id] = try_insert_lookup(
          &cs->deftypes_by_name, oo(ent)->name, default());
        push(arr, id);
        push(&mod->deftypes, id);
      }
      case &TypeAlias(a ast_type_alias): {
        ent shp[alias_entry] = emshp(mk(mod->module_name, a.name.value, &a));
        id alias_entry_id = ~count(&cs->aliases);
        push(&cs->aliases, ent);
        arr *array[alias_entry_id] = try_insert_lookup(
          &cs->aliases_by_name, oo(ent)->alias_name, default());
        push(arr, id);
        push(&mod->aliases, id);
      }
      case &Access(a ast_access): {
        if !process_toplevels(cs, mod, &a.toplevels) {
          return false;
        }
      }
    }
  }
  return true;
}

func[T, U, V, W] ERR(x T, y U, z V, p W) void {
  ERR(cons(cons(x, y), cons(z, p)));
}

func[T, U, V] ERR(x T, y U, z V) void {
  ERR(cons(cons(x, y), z));
}

func[T, U] ERR(x T, y U) void {
  ERR(cons(x, y));
}

func[T] ERR(x T) void {
  print(Stderr(), to_u8str(x));
  print(Stderr(), _u8("\n"));
  fflush(Stderr());
}

func ice(msg array[u8]) void {
  x _ = _u8("ICE: ");
  append(&x, &msg);
  crash(x);
}

