import identmap;
import shray;
import state;

// A "computed" typeexpr, which is complete, and which has isHas instpacks.
deftype cu_typeexpr te_typeexpr;

def `~` fn[te_typeexpr, cu_typeexpr] = wrapconvert;

// A "check and computed" typeexpr -- if it's not complete, it should not be converted to a cu_typeexpr.
deftype cac_typeexpr struct {
  complete bool;
  te te_typeexpr;
};

// TODO: Might this still exist in a particular scope?
// This type is an expanded ast_typeexpr.  I hope aliases are expanded and generics replaced consistently.
defenum te_typeexpr {
  TeName te_name;
  TeApp te_typeapp;
  TeStruct te_struct;
  TeEnum te_enum;
  TeUnion te_union;
  TeArraytype te_arraytype;
  TeUnknown void;
};

defenum te_puretype {
  TePureName sym;
  TePureUnknown void;
};

deftype te_instpack struct {
  ent_id deftype_entry_id;
  inst_id deftype_inst_id;
};

deftype te_name struct {
  value sym;
  // Only supplied if the type is complete, the lookup actually happened.
  pack opt[te_instpack];
};

deftype te_typeapp struct {
  typefunc te_puretype;
  params shray[te_typeexpr];
  // Only supplied if the type is complete, the lookup actually happened.
  pack opt[te_instpack];
};

deftype te_struct struct {
  fields shray[te_vardecl];
};

deftype te_enum struct {
  constructors shray[te_vardecl];
};

deftype te_union struct {
  fields shray[te_vardecl];
};

deftype te_arraytype struct {
  count opt[u32];
  param shp[te_typeexpr];
};

deftype te_vardecl struct {
  name sym;
  type te_typeexpr;
};

func typeexpr_list_equal(a *shray[cu_typeexpr], b *shray[cu_typeexpr]) bool {
  n size = count(a);
  if n != count(b) {
    return false;
  }
  adata *cu_typeexpr = data(a);
  bdata *cu_typeexpr = data(b);
  for i size = 0; i < n; i = i + 1 {
    if !typeexpr_equal(&adata[i], &bdata[i]) {
      return false;
    }
  }
  return true;
}

func typeexpr_equal(a *cu_typeexpr, b *cu_typeexpr) bool {
  return help_typeexpr_equal(&a->~, &b->~);
}

// Must be called on complete, concrete types.
func help_typeexpr_equal(a *te_typeexpr, b *te_typeexpr) bool {
  switch a {
    case &TeName(ax te_name): {
      if case &TeName(bx te_name) = b {
        if case &Has(p te_instpack) = &ax.pack {
          if case &Has(q te_instpack) = &bx.pack {
            return p.inst_id.~ == q.inst_id.~;
          }
        }
        ice(_u8("typeexpr_equal on a non-pack-having name typeexpr"));
      }
    }
    case &TeApp(ax te_typeapp): {
      if case &TeApp(bx te_typeapp) = b {
        if case &Has(p te_instpack) = &ax.pack {
          if case &Has(q te_instpack) = &bx.pack {
            return p.inst_id.~ == q.inst_id.~;
          }
        }
        ice(_u8("typeexpr_equal on non-pack-having app typeexpr"));
      }
    }
    case &TeStruct(ax te_struct): {
      if case &TeStruct(bx te_struct) = b {
        return help_te_vardecl_list_equal(&ax.fields, &bx.fields);
      }
    }
    case &TeEnum(ax te_enum): {
      if case &TeEnum(bx te_enum) = b {
        return help_te_vardecl_list_equal(&ax.constructors, &bx.constructors);
      }
    }
    case &TeUnion(ax te_union): {
      if case &TeUnion(bx te_union) = b {
        return help_te_vardecl_list_equal(&ax.fields, &bx.fields);
      }
    }
    case &TeArraytype(ax te_arraytype): {
      if case &TeArraytype(bx te_arraytype) = b {
        return ax.count == bx.count && help_typeexpr_equal(oo(&ax.param), oo(&bx.param));
      }
    }
    case &TeUnknown(v void): {
      ice(_u8("typeexpr_equal sees TeUnknown"));
    }
  }

  return false;
}

func te_puretype_equal(cs *checkstate, a *te_puretype, b *te_puretype) bool {
  switch a {
    case &TePureName(an sym): {
      if case &TePureName(bn sym) = b {
        return an == bn;
      }
    }
    case &TePureUnknown(u void): {
      if case &TePureUnknown(v void) = b {
        return true;
      }
    }
  }
  return false;
}

func help_te_vardecl_list_equal(a *shray[te_vardecl], b *shray[te_vardecl]) bool {
  n size = count(a);
  if n != count(b) {
    return false;
  }
  adata *te_vardecl = data(a);
  bdata *te_vardecl = data(b);
  for i size = 0; i < n; i = i + 1 {
    adecl *te_vardecl = &adata[i];
    bdecl *te_vardecl = &bdata[i];
    if !(adecl->name == bdecl->name && help_typeexpr_equal(&adecl->type, &bdecl->type)) {
      return false;
    }
  }
  return true;
}

func enum_tag_type(cs *checkstate, et *te_enum) te_typeexpr {
  tagsize u32 = cs->plat.enum_tag_size;
  if tagsize == 1 {
    return primitive_u8_type(cs);
  } else if tagsize == 2 {
    return primitive_u16_type(cs);
  } else if tagsize == 4 {
    return primitive_u32_type(cs);
  } else {
    ice(_u8("enum_tag_type does not support enum_tag_size value"));
    return fake();
  }
}

deftype enum_tag_value u32;
def `~` fn[u32, enum_tag_value] = wrapconvert;

func enum_field_offset(cs *checkstate, et *te_enum, tag enum_tag_value) u32 {
  // Things will get more complicated at some point.
  return cs->plat.enum_tag_size;
}

func mk_enum_tag_value(constructor_decl_index size) enum_tag_value {
  return ~(enum_tag_min + ~constructor_decl_index);
}

func[H] build_u8str(help H, r *array[u8], a *cu_typeexpr) void {
  return build_u8str(help, r, &a->~);
}

func[H] build_u8str(help H, r *array[u8], a *te_typeexpr) void {
  switch a {
    case &TeName(b te_name): {
      wrap_u8str(help, r, _u8("TeName"), &b);
    }
    case &TeApp(b te_typeapp): {
      wrap_u8str(help, r, _u8("TeApp"), &b);
    }
    case &TeStruct(b te_struct): {
      wrap_u8str(help, r, _u8("TeStruct"), &b);
    }
    case &TeEnum(b te_enum): {
      wrap_u8str(help, r, _u8("TeEnum"), &b);
    }
    case &TeUnion(b te_union): {
      wrap_u8str(help, r, _u8("TeUnion"), &b);
    }
    case &TeArraytype(b te_arraytype): {
      wrap_u8str(help, r, _u8("TeArraytype"), &b);
    }
    case &TeUnknown(v void): {
      append(r, _u8("TeUnknown"));
    }
  }
}

func[H] build_u8str(help H, r *array[u8], a *te_name) void {
  append(r, _u8("{value:"));
  build_u8str(help, r, &a->value);
  append(r, _u8("}"));
}

func[H] build_u8str(help H, r *array[u8], a *te_typeapp) void {
  append(r, _u8("{typefunc:"));
  build_u8str(help, r, &a->typefunc);
  append(r, _u8(",params:"));
  build_shray_u8str(help, r, &a->params);
  push(r, '}');
}

func[H] build_u8str(help H, r *array[u8], a *te_struct) void {
  append(r, _u8("{fields:"));
  build_shray_u8str(help, r, &a->fields);
  push(r, '}');
}

func[H] build_u8str(help H, r *array[u8], a *te_enum) void {
  append(r, _u8("{constructors:"));
  build_shray_u8str(help, r, &a->constructors);
  push(r, '}');
}

func[H] build_u8str(help H, r *array[u8], a *te_union) void {
  append(r, _u8("{fields:"));
  build_shray_u8str(help, r, &a->fields);
  push(r, '}');
}

func[H] build_u8str(help H, r *array[u8], a *te_arraytype) void {
  append(r, _u8("{count:"));
  build_u8str(help, r, &a->count);
  append(r, _u8(",param:"));
  build_u8str(help, r, &a->param);
  push(r, '}');
}

func[H] build_u8str(help H, r *array[u8], a *te_vardecl) void {
  append(r, _u8("{name:"));
  build_u8str(help ,r, &a->name);
  append(r, _u8(",type:"));
  build_u8str(help, r, &a->type);
  push(r, '}');
}

func[H] build_u8str(help H, r *array[u8], a *te_puretype) void {
  switch a {
    case &TePureName(s sym): {
      append(r, _u8("TePureName("));
      build_u8str(help, r, &s);
      push(r, ')');
    }
    case &TePureUnknown(v void): {
      append(r, _u8("TePureUnknown"));
    }
  }
}

func hash_compute_hash(x *cu_typeexpr) osize {
  return help_compute_hash(&x->~);
}

// Must be called on complete, concrete types.
func help_compute_hash(a *te_typeexpr) osize {
  switch a {
  case &TeName(ax te_name):
    if case &Has(p te_instpack) = &ax.pack {
      return ~p.inst_id.~;
    }
    ice(_u8("help_compute_hash on non-pack-having name typeexpr"));
  case &TeApp(ax te_typeapp):
    if case &Has(p te_instpack) = &ax.pack {
      return ~p.inst_id.~;
    }
    ice(_u8("help_compute_hash on non-pack-having app typeexpr"));
  case &TeStruct(ax te_struct):
    return 0x3 ^ help_te_vardecl_list_compute_hash(&ax.fields);
  case &TeEnum(ax te_enum):
    return 0x4 ^ help_te_vardecl_list_compute_hash(&ax.constructors);
  case &TeUnion(ax te_union):
    return 0x5 ^ help_te_vardecl_list_compute_hash(&ax.fields);
  case &TeArraytype(ax te_arraytype):
    if case Has(n u32) = ax.count {
      return (@[osize]~n * 0x3001) + help_compute_hash(oo(&ax.param));
    }
  case &TeUnknown(v void):
    ice(_u8("help_compute_hash sees TeUnknown"));
  }
  return fake();
}

func help_te_vardecl_list_compute_hash(a *shray[te_vardecl]) osize {
  n size = count(a);
  adata *te_vardecl = data(a);
  accum osize = 0x84ac113;
  for i size = 0; i < n; i = i + 1 {
    adecl *te_vardecl = &adata[i];
    accum = (accum * 33) ^ ~adecl->name.~;
    accum = (accum * 3) ^ help_compute_hash(&adecl->type);
  }
  return accum;
}

func pretty_u8str(im *identmap, r *array[u8], a *te_typeexpr) void {
  switch a {
  case &TeName(b te_name):
    build_u8str(im, r, &b.value);
  case &TeApp(b te_typeapp):
    switch b.typefunc {
    case TePureName(s sym):
      build_u8str(im, r, &s);
      if s == im->cym.ptrtype_sym && count(&b.params) == 1 {
        pretty_u8str(im, r, ref(&b.params, 0));
      } else {
        push(r, '[');
        pretty_u8str_list(im, r, &b.params);
        push(r, ']');
      }
    case TePureUnknown(v void):
      push(r, '_');
    }
  case &TeStruct(b te_struct):
    append(r, _u8("struct { "));
    help_pretty_vardecl(im, r, &b.fields);
    push(r, '}');
  case &TeEnum(b te_enum):
    append(r, _u8("enum { "));
    help_pretty_vardecl(im, r, &b.constructors);
    push(r, '}');
  case &TeUnion(b te_union):
    append(r, _u8("struct { "));
    help_pretty_vardecl(im, r, &b.fields);
    push(r, '}');
  case &TeArraytype(b te_arraytype):
    push(r, '[');
    if case Has(n u32) = b.count {
      build_u8str(void, r, &n);
    } else {
      push(r, '_');
    }
    push(r, ']');
    pretty_u8str(im, r, oo(&b.param));
  case &TeUnknown(v void):
    push(r, '_');
  }
}

func pretty_u8str_list(im *identmap, r *array[u8], a *shray[te_typeexpr]) void {
  n size = count(a);
  for i size = 0; i < n; i = i + 1 {
    if i != 0 {
      push(r, ',');
      push(r, ' ');
    }
    pretty_u8str(im, r, ref(a, i));
  }
}

func help_pretty_vardecl(im *identmap, r *array[u8], a *shray[te_vardecl]) void {
  n size = count(a);
  for i size = 0; i < n; i = i + 1 {
    v *te_vardecl = ref(a, i);
    build_u8str(im, r, &v->name);
    push(r, ' ');
    pretty_u8str(im, r, &v->type);
    push(r, ';');
    push(r, ' ');
  }
}
