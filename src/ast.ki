import arity;
import box;
import identmap;
import pos;
import typeexpr;

// This is an index into some ps-specific structure.
deftype ast_meta size;

def `~` fn[size, ast_meta] = wrapconvert;

func fake_ast_meta() ast_meta { return default(); }

deftype interval struct {
  left pos;
  right pos;
};

deftype ast_ident struct {
  meta ast_meta;
  value sym;
};

// Add pos info below.

deftype ast_hex_literal struct {
  meta ast_meta;
  digits array[i8];
};

deftype ast_dec_literal struct {
  meta ast_meta;
  digits array[i8];
};

defenum ast_numeric_literal {
  HexLiteral ast_hex_literal;
  DecLiteral ast_dec_literal;
};

deftype ast_bool_literal struct {
  meta ast_meta;
  value bool;
};

deftype ast_void_literal struct {
  meta ast_meta;
};

deftype ast_null_literal struct {
  meta ast_meta;
};

deftype ast_charspec struct {
  value i32;
};

deftype ast_char_literal struct {
  charspec ast_charspec;
};

deftype ast_string_literal struct {
  charspecs array[ast_charspec];
};

deftype ast_funcall struct {
  fun box[ast_expr_consume];
  params array[ast_expr_consume];
};

deftype ast_assignment_comparecells struct {
  ip instpair;
  funcell cell_num;
  destptr cell_num;
  srcptr cell_num;
  cmp_result cell_num;
};

deftype ast_conditional_assignment_info struct {
  comparecells ast_assignment_comparecells;

  /* These actions perform the assignment -- they happen if the
  assignment isn't self-assignment. */
  conditional_actions array[after_action];

  /* These unconditionally happen, even if no assignment happens.
  They happen _after_ the conditional actions. */
  unconditional_actions array[after_action];
};

defenum ast_assignment_info {
  StaticSelfAssignment void;
  ConditionalAssignment ast_conditional_assignment_info;
};

deftype ast_assignment struct {
  info opt[ast_assignment_info];
  lhs box[ast_expr];
  rhs box[ast_expr];
};

func annotate_assignment(a *ast_assignment, info ast_assignment_info) void {
  if case &Has(i ast_assignment_info) = &a->info {
    ice(_u8("assignment already annotated"));
  }
  a->info = Has(info);
}

func assignment_info(a *ast_assignment) *ast_assignment_info {
  if case &Has(info ast_assignment_info) = &a->info {
    return &info;
  } else {
    ice(_u8("assignment_info not annotated"));
    return fake();
  }
}

deftype ast_addressof struct {
  rhs box[ast_expr];
};

deftype ast_deref struct {
  ptr_discard ast_later_discard_info;
  rhs box[ast_expr_consume];
};

deftype ast_typeapp struct {
  typefunc box[ast_typeexpr];
  params array[ast_typeexpr];
};

deftype ast_struct struct {
  fields array[ast_vardecl];
};

deftype ast_enum struct {
  constructors array[ast_vardecl];
};

deftype ast_union struct {
  fields array[ast_vardecl];
};

deftype ast_arraytype struct {
  count opt[box[ast_expr]];
  param box[ast_typeexpr];
};

deftype ast_unknown struct {
};

defenum ast_typeexpr {
  Name ast_ident;
  App ast_typeapp;
  Struct ast_struct;
  Enum ast_enum;
  Union ast_union;
  Arraytype ast_arraytype;
  Unknown ast_unknown;
};

deftype ast_vardecl struct {
  name ast_ident;
  type ast_typeexpr;
};

deftype ast_bracebody struct {
  statements array[ast_statement];
};

deftype ast_var_info struct {
  vn var_number;
};

deftype ast_var_statement struct {
  info opt[ast_var_info];
  decl ast_vardecl;
  rhs opt[box[ast_expr_consume]];
};

deftype ast_pattern_assign struct {
  pattern ast_constructor_pattern;
  rhs box[ast_expr_consume];
};

defenum ast_condition {
  ExprCondition box[ast_expr_consume];
  PatternCondition ast_pattern_assign;
};

deftype ast_ifthen_statement struct {
  condition_discard ast_later_discard_info;
  condition ast_condition;
  body ast_bracebody;
};

deftype ast_ifthenelse_statement struct {
  condition_discard ast_later_discard_info;
  condition ast_condition;
  thenbody ast_bracebody;
  elsebody ast_bracebody;
};

deftype ast_while_statement struct {
  condition_discard ast_later_discard_info;
  condition ast_condition;
  body ast_bracebody;
};

deftype ast_for_statement struct {
  // Can only be an ast_expr or ast_statement_var.
  initializer opt[box[ast_statement]];
  condition_discard ast_later_discard_info;
  condition opt[box[ast_expr_consume]];
  increment opt[box[ast_expr_discard]];
  body ast_bracebody;
};

deftype ast_switch_statement struct {
  swartch_discard ast_later_discard_info;
  swartch box[ast_expr_consume];
  cases array[ast_switch_case];
};

deftype ast_return_statement_info struct {
  // TODO: Nothing uses in_scope.
  in_scope array[var_number];
  destructions array[destroy_action];
};

deftype ast_return_statement struct {
  info opt[ast_return_statement_info];
  // If no expr, it returns void.
  expr opt[box[ast_expr_consume]];
};

deftype ast_label_statement struct {
  name ast_ident;
};

deftype ast_goto_statement struct {
  target ast_ident;
};

defenum ast_statement {
  Expr ast_expr_discard;
  Return ast_return_statement;
  Var ast_var_statement;
  IfThen ast_ifthen_statement;
  IfThenElse ast_ifthenelse_statement;
  While ast_while_statement;
  For ast_for_statement;
  Switch ast_switch_statement;
  Label ast_label_statement;
  Goto ast_goto_statement;
};

deftype ast_constructor_pattern struct {
  addressof_constructor opt[ast_ident];
  constructor_name ast_ident;
  decl ast_vardecl;
};

defenum ast_case_pattern {
  Case ast_constructor_pattern;
  Default void;
};

deftype ast_switch_case struct {
  pattern ast_case_pattern;
  body ast_bracebody;
};

deftype ast_fullbody_info struct {
  all_vars array[var_info];
  cells array[cell_info];

  gotos array[goto_info];
  labels array[label_info];
  statements array[statement_info];
};

deftype ast_fullbody struct {
  info opt[ast_fullbody_info];
  bb ast_bracebody;
};

func annotate_fullbody(a *ast_fullbody, info ast_fullbody_info) void {
  if isHas(&a->info) {
    ice(_u8("annotate_fullbody sees already annotated"));
  }
  a->info = Has(info);
}

deftype ast_lambda struct {
  args array[ast_vardecl];
  return_type ast_typeexpr;
  body ast_fullbody;
};

defenum ast_fieldname {
  WholeField void;
  NameField ast_ident;
};

deftype ast_arraylength_info struct {
  // After actions to discard the array.
  after ast_expr_after;
  count u32;
};

defenum ast_local_field_info {
  ArrayLength ast_arraylength_info;
  // Holds the offset.
  FieldName u32;
};

deftype ast_local_field struct {
  info opt[ast_local_field_info];
  lhs box[ast_expr];
  fieldname ast_fieldname;
};

func mk(lhs box[ast_expr], fieldname ast_fieldname) ast_local_field {
  return {None@[ast_local_field_info](), lhs, fieldname};
}

func annotate_local_field(a *ast_local_field, info ast_local_field_info) void {
  if isHas(&a->info) {
    ice(_u8("annotate_local_field already annotated"));
  }
  a->info = Has(info);
}

defenum ast_deref_field_info {
  // The array's count.
  DerefArrayLength u32;
  // The field's offset.
  DerefFieldName u32;
};

deftype ast_deref_field struct {
  info opt[ast_deref_field_info];
  ptr_discard ast_later_discard_info;
  lhs box[ast_expr_consume];
  fieldname ast_fieldname;
};

func annotate_deref_field(a *ast_deref_field, info ast_deref_field_info) void {
  if isHas(&a->info) {
    ice(_u8("annotate_deref_field already annotated"));
  }
  a->info = Has(info);
}

deftype global_info struct {
  ent def_entry_id;
  inst def_inst_id;
};

deftype local_info struct {
  varnum var_number;
};

defenum ast_name_expr_info {
  LocalResolve local_info;
  GlobalResolve global_info;
  EnumConstructor void;
};

deftype ast_name_expr struct {
  name_info opt[ast_name_expr_info];
  ident ast_ident;
  generic_params opt[array[ast_typeexpr]];
};

func mk(ident ast_ident, generic_params opt[array[ast_typeexpr]]) ast_name_expr {
  return {None(), ident, generic_params};
}

func name_info(a *ast_name_expr) *ast_name_expr_info {
  if case &Has(info ast_name_expr_info) = &a->name_info {
    return &info;
  } else {
    ice(_u8("name_info does not see info"));
    return fake();
  }
}

func annotate_name_info(a *ast_name_expr, info ast_name_expr_info) void {
  check(isNone(&a->name_info));
  a->name_info = Has(info);
}

deftype ast_paren_expr struct {
  expr box[ast_expr];
};

deftype ast_index_expr_info struct {
  // isHas if the lhs needs discarding (if it's a ptr).
  after opt[ast_expr_after];
};

deftype ast_index_expr struct {
  info opt[ast_index_expr_info];
  lhs box[ast_expr];
  rhs box[ast_expr_consume];
};

func mk(lhs box[ast_expr], rhs box[ast_expr_consume]) ast_index_expr {
  return {None@[ast_index_expr_info](), lhs, rhs};
}

func annotate_index_expr(a *ast_index_expr, info ast_index_expr_info) void {
  if isHas(&a->info) {
    ice(_u8("annotate_index_expr already annotated"));
  }
  a->info = Has(info);
}


deftype ast_typed_expr struct {
  type ast_typeexpr;
  expr box[ast_expr];
};

deftype ast_strinit_param_info struct {
  offset u32;
};

deftype ast_strinit_param struct {
  info opt[ast_strinit_param_info];
  ec ast_expr_consume;
};

deftype ast_strinit struct {
  exprs array[ast_strinit_param];
};

func strinit_param_info(a *ast_strinit_param) *ast_strinit_param_info {
  if case &Has(info ast_strinit_param_info) = &a->info {
    return &info;
  } else {
    ice(_u8("ast_strinit_param_info not annotated"));
    return fake();
  }
}

func annotate_strinit_param(a *ast_strinit_param, info ast_strinit_param_info) void {
  if isHas(&a->info) {
    ice(_u8("strinit_param already annotated"));
  }
  a->info = Has(info);
}

// Is a non-lval an rval?  Okay.
deftype rval_description struct {
  // The cell number of the temporary that this rval is _part of_.
  whole_num cell_num;

  // The cell number of the field (a virtual cell if different from num).
  partial_num cell_num;
};

// Tells whether the rval would need to get copied out of the temporary, or whether the rval _is_ the whole temporary and can get moved.
func whole_temporary(d *rval_description) bool {
  return d->whole_num == d->partial_num;
}

deftype lval_description struct {
  // The cell number of the lvalue.  Be it part of a bigger object or not.
  num cell_num;
};

defenum is_lval {
  IsLvalNo rval_description;
  IsLvalYes lval_description;
};

func wholeRval(num cell_num) is_lval {
  return IsLvalNo({num, num});
}

func isNo(x is_lval) bool {
  if case IsLvalNo(a rval_description) = x {
    return true;
  }
  return false;
}

// Where the value of the expr is, _before_ after actions are run.
func value_cell(x *is_lval) cell_num {
  switch x {
    case &IsLvalYes(desc lval_description): { return desc.num; }
    case &IsLvalNo(desc rval_description): { return desc.partial_num; }
  }
}

func value_cell(a *ast_expr) cell_num {
  return value_cell(&expr_complete_info(a)->lval);
}

deftype ast_later_discard_info struct {
  // None() means not-yet-specified, typechecking always leaves this in an isHas state.
  action opt[destroy_action];
};

func mk_later() ast_later_discard_info {
  return {None()};
}

func annotate_later(a *ast_later_discard_info, action destroy_action) void {
  if isHas(&a->action) {
    ice(_u8("ast_later_discard_info already annotated"));
  }
  a->action = Has(action);
}

deftype instpair struct {
  ent_id def_entry_id;
  inst_id def_inst_id;
};

defenum ctor_desc {
  TrivialCtor void;
  FunCtor instpair;
};

defenum bi_ctor_desc {
  BiTrivialCtor void;
  BiFunCtor bi_fun_ctor_desc;
};

deftype bi_fun_ctor_desc struct {
  ip instpair;
  // Cells for the constructor params and return cell.
  funcell cell_num;
  destptr cell_num;
  srcptr cell_num;
  retvoid cell_num;
};

deftype bi_action struct {
  ctor bi_ctor_desc;
  dest cell_num;
  src cell_num;
};

deftype copy_action bi_action;
deftype move_action bi_action;

defenum uni_ctor_desc {
  UniTrivialCtor void;
  UniFunCtor uni_fun_ctor_desc;
};

deftype uni_fun_ctor_desc struct {
  ip instpair;
  funcell cell_num;
  argptr cell_num;
  retvoid cell_num;
};

deftype destroy_action struct {
  ctor uni_ctor_desc;
  arg cell_num;
};

defenum after_action {
  CopyAfter copy_action;
  MoveAfter move_action;
  DestroyAfter destroy_action;
};

deftype ast_expr_after struct {
  // The after-actions get evaluated -in order-.  For example, copying a field from a temporary should happen -before- destroying the temporary.
  actions array[after_action];
  // The cell the expr's result... goes.  This is really a property of the thing holding the expr, not the expr itself...  If the result is discarded, this is None().
  // TODO: We should prohibit exprs where a non-whole_field result is discarded.  This will mean we don't need to handle the case where we discard a field lookup without copying it out first.
  result opt[cell_num];
};

func result_cell(a *ast_expr_after) cell_num {
  if case &Has(c cell_num) = &a->result {
    return c;
  } else {
    ice(_u8("result_cell sees None"));
    return fake();
  }
}

func result_cell(a *ast_expr_consume) cell_num {
  if case &Has(aft ast_expr_after) = &a->after {
    return result_cell(&aft);
  } else {
    ice(_u8("result_cell sees None for after"));
    return fake();
  }
}

func mk_after(result opt[cell_num]) ast_expr_after {
  return {mk_array(), result};
}

func mk_after(x after_action, result opt[cell_num]) ast_expr_after {
  return {mk_array(x), result};
}

func mk_after(x after_action, y after_action, result opt[cell_num]) ast_expr_after {
  return {mk_array(x, y), result};
}

deftype ast_expr_complete_info struct {
  lval is_lval;
  cu cu_typeexpr;
  cu_props type_properties;
};

func mk(lval is_lval, cu cu_typeexpr, cu_props type_properties) ast_expr_complete_info {
  return {lval, cu, cu_props};
}

defenum ast_expr_info {
  NoInfo void;
  IncompleteCheck te_typeexpr;
  CompleteCheck ast_expr_complete_info;
};

deftype ast_expr struct {
  info ast_expr_info;
  u ast_expr_enum;
};

func inner_info(a *ast_expr_info) ast_expr_info {
  switch a {
    case &NoInfo(v void): {
      return NoInfo(void);
    }
    case &IncompleteCheck(t te_typeexpr): {
      return IncompleteCheck(t);
    }
    case &CompleteCheck(t ast_expr_complete_info): {
      return CompleteCheck(mk(t.lval, t.cu, t.cu_props));
    }
  }
}

func annotate_info(a *ast_expr, info ast_expr_info) void {
  switch &a->info {
    case &CompleteCheck(t ast_expr_complete_info): {
      ice(_u8("expr already completely annotated"));
    }
    case &IncompleteCheck(pt te_typeexpr): {
      switch &info {
        case &CompleteCheck(t ast_expr_complete_info): { /* Do nothing. */ }
        default: {
          ice(_u8("expr already incompletely annotated"));
        }
      }
    }
    case &NoInfo(v void): { }
  }

  a->info = info;
}

func annotate_disposal(a *opt[ast_expr_after], aft ast_expr_after) void {
  if case &Has(a2 ast_expr_after) = a {
    ice(_u8("annotate_disposal impossibly called twice"));
  } else {
    *a = Has(aft);
  }
}

func annotate_disposal(a *ast_expr_discard, aft ast_expr_after) void {
  annotate_disposal(&a->after, aft);
}

func annotate_disposal(a *ast_expr_consume, aft ast_expr_after) void {
  annotate_disposal(&a->after, aft);
}


defenum ast_expr_enum {
  NameExpr ast_name_expr;
  ParenExpr ast_paren_expr;
  NumericLiteral ast_numeric_literal;
  BoolLiteral ast_bool_literal;
  VoidLiteral ast_void_literal;
  NullLiteral ast_null_literal;
  CharLiteral ast_char_literal;
  StringLiteral ast_string_literal;
  Funcall ast_funcall;
  Assignment ast_assignment;
  AddressOf ast_addressof;
  Deref ast_deref;
  IndexExpr ast_index_expr;
  Lambda ast_lambda;
  LocalField ast_local_field;
  DerefField ast_deref_field;
  TypedExpr ast_typed_expr;
  Strinit ast_strinit;
};

func mk(x ast_expr_enum) ast_expr {
  return {NoInfo(void), x};
}

deftype ast_expr_consume struct {
  after opt[ast_expr_after];
  expr ast_expr;
};

func consume(expr ast_expr) ast_expr_consume {
  return {None@[ast_expr_after](), expr};
}

deftype ast_expr_discard struct {
  after opt[ast_expr_after];
  expr ast_expr;
};

func discard(expr ast_expr) ast_expr_discard {
  return {None@[ast_expr_after](), expr};
}

deftype ast_variadic_generics struct {
  before array[ast_ident];
  variadic_name ast_ident;
  after array[ast_ident];
};

defenum ast_generics {
  NoGenerics void;
  HasGenerics array[ast_ident];
  // Right now VariadicGenerics can't be parsed.
  VariadicGenerics ast_variadic_generics;
};

defenum ast_isexport {
  IsExport void;
  IsNotExport void;
};

defenum ast_isvar {
  IsVar void;
  IsNotVar void;
};

deftype ast_def struct {
  is_export ast_isexport;
  is_var ast_isvar;
  generics ast_generics;
  name ast_ident;
  syntactic_typeexpr opt[ast_typeexpr];
  rhs ast_expr_consume;
};

deftype ast_extern_def struct {
  name ast_ident;
  type ast_typeexpr;
};

deftype ast_import struct {
  name ast_ident;
};

defenum ast_defclass_disposition {
  DefaultCopyMoveDestroy void;
  DefaultMove void;
  NoDefaults void;
};

defenum ast_type_def_rhs {
  TypeexprRhs ast_typeexpr;
  ClassexprRhs struct {
    disposition ast_defclass_disposition;
    rhs_type ast_typeexpr;
  };
};

deftype ast_type_def struct {
  generics ast_generics;
  name ast_ident;
  rhs ast_type_def_rhs;
};

defenum ast_access_arity {
  AccessArityNone void;
  AccessArityFinite u32;
};

deftype ast_access struct {
  name ast_ident;
  arity ast_access_arity;
  toplevels array[ast_toplevel];
};

defenum ast_toplevel {
  Import ast_import;
  Def ast_def;
  ExternDef ast_extern_def;
  TypeDef ast_type_def;
  Access ast_access;
};

deftype ast_file struct {
  toplevels array[ast_toplevel];
};

