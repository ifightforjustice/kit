import ast;
import parse;
import tok;

/* Ultimately, we want to convert a module into byte code.  The code
calculates what the program specifically does -- the
constructor/destructor calls, etc.  It also verifies that the code
typechecks.  It puts the information into the "checkstate" object. */


deftype module_loader struct {
  loadfn fn[ident_value, opt[array[u8]]];
};

deftype modules struct {
  by_name hash[ident_value, box[ast_file]];
};

deftype checkstate struct {
  im *identmap;
  loader module_loader;
  mods modules;
};

func check_module(cs *checkstate, name ident_value) bool {
  f ast_file;
  switch lookup(&cs->mods.by_name, name) {
    case None(v): {
      switch (cs->loader.loadfn)(name) {
        case None(v2): {
          printerr(make("Could not load file "), lookup(cs->im, name));
          return false;
        }
        case Has(s): {
          p ps = make_ps(cs->im, data(&s), count(&s));
          file box[ast_file];
          if !parse_file(&p, oo(&file)) {
            printerr(make("Parse error in "), lookup(cs->im, name));
            return false;
          }
          f = *oo(&file);
          res bool = try_insert(&cs->mods.by_name, name, file);
          check(res);
        }
      }
    }
    case Has(b): {
      f = *oo(&b);
    }
  }

  // TODO: We've got an ast_file, now actually typecheck it.

  return false;
}
