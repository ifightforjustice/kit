import check;

deftype frame_graph struct {
  cells array[cell_info];
  ops array[gr_node];
};

deftype gr_num size;

func add_node(gr *frame_graph, node gr_node) gr_num {
  ret gr_num;
  ret.~ = count(&gr->ops);
  push(&gr->ops, node);
  return ret;
}

func mut_nop_node(gr *frame_graph, ix gr_num, newnode gr_node) void {
  node *gr_node = ref(&gr->ops, ix.~);
  if case &GrNop(v void) = &node->op {
    *node = newnode;
  } else {
    ice(_u8("mut_nop_node sees non-nop node"));
  }
}

func ref_cell(gr *frame_graph, c cell_num) *cell_info {
  return ref(&gr->cells, c.~);
}

// To "evaluate" an op, first we evaluate its precs (in unspecified order), then we ealuate the op.
deftype gr_node struct {
  precs array[gr_num];
  op gr_op;
};

func node(precs array[gr_num], op gr_op) gr_node {
  return {precs, op};
}

defenum gr_op {
  GrApply gr_apply;
  GrMemCopy gr_memcopy;
  GrWriteConst gr_writeconst;
  GrAddressof gr_addressof;
  GrDeref gr_deref;
  GrSubcell gr_subcell;
  GrStrinit gr_strinit;
  GrBranch gr_branch;
  GrSequence gr_sequence;
  GrJmp gr_jmp;
  GrDead gr_dead;
  GrNop void;
};

deftype gr_apply struct {
  funcell cell_num;
  params array[cell_num];
  retcell cell_num;
};

deftype gr_memcopy struct {
  dest cell_num;
  src cell_num;
};

deftype gr_addressof struct {
  dest cell_num;
  addressee cell_num;
};

deftype gr_deref struct {
  name cell_num;
  pointer cell_num;
  offset gr_offset;
};

deftype gr_subcell struct {
  name cell_num;
  partof cell_num;
  offset gr_offset;
};

defenum gr_offset {
  OffsetConst u32;
  OffsetComputed tup[u32, cell_num];
};

deftype gr_writeconst struct {
  dest cell_num;
  value gr_const;
};

deftype gr_strinit struct {
  dest cell_num;
  parts array[tup[u32, cell_num]];
};

deftype gr_branch struct {
  src cell_num;
  cases array[tup[gr_const, gr_num]];
  default_case opt[gr_num];
};

deftype gr_sequence struct {
  first gr_num;
  second gr_num;
};

deftype gr_jmp struct {
  next gr_num;
};

deftype gr_dead struct {
  cell cell_num;
};

defenum gr_const {
  ConstInt bigint;
  ConstDef instpair;
  ConstBytes array[u8];
};

deftype fullbody_state struct {
  // TODO: This is disconcerting because fb->info->cells is a copy of gr->cells.
  info *ast_fullbody_info;
  exit_node gr_num;
};

func gr_fullbody(cs *checkstate, gr *frame_graph, x *ast_fullbody, out *gr_num) bool {
  fb fullbody_state;
  fb.info = unHas(&x->info);
  // TODO: What is the exit_node?  What variables are destroyed?  Implement variable destruction... everywhere it's necessary.
  fb.exit_node = add_node(gr, node(mk_array(), GrNop(void)));
  if !gr_bracebody(cs, gr, &fb, &x->bb, fb.exit_node, out) {
    return false;
  }
  return true;
}

func gr_bracebody(cs *checkstate, gr *frame_graph, fb *fullbody_state, x *ast_bracebody, outflow gr_num, out *gr_num) bool {
  // TODO: We need to destroy variables at the end of the body.
  bn gr_num = outflow;
  n size = count(&x->statements);
  for i size = n; i > 0; {
    i = i - 1;
    gn gr_num;
    if !gr_statement(cs, gr, fb, ref(&x->statements, i), bn, &gn) {
      return false;
    }
    bn = gn;
  }
  *out = bn;
  return true;
}

func gr_statement(cs *checkstate, gr *frame_graph, fb *fullbody_state, x *ast_statement, outflow gr_num, out *gr_num) bool {
  switch x {
    case &Expr(a ast_expr_discard): {
      gn gr_num;
      if !gr_expr_discard(cs, gr, &a, &gn) {
        return false;
      }
      *out = add_node(gr, node(mk_array(), GrSequence({gn, outflow})));
      return true;
    }
    case &Return(a ast_return_statement): {
      if !gr_return_statement(cs, gr, fb, &a, out) {
        return false;
      }
      return true;
    }
    case &Var(a ast_var_statement): {
      gn gr_num;
      if !gr_var_statement(cs, gr, fb, &a, &gn) {
        return false;
      }
      *out = add_node(gr, node(mk_array(), GrSequence({gn, outflow})));
      return true;
    }

    case &IfThen(a ast_ifthen_statement): {
      if !gr_ifthen_statement(cs, gr, fb, &a, outflow, out) {
        return false;
      }
      return true;
    }
    case &IfThenElse(a ast_ifthenelse_statement): {
      if !gr_ifthenelse_statement(cs, gr, fb, &a, outflow, out) {
        return false;
      }
      return true;
    }
    case &While(a ast_while_statement): {
      if !gr_while_statement(cs, gr, fb, &a, outflow, out) {
        return false;
      }
      return true;
    }

    case &For(a ast_for_statement): {
      if !gr_for_statement(cs, gr, fb, &a, outflow, out) {
        return false;
      }
      return true;
    }
    case &Switch(a ast_switch_statement): {
      gn gr_num;
      if !gr_switch_statement(cs, gr, fb, &a, &gn) {
        return false;
      }
      *out = add_node(gr, node(mk_array(), GrSequence({gn, outflow})));
      return true;
    }
    case &Label(a ast_label_statement): {
      return TODO();
    }
    case &Goto(a ast_goto_statement): {
      return TODO();
    }
  }
}

func gr_switch_statement(cs *checkstate, gr *frame_graph, fb *fullbody_state, a *ast_switch_statement, out *gr_num) bool {
  swartch_discard_gn gr_num;
  if !gr_later_discard(cs, gr, &a->swartch_discard, &swartch_discard_gn) {
    return false;
  }

  info *ast_enum_deconstruction_info = unHas(&a->info);
  cases array[tup[gr_const, gr_num]];
  default_case opt[gr_num] = None();
  ncases size = count(&a->cases);
  for i size = 0; i < ncases; i = i + 1 {
    sc *ast_switch_case = ref(&a->cases, i);
    body_gn gr_num;
    if !gr_bracebody(cs, gr, fb, &sc->body, swartch_discard_gn, &body_gn) {
      return false;
    }

    switch &sc->pattern {
      case &Case(cp ast_constructor_pattern): {
        cp_info *ast_cp_info = unHas(&cp.cp_info);
        vi *var_info = ref(&fb->info->all_vars, cp_info->vn.~);
        var vcgn = add_node(gr, node(mk_array(), GrSubcell({vi->cell, result_cell(oo(&a->swartch)), OffsetConst(cp_info->field_offset)})));
        var gn = add_node(gr, node(mk_array(), GrSequence({vcgn, body_gn})));
        push(&cases, cons(ConstInt(~cp_info->tag_value), gn));
      }
      case &Default(v void): {
        set(&default_case, body_gn);
      }
    }
  }

  swartch_gn gr_num;
  if !gr_expr_consume(cs, gr, oo(&a->swartch), &swartch_gn) {
    return false;
  }

  var taggn = add_node(gr, node(mk_array(swartch_gn), GrSubcell({info->tag_cell, result_cell(oo(&a->swartch)), OffsetConst(enum_tag_offset)})));

  var br = add_node(gr, node(mk_array(taggn), GrBranch({info->tag_cell, cases, default_case})));

  *out = br;
  return true;
}

func gr_for_statement(cs *checkstate, gr *frame_graph, fb *fullbody_state, a *ast_for_statement, outflow gr_num, out *gr_num) bool {
  var topgn = add_node(gr, node(mk_array(), GrNop(void)));

  loopcleanupgn gr_num;
  if !gr_later_discard(cs, gr, &a->condition_discard, &loopcleanupgn) {
    return false;
  }

  continuegn gr_num;
  if case &Has(increment box[ast_expr_discard]) = &a->increment {
    incrgn gr_num;
    if !gr_expr_discard(cs, gr, oo(&increment), &incrgn) {
      return false;
    }
    var totopgn = add_node(gr, node(mk_array(), GrSequence({incrgn, topgn})));
    continuegn = add_node(gr, node(mk_array(), GrSequence({loopcleanupgn, incrgn})));
  } else {
    continuegn = add_node(gr, node(mk_array(), GrSequence({loopcleanupgn, topgn})));
  }

  thengn gr_num;
  if !gr_bracebody(cs, gr, fb, &a->body, continuegn, &thengn) {
    return false;
  }

  gn gr_num;
  if case &Has(bc box[ast_expr_consume]) = &a->condition {
    // TODO: We might need to cleanup the variable declared in the initializer.
    loopexitgn gr_num;
    if !gr_later_discard(cs, gr, &a->condition_discard, &loopexitgn) {
      return false;
    }

    var exitseq = add_node(gr, node(mk_array(), GrSequence({loopexitgn, outflow})));

    if !gr_expr_condition(cs, gr, fb, oo(&bc), thengn, exitseq, &gn) {
      return false;
    }
  } else {
    gn = thengn;
  }

  mut_nop_node(gr, topgn, node(mk_array(), GrJmp({gn})));

  fingn gr_num;
  if case &Has(bi box[ast_statement]) = &a->initializer {
    if !gr_statement(cs, gr, fb, oo(&bi), topgn, &fingn) {
      return false;
    }
  } else {
    fingn = topgn;
  }
  *out = fingn;
  return true;
}

func gr_while_statement(cs *checkstate, gr *frame_graph, fb *fullbody_state, a *ast_while_statement, outflow gr_num, out *gr_num) bool {
  var topgn = add_node(gr, node(mk_array(), GrNop(void)));

  loopcleanupgn gr_num;
  if !gr_later_discard(cs, gr, &a->condition_discard, &loopcleanupgn) {
    return false;
  }

  loopexitgn gr_num;
  if !gr_later_discard(cs, gr, &a->condition_discard, &loopexitgn) {
    return false;
  }

  var exitseq = add_node(gr, node(mk_array(), GrSequence({loopexitgn, outflow})));

  var continuegn = add_node(gr, node(mk_array(), GrSequence({loopcleanupgn, topgn})));
  thengn gr_num;
  if !gr_bracebody(cs, gr, fb, &a->body, continuegn, &thengn) {
    return false;
  }
  gn gr_num;
  if !gr_condition(cs, gr, fb, &a->condition, thengn, exitseq, &gn) {
    return false;
  }

  mut_nop_node(gr, topgn, node(mk_array(), GrJmp({gn})));
  *out = topgn;
  return true;
}

func gr_ifthenelse_statement(cs *checkstate, gr *frame_graph, fb *fullbody_state, a *ast_ifthenelse_statement, outflow gr_num, out *gr_num) bool {
  latergn gr_num;
  if !gr_later_discard(cs, gr, &a->condition_discard, &latergn) {
    return false;
  }

  var latseq = add_node(gr, node(mk_array(), GrSequence({latergn, outflow})));

  thengn gr_num;
  if !gr_bracebody(cs, gr, fb, &a->thenbody, latseq, &thengn) {
    return false;
  }
  elsegn gr_num;
  if !gr_bracebody(cs, gr, fb, &a->elsebody, latseq, &elsegn) {
    return false;
  }
  gn gr_num;
  if !gr_condition(cs, gr, fb, &a->condition, thengn, elsegn, &gn) {
    return false;
  }
  *out = gn;
  return true;
}

func gr_ifthen_statement(cs *checkstate, gr *frame_graph, fb *fullbody_state, a *ast_ifthen_statement, outflow gr_num, out *gr_num) bool {
  latergn gr_num;
  if !gr_later_discard(cs, gr, &a->condition_discard, &latergn) {
    return false;
  }

  var latseq = add_node(gr, node(mk_array(), GrSequence({latergn, outflow})));

  bodygn gr_num;
  if !gr_bracebody(cs, gr, fb, &a->body, latseq, &bodygn) {
    return false;
  }
  gn gr_num;
  if !gr_condition(cs, gr, fb, &a->condition, bodygn, latseq, &gn) {
    return false;
  }
  *out = gn;
  return true;
}

func gr_expr_condition(cs *checkstate, gr *frame_graph, fb *fullbody_state, a *ast_expr_consume, thengn gr_num, elsegn gr_num, out *gr_num) bool {
  congn gr_num;
  if !gr_expr_consume(cs, gr, a, &congn) {
    return false;
  }
  cases array[tup[gr_const, gr_num]] = mk_array(cons(ConstInt(~ @[u32] 0), elsegn), cons(ConstInt(~ @[u32] 1), thengn));
  var br = add_node(gr, node(mk_array(congn), GrBranch({result_cell(a), cases, None()})));

  *out = br;
  return true;
}

func gr_condition(cs *checkstate, gr *frame_graph, fb *fullbody_state, a *ast_condition, thengn gr_num, elsegn gr_num, out *gr_num) bool {
  switch a {
    case &ExprCondition(bec box[ast_expr_consume]): {
      return gr_expr_condition(cs, gr, fb, oo(&bec), thengn, elsegn, out);
    }

    case &PatternCondition(pa ast_pattern_assign): {
      rhs gr_num;
      if !gr_expr_consume(cs, gr, oo(&pa.rhs), &rhs) {
        return false;
      }
      info *ast_pattern_assign_info = unHas(&pa.info);
      taggn gr_num = add_node(gr, node(mk_array(rhs), GrSubcell({info->deconstruct.tag_cell, result_cell(oo(&pa.rhs)), OffsetConst(enum_tag_offset)})));
      cases array[tup[gr_const, gr_num]];
      n u32 = info->deconstruct.num_enum_constructors;
      for i u32 = 0; i < n; i = i + 1 {
        tag u32 = enum_tag_min + i;
        if info->matching_tag_value == tag {
          push(&cases, cons(ConstInt(~tag), thengn));
        } else {
          push(&cases, cons(ConstInt(~tag), elsegn));
        }
      }
      var br = add_node(gr, node(mk_array(taggn), GrBranch({info->deconstruct.tag_cell, cases, None()})));

      *out = br;
      return true;
    }
  }
}

func gr_var_statement(cs *checkstate, gr *frame_graph, fb *fullbody_state, a *ast_var_statement, out *gr_num) bool {
  switch &a->rhs {
    case &HasExpr(be box[ast_expr_consume]): {
      return gr_expr_consume(cs, gr, oo(&be), out);
    }
    case &AutoInit(x opt[init_action]): {
      if case &Has(ia init_action) = &x {
        return gr_init_action(cs, gr, &ia, out);
      } else {
        ice(_u8("AutoInit action not annotated"));
        return fake();
      }
    }
  }
}

func gr_return_statement(cs *checkstate, gr *frame_graph, fb *fullbody_state, a *ast_return_statement, out *gr_num) bool {
  // TODO: The return exprs aren't exactly writing to the same return location cell -- a canonical one doesn't exist yet.  (Ternary operators would also have this problem.)
  gn gr_num;
  if case &Has(b box[ast_expr_consume]) = &a->expr {
    if !gr_expr_consume(cs, gr, oo(&b), &gn) {
      return false;
    }
  } else {
    // TODO: Maybe we'll need to mark the return_cell initialized, when it exists.
    gn = add_node(gr, node(mk_array(), GrNop(void)));
  }
  info *ast_return_statement_info = unHas(&a->info);
  uw gr_num;
  if !gr_unwind_vars(cs, gr, fb, &info->destructions, &uw) {
    return false;
  }
  var sn = add_node(gr, node(mk_array(), GrSequence({gn, uw})));
  *out = sn;
  return true;
}

func gr_unwind_vars(cs *checkstate, gr *frame_graph, fb *fullbody_state, destructions *array[destroy_action], out *gr_num) bool {
  bn gr_num = fb->exit_node;
  n size = count(destructions);
  for i size = 0; i < n; i = i + 1 {
    gn gr_num;
    if !gr_destroy_action(cs, gr, ref(destructions, i), &gn) {
      return false;
    }
    bn = add_node(gr, node(mk_array(), GrSequence({gn, bn})));
  }
  *out = bn;
  return true;
}

func gr_expr_discard(cs *checkstate, gr *frame_graph, x *ast_expr_discard, out *gr_num) bool {
  if case &Has(aft ast_expr_after) = &x->after {
    dp gr_num;
    if !gr_expr(cs, gr, &x->expr, &dp) {
      return false;
    }
    after_gn gr_num;
    if !gr_after_actions(cs, gr, dp, &aft.actions, &after_gn) {
      return false;
    }
    *out = after_gn;
    return true;
  } else {
    ice(_u8("gr_expr_discard missing annotation"));
    return fake();
  }
}

func gr_expr_consume(cs *checkstate, gr *frame_graph, x *ast_expr_consume, out *gr_num) bool {
  if case &Has(aft ast_expr_after) = &x->after {
    return gr_expr_and_consume(cs, gr, &x->expr, &aft, out);
  } else {
    ice(_u8("gr_expr_consume missing after"));
    return fake();
  }
}

func gr_expr_and_consume(cs *checkstate, gr *frame_graph, x *ast_expr, aft *ast_expr_after, out *gr_num) bool {
  expr_gn gr_num;
  if !gr_expr(cs, gr, x, &expr_gn) {
    return false;
  }
  after_gn gr_num;
  if !gr_after_actions(cs, gr, expr_gn, &aft->actions, &after_gn) {
    return false;
  }
  *out = after_gn;
  return true;
}

func gr_expr(cs *checkstate, gr *frame_graph, x *ast_expr, out *gr_num) bool {
  switch &x->u {
    case &NameExpr(a ast_name_expr): {
      return gr_name_expr(cs, gr, x, &a, out);
    }
    case &ParenExpr(a ast_paren_expr): {
      return gr_expr(cs, gr, oo(&a.expr), out);
    }
    case &NumericLiteral(a ast_numeric_literal): {
      return gr_literal(cs, gr, x, numeric_literal_value(&a), out);
    }
    case &BoolLiteral(a ast_bool_literal): {
      value bigint;
      if a.value {
        value = ~ @[u32] 1;
      } else {
        value = ~ @[u32] 0;
      }
      return gr_literal(cs, gr, x, value, out);
    }
    case &VoidLiteral(a ast_void_literal): {
      value bigint = ~ @[u32] 0;
      return gr_literal(cs, gr, x, value, out);
    }
    case &NullLiteral(a ast_null_literal): {
      value bigint = ~ @[u32] 0;
      return gr_literal(cs, gr, x, value, out);
    }
    case &CharLiteral(a ast_char_literal): {
      value bigint = ~ a.charspec.value;
      return gr_literal(cs, gr, x, value, out);
    }

    case &StringLiteral(a ast_string_literal): {
      return gr_string_literal(cs, gr, x, &a, out);
    }
    case &Funcall(a ast_funcall): {
      return gr_funcall(cs, gr, x, &a, out);
    }
    case &Assignment(a ast_assignment): {
      return gr_assignment(cs, gr, x, &a, out);
    }
    case &AddressOf(a ast_addressof): {
      return gr_mk_addressof(cs, gr, x, &a, out);
    }
    case &Deref(a ast_deref): {
      return gr_mk_deref(cs, gr, x, &a, out);
    }
    case &IndexExpr(a ast_index_expr): {
      return gr_index_expr(cs, gr, x, &a, out);
    }
    case &Lambda(a ast_lambda): {
      return TODO();
    }
    case &LocalField(a ast_local_field): {
      return gr_local_field(cs, gr, x, &a, out);
    }
    case &DerefField(a ast_deref_field): {
      return gr_deref_field(cs, gr, x, &a, out);
    }
    case &TypedExpr(a ast_typed_expr): {
      return gr_expr(cs, gr, oo(&a.expr), out);
    }
    case &Strinit(a ast_strinit): {
      return gr_mk_strinit(cs, gr, x, &a, out);
    }
  }
}

func gr_mk_strinit(cs *checkstate, gr *frame_graph, x *ast_expr, a *ast_strinit, out *gr_num) bool {
  precs array[gr_num];
  nparams size = count(&a->exprs);
  parts array[tup[u32, cell_num]];
  for i size = 0; i < nparams; i = i + 1 {
    param *ast_strinit_param = ref(&a->exprs, i);
    dep gr_num;
    if !gr_expr_consume(cs, gr, &param->ec, &dep) {
      return false;
    }
    push(&precs, dep);
    push(&parts, cons(strinit_param_info(param)->offset, result_cell(&param->ec)));
  }
  var ap = add_node(gr, node(precs, GrStrinit({rval_cell(x), parts})));
  *out = ap;
  return true;
}

func gr_deref_field(cs *checkstate, gr *frame_graph, x *ast_expr, a *ast_deref_field, out *gr_num) bool {
  rp gr_num;
  if !gr_expr_consume(cs, gr, oo(&a->lhs), &rp) {
    return false;
  }
  if case &Has(info ast_deref_field_info) = &a->info {
    ap gr_num;
    if !gr_later_discard(cs, gr, &a->ptr_discard, &ap) {
      return false;
    }
    switch info {
      case DerefArrayLength(count u32): {
        var cp = add_node(gr, node(mk_array(), GrWriteConst({rval_cell(x), ConstInt(~count)})));
        var sp = add_node(gr, node(mk_array(), GrSequence({rp, ap})));
        var gn = add_node(gr, node(mk_array(sp, cp), GrNop(void)));
        *out = gn;
        return true;
      }
      case DerefFieldName(offset u32): {
        name cell_num = ellval_cell(x);
        var dp = add_node(gr, node(mk_array(rp), GrDeref({name, result_cell(oo(&a->lhs)), OffsetConst(offset)})));
        var sp = add_node(gr, node(mk_array(), GrSequence({dp, ap})));
        *out = sp;
        return true;
      }
    }
  } else {
    ice(_u8("gr_deref_field sees ast_deref_field not annotated"));
    return fake();
  }
}

func gr_local_field(cs *checkstate, gr *frame_graph, x *ast_expr, a *ast_local_field, out *gr_num) bool {
  if case &Has(info ast_local_field_info) = &a->info {
    lp gr_num;
    if !gr_expr(cs, gr, oo(&a->lhs), &lp) {
      return false;
    }
    switch &info {
      case &ArrayLength(alinfo ast_arraylength_info): {
        dp gr_num;
        if !gr_after_actions(cs, gr, lp, &alinfo.after.actions, &dp) {
          return false;
        }
        var cp = add_node(gr, node(mk_array(), GrWriteConst({rval_cell(x), ConstInt(~alinfo.count)})));
        var gn = add_node(gr, node(mk_array(dp, cp), GrNop(void)));
        *out = gn;
        return true;
      }
      case &FieldName(offset u32): {
        var gn = add_node(gr, node(mk_array(lp), GrSubcell({value_cell(x), value_cell(oo(&a->lhs)), OffsetConst(offset)})));
        *out = gn;
        return true;
      }
    }
  } else {
    ice(_u8("ast_local_field missing info"));
    return fake();
  }
}

func gr_index_expr(cs *checkstate, gr *frame_graph, x *ast_expr, a *ast_index_expr, out *gr_num) bool {
  if case &Has(info ast_index_expr_info) = &a->info {
    rp gr_num;
    if !gr_expr_consume(cs, gr, oo(&a->rhs), &rp) {
      return false;
    }
    lp gr_num;
    if !gr_expr(cs, gr, oo(&a->lhs), &lp) {
      return false;
    }
    if case &Has(aft ast_expr_after) = &info.after {
      // It's a pointer.
      name cell_num = ellval_cell(x);
      flat_size u32 = ref_cell(gr, name)->props.flat_size;
      var gp = add_node(gr, node(mk_array(rp, lp), GrDeref({name, result_cell(&aft), OffsetComputed(cons(flat_size, result_cell(oo(&a->rhs))))})));
      gn gr_num;
      if !gr_after_actions(cs, gr, gp, &aft.actions, &gn) {
        return false;
      }
      *out = gn;
      return true;
    } else {
      name cell_num = value_cell(x);
      flat_size u32 = ref_cell(gr, name)->props.flat_size;
      var gp = add_node(gr, node(mk_array(rp, lp), GrSubcell({name, value_cell(oo(&a->lhs)), OffsetComputed(cons(flat_size, result_cell(oo(&a->rhs))))})));
      *out = gp;
      return true;
    }
  } else {
    ice(_u8("gr_index_expr sees unannotated ast_index_expr"));
    return fake();
  }
}

func gr_later_discard(cs *checkstate, gr *frame_graph, a *ast_later_discard_info, out *gr_num) bool {
  if case &Has(da destroy_action) = &a->action {
    return gr_destroy_action(cs, gr, &da, out);
  } else {
    ice(_u8("ast_later_discard_info not annotated"));
    return fake();
  }
}

func gr_mk_deref(cs *checkstate, gr *frame_graph, x *ast_expr, a *ast_deref, out *gr_num) bool {
  rp gr_num;
  if !gr_expr_consume(cs, gr, oo(&a->rhs), &rp) {
    return false;
  }
  var dp = add_node(gr, node(mk_array(rp), GrDeref({ellval_cell(x), result_cell(oo(&a->rhs)), OffsetConst(0)})));
  ap gr_num;
  if !gr_later_discard(cs, gr, &a->ptr_discard, &ap) {
    return false;
  }
  var gn = add_node(gr, node(mk_array(), GrSequence({dp, ap})));
  *out = gn;
  return true;
}

func gr_mk_addressof(cs *checkstate, gr *frame_graph, x *ast_expr, a *ast_addressof, out *gr_num) bool {
  rp gr_num;
  if !gr_expr(cs, gr, oo(&a->rhs), &rp) {
    return false;
  }
  ap gr_num = add_node(gr, node(mk_array(rp), GrAddressof({rval_cell(x), ellval_cell(oo(&a->rhs))})));
  *out = ap;
  return true;
}

func gr_assignment(cs *checkstate, gr *frame_graph, x *ast_expr, a *ast_assignment, out *gr_num) bool {
  lp gr_num;
  if !gr_expr(cs, gr, oo(&a->lhs), &lp) {
    return false;
  }
  rp gr_num;
  if !gr_expr(cs, gr, oo(&a->rhs), &rp) {
    return false;
  }
  switch assignment_info(a) {
    case &StaticSelfAssignment(v void): {
      var nop = add_node(gr, node(mk_array(lp, rp), GrNop(void)));
      *out = nop;
      return true;
    }
    case &ConditionalAssignment(ci ast_conditional_assignment_info): {
      var fc = add_node(gr, node(mk_array(), GrWriteConst({ci.comparecells.funcell, ConstDef(ci.comparecells.ip)})));
      var dp = add_node(gr, node(mk_array(), GrAddressof({ci.comparecells.destptr, value_cell(oo(&a->lhs))})));
      var sp = add_node(gr, node(mk_array(), GrAddressof({ci.comparecells.srcptr, value_cell(oo(&a->rhs))})));
      var ap = add_node(gr, node(mk_array(fc, dp, sp), GrApply({ci.comparecells.funcell, mk_array(ci.comparecells.destptr, ci.comparecells.srcptr), ci.comparecells.cmp_result})));

      var nop = add_node(gr, node(mk_array(), GrNop(void)));
      var assignnop = add_node(gr, node(mk_array(), GrNop(void)));
      assign gr_num;
      if !gr_after_actions(cs, gr, assignnop, &ci.conditional_actions, &assign) {
        return false;
      }
      cases array[tup[gr_const, gr_num]] = mk_array(cons(ConstInt(~ @[u32] 0), assign), cons(ConstInt(~ @[u32] 1), nop));

      var br = add_node(gr, node(mk_array(ap), GrBranch({ci.comparecells.cmp_result, cases, None()})));
      unc gr_num;
      if !gr_after_actions(cs, gr, br, &ci.unconditional_actions, &unc) {
        return false;
      }
      *out = unc;
      return true;
    }
  }
}

func gr_funcall(cs *checkstate, gr *frame_graph, x *ast_expr, a *ast_funcall, out *gr_num) bool {
  precs array[gr_num];
  dep gr_num;
  if !gr_expr_consume(cs, gr, oo(&a->fun), &dep) {
    return false;
  }
  push(&precs, dep);
  paramcells array[cell_num];
  nparams size = count(&a->params);
  for i size = 0; i < nparams; i = i + 1 {
    param *ast_expr_consume = ref(&a->params, i);
    if !gr_expr_consume(cs, gr, param, &dep) {
      return false;
    }
    push(&precs, dep);
    push(&paramcells, result_cell(param));
  }
  var ap = add_node(gr, node(precs, GrApply({result_cell(oo(&a->fun)), paramcells, rval_cell(x)})));
  *out = ap;
  return true;
}

func gr_string_literal(cs *checkstate, gr *frame_graph, x *ast_expr, a *ast_string_literal, out *gr_num) bool {
  bytes array[u8];
  nchars size = count(&a->charspecs);
  for i size = 0; i < nchars; i = i + 1 {
    ch i32 = get(&a->charspecs, i).value;
    if ch < 0 || ch > 255 {
      ice(_u8("gr_string_literal char values out of range"));
    }
    push(&bytes, ~ch);
  }
  var gn = add_node(gr, node(mk_array(), GrWriteConst({rval_cell(x), ConstBytes(bytes)})));
  *out = gn;
  return true;
}

func gr_literal(cs *checkstate, gr *frame_graph, x *ast_expr, value bigint, out *gr_num) bool {
  var gn = add_node(gr, node(mk_array(), GrWriteConst({rval_cell(x), ConstInt(value)})));
  *out = gn;
  return true;
}

func gr_name_expr(cs *checkstate, gr *frame_graph, x *ast_expr, a *ast_name_expr, out *gr_num) bool {
  switch name_info(a) {
    case &LocalResolve(li local_info): {
      *out = add_node(gr, node(mk_array(), GrNop(void)));
      return true;
    }
    case &GlobalResolve(gi global_info): {
      *out = add_node(gr, node(mk_array(), GrWriteConst({rval_cell(x), ConstDef({gi.ent, gi.inst})})));
      return true;
    }
    case &EnumConstructor(v void): {
      return TODO();
    }
  }
}

func ellval_cell(x *is_lval) cell_num {
  switch x {
    case &IsLvalYes(desc lval_description): { return desc.num; }
    case &IsLvalNo(desc rval_description): {
      ice(_u8("lvalue_value_cell expects lvalue"));
      return fake();
    }
  }
}

func ellval_cell(a *ast_expr) cell_num {
  return ellval_cell(&expr_complete_info(a)->lval);
}

func rval_cell(x *ast_expr) cell_num {
  return rval_cell(&expr_complete_info(x)->lval);
}

func rval_cell(x *is_lval) cell_num {
  switch x {
    case &IsLvalNo(desc rval_description): {
      return desc.whole_num;
    }
    case &IsLvalYes(desc lval_description): {
      ice(_u8("rval_cell sees lvalue"));
      return fake();
    }
  }
}

func gr_after_actions(cs *checkstate, gr *frame_graph, prec gr_num, x *array[after_action], out *gr_num) bool {
  nacts size = count(x);
  for i size = 0; i < nacts; i = i + 1 {
    dep gr_num;
    if !gr_after_action(cs, gr, ref(x, i), &dep) {
      return false;
    }
    prec = add_node(gr, node(mk_array(), GrSequence({prec, dep})));
  }
  *out = prec;
  return true;
}

func gr_after_action(cs *checkstate, gr *frame_graph, x *after_action, out *gr_num) bool {
  switch x {
    case &CopyAfter(ca copy_action): {
      return gr_bi_action(cs, gr, &ca.~, out);
    }
    case &MoveAfter(ma move_action): {
      dep gr_num;
      if !gr_bi_action(cs, gr, &ma.~, &dep) {
        return false;
      }
      *out = add_node(gr, node(mk_array(dep), GrDead({ma.src})));
      return true;
    }
    case &DestroyAfter(da destroy_action): {
      return gr_destroy_action(cs, gr, &da, out);
    }
  }
}


func gr_init_action(cs *checkstate, gr *frame_graph, x *init_action, out *gr_num) bool {
  switch &x->ctor {
    case &UniTrivialCtor(v void): {
      var dp = add_node(gr, node(mk_array(), GrWriteConst({x->arg, ConstInt(~ @[u32] 0)})));
      *out = dp;
      return true;
    }
    case &UniFunCtor(desc uni_fun_ctor_desc): {
      // TODO: This dupes some code of gr_destroy_action.
      var fc = add_node(gr, node(mk_array(), GrWriteConst({desc.funcell, ConstDef(desc.ip)})));
      var arp = add_node(gr, node(mk_array(), GrAddressof({desc.argptr, x->arg})));
      var ap = add_node(gr, node(mk_array(fc, arp), GrApply({desc.funcell, mk_array(desc.argptr), desc.retvoid})));
      var deadret = add_node(gr, node(mk_array(ap), GrDead({desc.retvoid})));
      *out = deadret;
      return true;
    }
  }
}

func gr_destroy_action(cs *checkstate, gr *frame_graph, x *destroy_action, out *gr_num) bool {
  switch &x->ctor {
    case &UniTrivialCtor(v void): {
      var dp = add_node(gr, node(mk_array(), GrDead({x->arg})));
      *out = dp;
      return true;
    }
    case &UniFunCtor(desc uni_fun_ctor_desc): {
      var fc = add_node(gr, node(mk_array(), GrWriteConst({desc.funcell, ConstDef(desc.ip)})));
      var arp = add_node(gr, node(mk_array(), GrAddressof({desc.argptr, x->arg})));
      var ap = add_node(gr, node(mk_array(fc, arp), GrApply({desc.funcell, mk_array(desc.argptr), desc.retvoid})));
      var deadret = add_node(gr, node(mk_array(ap), GrDead({desc.retvoid})));
      var dp = add_node(gr, node(mk_array(deadret), GrDead({x->arg})));
      *out = dp;
      return true;
    }
  }
}

func gr_bi_action(cs *checkstate, gr *frame_graph, x *bi_action, out *gr_num) bool {
  switch &x->ctor {
    case &BiTrivialCtor(v void): {
      var cp = add_node(gr, node(mk_array(), GrMemCopy({x->dest, x->src})));
      *out = cp;
      return true;
    }
    case &BiFunCtor(desc bi_fun_ctor_desc): {
      var fc = add_node(gr, node(mk_array(), GrWriteConst({desc.funcell, ConstDef(desc.ip)})));
      var dp = add_node(gr, node(mk_array(), GrAddressof({desc.destptr, x->dest})));
      var sp = add_node(gr, node(mk_array(), GrAddressof({desc.srcptr, x->src})));
      var ap = add_node(gr, node(mk_array(fc, dp, sp), GrApply({desc.funcell, mk_array(desc.destptr, desc.srcptr), desc.retvoid})));
      var deadret = add_node(gr, node(mk_array(ap), GrDead({desc.retvoid})));
      *out = deadret;
      return true;
    }
  }
}
