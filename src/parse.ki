import tok;

defenum allow_blanks {
  AllowBlanksNo void;
  AllowBlanksYes void;
};

defenum force_assignment {
  ForceAssignmentNo void;
  ForceAssignmentYes void;
};

// Used to indicate a "parse failure", grepabbly in case we want fancier handling later.
def Fail bool = false;

deftype prec_pair struct {
  left i32;
  right i32;
};

defenum prec_cmp {
  Conflicts void;
  PullsLeft void;
  PullsRight void;
};

// def[T] dbgparse fn[T, void] = debugstr;
func[T] dbgparse(x T) void { }

def kSemicolonPrec i32 = 205;
def kCommaPrec i32 = 205;
// Just enough to force assignment in conditionals to be parenthesized.
def kConditionPrec i32 = 305;
def kConversionRightPrec i32 = 905;

func parse_file(p *ps, out *ast_file) bool {
  dbgparse("parse_file\n");
  arr array[ast_toplevel];
  if !parse_toplevels(p, Eof(void), &arr) {
    return Fail;
  }
  *out = {arr};
  return true;
}

func parse_toplevels(p *ps, stop tokval, out *array[ast_toplevel]) bool {
  dbgparse("parse_toplevels\n");
  ret array[ast_toplevel];
  for ;; {
    if peek(p).val == stop {
      *out = ret;
      return true;
    }
    top ast_toplevel;
    if !parse_toplevel(p, &top) {
      return Fail;
    }
    push(&ret, top);
  }
}

func try_skip_token(p *ps, expected tokval) bool {
  if peek(p).val == expected {
    step(p);
    return true;
  }
  return Fail;
}

func try_skip_oper(p *ps, expected i32, out *ast_ident) bool {
  if peek(p).val == mk_oper(expected) {
    m ast_meta = startend(p);
    *out = {m, intern(p->im, ~mk_array(expected))};
    step(p);
    return true;
  } else {
    return Fail;
  }
}
func try_skip_oper(p *ps, expected i32) bool {
  return try_skip_token(p, mk_oper(expected));
}
func try_skip_oper(p *ps, exp0 i32, exp1 i32) bool {
  return try_skip_token(p, mk_oper(exp0, exp1));
}
func try_skip_oper(p *ps, exp0 i32, exp1 i32, exp2 i32) bool {
  return try_skip_token(p, mk_oper(exp0, exp1, exp2));
}

func parse_toplevel(p *ps, out *ast_toplevel) bool {
  dbgparse("parse_toplevel\n");
  if try_skip_token(p, Keyw(Func(void))) {
    return parse_rest_of_func(p, IsNotExport(void), out);
  } else if try_skip_token(p, Keyw(Def(void))) {
    return parse_rest_of_def(p, IsNotExport(void), IsNotVar(void), out);
  } else if try_skip_token(p, Keyw(Var(void))) {
    return parse_rest_of_def(p, IsNotExport(void), IsVar(void), out);
  } else if try_skip_token(p, Keyw(Export(void))) {
    if try_skip_token(p, Keyw(Func(void))) {
      return parse_rest_of_func(p, IsExport(void), out);
    } else if try_skip_token(p, Keyw(Var(void))) {
      return parse_rest_of_def(p, IsExport(void), IsVar(void), out);
    } else if try_skip_token(p, Keyw(Def(void))) {
      return parse_rest_of_def(p, IsExport(void), IsNotVar(void), out);
    }
    return Fail;
  } else if try_skip_token(p, Keyw(Extern(void))) {
    return parse_rest_of_extern_def(p, out);
  } else if try_skip_token(p, Keyw(Import(void))) {
    return parse_rest_of_import(p, out);
  } else if try_skip_token(p, Keyw(Deftype(void))) {
    return parse_rest_of_deftype(p, out);
  } else if try_skip_token(p, Keyw(Defclass(void))) {
    return parse_rest_of_defclass(p, out);
  } else if try_skip_token(p, Keyw(Defenum(void))) {
    return parse_rest_of_defenum(p, out);
  } else if try_skip_token(p, Keyw(Alias(void))) {
    return parse_rest_of_alias(p, out);
  } else if try_skip_token(p, Keyw(Access(void))) {
    return parse_rest_of_access(p, out);
  } else {
    return Fail;
  }
}

// TODO: Have a specific AST datatype for funcs instead of munging them into ast_def.
func parse_rest_of_func(p *ps, is_export ast_isexport, out *ast_toplevel) bool {
  generics ast_generics;
  name ast_ident;
  params array[ast_vardecl];
  return_type ast_typeexpr;
  body ast_bracebody;
  if !(parse_def_generics_and_name(p, is_export, IsNotVar(void), &generics, &name)
       && parse_lambdaspec(p, &params, &return_type, &body)) {
    return Fail;
  }

  *out = Def({is_export, IsNotVar(void), generics, name, None(),
              Lambda({params, return_type, body})});
  return true;
}

func parse_rest_of_def(p *ps, is_export ast_isexport, is_var ast_isvar, out *ast_toplevel) bool {
  generics ast_generics;
  name ast_ident;
  if !parse_def_generics_and_name(p, is_export, is_var, &generics, &name) {
    return Fail;
  }

  typeexpr opt[ast_typeexpr];
  if try_skip_oper(p, '=') {
    typeexpr = None();
  } else {
    t ast_typeexpr;
    if !(parse_typeexpr(p, &t) && try_skip_oper(p, '=')) {
      return Fail;
    }
    typeexpr = Has(t);
  }

  rhs ast_expr;
  if !(parse_expr(p, kSemicolonPrec, &rhs)
       && try_skip_oper(p, ';')) {
    return Fail;
  }

  *out = Def({is_export, is_var, generics, name, typeexpr, rhs});
  return true;
}

func parse_rest_of_extern_def(p *ps, out *ast_toplevel) bool {
  name ast_ident;
  type ast_typeexpr;
  if !(parse_ident(p, &name)
       && parse_typeexpr(p, &type)
       && try_skip_oper(p, ';')) {
    return Fail;
  }
  *out = ExternDef({name, type});
  return true;
}

func parse_rest_of_import(p *ps, out *ast_toplevel) bool {
  dbgparse("parse_rest_of_import\n");
  name ast_ident;
  if !(parse_ident(p, &name) && try_skip_oper(p, ';')) {
    return Fail;
  }
  *out = Import({name});
  return true;
}

func parse_rest_of_deftype(p *ps, out *ast_toplevel) bool {
  generics ast_generics;
  name ast_ident;
  type ast_typeexpr;
  if !(parse_generics_if_present(p, &generics)
       && parse_ident(p, &name)
       && parse_typeexpr(p, &type)
       && try_skip_oper(p, ';')) {
    return Fail;
  }
  *out = TypeDef({generics, name, TypeexprRhs(type)});
  return true;
}

func parse_rest_of_alias(p *ps, out *ast_toplevel) bool {
  generics ast_generics;
  name ast_ident;
  type ast_typeexpr;
  if !(parse_generics_if_present(p, &generics)
       && parse_ident(p, &name)
       && parse_typeexpr(p, &type)
       && try_skip_oper(p, ';')) {
    return Fail;
  }
  *out = TypeAlias({generics, name, type});
  return true;
}

func parse_rest_of_defclass(p *ps, out *ast_toplevel) bool {
  generics ast_generics;
  if !parse_generics_if_present(p, &generics) {
    return Fail;
  }
  disposition ast_defclass_disposition;
  if try_skip_token(p, Keyw(Copy(void))) {
    disposition = DefaultCopyMoveDestroy(void);
  } else if try_skip_token(p, Keyw(Move(void))) {
    disposition = DefaultMove(void);
  } else {
    disposition = NoDefaults(void);
  }
  name ast_ident;
  type ast_typeexpr;
  if !(parse_ident(p, &name) && parse_typeexpr(p, &type)
       && try_skip_oper(p, ';')) {
    return Fail;
  }
  *out = TypeDef({generics, name, ClassexprRhs({disposition, type})});
  return true;
}

func parse_rest_of_defenum(p *ps, out *ast_toplevel) bool {
  generics ast_generics;
  name ast_ident;
  enumfields array[ast_vardecl];
  if !(parse_generics_if_present(p, &generics)
       && parse_ident(p, &name)
       && parse_braced_fields(p, &enumfields)
       && try_skip_oper(p, ';')) {
    return Fail;
  }
  *out = TypeDef({generics, name,
                  TypeexprRhs(@[ast_typeexpr]Enum({enumfields}))});
  return true;
}

func parse_rest_of_access(p *ps, out *ast_toplevel) bool {
  name ast_ident;
  if !parse_ident(p, &name) {
    return Fail;
  }
  arity generics_arity;
  if !try_skip_token(p, Grouper(LBracket(void))) {
    arity = NoParamsArity(void);
  } else {
    counter u32 = 0;
    done bool = false;
    while !done {
      if try_skip_token(p, Grouper(RBracket(void))) {
        done = true;
      } else {
        if counter != 0 {
          if !try_skip_oper(p, ',') {
            return Fail;
          }
        }
        if !try_skip_token(p, Keyw(Underscore(void))) {
          return Fail;
        }
        counter = counter + 1;
      }
    }
    arity = FiniteArity(counter);
  }

  toplevels array[ast_toplevel];
  if !(try_skip_token(p, Grouper(LBrace(void)))
       && parse_toplevels(p, Grouper(RBrace(void)), &toplevels)
       && try_skip_token(p, Grouper(RBrace(void)))) {
    return Fail;
  }
  *out = Access({name, arity, toplevels});
  return true;
}

func parse_def_generics_and_name(p *ps, is_export ast_isexport, is_var ast_isvar,
                                 generics_out *ast_generics, name_out *ast_ident) bool {
  switch is_export {
    case IsExport(v): {
      *generics_out = NoGenerics(void);
    }
    case IsNotExport(v): {
      switch is_var {
        case IsVar(v2): {
          *generics_out = NoGenerics(void);
        }
        case IsNotVar(v2): {
          if !parse_generics_if_present(p, generics_out) {
            return Fail;
          }
        }
      }
    }
  }
  if !parse_ident(p, name_out) {
    return Fail;
  }
  return true;
}

func parse_lambdaspec(p *ps, params_out *array[ast_vardecl],
                      return_type_out *ast_typeexpr, body_out *ast_bracebody) bool {
  return parse_args_list(p, params_out)
    && parse_typeexpr(p, return_type_out)
    && parse_bracebody(p, body_out);
}

func parse_typeexpr(p *ps, out *ast_typeexpr) bool {
  return help_parse_typeexpr(p, AllowBlanksNo(void), out);
}

func parse_ident(p *ps, out *ast_ident) bool {
  return try_parse_ident(p, out);
}

func parse_rest_of_backtick_ident(p *ps, ident_meta ast_meta, out *ast_ident) bool {
  switch peek(p).val {
    default: {
      return Fail;
    }
    // TODO: "Opers" such as "@" or maybe even "=" shouldn't really be allowed here -- only functional opers allowed.
    // TODO: We probably should not allow "` + `" to parse -- require tight quoting, do this at tokenization.
    case Oper(operch array[i32]): {
      step(p);
      if !try_skip_token(p, Backtick(void)) {
        return Fail;
      }
      end(p, ident_meta);
      *out = {ident_meta, intern(p->im, ~operch)};
      return true;
    }
  }
}

func try_parse_ident(p *ps, out *ast_ident) bool {
  dbgparse("try_parse_ident\n");
  switch peek(p).val {
    case Ident(text array[i32]): {
      m ast_meta = startend(p);
      step(p);
      *out = {m, intern(p->im, ~text)};
      return true;
    }
    case Backtick(v): {
      ident_meta ast_meta = start(p);
      step(p);
      return parse_rest_of_backtick_ident(p, ident_meta, out);
    }
    default: {
      return Fail;
    }
  }
}

func parse_generics_if_present(p *ps, out *ast_generics) bool {
  args array[ast_ident];
  if !try_skip_token(p, Grouper(LBracket(void))) {
    *out = NoGenerics(void);
    return true;
  }
  for ;; {
    if try_skip_token(p, Grouper(RBracket(void))) {
      *out = HasGenerics(args);
      return true;
    }
    if count(&args) != 0 {
      if !try_skip_oper(p, ',') {
        return Fail;
      }
    }
    arg ast_ident;
    if !parse_ident(p, &arg) {
      return Fail;
    }
    push(&args, arg);
  }
}

func parse_args_list(p *ps, out *array[ast_vardecl]) bool {
  if !try_skip_token(p, Grouper(LParen(void))) {
    return Fail;
  }
  args array[ast_vardecl];
  for ;; {
    if try_skip_token(p, Grouper(RParen(void))) {
      *out = args;
      return true;
    }
    if count(&args) != 0 {
      if !try_skip_oper(p, ',') {
        return Fail;
      }
    }
    decl ast_vardecl;
    if !parse_vardecl(p, AllowBlanksNo(void), &decl) {
      return Fail;
    }
    push(&args, decl);
  }
}

func parse_bracebody(p *ps, out *ast_bracebody) bool {
  if !try_skip_token(p, Grouper(LBrace(void))) {
    return Fail;
  }
  statements array[ast_statement];
  for ;; {
    if try_skip_token(p, Grouper(RBrace(void))) {
      *out = {statements};
      return true;
    }
    statement ast_statement;
    if !parse_statement(p, &statement) {
      return Fail;
    }
    push(&statements, statement);
  }
}

func try_underscore_if_allowed(p *ps, ab allow_blanks, out *ast_typeexpr) bool {
  switch ab {
    case AllowBlanksYes(v): {
      if try_skip_token(p, Keyw(Underscore(void))) {
        *out = Unknown({});
        return true;
      }
      return Fail;
    }
    case AllowBlanksNo(v): {
      return Fail;
    }
  }
}

func help_parse_typeexpr(p *ps, ab allow_blanks, out *ast_typeexpr) bool {
  switch help_triparse_typeexpr(p, ab, out) {
    case Success(v): { return true; }
    default: { return false; }
  }
}

func success_or_fail(res bool) triparse_result {
  if res {
    return Success(void);
  } else {
    return Error(void);
  }
}

func help_triparse_typeexpr(p *ps, ab allow_blanks, out *ast_typeexpr) triparse_result {
  if try_skip_token(p, Keyw(Struct(void))) {
    return success_or_fail(parse_rest_of_struct(p, out));
  }
  if try_skip_token(p, Keyw(Enum(void))) {
    return success_or_fail(parse_rest_of_enum(p, out));
  }
  if try_skip_token(p, Keyw(Union(void))) {
    return success_or_fail(parse_rest_of_union(p, out));
  }
  if try_skip_token(p, Grouper(LBracket(void))) {
    return success_or_fail(parse_rest_of_arraytype(p, ab, out));
  }
  oper ast_ident;
  if try_skip_oper(p, '*', &oper) {
    return success_or_fail(parse_rest_of_pointer(p, ab, oper, out));
  }

  lhs ast_typeexpr;
  if !try_underscore_if_allowed(p, ab, &lhs) {
    name ast_ident;
    if !try_parse_ident(p, &name) {
      return Quickfail(void);
    }
    lhs = Name(name);
  }
  if !try_skip_token(p, Grouper(LBracket(void))) {
    *out = lhs;
    return Success(void);
  }
  args array[ast_typeexpr];
  if !parse_rest_of_type_param_list(p, ab, &args) {
    return Error(void);
  }
  // TODO: Allow arbitrarily many type applications?
  *out = App({embox(lhs), args});
  return Success(void);
}

func parse_rest_of_struct(p *ps, out *ast_typeexpr) bool {
  fields array[ast_vardecl];
  if !parse_braced_fields(p, &fields) {
    return Fail;
  }
  *out = Struct({fields});
  return true;
}

func parse_rest_of_enum(p *ps, out *ast_typeexpr) bool {
  fields array[ast_vardecl];
  if !parse_braced_fields(p, &fields) {
    return Fail;
  }
  *out = Enum({fields});
  return true;
}

func parse_rest_of_union(p *ps, out *ast_typeexpr) bool {
  fields array[ast_vardecl];
  if !parse_braced_fields(p, &fields) {
    return Fail;
  }
  *out = Union({fields});
  return true;
}

func parse_rest_of_arraytype(p *ps, ab allow_blanks, out *ast_typeexpr) bool {
  switch ab {
    case AllowBlanksYes(v): {
      if try_skip_token(p, Keyw(Underscore(void))) {
        param box[ast_typeexpr];
        if !(try_skip_token(p, Grouper(RBracket(void)))
             && help_parse_typeexpr(p, ab, oo(&param))) {
          return Fail;
        }

        *out = Arraytype({None(), param});
        return true;
      }
    }
    default: { }
  }

  count box[ast_expr];
  param box[ast_typeexpr];
  if !(parse_expr(p, kSemicolonPrec, oo(&count))
       && try_skip_token(p, Grouper(RBracket(void)))
       && parse_typeexpr(p, oo(&param))) {
    return Fail;
  }

  *out = Arraytype({Has(count), param});
  return true;
}

func parse_rest_of_pointer(p *ps, ab allow_blanks, oper ast_ident, out *ast_typeexpr) bool {
  arg ast_typeexpr;
  if !help_parse_typeexpr(p, ab, &arg) {
    return Fail;
  }
  *out = App({embox(Name(oper)),
              mk_array(arg)});
  return true;
}

func parse_rest_of_type_param_list(p *ps, ab allow_blanks, out *array[ast_typeexpr]) bool {
  args array[ast_typeexpr];
  for ;; {
    if try_skip_token(p, Grouper(RBracket(void))) {
      *out = args;
      return true;
    }

    if count(&args) != 0 {
      if !try_skip_oper(p, ',') {
        return Fail;
      }
    }

    typeexpr ast_typeexpr;
    if !help_parse_typeexpr(p, ab, &typeexpr) {
      return Fail;
    }
    push(&args, typeexpr);
  }
}


func parse_braced_fields(p *ps, out *array[ast_vardecl]) bool {
  if !try_skip_token(p, Grouper(LBrace(void))) {
    return Fail;
  }
  fields array[ast_vardecl];
  for ;; {
    if try_skip_token(p, Grouper(RBrace(void))) {
      *out = fields;
      return true;
    }

    field ast_vardecl;
    if !(parse_vardecl(p, AllowBlanksNo(void), &field)
         && try_skip_oper(p, ';')) {
      return Fail;
    }
    push(&fields, field);
  }
}

func parse_vardecl(p *ps, ab allow_blanks, out *ast_vardecl) bool {
  name ast_ident;
  if !parse_ident(p, &name) {
    return Fail;
  }

  switch ab {
    case AllowBlanksYes(v): {
      type ast_typeexpr;
      switch help_triparse_typeexpr(p, ab, &type) {
        case Success(v2): {
          *out = {name, type};
          return true;
        }
        case Quickfail(v2): {
          *out = {name, Unknown({})};
          return true;
        }
        case Error(v2): {
          return Fail;
        }
      }
    }
    case AllowBlanksNo(v): {
      type ast_typeexpr;
      if !help_parse_typeexpr(p, ab, &type) {
        return Fail;
      }
      *out = {name, type};
      return true;
    }
  }
}

func parse_expr(p *ps, prec_ctx i32, out *ast_expr) bool {
  lhs ast_expr;
  if !parse_atomic_expr(p, &lhs) {
    return Fail;
  }

  return parse_after_atomic_expr(p, prec_ctx, lhs, out);
}

func parse_after_atomic_expr(p *ps, prec_ctx i32, lhs ast_expr, out *ast_expr) bool {
  for ;; {
    if try_skip_token(p, Grouper(LParen(void))) {
      params array[ast_expr];
      if !parse_rest_of_param_list(p, &params) {
        return Fail;
      }
      lhs = Funcall({embox(lhs), params});
    } else if try_skip_token(p, Grouper(LBracket(void))) {
      arg box[ast_expr];
      if !(parse_expr(p, kCommaPrec, oo(&arg))
           && try_skip_token(p, Grouper(RBracket(void)))) {
        return Fail;
      }
      lhs = IndexExpr({embox(lhs), arg});
    } else if try_skip_oper(p, '.', '~') {
      lhs = LocalField({embox(lhs), WholeField(void)});
    } else if try_skip_oper(p, '.') {
      fieldname ast_ident;
      if !parse_ident(p, &fieldname) {
        return Fail;
      }
      lhs = LocalField({embox(lhs), NameField(fieldname)});
    } else if try_skip_oper(p, '-', '>', '~') {
      lhs = DerefField({embox(lhs), WholeField(void)});
    } else if try_skip_oper(p, '-', '>') {
      fieldname ast_ident;
      if !parse_ident(p, &fieldname) {
        return Fail;
      }
      lhs = DerefField({embox(lhs), NameField(fieldname)});
    } else if is_binop(peek(p).val) {
      op tok = peek(p);
      op_prec prec_pair = binop_prec(op.val);
      switch compare_prec(prec_ctx, op_prec.left) {
        case Conflicts(v): {
          return Fail;
        }
        case PullsLeft(v): {
          *out = lhs;
          return true;
        }
        case PullsRight(v): {
          oper ast_ident = {startend(p), intern(p->im, ~oper_arr(op.val))};
          step(p);
          rhs ast_expr;
          if !parse_expr(p, op_prec.right, &rhs) {
            return Fail;
          }
          lhs = build_binop_expr(p->im, oper, lhs, rhs);
        }
      }
    } else {
      *out = lhs;
      return true;
    }
  }
}

func is_binop(t tokval) bool {
  switch binop_info(t) {
    case Has(x): { return true; }
    case None(v): { return false; }
  }
}

func binop_prec(t tokval) prec_pair {
  switch binop_info(t) {
    case Has(x): { return x; }
    case None(v): { check(false); return fake(); }
  }
}

func binop_info(t tokval) opt[prec_pair] {
  switch t {
    default: { return None(); }
    case Oper(x array[i32]): {
      if count(&x) == 1 {
        c0 i32 = get(&x, 0);
        if c0 == '=' { return Has({306, 304}); }
        if c0 == '+' || c0 == '-' { return Has({504, 506}); }
        if c0 == '<' || c0 == '>' { return Has({405, 405}); }
        if c0 == '*' || c0 == '/' { return Has({604, 606}); }
        if c0 == '%' { return Has({605, 605}); }
        if c0 == '^' || c0 == '&' || c0 == '|' { return Has({405, 405}); }
        return None();
      }
      if count(&x) == 2 {
        c0 i32 = get(&x, 0);
        c1 i32 = get(&x, 1);
        if c0 == '&' && c1 == '&' { return Has({376, 374}); }
        if c0 == '|' && c1 == '|' { return Has({356, 354}); }
        if (c0 == '<' && c1 == '<') || (c0 == '>' && c1 =='>') {
          return Has({405, 405});
        }
        if c1 == '=' && (c0 == '!' || c0 == '%' || c0 == '&' || c0 == '*'
                         || c0 == '-' || c0 == '=' || c0 == '+' || c0 == '|'
                         || c0 == '<' || c0 == '>' || c0 == '/') {
          return Has({306, 304});
        }
        return None();
      }
      if count(&x) == 3 {
        c0 i32 = get(&x, 0);
        c1 i32 = get(&x, 1);
        c2 i32 = get(&x, 2);
        if c2 == '=' && ((c0 == '<' && c1 == '<')
                         || (c0 == '>' && c1 == '>')) {
          return Has({306, 304});
        }
        return None();
      }
      return None();
    }
  }
}

func compare_prec(left i32, right i32) prec_cmp {
  if left + 1 < right { return PullsRight(void); }
  if right + 1 < left { return PullsLeft(void); }
  return Conflicts(void);
}

func oper_arr(tv tokval) array[i32] {
  switch tv {
    case Oper(arr array[i32]): { return arr; }
    default: { check(false); return fake(); }
  }
}

func build_binop_expr(im *identmap, op ast_ident, lhs ast_expr, rhs ast_expr) ast_expr {
  return Funcall({embox(NameExpr({op, None()})),
                  mk_array(lhs, rhs)});
}

func parse_finish_name_expr(p *ps, ident ast_ident, out *ast_expr) bool {
  switch peek(p).val {
    case Oper(operch array[i32]): {
      if is_at_sign(&operch) {
        step(p);
        args array[ast_typeexpr];
        if !(try_skip_token(p, Grouper(LBracket(void)))
             && parse_rest_of_type_param_list(p, AllowBlanksNo(void), &args)) {
          return Fail;
        }
        *out = NameExpr({ident, Has(args)});
        return true;
      }
    }
    default: { }
  }
  *out = NameExpr({ident, None()});
  return true;
}

func parse_atomic_expr(p *ps, out *ast_expr) bool {
  switch peek(p).val {
    case Keyw(k): {
      switch k {
        case Func(v): {
          step(p);
          return parse_rest_of_lambda(p, out);
        }
        case True(v): {
          m ast_meta = startend(p);
          step(p);
          *out = BoolLiteral({m, true});
          return true;
        }
        case False(v): {
          m ast_meta = startend(p);
          step(p);
          *out = BoolLiteral({m, false});
          return true;
        }
        case Void(v): {
          m ast_meta = startend(p);
          step(p);
          *out = VoidLiteral({m});
          return true;
        }
        case Null(v): {
          m ast_meta = startend(p);
          step(p);
          *out = NullLiteral({m});
          return true;
        }
        default: {
          return Fail;
        }
      }
    }
    case Num(n numlit): {
      num_meta ast_meta = startend(p);
      switch n {
        case DecNum(arr array[i8]): {
          step(p);
          *out = NumericLiteral(DecLiteral({num_meta, arr}));
          return true;
        }
        case HexNum(arr array[i8]): {
          step(p);
          *out = NumericLiteral(HexLiteral({num_meta, arr}));
          return true;
        }
      }
    }
    case Grouper(g grouper): {
      switch g {
        case LParen(v): {
          step(p);
          expr ast_expr;
          if !(parse_expr(p, kSemicolonPrec, &expr)
               && try_skip_token(p, Grouper(RParen(void)))) {
            return Fail;
          }
          *out = ParenExpr({embox(expr)});
          return true;
        }
        case LBrace(v): {
          step(p);
          // TODO: Have some way to prevent naked struct initializers in a condition expression.
          return parse_rest_of_strinit(p, out);
        }
        default: { return Fail; }
      }
    }
    case Ident(identch array[i32]): {
      ident_meta ast_meta = startend(p);
      step(p);
      return parse_finish_name_expr(p, {ident_meta, intern(p->im, ~identch)}, out);
    }
    case Oper(operch array[i32]): {
      if is_at_sign(&operch) {
        step(p);
        type ast_typeexpr;
        expr ast_expr;
        if !(try_skip_token(p, Grouper(LBracket(void)))
             && help_parse_typeexpr(p, AllowBlanksYes(void), &type)
             && try_skip_token(p, Grouper(RBracket(void)))
             && parse_expr(p, kConversionRightPrec, &expr)) {
          return Fail;
        }
        *out = TypedExpr({type, embox(expr)});
        return true;
      } else {
        switch unop_info(&operch) {
          case None(v): { return Fail; }
          case Has(rightprec i32): {
            oper_meta ast_meta = startend(p);
            step(p);
            rhs ast_expr;
            if !parse_expr(p, rightprec, &rhs) {
              return Fail;
            }
            *out = Funcall({embox(NameExpr({{oper_meta, intern(p->im, ~operch)}, None()})),
                            mk_array(rhs)});
            return true;
          }
        }
      }
    }
    case StringDelim(ch i32): {
      if ch == '\"' {
        string_step(p, '\"');
        return parse_rest_of_string_literal(p, out);
      } else if ch == '\'' {
        string_step(p, '\'');
        return parse_rest_of_char_literal(p, out);
      } else {
        check(false);
        return fake();
      }
    }
    case Backtick(v): {
      ident_meta ast_meta = start(p);
      step(p);
      ident ast_ident;
      if !parse_rest_of_backtick_ident(p, ident_meta, &ident) {
        return Fail;
      }
      return parse_finish_name_expr(p, ident, out);
    }
    case Bad(v): {
      return Fail;
    }
    case Eof(v): {
      return Fail;
    }
  }
}

func unop_info(operch *array[i32]) opt[i32] {
  if count(operch) != 1 {
    return None();
  }
  ch0 i32 = get(operch, 0);
  if ch0 == '~' || ch0 == '*' || ch0 == '&'
     || ch0 == '-' || ch0 == '!' || ch0 == '^' {
    return Has(905);
  }
  return None();
}

func is_equal(arr *array[i32], v0 i32) bool {
  return count(arr) == 1 && get(arr, 0) == v0;
}

func is_at_sign(operch *array[i32]) bool {
  return is_equal(operch, '@');
}

func parse_rest_of_lambda(p *ps, out *ast_expr) bool {
  args array[ast_vardecl];
  return_type ast_typeexpr;
  body ast_bracebody;
  if !parse_lambdaspec(p, &args, &return_type, &body) {
    return Fail;
  }
  *out = Lambda({args, return_type, body});
  return true;
}

func parse_rest_of_strinit(p *ps, out *ast_expr) bool {
  params array[ast_expr];
  if !parse_rest_of_expr_list(p, RBrace(void), &params) {
    return Fail;
  }
  *out = Strinit({params});
  return true;
}

func parse_rest_of_param_list(p *ps, out *array[ast_expr]) bool {
  return parse_rest_of_expr_list(p, RParen(void), out);
}

func parse_rest_of_expr_list(p *ps, stop grouper, out *array[ast_expr]) bool {
  exprs array[ast_expr];
  for ;; {
    if try_skip_token(p, Grouper(stop)) {
      *out = exprs;
      return true;
    }
    if count(&exprs) != 0 {
      if !try_skip_oper(p, ',') {
        return Fail;
      }
    }
    expr ast_expr;
    if !parse_expr(p, kCommaPrec, &expr) {
      return Fail;
    }
    push(&exprs, expr);
  }
}

func parse_statement(p *ps, out *ast_statement) bool {
  switch peek(p).val {
    case Keyw(k): {
      switch k {
        case Var(v): {
          step(p);
          return parse_rest_of_var_statement(p, out);
        }
        case Return(v): {
          step(p);
          return parse_rest_of_return_statement(p, out);
        }
        case If(v): {
          step(p);
          return parse_rest_of_if_statement(p, out);
        }
        case While(v): {
          step(p);
          return parse_rest_of_while_statement(p, out);
        }
        case For(v): {
          step(p);
          return parse_rest_of_for_statement(p, out);
        }
        case Switch(v): {
          step(p);
          return parse_rest_of_switch_statement(p, out);
        }
        case Label(v): {
          step(p);
          return parse_rest_of_label_statement(p, out);
        }
        case Goto(v): {
          step(p);
          return parse_rest_of_goto_statement(p, out);
        }
        default: { }
      }
    }
    default: { }
  }
  return parse_naked_var_or_expr_statement(p, ForceAssignmentNo(void), out);
}

func parse_rest_of_label_statement(p *ps, out *ast_statement) bool {
  name ast_ident;
  if !(parse_ident(p, &name) && try_skip_oper(p, ';')) {
    return Fail;
  }
  *out = Label({name});
  return true;
}

func parse_rest_of_goto_statement(p *ps, out *ast_statement) bool {
  target ast_ident;
  if !(parse_ident(p, &target) && try_skip_oper(p, ';')) {
    return Fail;
  }
  *out = Goto({target});
  return true;
}

func parse_rest_of_var_statement(p *ps, out *ast_statement) bool {
  decl ast_vardecl;
  if !parse_vardecl(p, AllowBlanksYes(void), &decl) {
    return Fail;
  }

  if try_skip_oper(p, ';') {
    *out = Var({decl, None()});
    return true;
  }

  rhs box[ast_expr];
  if !(try_skip_oper(p, '=')
       && parse_expr(p, kSemicolonPrec, oo(&rhs))
       && try_skip_oper(p, ';')) {
    return Fail;
  }

  *out = Var({decl, Has(rhs)});
  return true;
}

func parse_rest_of_return_statement(p *ps, out *ast_statement) bool {
  if try_skip_oper(p, ';') {
    *out = Return({None()});
    return true;
  }
  expr box[ast_expr];
  if !(parse_expr(p, kSemicolonPrec, oo(&expr))
       && try_skip_oper(p, ';')) {
    return Fail;
  }
  *out = Return({Has(expr)});
  return true;
}

func parse_condition(p *ps, out *ast_condition) bool {
  if try_skip_token(p, Keyw(Case(void))) {
    conspatt ast_constructor_pattern;
    rhs box[ast_expr];
    if !(parse_rest_of_constructor_pattern(p, &conspatt)
         && try_skip_oper(p, '=')
         && parse_expr(p, kConditionPrec, oo(&rhs))) {
      return Fail;
    }
    *out = PatternCondition({conspatt, rhs});
    return true;
  } else {
    condition box[ast_expr];
    if !parse_expr(p, kConditionPrec, oo(&condition)) {
      return Fail;
    }
    *out = ExprCondition(condition);
    return true;
  }
}

func parse_rest_of_if_statement(p *ps, out *ast_statement) bool {
  condition ast_condition;
  thenbody ast_bracebody;
  if !(parse_condition(p, &condition)
       && parse_bracebody(p, &thenbody)) {
    return Fail;
  }

  if !try_skip_token(p, Keyw(Else(void))) {
    *out = IfThen({condition, thenbody});
    return true;
  }

  if try_skip_token(p, Keyw(If(void))) {
    elseif ast_statement;
    if !parse_rest_of_if_statement(p, &elseif) {
      return Fail;
    }
    *out = IfThenElse({condition, thenbody, {mk_array(elseif)}});
    return true;
  }
  elsebody ast_bracebody;
  if !parse_bracebody(p, &elsebody) {
    return Fail;
  }
  *out = IfThenElse({condition, thenbody, elsebody});
  return true;
}

func parse_rest_of_while_statement(p *ps, out *ast_statement) bool {
  condition box[ast_expr];
  body ast_bracebody;
  if !(parse_expr(p, kConditionPrec, oo(&condition))
       && parse_bracebody(p, &body)) {
    return Fail;
  }
  *out = While({ExprCondition(condition), body});
  return true;
}

func parse_rest_of_for_statement(p *ps, out *ast_statement) bool {
  initializer opt[box[ast_statement]];
  if try_skip_oper(p, ';') {
    initializer = None();
  } else {
    statement box[ast_statement];
    if try_skip_token(p, Keyw(Var(void))) {
      if !parse_rest_of_var_statement(p, oo(&statement)) {
        return Fail;
      }
    } else {
      if !parse_naked_var_or_expr_statement(p, ForceAssignmentYes(void), oo(&statement)) {
        return Fail;
      }
    }
    initializer = Has(statement);
  }
  condition opt[box[ast_expr]];
  if try_skip_oper(p, ';') {
    condition = None();
  } else {
    expr box[ast_expr];
    if !(parse_expr(p, kConditionPrec, oo(&expr))
         && try_skip_oper(p, ';')) {
      return Fail;
    }
    condition = Has(expr);
  }
  increment opt[box[ast_expr]];
  if peek(p).val == Grouper(LBrace(void)) {
    increment = None();
  } else {
    expr box[ast_expr];
    if !parse_expr(p, kSemicolonPrec, oo(&expr)) {
      return Fail;
    }
    increment = Has(expr);
  }

  body ast_bracebody;
  if !parse_bracebody(p, &body) {
    return Fail;
  }
  *out = For({initializer, condition, increment, body});
  return true;
}

func parse_rest_of_switch_statement(p *ps, out *ast_statement) bool {
  swartch box[ast_expr];
  if !(parse_expr(p, kConditionPrec, oo(&swartch))
       && try_skip_token(p, Grouper(LBrace(void)))) {
    return Fail;
  }

  cases array[ast_switch_case];
  for ;; {
    if try_skip_token(p, Grouper(RBrace(void))) {
      *out = Switch({swartch, cases});
      return true;
    }
    cas ast_switch_case;
    if !parse_switch_case(p, &cas) {
      return Fail;
    }
    push(&cases, cas);
  }
}

func parse_switch_case(p *ps, out *ast_switch_case) bool {
  pattern ast_case_pattern;
  body ast_bracebody;
  if !(parse_case_pattern(p, &pattern)
       && try_skip_oper(p, ':')
       && parse_bracebody(p, &body)) {
    return Fail;
  }
  *out = {pattern, body};
  return true;
}

func parse_rest_of_constructor_pattern(p *ps,
                                       out *ast_constructor_pattern) bool {
  constructor_name ast_ident;
  decl ast_vardecl;
  if !(parse_ident(p, &constructor_name)
       && try_skip_token(p, Grouper(LParen(void)))
       && parse_vardecl(p, AllowBlanksYes(void), &decl)
       && try_skip_token(p, Grouper(RParen(void)))) {
    return Fail;
  }
  *out = {constructor_name, decl};
  return true;
}

func parse_case_pattern(p *ps, out *ast_case_pattern) bool {
  if try_skip_token(p, Keyw(Default(void))) {
    *out = Default(void);
    return true;
  }
  conspatt ast_constructor_pattern;
  if !(try_skip_token(p, Keyw(Case(void)))
       && parse_rest_of_constructor_pattern(p, &conspatt)) {
    return Fail;
  }
  *out = Case(conspatt);
  return true;
}

defenum triparse_result {
  Success void;
  Quickfail void;
  Error void;
};

func parse_naked_var_or_expr_statement(p *ps, fa force_assignment, out *ast_statement) bool {
  name ast_ident;
  if !try_parse_ident(p, &name) {
    // (The force_assignment argument only matters for var statements.)
    expr ast_expr;
    if !(parse_expr(p, kSemicolonPrec, &expr)
         && try_skip_oper(p, ';')) {
      return Fail;
    }
    *out = Expr(expr);
    return true;
  }

  type ast_typeexpr;
  indexers array[ast_expr];
  done bool = false;
  while !done {
    if try_skip_token(p, Grouper(LBracket(void))) {
      if try_skip_token(p, Keyw(Underscore(void))) {
        param box[ast_typeexpr];
        if !(try_skip_token(p, Grouper(RBracket(void)))
             && parse_typeexpr(p, oo(&param))) {
          return Fail;
        }

        type = collapse_indexers(indexers, Arraytype({None(), param}));
        done = true;
      } else {
        ambi ast_expr;
        if !(parse_expr(p, kCommaPrec, &ambi)
             && try_skip_token(p, Grouper(RBracket(void)))) {
          return Fail;
        }
        push(&indexers, ambi);
      }
    } else {
      local_type ast_typeexpr;
      switch help_triparse_typeexpr(p, AllowBlanksYes(void), &local_type) {
        case Quickfail(v): {
          lhs ast_expr = expressionize(name, indexers);
          whole_expr ast_expr;
          if !(parse_after_atomic_expr(p, kSemicolonPrec, lhs, &whole_expr)
               && try_skip_oper(p, ';')) {
            return Fail;
          }
          *out = Expr(whole_expr);
          return true;
        }
        case Error(v): {
          return Fail;
        }
        case Success(v): {
          type = collapse_indexers(indexers, local_type);
          done = true;
        }
      }
    }
  }

  decl ast_vardecl = {name, type};

  if peek(p).val == mk_oper(';') {
    switch fa {
      case ForceAssignmentYes(v): { return Fail; }
      case ForceAssignmentNo(v): {
        step(p);
        *out = Var({decl, None()});
        return true;
      }
    }
  }

  rhs box[ast_expr];
  if !(try_skip_oper(p, '=')
       && parse_expr(p, kSemicolonPrec, oo(&rhs))
       && try_skip_oper(p, ';')) {
    return Fail;
  }
  *out = Var({decl, Has(rhs)});
  return true;
}

func expressionize(name ast_ident, indexers array[ast_expr]) ast_expr {
  lhs ast_expr = NameExpr({name, None()});
  e size = count(&indexers);
  for i size = 0; i < e; i = i + 1 {
    lhs = IndexExpr({embox(lhs), embox(get(&indexers, i))});
  }
  return lhs;
}

func collapse_indexers(indexers array[ast_expr], param ast_typeexpr) ast_typeexpr {
  for i size = count(&indexers); i > 0; {
    i = i - 1;
    param = Arraytype({Has(embox(get(&indexers, i))), embox(param)});
  }
  return param;
}

func parse_rest_of_string_literal(p *ps, out *ast_expr) bool {
  specs array[ast_charspec];
  for ;; {
    switch peek(p).val {
      case StringDelim(ch i32): {
        check(ch == '\"');
        step(p);
        *out = StringLiteral({specs});
        return true;
      }
      case StringChar(ch i32): {
        push(&specs, {ch});
        string_step(p, '\"');
      }
      default: {
        return Fail;
      }
    }
  }
}

func parse_rest_of_char_literal(p *ps, out *ast_expr) bool {
  value i32;
  switch peek(p).val {
    case StringChar(ch i32): {
      value = ch;
      string_step(p, '\'');
    }
    default: {
      return Fail;
    }
  }
  switch peek(p).val {
    case StringDelim(ch i32): {
      check(ch == '\'');
      step(p);
      *out = CharLiteral({{value}});
      return true;
    }
    default: {
      return Fail;
    }
  }
}



func showu8(x size) array[u8] {
  ret array[u8];
  if x == 0 {
    push(&ret, '0');
    return ret;
  }
  while x != 0 {
    push(&ret, @[u8]'0' + ~(x % 10));
    x = x / 10;
  }
  j size = count(&ret);
  d *u8 = data(&ret);
  for i size = 0; i < j; {
    j = j - 1;
    tmp u8 = d[i];
    d[i] = d[j];
    d[j] = tmp;
    i = i + 1;
  }
  return ret;
}

func see_if_parse(file array[u8]) bool {
  im identmap;
  p ps = make_ps(&im, data(&file), count(&file));
  out ast_file;
  ret bool = parse_file(&p, &out);
  if !ret {
    print(Stdout(), make("at offset "));
    print(Stdout(), showu8(peek(&p).interval.left.~));
    print(Stdout(), make("..."));
    fflush(Stdout());
  }
  return ret;
}

func run_parse_test(test_name array[u8], file array[u8]) bool {
  print(Stdout(), make("test "));
  print(Stdout(), test_name);
  print(Stdout(), make("..."));
  fflush(Stdout());
  if !see_if_parse(file) {
    print(Stdout(), make("FAIL\n"));
    fflush(Stdout());
    return false;
  } else {
    print(Stdout(), make("PASS\n"));
    fflush(Stdout());
    return true;
  }
}

func test_parse() bool {
  pass bool = true;
  pass = pass & run_parse_test(make("p001"), make("import foo;"));
  pass = pass & run_parse_test(make("p002"), make("def a int = 0;"));
  pass = pass & run_parse_test(make("p003"), make("def abc int = 1;\n"));
  pass = pass & run_parse_test(make("p004"), make("def _ab int =0x1;\n"));
  pass = pass & run_parse_test(make("p005"), make("def ab_ int = 0x1AF2;\n"));
  pass = pass & run_parse_test(make("p006"), make("def a_b int=\n0x1AF2 ;\n"));
  pass = pass & run_parse_test(make("p007"), make("def a int=0x1AF2 ;"));
  pass = pass & run_parse_test(make("p008"), make("def a fn[int, int] = 1;"));
  pass = pass & run_parse_test(make("p009"),
                               make("def a b = func(x int, y int) int { 3; };"));
  pass = pass & run_parse_test(make("p010"),
                               make("def a = func(x int, y int) int { return 3; };"));
  pass = pass & run_parse_test(make("p011"),
                               make("def a =\n\tfunc(x int, y int) int { *x; };"));
  pass = pass & run_parse_test(make("p012"),
                               make("def foo bar = 2 + 3;"));
  pass = pass & run_parse_test(make("p013"),
                               make("def foo bar = 2+*3-4;"));
  pass = pass & run_parse_test(make("p014"),
                               make("def foo bar = (2 ^ 3) - 4 && x -> quux;"));
  pass = pass & run_parse_test(make("p015"),
                               make("def[] foo fn[int] = func() int {\n  var x int = 3;\n  return x;};"));
  pass = pass & run_parse_test(make("p016"),
                               make("def[] foo/*heh*/fn[int] = func() int {\n//blah blah\n  var x int =-3;return x;};"));
  pass = pass & run_parse_test(make("p017"),
                               make("def a b = 1 == 1 || 2 == 1;\n"));
  pass = pass & run_parse_test(make("p018"),
                               make("def a b = 1 + - 1;"));
  pass = pass & run_parse_test(make("p019"),
                               make("def a b = 1 + -1;"));
  pass = pass & run_parse_test(make("p020"),
                               make("def a b = 1 +- 1;"));
  pass = pass & run_parse_test(make("p021"),
                               make("def a b = 1 +-1;"));
  pass = pass & run_parse_test(make("p022"),
                               make("func a() int {var x int;}"));
  pass = pass & run_parse_test(make("p023"),
                               make("func a() int {\n  (x+3)[y(z)] = 3;\n  return x[y];  }"));
  pass = pass & run_parse_test(make("p024"),
                               make("func a() int {\n  x[y(z)] = 3;\n  return x[y];  }"));
  pass = pass & run_parse_test(make("p025"),
                               make("func a() int {\n  x *[y(z)]t = 3;\n  return x[y]; }"));
  pass = pass & run_parse_test(make("p026"),
                               make("func a() int {\n  x [y(z)][1][2]t = 3;\n  return x[y]; }"));
  pass = pass & run_parse_test(make("p027"),
                               make("func a() int {\n  x [y(z)][1][2] = 3;\n  return x[y]; }"));
  pass = pass & run_parse_test(make("p028"),
                               make("func a() int {\n  x [y(z)][1][2];\n  return x[y];  }"));
  pass = pass & run_parse_test(make("p029"),
                               make("func a() int {\n  for var i i32 = 3; i < 3; i = i + 1 {}}"));
  pass = pass & run_parse_test(make("p030"),
                               make("func a() int {\n  for var i i32 = 3; i < 3; i = i + 1 { x = 2; }}"));
  pass = pass & run_parse_test(make("p031"),
                               make("def foo = baz@[a, b](1, 2, 3);"));
  pass = pass & run_parse_test(make("p032-a"),
                               make("def foo u8 = 'a';\n"));
  pass = pass & run_parse_test(make("p032-b"),
                               make("var foo u8 = 'a';\n"));
  pass = pass & run_parse_test(make("p033"),
                               make("def foo u8 = '\\n';\n"));
  pass = pass & run_parse_test(make("p034"),
                               make("def foo u8 = '\\x2A';\n"));
  pass = pass & run_parse_test(make("p035-a"),
                               make("def foo u8 = \"\\x2Azq\";\n"));
  pass = pass & run_parse_test(make("p035-b"),
                               make("def foo u8 = \"\";\n"));
  pass = pass & run_parse_test(make("p036"),
                               make("func a() b { switch c { case e(f g): { } case h(i): { j; } default: { } } }"));
  pass = pass & run_parse_test(make("p037"),
                               make("func `~`(x u32) size { }"));
  pass = pass & run_parse_test(make("p038"),
                               make("func foo() a { x int; }"));
  pass = pass & run_parse_test(make("p039"),
                               make("func foo() a { x int = 3; }"));
  pass = pass & run_parse_test(make("p040"),
                               make("func foo() a { for i i32 = 3; i < 3; i = i + 1 { } }"));
  pass = pass & run_parse_test(make("p041"),
                               make("func foo() a { if x { } else if y { } else { } }"));
  pass = pass & run_parse_test(make("p042"),
                               make("func foo() a { label foo; goto bar; }"));
  pass = pass & run_parse_test(make("p043"),
                               make("func foo() a { x struct { }; y union { }; z enum { }; }"));
  pass = pass & run_parse_test(make("p044-a"),
                               make(" deftype foo bar ;"));
  pass = pass & run_parse_test(make("p044-b"),
                               make(" alias foo bar ;"));
  pass = pass & run_parse_test(make("p045-a"),
                               make("deftype foo fn[int, int] ;"));
  pass = pass & run_parse_test(make("p045-b"),
                               make("deftype foo fn[int, int] ;"));
  pass = pass & run_parse_test(make("p046-a"),
                               make("deftype foo struct { x y; z int; t fn[beh]; };"));
  pass = pass & run_parse_test(make("p046-b"),
                               make("deftype foo enum { x y; z int; t fn[beh]; };"));
  pass = pass & run_parse_test(make("p046-c"),
                               make("alias foo enum { x y; z int; t fn[beh]; };"));
  pass = pass & run_parse_test(make("p046-c"),
                               make("defenum foo { x y; z int; t fn[beh]; };"));
  pass = pass & run_parse_test(make("p047-a"),
                               make("deftype[] foo bar;\n"));
  pass = pass & run_parse_test(make("p047-b"),
                               make("alias[] foo bar;\n"));
  pass = pass & run_parse_test(make("p048-a"),
                               make("deftype[] foo struct {x bar [quux]; };\n"));
  pass = pass & run_parse_test(make("p048-b"),
                               make("alias[] foo struct {x bar [quux]; };\n"));
  pass = pass & run_parse_test(make("p049-a"),
                               make("deftype[] foo struct {x [2 + 3]bar; };\n"));
  pass = pass & run_parse_test(make("p049-b"),
                               make("alias[] foo struct {x [2 + 3]bar; };\n"));
  pass = pass & run_parse_test(make("p049-c"),
                               make("deftype[T, U] foo struct {x [2 + 3]bar; };\n"));
  pass = pass & run_parse_test(make("p049-d"),
                               make("alias[T, U] foo struct {x [2 + 3]bar; };\n"));
  pass = pass & run_parse_test(make("p050"),
                               make("defclass move foo [7]bar;\ndeftype[T] foo struct { count u32; p [3]T; };\n"));
  pass = pass & run_parse_test(make("p051"),
                               make("defclass copy foo bar;"));
  pass = pass & run_parse_test(make("p052"),
                               make("extern putchar fn[i32, i32];"));
  pass = pass & run_parse_test(make("p053-a"),
                               make("export def blah fn[i32, i32] = 3;"));
  pass = pass & run_parse_test(make("p053-b"),
                               make("export var blah fn[i32, i32] = 3;"));
  pass = pass & run_parse_test(make("p054"),
                               make("access string { def foo i32 = 3; }\n"));
  pass = pass & run_parse_test(make("p054"),
                               make("access vec[_] { def foo i32 = 3; }\n"));
  pass = pass & run_parse_test(make("p055"),
                               make("func foo() a { if case foo(x) = bar { } else if y { } else { } }"));
  return pass;
}

