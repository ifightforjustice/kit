import ast;
import box;
import deferred;
import identmap;
import kitutil;
import shp;
import typeexpr;
import u8ast;

deftype numeric_traits struct {
  minval bigint;
  maxval bigint;
};

deftype flat_traits struct {
  size u32;
  alignment u32;
};

deftype integral_traits struct {
  flat flat_traits;
  numeric numeric_traits;
};

deftype platform_info struct {
  enum_tag_size u32;
  booltraits flat_traits;
  i8traits integral_traits;
  u8traits integral_traits;
  i16traits integral_traits;
  u16traits integral_traits;
  i32traits integral_traits;
  u32traits integral_traits;
  ptrtraits flat_traits;
  fntraits flat_traits;
};

deftype common_syms struct {
  fnsym sym;
  boolsym sym;
  voidsym sym;
  i8sym sym;
  u8sym sym;
  i16sym sym;
  u16sym sym;
  i32sym sym;
  u32sym sym;
  sizesym sym;
  primitive_module_sym sym;
  ptrtype_sym sym;
  lengthsym sym;
  tee_sym sym;
  derefsym sym;
  addressofsym sym;
  assignmentsym sym;
};

// TODO: Prevent unbounded recursive template instantiation.

deftype checkstate struct {
  im *identmap;
  instantiation_depth u32;
  platform platform_info;
  cym common_syms;
  loader_ctx *void;
  loader fn[*checkstate, sym, opt[array[u8]]];

  modules array[shp[module]];
  modules_by_name hash[sym, module_id];

  instantiations array[shp[def_inst]];
  type_instantiations array[shp[deftype_inst]];

  deftypes array[shp[deftype_entry]];
  deftypes_by_name hash[sym, array[deftype_entry_id]];

  defs array[shp[def_entry]];
  defs_by_name hash[sym, array[def_entry_id]];

  access_blocks array[shp[access_entry]];
};

func make_checkstate(im *identmap, platform platform_info, loader_ctx *void, loader fn[*checkstate, sym, opt[array[u8]]]) checkstate {
  ret checkstate;
  ret.im = im;
  ret.instantiation_depth = 0;
  ret.platform = platform;
  ret.cym = make_common_syms(im);
  ret.loader_ctx = loader_ctx;
  ret.loader = loader;
  return ret;
}

func make_common_syms(im *identmap) common_syms {
  ret common_syms;
  ret.fnsym = intern(im, from_u8(_u8("fn")));
  ret.boolsym = intern(im, from_u8(_u8("bool")));
  ret.voidsym = intern(im, from_u8(_u8("void")));
  ret.i8sym = intern(im, from_u8(_u8("i8")));
  ret.u8sym = intern(im, from_u8(_u8("u8")));
  ret.i16sym = intern(im, from_u8(_u8("i16")));
  ret.u16sym = intern(im, from_u8(_u8("u16")));
  ret.i32sym = intern(im, from_u8(_u8("i32")));
  ret.u32sym = intern(im, from_u8(_u8("u32")));
  ret.sizesym = intern(im, from_u8(_u8("size")));
  ret.primitive_module_sym = intern(im, from_u8(_u8("<primitive>")));
  ret.ptrtype_sym = intern(im, from_u8(_u8("*")));
  ret.lengthsym = intern(im, from_u8(_u8("length")));
  ret.tee_sym = intern(im, from_u8(_u8("T")));
  ret.derefsym = intern(im, from_u8(_u8("*")));
  ret.addressofsym = intern(im, from_u8(_u8("&")));
  ret.assignmentsym = intern(im, from_u8(_u8("=")));
  return ret;
}

// An index into checkstate's modules array.
deftype module_id size;
def `~` fn[size, module_id] = wrapconvert;

// An index into checkstate's instantiations array.
deftype def_inst_id size;
def `~` fn[size, def_inst_id] = wrapconvert;

// An index into checkstate's type_instantiations array.
deftype deftype_inst_id size;
def `~` fn[size, deftype_inst_id] = wrapconvert;
def `==` fn[deftype_inst_id, deftype_inst_id, bool] = wrapequate;

// An index into checkstate's defs array.
deftype def_entry_id size;
def `~` fn[size, def_entry_id] = wrapconvert;

// An index into checkstate's deftypes array.
deftype deftype_entry_id size;
def `~` fn[size, deftype_entry_id] = wrapconvert;
def `==` fn[deftype_entry_id, deftype_entry_id, bool] = wrapequate;

// An index into checkstate's access_blocks array.
deftype access_entry_id size;
def `~` fn[size, access_entry_id] = wrapconvert;

func ref_module(cs *checkstate, id module_id) *module {
  return oo(ref(&cs->modules, id.~));
}

func ref_def_entry(cs *checkstate, id def_entry_id) *def_entry {
  return oo(ref(&cs->defs, id.~));
}

func ref_deftype_entry(cs *checkstate, id deftype_entry_id) *deftype_entry {
  return oo(ref(&cs->deftypes, id.~));
}

func ref_access_entry(cs *checkstate, id access_entry_id) *access_entry {
  return oo(ref(&cs->access_blocks, id.~));
}

func ref_inst(cs *checkstate, id def_inst_id) *def_inst {
  return oo(ref(&cs->instantiations, id.~));
}

func ref_deftype_inst(cs *checkstate, id deftype_inst_id) *deftype_inst {
  return oo(ref(&cs->type_instantiations, id.~));
}

func add_def_entry(cs *checkstate, ent def_entry) def_entry_id {
  shent shp[def_entry] = emshp(ent);
  id def_entry_id = ~count(&cs->defs);
  push(&cs->defs, shent);
  arr *array[def_entry_id] = try_insert_lookup(&cs->defs_by_name, oo(&shent)->def_name, default());
  push(arr, id);
  return id;
}

func add_deftype_entry(cs *checkstate, ent deftype_entry) deftype_entry_id {
  shent shp[deftype_entry] = emshp(ent);
  id deftype_entry_id = ~count(&cs->deftypes);
  push(&cs->deftypes, shent);
  arr *array[deftype_entry_id] = try_insert_lookup(&cs->deftypes_by_name, oo(&shent)->name, default());
  push(arr, id);
  return id;
}

func add_access_entry(cs *checkstate, ent access_entry) access_entry_id {
  shent shp[access_entry] = emshp(ent);
  id access_entry_id = ~count(&cs->access_blocks);
  push(&cs->access_blocks, shent);
  return id;
}

func add_inst(cs *checkstate, val def_inst) def_inst_id {
  id def_inst_id = ~count(&cs->instantiations);
  push(&cs->instantiations, emshp(val));
  return id;
}

func add_deftype_inst(cs *checkstate, val deftype_inst) deftype_inst_id {
  id deftype_inst_id = ~count(&cs->type_instantiations);
  push(&cs->type_instantiations, emshp(val));
  return id;
}

defenum module_process_state {
  Unprocessed void;
  Processing void;
  DoneProcessing void;
};

func `==`(a module_process_state, b module_process_state) bool {
  return enumnum(&a) == enumnum(&b);
}

deftype module struct {
  module_name sym;
  file ast_file;
  buf array[u8];
  process_state module_process_state;
  // vvv  Valid when process_state == DoneProcessing.  vvv
  defs array[def_entry_id];
  deftypes array[deftype_entry_id];
  access_blocks array[access_entry_id];
};

// Describes the behavior of init/copy/move/destroy methods.
defenum derived_method_behavior {
  // Behavior's explicitly defined by a method.
  DerivedMethodExplicit def_inst_id;
  // Behavior's derived structurally, and one of its fields/constructors has an explicit method call.
  // TODO: This should be defined in one place by a method, and should have a def_inst_id.
  DerivedMethodNontrivial void;
  // Behavior's derived from the type definition (or it's primitive) and it's trivial. init: Fills with zero.  copy/move: memcpy.  destroy: no-op.
  DerivedMethodTrivial void;
};

func isTrivial(behav derived_method_behavior) bool {
  if case DerivedMethodTrivial(v void) = behav {
    return true;
  }
  return false;
}

func trivialOrNot(is_trivial bool) derived_method_behavior {
  if is_trivial {
    return DerivedMethodTrivial(void);
  } else {
    return DerivedMethodNontrivial(void);
  }
}

deftype type_properties struct {
  flat_size u32;
  flat_alignment u32;
  init_behavior derived_method_behavior;
  move_behavior derived_method_behavior;
  copy_behavior derived_method_behavior;
  destroy_behavior derived_method_behavior;
};

// TODO: This function is BS, now that type_properties has behavior fields.
func to_defclass_properties(props type_properties) type_properties {
  return props;
}

defenum deftype_inst_status {
  DidNotStartChecking void;
  StartedChecking void;
  FinishedChecking void;
  FailedChecking void;
};

deftype deftype_inst_info struct {
  // This is None() if the type is primitive.
  rhs opt[cu_typeexpr];
  props type_properties;
};

deftype deftype_inst struct {
  parms cu_genparms;
  // TODO: should status+info be nfbc[deftype_inst_info]?
  status deftype_inst_status;
  info opt[deftype_inst_info];
};

deftype deftype_nonprim struct {
  tl *ast_type_def;
  // The RHS typeexpr, if computed, without generics replaced, of course.
  rhs nbfc[te_typeexpr];
};

defenum rhs_accessibility {
  RhsPublic void;
  RhsPrivate void;
  RhsImpossible void;
};

deftype deftype_entry struct {
  module_name sym;
  name sym;
  accessible array[access_entry_id];
  accessibility rhs_accessibility;
  generics ast_generics;
  // nonprim/default_info are mutually exclusive Has-havers.
  // Info relevant for non-primitive types.
  nonprim opt[deftype_nonprim];
  // Info for primitive types.
  default_info opt[deftype_inst_info];
  insts array[deftype_inst_id];
};

func mk(module_name sym, name sym, accessible array[access_entry_id], accessibility rhs_accessibility, g ast_generics, tl *ast_type_def) deftype_entry {
  return {module_name, name, accessible, accessibility, g, Has({tl, NotComputed()}), None(), default@[array[deftype_inst_id]]()};
}

deftype access_entry struct {
  name sym;
  arity generics_arity;
  ent_id nbfc[deftype_entry_id];
};

func mk(name sym, arity generics_arity) access_entry {
  return {name, arity, NotComputed()};
}

defenum genparms {
  NoParms void;
  HasParms array[te_typeexpr];
};

defenum cu_genparms {
  NoParms void;
  HasParms array[cu_typeexpr];
};

defenum def_inst_status {
  DidNotStartComputingType void;
  BeganComputingType void;
  FinishedComputingType void;
  // The following are OK, if the def_inst's rhs is None().  (Non-ephemerally, you'll only see FinishedCheckingRhs.)
  BeganCheckingRhs void;
  FinishedCheckingRhs void;
};

deftype def_inst struct {
  parms cu_genparms;
  // Our own copy of the def's rhs, which we can annotate.  It does not have its generics replaced.  This is None() if we have an extern def.
  rhs opt[ast_expr];
  status def_inst_status;
  // TODO: Use nbfc or something.
  // Becomes the concrete type (with generics replaced) once we've computed it and checked it (see status).
  computed_type cu_typeexpr;
  computed_type_properties type_properties;
};

func mk(parms cu_genparms, rhs opt[ast_expr]) def_inst {
  return {parms, rhs, DidNotStartComputingType(void), default@[cu_typeexpr](), default@[type_properties]()};
}

deftype def_nonprim struct {
  // This is either the syntactic typeexpr (converted to te_typeexpr) or converted from a shallow look at the RHS.
  quick_typeexpr ast_typeexpr;
  tl *ast_toplevel;
};

deftype def_entry struct {
  module_name sym;
  def_name sym;
  accessible array[access_entry_id];
  // A copy of the ast_def's generics field -- if it's an ast_extern_def, this is NoGenerics.
  generics ast_generics;
  nonprim opt[def_nonprim];
  converted_typeexpr nbfc[te_typeexpr];

  insts array[def_inst_id];
};

func mk(module_name sym, def_name sym, accessible array[access_entry_id], generics ast_generics, quick_typeexpr ast_typeexpr, tl *ast_toplevel) def_entry {
  return {module_name, def_name, accessible, generics, Has({quick_typeexpr, tl}), NotComputed(), default@[array[def_inst_id]]()};
}

deftype clqueue_deftype_entry struct {
  ent_id deftype_entry_id;
  inst_id deftype_inst_id;
  // The instantiation depth when we _push_ the entry.
  instantiation_depth u32;
};

deftype clqueue_def_entry struct {
  ent_id def_entry_id;
  inst_id def_inst_id;
  // The instantiation depth when we _push_ the entry.
  instantiation_depth u32;
};

defenum clqueue_entry {
  ClqDeftypeEntry clqueue_deftype_entry;
  ClqDefEntry clqueue_def_entry;
};

deftype clqueue struct {
  entries array[clqueue_entry];
};


defclass move depth_rewinder struct {
  cs *checkstate;
  old_depth u32;
};

def template_instantiation_limit u32 = 50;

access depth_rewinder {
  func do_init(d *depth_rewinder) void {
    init(&d->cs);
    init(&d->old_depth);
  }
  func do_destroy(d *depth_rewinder) void {
    check(d->old_depth <= template_instantiation_limit);
    if d->cs != null {
      d->cs->instantiation_depth = d->old_depth;
    }
    d->cs = null;
    d->old_depth = 0;
  }
  func set_instantiation_depth(cs *checkstate, depth u32, rw *depth_rewinder) bool {
    check(rw->cs == null);
    if depth > template_instantiation_limit {
      ERR(_u8("Instantiation depth too deep."));
      return false;
    }
    rw->cs = cs;
    rw->old_depth = cs->instantiation_depth;
    cs->instantiation_depth = depth;
    return true;
  }
}
