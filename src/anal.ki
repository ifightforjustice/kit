import state;

/* We need to figure out what cell is what.

In a function body, cells fit in exactly ONE leaf node of this tree of categories:

 - subcells of some other cell
   - constant offset subcells
   - computed offset subcells -- location depends on another cell
 - not a subcell
   - static cells -- these can be statically located, have a static lifetime
     - outer cells -- pre-existing, locations taken as given
    //  - globals (these do not exist yet)
        - outer func paramlist & return cell
     - paramlist cells -- part of a func paramlist in GrApply
     - free cells -- temporaries, variables, we can locate them anywhere in the stack frame.
   - deref cells -- formed by dereferencing a pointer

Some more definitions:
 - A cell is "statically locatable" if it is a static cell or a constant offset subcells of a statically locatable cell.
 - "Statlocat" is an abbrevation for "statically locatable."
 - A cell is "derefalike" if it is a deref cell or a subcell of a derefalike cell.

We should find that some restrictions are upheld:

 - subcells are always subcells of exactly one cell, declared in exactly one node.  hell, every cell is sort of defined by exactly one node.
 - computed offset subcells' location cells must be statlocat.
 - GrApply return cells must be statlocat (for now).
 - paramlist cells can only be part of one func paramlist.
*/

/* What we want to do:

  At a minimum, we want to know whether a cell is a paramlist cell, and what paramlist it's part of.
*/

deftype subcell_disp struct {
  subcell_opnum gr_num;
  partof cell_num;
  offset gr_offset;
};

defenum cell_const_disp {
  NoConstDisp void;
  HasConstValue gr_const;
  NotConst void;
};

deftype cell_disp struct {
  // If the cell's part of a function param list, tells what paramlist it's part of.
  paramlist opt[gr_num];
  // If the cell's a funcell of a GrApply, tells what paramlist it's applying.
  funcell opt[gr_num];
  // If the cell's a subcell of another, tells what it's a subcell of.
  subcell opt[subcell_disp];
  // If the cell has a constant value.  (Must be a static cell.)
  const_value cell_const_disp;

  // Which cells are subcells of this one.
  subcelled array[cell_num];
};

deftype basic_analyze_state struct {
  // This means we've analyzed gns [0, gns_analyzed).  But we haven't analyzed further gns.
  gns_analyzed size;
  paramlists array[gr_num];
  celldisp array[cell_disp];
};

func basic_analyze_fn_body(cs *checkstate, g *graphed_fn_body, bas_out *basic_analyze_state) bool {
  bas basic_analyze_state = {0, mk_array@[gr_num](), mk_array@[cell_disp]()};

  if !help_basic_analyze(cs, &bas, &g->graph.gr) {
    return false;
  }

  // TODO: Check mutual exclusivity of celldisps -- cells can't be certain combinations of things.

  *bas_out = bas;
  return true;
}

func help_basic_analyze(cs *checkstate, bas *basic_analyze_state, gr *frame_graph) bool {
  n_ops size = count(&gr->ops);
  cellcount size = count(&gr->cells);
  for i size = count(&bas->celldisp); i < cellcount; i = i + 1 {
    push(&bas->celldisp, {None(), None(), None(), NoConstDisp(void), mk_array@[cell_num]()});
  }

  for i size = bas->gns_analyzed; i < n_ops; i = i + 1 {
    gn gr_num = ~i;
    node *gr_node = ref(&gr->ops, i);
    switch &node->op {
    case &GrApply(a gr_apply):
      push(&bas->paramlists, ~i);
      funcell_cd *cell_disp = ref(&bas->celldisp, a.funcell.~);
      if case &Has(other_gn gr_num) = &funcell_cd->funcell {
        ice(_u8("two-timing funcell "), a.funcell.~, _u8(" for "), other_gn.~, _u8(" and "), i);
      } else {
        funcell_cd->funcell = Has(gn);
      }
      nparams size = count(&a.params);
      for j size = 0; j < nparams; j = j + 1 {
        mark_cell_paramlist(bas, get(&a.params, j), gn);
      }
      mark_cell_not_const(bas, a.retcell);
    case &GrPrimApply(a gr_prim_apply):
      mark_cell_not_const(bas, a.retcell);
    case &GrMemCopy(a gr_memcopy):
      mark_cell_not_const(bas, a.dest);
    case &GrWriteConst(a gr_writeconst):
      if case LocationStatic(v void) = ref(&gr->cells, a.dest.~)->location {
        disp *cell_const_disp = &ref(&bas->celldisp, a.dest.~)->const_value;
        switch disp {
        case &NoConstDisp(v2 void):
          *disp = HasConstValue(a.value);
        case &HasConstValue(gc gr_const):
          *disp = NotConst(void);
        case &NotConst(v2 void): { }
        }
      }
    case &GrAddressof(a gr_addressof):
      // If this is the address of a static cell, the value is actually const.  But we ignore that possibility.
      mark_cell_not_const(bas, a.dest);
    case &GrSubcell(a gr_subcell):
      set(&ref(&bas->celldisp, a.name.~)->subcell, {gn, a.partof, a.offset});
      push(&ref(&bas->celldisp, a.partof.~)->subcelled, a.name);
      check(ref(&gr->cells, a.name.~)->location == LocationVirtual(void));
    default: { }
    }
  }
  bas->gns_analyzed = n_ops;
  return true;
}

func mark_cell_paramlist(bas *basic_analyze_state, c cell_num, apply_opnum gr_num) void {
  p *cell_disp = ref(&bas->celldisp, c.~);
  set(&p->paramlist, apply_opnum);
}

func mark_cell_not_const(bas *basic_analyze_state, c cell_num) void {
  ref(&bas->celldisp, c.~)->const_value = NotConst(void);
}

func basic_inline_inlinables(cs *checkstate, bas *basic_analyze_state, g *graphed_fn_body) bool {
  gr *frame_graph = &g->graph.gr;
  // nparamlists is _not_ constant.
  nparamlists size = count(&bas->paramlists);
  new_paramlists array[gr_num];
  for i size = 0; i < nparamlists; i = i + 1 {
    // (We avoid retaining references into arrays that we'll modify.)
    gn gr_num = get(&bas->paramlists, i);
    node gr_node = *ref_node(gr, gn);
    switch &node.op {
    case &GrApply(a gr_apply):
      if case Has(fnid fn_body_id) = is_const_funcell(cs, bas, a.funcell) {
        ent *fn_body_entry = ref_fn_body(cs, fnid);
        switch &ent->u {
        case &GraphedFnBody(eg graphed_fn_body):
          switch eg.inline {
          case InlineMust(v void):
            nparams size = count(&a.params);
            check(count(&eg.argcells) == nparams);
            // Okay, we're inlining.
            nec size = count(&eg.graph.gr.cells);
            cell_mapping array[cell_num];
            reserve(&cell_mapping, nec);
            for j size = 0; j < nec; j = j + 1 {
              mapped cell_num;
              if case Has(k size) = find(&eg.argcells, ~j) {
                // TODO: Assert that the cell types in g and eg are equal?  The sizes?
                mapped = get(&a.params, k);
              } else if eg.graph.cell == ~j {
                // TODO: Assert that the cell types in g and eg are equal?  The sizes?
                mapped = a.retcell;
              } else {
                egi *cell_info = ref(&eg.graph.gr.cells, j);
                mapped = add_cell(gr, {egi->location, egi->type, egi->props});
              }
              push(&cell_mapping, mapped);
            }

            op_addend size = count(&gr->ops);

            neo size = count(&eg.graph.gr.ops);
            for j size = 0; j < neo; j = j + 1 {
              push(&gr->ops, adjust_op_for_inline(op_addend, &cell_mapping, get(&eg.graph.gr.ops, j)));
            }

            base_op_adjusted gr_num = ~(eg.graph.gn.~ + op_addend);

            // Now we overwrite the apply op.
            // TODO: It would be nice if function bodies always had to set their return cell live, instead of having it be done for them with our GrWriteNothing statement.
            precs_op gr_num = addx(gr, node.precs, @[gr_op]GrDead({a.funcell}));
            seqer sq_num = seqq(gr, {precs_op,
                                     seqq(gr, {addx(gr, @[gr_op]GrWriteNothing({a.retcell})),
                                               seqq(gr, {base_op_adjusted,
                                                         nopq(gr)})})});

            // It's important to note that GrXNop would be ignored by help_basic_analyze.
            // TODO: It'd be nice if we could undo the mark_cell_not_const of a.retcell (that happened when we processed GrApply in help_basic_analyze before).

            set(&gr->ops, gn.~, {mk_shray(seqer.~), GrXNop(void)});

            // And since there's no apply op, we update the arg/funcell cell_disps.
            unSet(&ref(&bas->celldisp, a.funcell.~)->funcell);
            for j size = 0; j < nparams; j = j + 1 {
              unSet(&ref(&bas->celldisp, get(&a.params, j).~)->paramlist);
            }

            help_basic_analyze(cs, bas, gr);
            nparamlists = count(&bas->paramlists);
          case InlineYawn(v void):
            push(&new_paramlists, gn);
          }
        default:
          push(&new_paramlists, gn);
        }
      } else {
        push(&new_paramlists, gn);
      }
    default:
      ice(_u8("basic_inline_inlinables impossible node type"));
    }
  }
  swap(&bas->paramlists, &new_paramlists);
  return true;
}

func adjust_op_for_inline(op_addend size, cm *array[cell_num], node gr_node) gr_node {
  build array[gr_num];
  nprecs size = count(&node.precs);
  for i size = 0; i < nprecs; i = i + 1 {
    push(&build, ~(get(&node.precs, i).~ + op_addend));
  }
  newprecs shray[gr_num] = freeze(&build);
  switch &node.op {
  case &GrApply(a gr_apply):
    return {newprecs, GrApply({get(cm, a.funcell.~), help_adjust_params(cm, &a.params), get(cm, a.retcell.~)})};
  case &GrPrimApply(a gr_prim_apply):
    return {newprecs, GrPrimApply({a.primop, help_adjust_params(cm, &a.params), get(cm, a.retcell.~)})};
  case &GrMemCopy(a gr_memcopy):
    return {newprecs, GrMemCopy({get(cm, a.dest.~), get(cm, a.src.~)})};
  case &GrWriteConst(a gr_writeconst):
    return {newprecs, GrWriteConst({get(cm, a.dest.~), a.value})};
  case &GrAddressof(a gr_addressof):
    return {newprecs, GrAddressof({get(cm, a.dest.~), get(cm, a.addressee.~)})};
  case &GrDeref(a gr_deref):
    return {newprecs, GrDeref({get(cm, a.name.~), get(cm, a.pointer.~), help_adjust_offset(cm, &a.offset)})};
  case &GrSubcell(a gr_subcell):
    return {newprecs, GrSubcell({get(cm, a.name.~), get(cm, a.partof.~), help_adjust_offset(cm, &a.offset)})};
  case &GrBranch(a gr_branch):
    newcases array[tup[gr_const, sq_num]];
    ncases size = count(&a.cases);
    for i size = 0; i < ncases; i = i + 1 {
      cas *tup[gr_const, sq_num] = ref(&a.cases, i);
      push(&newcases, {cas->car, ~ ~(cas->cdr.~.~ + op_addend)});
    }
    defaultcase opt[sq_num];
    if case Has(sn sq_num) = a.default_case {
      defaultcase = Has(~ @[gr_num]~(sn.~.~ + op_addend));
    } else {
      defaultcase = None();
    }
    return {newprecs, GrBranch({get(cm, a.src.~), freeze(&newcases), defaultcase})};
  case &GrSequence(a gr_sequence):
    return {newprecs, GrSequence({~(a.first.~ + op_addend), ~ ~(a.second.~.~ + op_addend)})};
  case &GrJmp(a gr_jmp):
    return {newprecs, GrJmp({~ ~(a.next.~.~ + op_addend)})};
  case &GrWriteNothing(a gr_writenothing):
    return {newprecs, GrWriteNothing({get(cm, a.dest.~)})};
  case &GrDead(a gr_dead):
    return {newprecs, GrDead({get(cm, a.cell.~)})};
  case &GrVirtualDead(a gr_virtual_dead):
    return {newprecs, GrVirtualDead({get(cm, a.cell.~)})};
  case &GrXNop(v void):
    return {newprecs, GrXNop(void)};
  case &GrQNop(v void):
    return {newprecs, GrQNop(void)};
  }
}

func help_adjust_params(cm *array[cell_num], params *shray[cell_num]) shray[cell_num] {
  ret array[cell_num];
  n size = count(params);
  for i size = 0; i < n; i = i + 1 {
    push(&ret, get(cm, get(params, i).~));
  }
  return freeze(&ret);
}

func help_adjust_offset(cm *array[cell_num], off *gr_offset) gr_offset {
  switch off {
  case &OffsetConst(x u32):
    return OffsetConst(x);
  case &OffsetComputed(p tup[u32, cell_num]):
    return OffsetComputed({p.car, get(cm, p.cdr.~)});
  }
}
