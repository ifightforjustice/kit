import ast;
import identmap;
import pos;

deftype ps struct {
  data *u8;
  length size;
  pos size;

  current tok;
  // The previous value of pos, the same as the previous value of tok.interval.right,
  // or 0 if we're at the beginning of the stream.
  prev_right size;

  base_offset size;
  comments array[interval];
  // ast_meta values are indices into this array.
  metas *array[meta_datum];

  im *identmap;
};

func make_ps(im *identmap, posits *positionals, base_offset size, data *u8, length size) ps {
  p ps;
  p.data = data;
  p.length = length;
  p.pos = 0;
  p.base_offset = base_offset;
  p.im = im;
  p.metas = &posits->metas;
  step(&p);
  return p;
}

inline func ps_pos(p *ps) pos {
  return mk_pos(p->base_offset, p->pos);
}

inline func ps_restore_pos(p *ps, pos pos) void {
  p->pos = pos.~ - p->base_offset;
}

inline func ps_peek(p *ps) i32 {
  pos size = p->pos;
  if pos < p->length {
    return +p->data[pos];
  }
  return -1;
}

inline func ps_step(p *ps) void {
  if p->pos >= p->length {
    crash();
  }
  p->pos = p->pos + 1;
}

func startend(p *ps) ast_meta {
  ret ast_meta = ~count(p->metas);
  push(p->metas, {Has(p->current.interval.left), Has(p->current.interval.right)});
  return ret;
}

func start(p *ps) ast_meta {
  ret ast_meta = ~count(p->metas);
  push(p->metas, {Has(p->current.interval.left), None});
  return ret;
}

func copystart(p *ps, meta ast_meta) ast_meta {
  ret ast_meta = ~count(p->metas);
  push(p->metas, {ref(p->metas, meta.~)->left, None});
  return ret;
}

func copyend(p *ps, meta ast_meta) ast_meta {
  m ast_meta = copystart(p, meta);
  end(p, m);
  return m;
}

func end(p *ps, meta ast_meta) void {
  r *meta_datum = ref(p->metas, meta.~);
  if case Has(right_pos pos) = r->right {
    crash();
  }
  r->right = Has(mk_pos(p->base_offset, p->prev_right));
}

defenum keyw {
  Access void;
  Break void;
  Case void;
  Continue void;
  Def void;
  Default void;
  Defclass void;
  Defenum void;
  Deftype void;
  Else void;
  Enum void;
  Export void;
  Extern void;
  False void;
  For void;
  Func void;
  Goto void;
  If void;
  Import void;
  Label void;
  Null void;
  Return void;
  Struct void;
  Switch void;
  Then void;
  True void;
  Underscore void;
  Union void;
  Var void;
  Void void;
  While void;
};

defenum numlit {
  DecNum shray[i8];
  HexNum shray[i8];
};

defenum grouper {
  LParen void;
  RParen void;
  LBracket void;
  RBracket void;
  LBrace void;
  RBrace void;
  DoubleQuote void;
  SingleQuote void;
  Backtick void;
};

defenum tokval {
  Keyw keyw;
  Num numlit;
  Oper shray[i32];
  Ident shray[i32];
  Grouper grouper;
  StringChar i32;
  Bad void;
  Eof void;
  Comment void;
};

inline func `==`(a keyw, b keyw) bool {
  return enumnum(&a) == enumnum(&b);
}

func equal(a *numlit, b *numlit) bool {
  if enumnum(a) != enumnum(b) { return false; }
  switch a {
  case &DecNum(j): { switch b { case &DecNum(k): { return shray_equal(&j, &k); } } }
  case &HexNum(j): { switch b { case &HexNum(k): { return shray_equal(&j, &k); } } }
  }
}

func `==`(a grouper, b grouper) bool {
  return enumnum(&a) == enumnum(&b);
}

func is_keyw(a *tokval, k keyw) bool {
  if case &Keyw(j keyw) = a {
    return j == k;
  } else {
    return false;
  }
}

func equal(a *tokval, b *tokval) bool {
  if enumnum(a) != enumnum(b) { return false; }
  switch a {
  case &Keyw(j): { switch b { case &Keyw(k): { return j == k; } } }
  case &Num(j): { switch b { case &Num(k): { return equal(&j, &k); } } }
  case &Oper(j): { switch b { case &Oper(k): { return shray_equal(&j, &k); } } }
  case &Ident(j): { switch b { case &Ident(k): { return shray_equal(&j, &k); } } }
  case &Grouper(j): { switch b { case &Grouper(k): { return j == k; } } }
  case &StringChar(j): { switch b { case &StringChar(k): { return j == k; } } }
  case &Bad(j): { return true; }
  case &Eof(j): { return true; }
  case &Comment: { return true; }
  }
}

deftype tok struct {
  interval interval;
  val tokval;
};

func mk_tok(left pos, right pos, val tokval) tok {
  return {{left, right}, val};
}

inline func is_lower(x i32) bool {
  // TODO: Statically assert 'z' - 'a' == 25.
  return x >= 'a' && x <= 'z';
}

inline func is_upper(x i32) bool {
  // TODO: Statically assert 'Z' - 'A' == 25.
  return x >= 'A' && x <= 'Z';
}

inline func is_alpha(x i32) bool {
  return is_lower(x) || is_upper(x);
}

inline func is_digit(x i32) bool {
  // TODO: Statically assert '9' - '0' == 9.
  return x >= '0' && x <= '9';
}

inline func is_alphalike(x i32) bool {
  return is_alpha(x) || x == '_';
}

inline func is_alnumlike(x i32) bool {
  return is_alphalike(x) || is_digit(x);
}

func is_hexdigit(x i32, val_out *i8) bool {
  // TODO: Statically assert 'f' - 'a', 'F' - 'A', '9' - '0'.
  if is_digit(x) {
    *val_out = ~(x - '0');
    return true;
  }
  if 'A' <= x && x <= 'F' {
    *val_out = 10 + ~(x - 'A');
    return true;
  }
  if 'a' <= x && x <= 'f' {
    *val_out = 10 + ~(x - 'a');
    return true;
  }
  return false;
}

// We use blacklists for postchar funcs, stuff like non-printable characters won't parse anyway.
inline func is_numeric_postchar(x i32) bool {
  return !(is_alnumlike(x) || is_quotelike(x));
}

inline func is_ident_firstchar(x i32) bool {
  return is_alphalike(x);
}

inline func is_ident_midchar(x i32) bool {
  // Same as is_alnumlike.
  return is_ident_firstchar(x) || is_digit(x);
}

inline func is_ident_postchar(x i32) bool {
  return !(is_ident_midchar(x) || is_quotelike(x));
}

inline func is_quotelike(x i32) bool {
  return x == '\'' || x == '\"' || x == '`';
}

inline func is_string_postchar(x i32) bool {
  return !(is_alnumlike(x) || is_quotelike(x));
}

inline func is_ws(x i32) bool {
  return x <= ' ' && (x == ' ' || x == '\n' || x == '\t' || x == '\r');
}

func step(p *ps) void {
  right size = p->pos;
  for ;; {
    t tok = grab_tok(p);
    switch t.val {
      case Comment: {
        push(&p->comments, t.interval);
      }
      default: {
        p->current = t;
        p->prev_right = right;
        return;
      }
    }
  }
}

inline func peek(p *ps) *tok {
  return &p->current;
}

func grab_tok(p *ps) tok {
  ch i32 = ps_peek(p);
  while is_ws(ch) {
    ps_step(p);
    ch = ps_peek(p);
  }
  left pos = ps_pos(p);
  if ch < 0 {
    return {{left, left}, Eof(void)};
  }
  if ch == '0' {
    ps_step(p);
    ch = ps_peek(p);
    if ch == 'x' {
      ps_step(p);
      ch = ps_peek(p);
      digits array[i8];
      val i8;
      while is_hexdigit(ch, &val) {
        push(&digits, val);
        ps_step(p);
        ch = ps_peek(p);
      }

      if is_numeric_postchar(ch) {
        return mk_res(p, left, @[tokval]Num(HexNum(freeze(&digits))));
      } else {
        return {{left, ps_pos(p)}, Bad(void)};
      }
    } else {
      if is_numeric_postchar(ch) {
        digits array[i8];
        push(&digits, 0);
        return mk_res(p, left, @[tokval]Num(DecNum(freeze(&digits))));
      } else {
        return {{left, ps_pos(p)}, Bad(void)};
      }
    }
  } else if is_digit(ch) {
    digits array[i8];
    push(&digits, @[i8]~(ch - '0'));
    ps_step(p);
    ch = ps_peek(p);
    while is_digit(ch) {
      push(&digits, @[i8]~(ch - '0'));
      ps_step(p);
      ch = ps_peek(p);
    }
    if is_numeric_postchar(ch) {
      return mk_res(p, left, @[tokval]Num(DecNum(freeze(&digits))));
    } else {
      return {{left, ps_pos(p)}, Bad(void)};
    }
  } else if is_ident_firstchar(ch) {
    ret tok;

    // '_' == 95, by the way.
    if ch >= '_' && ch <= 'w' {
      if ch < 'f' {
        if ch < 'd' {
          if (grab_keyword(p, "_", Underscore(void), &ret)
              || grab_keyword(p, "access", Access(void), &ret)
              || grab_keyword(p, "break", Break(void), &ret)
              || grab_keyword(p, "case", Case(void), &ret)
              || grab_keyword(p, "continue", Continue(void), &ret)) {
            return ret;
          }
        } else {
          if (grab_keyword(p, "def", Def(void), &ret)
              || grab_keyword(p, "default", Default(void), &ret)
              || grab_keyword(p, "defclass", Defclass(void), &ret)
              || grab_keyword(p, "defenum", Defenum(void), &ret)
              || grab_keyword(p, "deftype", Deftype(void), &ret)
              || grab_keyword(p, "else", Else(void), &ret)
              || grab_keyword(p, "enum", Enum(void), &ret)
              || grab_keyword(p, "export", Export(void), &ret)
              || grab_keyword(p, "extern", Extern(void), &ret)) {
            return ret;
          }
        }
      } else {
        if ch < 'r' {
          if (grab_keyword(p, "false", False(void), &ret)
              || grab_keyword(p, "for", For(void), &ret)
              || grab_keyword(p, "func", Func(void), &ret)
              || grab_keyword(p, "goto", Goto(void), &ret)
              || grab_keyword(p, "if", If(void), &ret)
              || grab_keyword(p, "import", Import(void), &ret)
              || grab_keyword(p, "label", Label(void), &ret)
              || grab_keyword(p, "null", Null(void), &ret)) {
            return ret;
          }
        } else {
          if (grab_keyword(p, "return", Return(void), &ret)
              || grab_keyword(p, "struct", Struct(void), &ret)
              || grab_keyword(p, "switch", Switch(void), &ret)
              || grab_keyword(p, "then", Then(void), &ret)
              || grab_keyword(p, "true", True(void), &ret)
              || grab_keyword(p, "union", Union(void), &ret)
              || grab_keyword(p, "var", Var(void), &ret)
              || grab_keyword(p, "void", Void(void), &ret)
              || grab_keyword(p, "while", While(void), &ret)) {
            return ret;
          }
        }
      }
    }

    arr array[i32];
    push(&arr, ch);
    ps_step(p);
    ch = ps_peek(p);
    while is_ident_midchar(ch) {
      push(&arr, ch);
      ps_step(p);
      ch = ps_peek(p);
    }
    if !is_ident_postchar(ch) {
      return {{left, ps_pos(p)}, Bad(void)};
    }
    return mk_res(p, left, Ident(freeze(&arr)));
  } else {
    if ch < '.' {
      if ch == '!' {
        return grab_oper2(p, left, ch, '=');
      } else if ch == '\"' {
        ps_step(p);
        return mk_res(p, left, @[tokval]Grouper(DoubleQuote));
      } else if ch == '%' {
        return grab_oper2(p, left, ch, '=');
      } else if ch == '&' {
        return grab_oper2(p, left, ch, '=', '&');
      } else if ch == '\'' {
        ps_step(p);
        return mk_res(p, left, @[tokval]Grouper(SingleQuote));
      } else if ch == '(' {
        ps_step(p);
        return mk_res(p, left, @[tokval]Grouper(LParen(void)));
      } else if ch == ')' {
        ps_step(p);
        return mk_res(p, left, @[tokval]Grouper(RParen(void)));
      } else if ch == '*' {
        return grab_oper2(p, left, ch, '=');
      } else if ch == '+' {
        return grab_oper2(p, left, ch, '=', '+');
      } else if ch == ',' {
        ps_step(p);
        return mk_res(p, left, Oper(mk_shray(ch)));
      } else if ch == '-' {
        arr array[i32] = mk_array(ch);
        ps_step(p);
        ch = ps_peek(p);
        if ch == '=' || ch == '-' {
          push(&arr, ch);
          ps_step(p);
        } else if ch == '>' {
          push(&arr, ch);
          ps_step(p);
          ch = ps_peek(p);
          if ch == '~' {
            push(&arr, ch);
            ps_step(p);
          }
        }
        return mk_res(p, left, Oper(freeze(&arr)));
      } else {
        return {{left, ps_pos(p)}, Bad(void)};
      }

    } else if ch < '[' {
      if ch == '.' {
        return grab_oper2(p, left, ch, '~');
      } else if ch == '=' {
        return grab_oper2(p, left, ch, '=');
      } else if ch == '/' {
        ps_step(p);
        ch = ps_peek(p);
        if ch == '/' {
          ps_step(p);
          ch = ps_peek(p);
          while ch != '\n' {
            ps_step(p);
            ch = ps_peek(p);
          }
          ps_step(p);
          return mk_res(p, left, Comment(void));
        } else if ch == '*' {
          ps_step(p);
          ch = ps_peek(p);
          for ;; {
            while ch != '*' {
              ps_step(p);
              ch = ps_peek(p);
            }
            ps_step(p);
            ch = ps_peek(p);
            if ch == '/' {
              ps_step(p);
              return mk_res(p, left, Comment(void));
            }
          }
        } else if ch == '=' {
          ps_step(p);
          return mk_res(p, left, mk_oper('/', '='));
        } else {
          return mk_res(p, left, mk_oper('/'));
        }
      } else if ch == ':' {
        ps_step(p);
        return mk_res(p, left, Oper(mk_shray(ch)));
      } else if ch == ';' {
        ps_step(p);
        return mk_res(p, left, Oper(mk_shray(ch)));
      } else if ch == '<' {
        return grab_angly(p, left, ch);
      } else if ch == '>' {
        return grab_angly(p, left, ch);
      } else if ch == '@' {
        ps_step(p);
        return mk_res(p, left, Oper(mk_shray(ch)));
      } else {
        return {{left, ps_pos(p)}, Bad(void)};
      }

    } else {
      if ch == '[' {
        ps_step(p);
        return mk_res(p, left, @[tokval]Grouper(LBracket(void)));
      } else if ch == ']' {
        ps_step(p);
        return mk_res(p, left, @[tokval]Grouper(RBracket(void)));
      } else if ch == '^' {
        return grab_oper2(p, left, ch, '=');
      } else if ch == '`' {
        ps_step(p);
        return mk_res(p, left, @[tokval]Grouper(Backtick));
      } else if ch == '{' {
        ps_step(p);
        return mk_res(p, left, @[tokval]Grouper(LBrace(void)));
      } else if ch == '|' {
        return grab_oper2(p, left, ch, '=', '|');
      } else if ch == '}' {
        ps_step(p);
        return mk_res(p, left, @[tokval]Grouper(RBrace(void)));
      } else if ch == '~' {
        ps_step(p);
        return mk_res(p, left, Oper(mk_shray(ch)));
      } else {
        return {{left, ps_pos(p)}, Bad(void)};
      }
    }
  }
}

func grab_angly(p *ps, left pos, ch i32) tok {
  arr array[i32] = mk_array(ch);
  ps_step(p);
  dh i32 = ps_peek(p);
  if dh == ch {
    push(&arr, dh);
    ps_step(p);
    dh = ps_peek(p);
  }
  if dh == '=' {
    push(&arr, dh);
    ps_step(p);
  }
  return mk_res(p, left, Oper(freeze(&arr)));
}

func grab_oper2(p *ps, left pos, ch i32, n0 i32) tok {
  return grab_oper2(p, left, ch, n0, n0, n0);
}

func grab_oper2(p *ps, left pos, ch i32, n0 i32, n1 i32) tok {
  return grab_oper2(p, left, ch, n0, n1, n1);
}

func grab_oper2(p *ps, left pos, ch i32, n0 i32, n1 i32, n2 i32) tok {
  arr array[i32] = mk_array(ch);
  ps_step(p);
  ch = ps_peek(p);
  if ch == n0 || ch == n1 || ch == n2 {
    push(&arr, ch);
    ps_step(p);
  }
  return mk_res(p, left, Oper(freeze(&arr)));
}

func mk_res(p *ps, left pos, v tokval) tok {
  return mk_tok(left, ps_pos(p), v);
}

func mk_oper(ch0 i32) tokval {
  return Oper(mk_shray(ch0));
}

func mk_oper(ch0 i32, ch1 i32) tokval {
  return Oper(mk_shray(ch0, ch1));
}

func mk_oper(ch0 i32, ch1 i32, ch2 i32) tokval {
  return Oper(mk_shray(ch0, ch1, ch2));
}

func[String] grab_keyword(p *ps, s String, k keyw, out *tok) bool {
  left pos = ps_pos(p);
  n size = s.length;
  for i size = 0; i < n; i = i + 1 {
    si u8 = s[i];
    if ps_peek(p) != ~si {
      ps_restore_pos(p, left);
      return false;
    }
    ps_step(p);
  }

  if !is_ident_postchar(ps_peek(p)) {
    ps_restore_pos(p, left);
    return false;
  }

  *out = mk_tok(left, ps_pos(p), Keyw(k));
  return true;
}

func backquote_step(p *ps) void {
  p->current = backquote_grab_tok(p);
}

func backquote_grab_tok(p *ps) tok {
  left pos = ps_pos(p);
  ch i32 = ps_peek(p);
  if ch == '`' {
    ps_step(p);
    return mk_res(p, left, Grouper(@[grouper]Backtick));
  }
  build array[i32];
  for ;; {
    // NOTE: ASCII static assertions.
    // The less-than-or-equal-to is intentional.
    // Also, if ch is -1, we return Bad (not Eof).
    if ch <= ' ' || ch > '~' || is_alnumlike(ch) {
      return mk_res(p, left, Bad);
    }
    // TODO: Do backquote token-grabbing much better -- only accept valid opers.
    if ch == '`' {
      return mk_res(p, left, Oper(freeze(&build)));
    }
    ps_step(p);
    push(&build, ch);
    ch = ps_peek(p);
  }
}

// stop is either '\'' or '\"'.
func string_step(p *ps, stop i32) void {
  p->current = string_grab_tok(p, stop);
}

func string_grab_tok(p *ps, stop i32) tok {
  left pos = ps_pos(p);
  ch i32 = ps_peek(p);

  // TODO: ASCII static assertions.
  // If ch is -1, we return Bad (not Eof).
  if ch < ' ' || ch > '~' {
    return {{left, left}, Bad(void)};
  }

  ps_step(p);
  if ch != '\\' {
    if ch != stop {
      return {{left, ps_pos(p)}, StringChar(ch)};
    } else {
      dh i32 = ps_peek(p);
      if is_string_postchar(dh) {
        if ch == '\"' {
          return {{left, ps_pos(p)}, @[tokval]Grouper(DoubleQuote)};
        } else {
          check(ch == '\'');
          return {{left, ps_pos(p)}, @[tokval]Grouper(SingleQuote)};
        }
      } else {
        return {{left, ps_pos(p)}, Bad(void)};
      }
    }
  }

  ch = ps_peek(p);
  if ch == 'n' {
    ps_step(p);
    return {{left, ps_pos(p)}, StringChar('\n')};
  } else if ch == 't' {
    ps_step(p);
    return {{left, ps_pos(p)}, StringChar('\t')};
  } else if ch == '\'' || ch == '\"' || ch == '\\' {
    ps_step(p);
    return {{left, ps_pos(p)}, StringChar(ch)};
  } else if ch == 'r' {
    ps_step(p);
    return {{left, ps_pos(p)}, StringChar('\r')};
  } else if ch == '0' {
    ps_step(p);
    return {{left, ps_pos(p)}, StringChar(0)};
  } else if ch == 'x' {
    ps_step(p);
    ch = ps_peek(p);
    sixteens_value i8;
    if !is_hexdigit(ch, &sixteens_value) {
      return {{left, ps_pos(p)}, Bad(void)};
    }
    ps_step(p);
    ch = ps_peek(p);
    units_value i8;
    if !is_hexdigit(ch, &units_value) {
      return {{left, ps_pos(p)}, Bad(void)};
    }
    ps_step(p);

    combined i32 = 16 * (@[i32]~sixteens_value) + @[i32]~units_value;
    return {{left, ps_pos(p)}, StringChar(combined)};
  } else {
    return {{left, ps_pos(p)}, Bad(void)};
  }
}
