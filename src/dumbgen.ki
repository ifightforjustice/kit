import state;

deftype cell_locs struct {
  live bool;
};

deftype framestate struct {
  locs array[cell_locs];
};

deftype gn_annot struct {
  fs framestate;
};

deftype frame struct {
  cs *checkstate;
  gr *frame_graph;
  bas *basic_analyze_state;
  current framestate;
  // by_gn[i].fs shows what the state must is _before_ evaluating node i.
  by_gn array[nc[gn_annot]];
};

func dumbly_gen_graphed_fn_body(cs *checkstate, f *objfile, bas *basic_analyze_state, g *graphed_fn_body) bool {
  h frame = {cs, &g->graph.gr, bas, mk_arg_and_ret_framestate(g), repeat(count(&g->graph.gr.ops), NotComputed())};

  if !dumbly_gen_graph(cs, f, &h, &g->graph.gr, g->graph.gn) {
    return false;
  }

  return true;
}

func dumbly_gen_graph(cs *checkstate, f *objfile, h *frame, gr *frame_graph, gn gr_num) bool {
  gnc *nc[gn_annot] = ref(&h->by_gn, gn.~);
  if case &Computed(annot gn_annot) = gnc {
    // TODO: Return true??  Okay, I guess.
    return true;
  }

  annotate(gnc, {h->current});

  node *gr_node = ref_node(gr, gn);
  nprecs size = count(&node->precs);
  for i size = 0; i < nprecs; i = i + 1 {
    if !dumbly_gen_graph(cs, f, h, gr, get(&node->precs, i)) {
      return false;
    }
  }

  switch &node->op {
  case &GrApply(a gr_apply):
  case &GrMemCopy(a gr_memcopy):
  case &GrWriteConst(a gr_writeconst):
  case &GrAddressof(a gr_addressof):
  case &GrDeref(a gr_deref):
  case &GrSubcell(a gr_subcell):
  case &GrBranch(a gr_branch):
  case &GrSequence(a gr_sequence):
  case &GrJmp(a gr_jmp):
  case &GrWriteNothing(a gr_writenothing):
  case &GrDead(a gr_dead):
  case &GrNop(v void):
  }
  return true;
}


func refcur(h *frame, c cell_num) *cell_locs {
  return ref(&h->current.locs, c.~);
}

func mk_arg_and_ret_framestate(g *graphed_fn_body) framestate {
  arr array[cell_locs] = repeat(count(&g->graph.gr.cells), {false});
  nargcells size = count(&g->argcells);
  for i size = 0; i < nargcells; i = i + 1 {
    ref(&arr, get(&g->argcells, i).~)->live = true;
  }
  ref(&arr, g->graph.cell.~)->live = true;
  return {arr};
}
