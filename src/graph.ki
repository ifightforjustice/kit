import check;

deftype frame_graph struct {
  informal_name sym;
  cells array[cell_info];
  ops array[gr_node];
};

/* A cell location is tricky: the location of an expr's return value
is defined both by the expr itself and the context it's found
in. Location should be specified when:

   - for lvalues, whenever we create the cell (by calling add_cell) for the lvalue.
   - for rvalues, when we annotate the disposal for the rvalue.
*/

defenum cell_location {
  // The "cell" is actually caused by dereferencing something, or maybe accessing something's field?
  LocationVirtual void;
  LocationStatic void;
};

func `==`(x cell_location, y cell_location) bool {
  return enumnum(&x) == enumnum(&y);
}

func `!=`(x cell_location, y cell_location) bool {
  return enumnum(&x) != enumnum(&y);
}

func isLocationStatic(location cell_location) bool {
  switch location {
  case LocationVirtual(v void): return false;
  case LocationStatic(v void): return true;
  }
}

// TODO: Move to graph.ki or something.
deftype cell_info struct {
  // Location must be specified by type-checking, but it spends time in an unspecified state.
  location cell_location;
  type cu_typeexpr;
  props type_properties;
};

func location(info *cell_info) cell_location {
  return info->location;
}

// To "evaluate" an op, first we evaluate its precs (in unspecified order), then we ealuate the op.
deftype gr_node struct {
  precs shray[gr_num];
  op gr_op;
};

// TODO: Maybe gr_num should start from 1, so that 0 is an invalid value.
deftype gr_num size;
def `~` fn[size, gr_num] = wrapconvert;
func `==`(x gr_num, y gr_num) bool { return x.~ == y.~; }
func `!=`(x gr_num, y gr_num) bool { return x.~ != y.~; }
func `<`(x gr_num, y gr_num) bool { return x.~ < y.~; }
func hash_compute_hash(n *gr_num) osize {
  return hash_compute_hash(&n->~);
}
func hash_equal(x *gr_num, y *gr_num) bool {
  return x->~ == y->~;
}

deftype sq_num gr_num;
def `~` fn[gr_num, sq_num] = wrapconvert;

defenum gr_op {
  GrApply gr_apply;
  GrPrimApply gr_prim_apply;
  GrMemCopy gr_memcopy;
  GrWriteConst gr_writeconst;
  GrAddressof gr_addressof;
  GrDeref gr_deref;
  GrSubcell gr_subcell;
  GrBranch gr_branch;
  GrSequence gr_sequence;
  GrJmp gr_jmp;
  GrWriteNothing gr_writenothing;
  GrDead gr_dead;
  GrVirtualDead gr_virtual_dead;
  GrXNop void;
  GrQNop void;
};

func init_frame_graph_from_cells(informal_name sym, cells array[cell_info]) frame_graph {
  return {informal_name, cells, mk_array@[gr_node]()};
}

func init_frame_graph_empty(informal_name sym) frame_graph {
  return {informal_name, mk_array@[cell_info](), mk_array@[gr_node]()};
}

func add_cell(gr *frame_graph, info cell_info) cell_num {
  num cell_num = ~count(&gr->cells);
  push(&gr->cells, info);
  return num;
}

func help_add_node(gr *frame_graph, node gr_node) gr_num {
  ret gr_num = ~count(&gr->ops);
  push(&gr->ops, node);
  return ret;
}

func addx(gr *frame_graph, precs shray[gr_num], op gr_op) gr_num {
  return help_add_node(gr, {precs, op});
}

func addx(gr *frame_graph, op gr_op) gr_num {
  return help_add_node(gr, {mk_shray(), op});
}

func addq(gr *frame_graph, op gr_op) sq_num {
  return ~help_add_node(gr, {mk_shray(), op});
}

func mut_xnop_node(gr *frame_graph, ix gr_num, newnode gr_node) void {
  node *gr_node = ref(&gr->ops, ix.~);
  if case &GrXNop(v void) = &node->op {
    *node = newnode;
  } else {
    ice(_u8("mut_xnop_node sees non-nop node"));
  }
}

func mut_qnop_node(gr *frame_graph, ix sq_num, newnode gr_node) void {
  node *gr_node = ref_node(gr, ix.~);
  if case &GrQNop(v void) = &node->op {
    *node = newnode;
  } else {
    ice(_u8("mut_qnop_node sees non-nop node"));
  }
}

func ref_cell(gr *frame_graph, c cell_num) *cell_info {
  return ref(&gr->cells, c.~);
}

func ref_node(gr *frame_graph, gn gr_num) *gr_node {
  return ref(&gr->ops, gn.~);
}

func node0(op gr_op) gr_node {
  return {mk_shray(), op};
}

deftype gr_apply struct {
  funcell cell_num;
  params shray[cell_num];
  retcell cell_num;
};

deftype gr_prim_apply struct {
  primop primitive_op;
  params shray[cell_num];
  retcell cell_num;
};

deftype gr_memcopy struct {
  dest cell_num;
  src cell_num;
};

deftype gr_writeconst struct {
  dest cell_num;
  value gr_const;
};

deftype gr_addressof struct {
  dest cell_num;
  addressee cell_num;
};

deftype gr_deref struct {
  name cell_num;
  pointer cell_num;
  offset gr_offset;
};

deftype gr_subcell struct {
  name cell_num;
  partof cell_num;
  offset gr_offset;
};

defenum gr_offset {
  OffsetConst u32;
  OffsetComputed tup[u32, cell_num];
};

deftype gr_branch struct {
  src cell_num;
  cases shray[tup[gr_const, sq_num]];
  default_case opt[sq_num];
};

deftype gr_sequence struct {
  first gr_num;
  second sq_num;
};

deftype gr_jmp struct {
  next sq_num;
};

deftype gr_writenothing struct {
  dest cell_num;
};

deftype gr_dead struct {
  cell cell_num;
};

deftype gr_virtual_dead struct {
  cell cell_num;
};

defenum gr_const {
  ConstInt bigint;
  ConstDef instpair;
  ConstFnBody fn_body_id;
  ConstBytes shray[u8];
};

deftype fullbody_state struct {
  // all_vars and labels is from the ast_fullbody_info.
  // We use the cell field, to know the name of the var's cell.
  all_vars array[var_info];

  final_node sq_num;
  // count(&label_gn) == count(&info->labels), they start off as nop nodes until we see the label.
  label_gn array[sq_num];
  // Cells that are used as return cells.
  return_cells array[cell_num];
};

func nopq(gr *frame_graph) sq_num {
  return addq(gr, GrQNop(void));
}

func seqq(gr *frame_graph, gsq gr_sequence) sq_num {
  return addq(gr, GrSequence(gsq));
}

func seq1(gr *frame_graph, gn gr_num) sq_num {
  return seqq(gr, {gn, nopq(gr)});
}

func gr_fullbody(clq *clqueue, gr *frame_graph, x *ast_fullbody, out *gr_num, return_cell_out *cell_num) bool {
  final_node sq_num = nopq(gr);

  info *ast_fullbody_info = unHas(&x->info);
  exit_node sq_num;
  if !gr_unwind_vars(clq, gr, &info->parameter_destructions, final_node, &exit_node) {
    return false;
  }

  label_gn array[sq_num];
  n size = count(&info->labels);
  for i size = 0; i < n; i = i + 1 {
    ngn sq_num = nopq(gr);
    push(&label_gn, ngn);
  }

  fb fullbody_state = {info->all_vars, final_node, label_gn, mk_array@[cell_num]()};

  body_gn sq_num;
  if !gr_bracebody(clq, gr, &fb, None, &x->bb, exit_node, &body_gn) {
    return false;
  }

  // This assumes it's okay to have a subcell op produce the identical type -- it's the only place we do that.
  return_subcell_ops array[gr_num];
  return_subcell_deads array[gr_num];
  nreturncells size = count(&fb.return_cells);
  reserve(&return_subcell_ops, nreturncells);
  reserve(&return_subcell_deads, nreturncells);
  for i size = 0; i < nreturncells; i = i + 1 {
    subn var = addx(gr, @[gr_op]GrSubcell({get(&fb.return_cells, i), info->return_cell, OffsetConst(0)}));
    push(&return_subcell_ops, subn);
    deadn var = addx(gr, @[gr_op]GrVirtualDead({get(&fb.return_cells, i)}));
    push(&return_subcell_deads, deadn);
  }

  nopdep gr_num = addx(gr, freeze(&return_subcell_ops), @[gr_op]GrXNop(void));
  seqop sq_num = seqq(gr, {nopdep, body_gn});

  mut_qnop_node(gr, fb.final_node,
                node0(@[gr_op]GrSequence({
                  addx(gr, freeze(&return_subcell_deads), @[gr_op]GrXNop(void)),
                  nopq(gr)})));

  *out = seqop.~;
  *return_cell_out = info->return_cell;
  return true;
}

// TODO: Stop needing this -- make label_info and goto_info more general and use that, or make some other sort of annotation.  The use of breakgrack duplicates the usage of breakpack in body.ki.  It's not _particularly_ unsafe though.
deftype breakgrack struct {
  break_target sq_num;
  continue_target sq_num;
};

func gr_bracebody(clq *clqueue, gr *frame_graph, fb *fullbody_state, obg opt[breakgrack], x *ast_bracebody, outflow sq_num, out *sq_num) bool {
  bn sq_num;
  if !gr_unwind_vars(clq, gr, &unHas(&x->info)->destructions, outflow, &bn) {
    return false;
  }
  n size = count(&x->statements);
  for i size = n; i > 0; {
    i = i - 1;
    gn sq_num;
    if !gr_statement(clq, gr, fb, obg, ref(&x->statements, i), bn, &gn) {
      return false;
    }
    bn = gn;
  }
  *out = bn;
  return true;
}

func gr_statement(clq *clqueue, gr *frame_graph, fb *fullbody_state, obg opt[breakgrack], x *ast_statement, outflow sq_num, out *sq_num) bool {
  switch x {
    case &Expr(a ast_expr_discard): {
      gn gr_num;
      if !gr_expr_discard(clq, gr, &a, &gn) {
        return false;
      }
      *out = seqq(gr, {gn, outflow});
      return true;
    }
    case &Return(a ast_return_statement): {
      if !gr_return_statement(clq, gr, fb, &a, out) {
        return false;
      }
      return true;
    }
    case &Var(a ast_var_statement): {
      gn gr_num;
      if !gr_var_statement(clq, gr, fb, &a, &gn) {
        return false;
      }
      *out = seqq(gr, {gn, outflow});
      return true;
    }

    case &IfThen(a ast_ifthen_statement): {
      if !gr_ifthen_statement(clq, gr, fb, obg, &a, outflow, out) {
        return false;
      }
      return true;
    }
    case &IfThenElse(a ast_ifthenelse_statement): {
      if !gr_ifthenelse_statement(clq, gr, fb, obg, &a, outflow, out) {
        return false;
      }
      return true;
    }
    case &While(a ast_while_statement): {
      if !gr_while_statement(clq, gr, fb, &a, outflow, out) {
        return false;
      }
      return true;
    }

    case &For(a ast_for_statement): {
      if !gr_for_statement(clq, gr, fb, &a, outflow, out) {
        return false;
      }
      return true;
    }
    case &Switch(a ast_switch_statement): {
      if !gr_switch_statement(clq, gr, fb, obg, &a, outflow, out) {
        return false;
      }
      return true;
    }

    case &Break(a ast_break_statement):
      if !gr_break_statement(clq, gr, fb, obg, &a, outflow, out) {
        return false;
      }
      return true;

    case &Continue(a ast_continue_statement):
      if !gr_continue_statement(clq, gr, fb, obg, &a, outflow, out) {
        return false;
      }
      return true;

    case &Label(a ast_label_statement): {
      if !gr_label_statement(clq, gr, fb, &a, outflow, out) {
        return false;
      }
      return true;
    }
    case &Goto(a ast_goto_statement): {
      if !gr_goto_statement(clq, gr, fb, &a, outflow, out) {
        return false;
      }
      return true;
    }
  }
}

func gr_break_statement(clq *clqueue, gr *frame_graph, fb *fullbody_state, obg opt[breakgrack], a *ast_break_statement, outflow sq_num, out *sq_num) bool {
  info *ast_break_statement_info = unHas(&a->info);
  un sq_num;
  if !gr_unwind_vars(clq, gr, &info->destructions, unHas(&obg)->break_target, &un) {
    return false;
  }
  *out = un;
  return true;
}

func gr_continue_statement(clq *clqueue, gr *frame_graph, fb *fullbody_state, obg opt[breakgrack], a *ast_continue_statement, outflow sq_num, out *sq_num) bool {
  info *ast_continue_statement_info = unHas(&a->info);
  un sq_num;
  if !gr_unwind_vars(clq, gr, &info->destructions, unHas(&obg)->continue_target, &un) {
    return false;
  }
  *out = un;
  return true;
}

func gr_goto_statement(clq *clqueue, gr *frame_graph, fb *fullbody_state, a *ast_goto_statement, outflow sq_num, out *sq_num) bool {
  info *ast_goto_statement_info = unHas(&a->info);
  jmp sq_num = get(&fb->label_gn, info->label_number.~);
  wn sq_num;
  if !gr_wind_vars(clq, gr, &info->initializations, jmp, &wn) {
    return false;
  }
  un sq_num;
  if !gr_unwind_vars(clq, gr, &info->destructions, wn, &un) {
    return false;
  }
  *out = un;
  return true;
}

func gr_label_statement(clq *clqueue, gr *frame_graph, fb *fullbody_state, a *ast_label_statement, outflow sq_num, out *sq_num) bool {
  gn sq_num = get(&fb->label_gn, unHas(&a->info)->label_number.~);
  mut_qnop_node(gr, gn, node0(@[gr_op]GrJmp({outflow})));
  // Should we set *out to gn or outflow?  When labels get fancier, the answer will matter.
  *out = gn;
  return true;
}

func gr_switch_statement(clq *clqueue, gr *frame_graph, fb *fullbody_state, obg opt[breakgrack], a *ast_switch_statement, outflow sq_num, out *sq_num) bool {
  swartch_discard_gn gr_num;
  if !gr_later_discard(clq, gr, &a->swartch_discard, &swartch_discard_gn) {
    return false;
  }

  param_discard *te_typeexpr;
  is_ptr bool = decompose_typeapp(&expr_complete_type(&oo(&a->swartch)->expr)->~, primitive_pointer_puretype(clq->cs), &param_discard);

  exitseq var = seqq(gr, {swartch_discard_gn, outflow});

  info *ast_enum_deconstruction_info = unHas(&a->info);
  // TODO: Rename field
  cases array[opt[sq_num]] = repeat(info->num_enum_constructors, None);
  default_case opt[sq_num] = None();
  ncases size = count(&a->cases);
  reserve(&cases, ncases);
  for i size = 0; i < ncases; i = i + 1 {
    sc *ast_switch_case = ref(&a->cases, i);

    switch &sc->pattern {
      case &Case(cp ast_constructor_pattern): {
        cp_info *ast_cp_info = unHas(&cp.cp_info);
        if case Has(vn var_number) = cp_info->ovn {
          vi *var_info = ref(&fb->all_vars, vn.~);

          kill_var gr_num = addx(gr, @[gr_op]GrVirtualDead({vi->cell}));
          bodyexit sq_num = seqq(gr, {kill_var, exitseq});

          body_gn sq_num;
          if !gr_bracebody(clq, gr, fb, obg, &sc->body, bodyexit, &body_gn) {
            return false;
          }

          vcgn gr_num;
          if is_ptr {
            vcgn = addx(gr, @[gr_op]GrDeref({vi->cell, result_cell(oo(&a->swartch)), OffsetConst(cp_info->field_offset)}));
          } else {
            vcgn = addx(gr, @[gr_op]GrSubcell({vi->cell, result_cell(oo(&a->swartch)), OffsetConst(cp_info->field_offset)}));
          }
          gn1 var = seqq(gr, {vcgn, body_gn});
          kill_tag gr_num = addx(gr, @[gr_op]GrVirtualDead({info->tag_cell}));
          gn var = seqq(gr, {kill_tag, gn1});
          set(ref(&cases, unmk_enum_tag_value(cp_info->tag_value)), gn);
        } else {
          body_gn sq_num;
          if !gr_bracebody(clq, gr, fb, obg, &sc->body, exitseq, &body_gn) {
            return false;
          }
          kill_tag gr_num = addx(gr, @[gr_op]GrVirtualDead({info->tag_cell}));
          gn var = seqq(gr, {kill_tag, body_gn});
          set(ref(&cases, unmk_enum_tag_value(cp_info->tag_value)), gn);
        }
      }
      case &Default(v void): {
        body_gn sq_num;
        if !gr_bracebody(clq, gr, fb, obg, &sc->body, exitseq, &body_gn) {
          return false;
        }

        kill_tag gr_num = addx(gr, @[gr_op]GrVirtualDead({info->tag_cell}));
        gn var = seqq(gr, {kill_tag, body_gn});
        set(&default_case, gn);
      }
    }
  }

  branch_cases array[tup[gr_const, sq_num]];
  nconstructors size = count(&cases);
  for i size = 0; i < nconstructors; i++ {
    if case Has(sq sq_num) = get(&cases, i) {
      push(&branch_cases, {ConstInt(bigu(mk_enum_tag_value(i).~)), sq});
    } else {
      if case Has(dq sq_num) = default_case {
        push(&branch_cases, {ConstInt(bigu(mk_enum_tag_value(i).~)), dq});
      }
    }
  }

  swartch_gn gr_num;
  if !gr_expr_consume(clq, gr, oo(&a->swartch), &swartch_gn) {
    return false;
  }

  taggn gr_num;
  if is_ptr {
    taggn = addx(gr, mk_shray(swartch_gn), @[gr_op]GrDeref({info->tag_cell, result_cell(oo(&a->swartch)), OffsetConst(enum_tag_offset)}));
  } else {
    taggn = addx(gr, mk_shray(swartch_gn), @[gr_op]GrSubcell({info->tag_cell, result_cell(oo(&a->swartch)), OffsetConst(enum_tag_offset)}));
  }

  br var = seqq(gr, {taggn,
    addq(gr, @[gr_op]GrBranch({info->tag_cell, freeze(&branch_cases), None()}))});

  *out = br;
  return true;
}

func gr_for_statement(clq *clqueue, gr *frame_graph, fb *fullbody_state, a *ast_for_statement, outflow sq_num, out *sq_num) bool {
  topgn var = nopq(gr);

  loopcleanupgn gr_num;
  if case &Has(cond ast_expr_condition) = &a->condition {
    if !gr_later_discard(clq, gr, &cond.discard, &loopcleanupgn) {
      return false;
    }
  } else {
    loopcleanupgn = addx(gr, @[gr_op]GrXNop(void));
  }

  continue_target sq_num;

  continuegn sq_num;
  if case &Has(increment box[ast_expr_discard]) = &a->increment {
    incrgn gr_num;
    if !gr_expr_discard(clq, gr, oo(&increment), &incrgn) {
      return false;
    }
    totopgn var = seqq(gr, {incrgn, topgn});
    continue_target = totopgn;
    continuegn = seqq(gr, {loopcleanupgn, totopgn});
  } else {
    continuegn = seqq(gr, {loopcleanupgn, topgn});
    continue_target = continuegn;
  }

  bp breakgrack = {outflow, continue_target};

  thengn sq_num;
  if !gr_bracebody(clq, gr, fb, Has(bp), &a->body, continuegn, &thengn) {
    return false;
  }

  gn sq_num;
  if case &Has(cond ast_expr_condition) = &a->condition {
    // TODO: This would be using the same cells in different nodes.
    loopexitgn gr_num;
    if !gr_later_discard(clq, gr, &cond.discard, &loopexitgn) {
      return false;
    }

    initseq sq_num;
    if !gr_unwind_vars(clq, gr, &unHas(&a->info)->initter_destructions, outflow, &initseq) {
      return false;
    }

    exitseq var = seqq(gr, {loopexitgn, initseq});

    if !gr_expr_condition(clq, gr, oo(&cond.expr), thengn, exitseq, &gn) {
      return false;
    }
  } else {
    gn = thengn;
  }

  mut_qnop_node(gr, topgn, node0(@[gr_op]GrJmp({gn})));

  fingn sq_num;
  if case &Has(bi box[ast_statement]) = &a->initializer {
    if !gr_statement(clq, gr, fb, None(), oo(&bi), topgn, &fingn) {
      return false;
    }
  } else {
    fingn = topgn;
  }
  *out = fingn;
  return true;
}

func gr_condition_discard(clq *clqueue, gr *frame_graph, a *ast_condition_discard_info, out *gr_num) bool {
  disc gr_num;
  if !gr_later_discard(clq, gr, &a->later, &disc) {
    return false;
  }
  *out = disc;
  return true;
}

func gr_while_statement(clq *clqueue, gr *frame_graph, fb *fullbody_state, a *ast_while_statement, outflow sq_num, out *sq_num) bool {
  topgn var = nopq(gr);

  loopcleanupgn gr_num;
  if !gr_condition_discard(clq, gr, &a->condition_discard_continue, &loopcleanupgn) {
    return false;
  }

  loopexitgn gr_num;
  if !gr_condition_discard(clq, gr, &a->condition_discard_exit, &loopexitgn) {
    return false;
  }

  bp breakgrack = {outflow, topgn};

  exitseq var = seqq(gr, {loopexitgn, outflow});

  continuegn var = seqq(gr, {loopcleanupgn, topgn});
  thengn sq_num;
  if !gr_condition_body(clq, gr, fb, Has(bp), &a->condition_discard_continue, &a->body, continuegn, &thengn) {
    return false;
  }
  gn sq_num;
  if !gr_condition(clq, gr, fb, &a->condition, thengn, exitseq, &gn) {
    return false;
  }

  mut_qnop_node(gr, topgn, node0(@[gr_op]GrJmp({gn})));
  *out = topgn;
  return true;
}

func gr_ifthenelse_statement(clq *clqueue, gr *frame_graph, fb *fullbody_state, obg opt[breakgrack], a *ast_ifthenelse_statement, outflow sq_num, out *sq_num) bool {
  latergn gr_num;
  if !gr_condition_discard(clq, gr, &a->condition_discard, &latergn) {
    return false;
  }

  latseq var = seqq(gr, {latergn, outflow});

  thengn sq_num;
  if !gr_condition_body(clq, gr, fb, obg, &a->condition_discard, &a->thenbody, latseq, &thengn) {
    return false;
  }
  elsegn sq_num;
  if !gr_bracebody(clq, gr, fb, obg, &a->elsebody, latseq, &elsegn) {
    return false;
  }
  gn sq_num;
  if !gr_condition(clq, gr, fb, &a->condition, thengn, elsegn, &gn) {
    return false;
  }
  *out = gn;
  return true;
}

func gr_condition_body(clq *clqueue, gr *frame_graph, fb *fullbody_state, obg opt[breakgrack], cd *ast_condition_discard_info, body *ast_bracebody, outflow sq_num, out *sq_num) bool {
  if case &Has(c cell_num) = unHas(&cd->virtual_cell_dead) {
    vd gr_num = addx(gr, @[gr_op]GrVirtualDead({c}));
    outflow = seqq(gr, {vd, outflow});
  }
  return gr_bracebody(clq, gr, fb, obg, body, outflow, out);
}

func gr_ifthen_statement(clq *clqueue, gr *frame_graph, fb *fullbody_state, obg opt[breakgrack], a *ast_ifthen_statement, outflow sq_num, out *sq_num) bool {
  latergn gr_num;
  if !gr_condition_discard(clq, gr, &a->condition_discard, &latergn) {
    return false;
  }

  latseq var = seqq(gr, {latergn, outflow});

  bodygn sq_num;
  if !gr_condition_body(clq, gr, fb, obg, &a->condition_discard, &a->body, latseq, &bodygn) {
    return false;
  }
  gn sq_num;
  if !gr_condition(clq, gr, fb, &a->condition, bodygn, latseq, &gn) {
    return false;
  }
  *out = gn;
  return true;
}

func gr_expr_condition(clq *clqueue, gr *frame_graph, a *ast_expr_consume, thengn sq_num, elsegn sq_num, out *sq_num) bool {
  congn gr_num;
  if !gr_expr_consume(clq, gr, a, &congn) {
    return false;
  }
  cases shray[tup[gr_const, sq_num]] = mk_shray({@[gr_const]ConstInt(~ @[u32] 0), elsegn});
  br var = seqq(gr, {congn,
    addq(gr, @[gr_op]GrBranch({result_cell(a), cases, Has(thengn)}))});

  *out = br;
  return true;
}

func gr_condition(clq *clqueue, gr *frame_graph, fb *fullbody_state, a *ast_condition, thengn sq_num, elsegn sq_num, out *sq_num) bool {
  switch a {
    case &ExprCondition(bec box[ast_expr_consume]): {
      return gr_expr_condition(clq, gr, oo(&bec), thengn, elsegn, out);
    }

    case &PatternCondition(pa ast_pattern_assign): {
      rhs gr_num;
      if !gr_expr_consume(clq, gr, oo(&pa.rhs), &rhs) {
        return false;
      }

      info *ast_pattern_assign_info = unHas(&pa.info);
      // TODO: Avoid the duplicate checks for addressof_constructor, only do one GrDeref.
      taggn gr_num;
      if isHas(&pa.pattern.addressof_constructor) {
        taggn = addx(gr, mk_shray(rhs), @[gr_op]GrDeref({info->deconstruct.tag_cell, result_cell(oo(&pa.rhs)), OffsetConst(enum_tag_offset)}));
      } else {
        taggn = addx(gr, mk_shray(rhs), @[gr_op]GrSubcell({info->deconstruct.tag_cell, result_cell(oo(&pa.rhs)), OffsetConst(enum_tag_offset)}));
      }
      cases array[tup[gr_const, sq_num]];
      n size = info->deconstruct.num_enum_constructors;
      reserve(&cases, n);
      for i size = 0; i < n; i = i + 1 {
        tag enum_tag_value = mk_enum_tag_value(i);
        if info->matching_tag_value.~ == tag.~ {
          cp_info *ast_cp_info = unHas(&pa.pattern.cp_info);
          if case Has(vn var_number) = cp_info->ovn {
            vi *var_info = ref(&fb->all_vars, vn.~);
            vcgn gr_num;
            if isHas(&pa.pattern.addressof_constructor) {
              vcgn = addx(gr, @[gr_op]GrDeref({vi->cell, result_cell(oo(&pa.rhs)), OffsetConst(cp_info->field_offset)}));
            } else {
              vcgn = addx(gr, @[gr_op]GrSubcell({vi->cell, result_cell(oo(&pa.rhs)), OffsetConst(cp_info->field_offset)}));
            }
            gn var = seqq(gr, {vcgn, thengn});
            tagdead gr_num = addx(gr, @[gr_op]GrVirtualDead({info->deconstruct.tag_cell}));
            thenseq sq_num = seqq(gr, {tagdead, gn});
            push(&cases, cons(@[gr_const]ConstInt(~tag.~), thenseq));
          } else {
            tagdead gr_num = addx(gr, @[gr_op]GrVirtualDead({info->deconstruct.tag_cell}));
            thenseq sq_num = seqq(gr, {tagdead, thengn});
            push(&cases, cons(@[gr_const]ConstInt(~tag.~), thenseq));
          }
        } else {
          tagdead gr_num = addx(gr, @[gr_op]GrVirtualDead({info->deconstruct.tag_cell}));
          elseseq sq_num = seqq(gr, {tagdead, elsegn});
          push(&cases, cons(@[gr_const]ConstInt(~tag.~), elseseq));
        }
      }
      br var = seqq(gr, {taggn,
        addq(gr, @[gr_op]GrBranch({info->deconstruct.tag_cell, freeze(&cases), None()}))});

      *out = br;
      return true;
    }
  }
}

func gr_var_statement(clq *clqueue, gr *frame_graph, fb *fullbody_state, a *ast_var_statement, out *gr_num) bool {
  switch &a->rhs {
    case &HasExpr(be box[ast_expr_consume]): {
      return gr_expr_consume(clq, gr, oo(&be), out);
    }
    case &AutoInit(x opt[init_action]): {
      if case &Has(ia init_action) = &x {
        return gr_init_action(clq, gr, &ia, out);
      } else {
        ice(_u8("AutoInit action not annotated"));
        return fake();
      }
    }
  }
}

func gr_return_statement(clq *clqueue, gr *frame_graph, fb *fullbody_state, a *ast_return_statement, out *sq_num) bool {
  gn gr_num;
  if case &Has(b box[ast_expr_consume]) = &a->expr {
    if !gr_expr_consume(clq, gr, oo(&b), &gn) {
      return false;
    }
    push(&fb->return_cells, result_cell(oo(&b)));
  } else {
    gn = addx(gr, @[gr_op]GrXNop(void));
  }
  info *ast_return_statement_info = unHas(&a->info);
  uw sq_num;
  if !gr_unwind_vars(clq, gr, &info->destructions, fb->final_node, &uw) {
    return false;
  }
  sn var = seqq(gr, {gn, uw});
  *out = sn;
  return true;
}

// "initializations" is in variable declaration order -- the _same_ order as evaluation.
func gr_wind_vars(clq *clqueue, gr *frame_graph, initializations *array[init_action], outflow sq_num, out *sq_num) bool {
  bn sq_num = outflow;
  n size = count(initializations);
  for i size = n; i > 0; {
    i = i - 1;
    gn gr_num;
    if !gr_init_action(clq, gr, ref(initializations, i), &gn) {
      return false;
    }
    bn = seqq(gr, {gn, bn});
  }
  *out = bn;
  return true;
}

// "destructions" is in variable declaration order -- the _opposite_ order of evaluation.
func gr_unwind_vars(clq *clqueue, gr *frame_graph, destructions *array[var_destruction], outflow sq_num, out *sq_num) bool {
  bn sq_num = outflow;
  n size = count(destructions);
  for i size = 0; i < n; i = i + 1 {
    gn gr_num;
    switch get(destructions, i) {
    case VarSelfContainedDestruction(da destroy_action):
      if !gr_destroy_action(clq, gr, &da, DeadAfterDestroyYes(void), &gn) {
        return false;
      }
    case VarVirtualCellDead(c cell_num):
      gn = addx(gr, @[gr_op]GrVirtualDead({c}));
    }
    bn = seqq(gr, {gn, bn});
  }
  *out = bn;
  return true;
}

func gr_expr_discard(clq *clqueue, gr *frame_graph, x *ast_expr_discard, out *gr_num) bool {
  dp gr_num;
  if !gr_expr(clq, gr, &x->expr, &dp) {
    return false;
  }
  after_gn gr_num;
  if !gr_expr_after_discard(clq, gr, unHas(&x->after), &after_gn) {
    return false;
  }
  gn sq_num = seqq(gr, {dp, seq1(gr, after_gn)});
  *out = gn.~;
  return true;
}

func gr_expr_after_discard(clq *clqueue, gr *frame_graph, aft *ast_expr_after_discard, out *gr_num) bool {
  after_gn gr_num;
  switch aft {
  case &DiscardTemporary(da destroy_action):
    if !gr_destroy_action(clq, gr, &da, DeadAfterDestroyYes(void), &after_gn) {
      return false;
    }
  case &DiscardVirtualDead(c cell_num):
    after_gn = addx(gr, @[gr_op]GrVirtualDead({c}));
  case &DiscardNothing(v void):
    after_gn = addx(gr, @[gr_op]GrXNop(void));
  }
  *out = after_gn;
  return true;
}

func gr_expr_consume(clq *clqueue, gr *frame_graph, x *ast_expr_consume, out *gr_num) bool {
  return gr_expr_and_consume(clq, gr, &x->expr, unHas(&x->after), out);
}

func gr_expr_and_consume(clq *clqueue, gr *frame_graph, x *ast_expr, aft *ast_expr_after_consume, out *gr_num) bool {
  expr_gn gr_num;
  if !gr_expr(clq, gr, x, &expr_gn) {
    return false;
  }
  after_gn gr_num;
  if !gr_consume_actions(clq, gr, expr_gn, &aft->actions, &after_gn) {
    return false;
  }
  *out = after_gn;
  return true;
}

func gr_expr(clq *clqueue, gr *frame_graph, x *ast_expr, out *gr_num) bool {
  cs *checkstate = clq->cs;
  switch &x->u {
    case &NameExpr(a ast_name_expr): {
      return gr_name_expr(clq, gr, x, &a, out);
    }
    case &ParenExpr(a ast_paren_expr): {
      return gr_expr(clq, gr, oo(&a.expr), out);
    }
    case &NumericLiteral(a ast_numeric_literal): {
      return gr_literal(clq, gr, x, numeric_literal_value(&a), out);
    }
    case &BoolLiteral(a ast_bool_literal): {
      value bigint;
      if a.value {
        value = ~ @[u32] 1;
      } else {
        value = ~ @[u32] 0;
      }
      return gr_literal(clq, gr, x, value, out);
    }
    case &VoidLiteral(a ast_void_literal): {
      value bigint = ~ @[u32] 0;
      return gr_literal(clq, gr, x, value, out);
    }
    case &NullLiteral(a ast_null_literal): {
      value bigint = ~ @[u32] 0;
      return gr_literal(clq, gr, x, value, out);
    }
    case &CharLiteral(a ast_char_literal): {
      value bigint = ~ a.charspec.value;
      return gr_literal(clq, gr, x, value, out);
    }

    case &StringLiteral(a ast_string_literal): {
      return gr_string_literal(clq, gr, x, &a, out);
    }
    case &Funcall(a ast_funcall): {
      return gr_funcall(clq, gr, x, &a, out);
    }
    case &LogicalConjunction(a ast_logical_conjunction): {
      return gr_logical_conjunction(clq, gr, x, &a, out);
    }
    case &Assignment(a ast_assignment): {
      return gr_assignment(clq, gr, x, &a, out);
    }
    case &AddressOf(a ast_addressof): {
      return gr_mk_addressof(clq, gr, x, &a, out);
    }
    case &Deref(a ast_deref): {
      return gr_mk_deref(clq, gr, x, &a, out);
    }
    case &IndexExpr(a ast_index_expr): {
      return gr_index_expr(clq, gr, x, &a, out);
    }
    case &Lambda(a ast_lambda): {
      return gr_lambda_expr(clq, gr, x, &a, out);
    }
    case &LocalField(a ast_local_field): {
      return gr_local_field(clq, gr, x, &a, out);
    }
    case &DerefField(a ast_deref_field): {
      return gr_deref_field(clq, gr, x, &a, out);
    }
    case &TypedExpr(a ast_typed_expr): {
      return gr_expr(clq, gr, oo(&a.expr), out);
    }
    case &Strinit(a ast_strinit):
      return gr_mk_strinit(clq, gr, x, &a, out);
    case &Ternary(a ast_ternary):
      return gr_mk_ternary(clq, gr, x, &a, out);
  }
}

func gr_mk_ternary(clq *clqueue, gr *frame_graph, x *ast_expr, a *ast_ternary, out *gr_num) bool {
  // TODO: We do the condcleanup at the end instead of repeating it twice right after the branch... do it right after the branch.
  condcleanupgn gr_num;
  if !gr_later_discard(clq, gr, &oo(&a->condition)->discard, &condcleanupgn) {
    return false;
  }

  cleanup_tail sq_num = seq1(gr, condcleanupgn);

  then_gn gr_num;
  if !gr_expr_consume(clq, gr, oo(&a->then_clause), &then_gn) {
    return false;
  }
  else_gn gr_num;
  if !gr_expr_consume(clq, gr, oo(&a->else_clause), &else_gn) {
    return false;
  }

  conjoined cell_num = unHas(&a->info)->conjoined_result_cell;

  then_sn sq_num = seqq(gr, {
    addx(gr, @[gr_op]GrSubcell({result_cell(oo(&a->then_clause)), conjoined, OffsetConst(0)})),
    seqq(gr, {
      then_gn,
      seqq(gr, {
        addx(gr, @[gr_op]GrVirtualDead({result_cell(oo(&a->then_clause))})),
        cleanup_tail})})});
  else_sn sq_num = seqq(gr, {
    addx(gr, @[gr_op]GrSubcell({result_cell(oo(&a->else_clause)), conjoined, OffsetConst(0)})),
    seqq(gr, {
      else_gn,
      seqq(gr, {
        addx(gr, @[gr_op]GrVirtualDead({result_cell(oo(&a->else_clause))})),
        cleanup_tail})})});

  cond_sn sq_num;
  if !gr_expr_condition(clq, gr, oo(&oo(&a->condition)->expr), then_sn, else_sn, &cond_sn) {
    return false;
  }

  seq sq_num = seqq(gr, {
    addx(gr, @[gr_op]GrWriteNothing({conjoined})),
    cond_sn});
  *out = seq.~;
  return true;
}

func gr_mk_strinit(clq *clqueue, gr *frame_graph, x *ast_expr, a *ast_strinit, out *gr_num) bool {
  ngn gr_num = addx(gr, @[gr_op]GrWriteNothing({rval_cell(x)}));

  precs array[gr_num];
  nparams size = count(&a->exprs);
  reserve(&precs, nparams);
  for i size = 0; i < nparams; i = i + 1 {
    param *ast_strinit_param = ref(&a->exprs, i);
    befdep gr_num = addx(gr, @[gr_op]GrSubcell({result_cell(&param->ec), rval_cell(x), OffsetConst(unHas(&param->info)->offset)}));
    dep gr_num;
    if !gr_expr_consume(clq, gr, &param->ec, &dep) {
      return false;
    }
    aftdep gr_num = addx(gr, @[gr_op]GrVirtualDead({result_cell(&param->ec)}));

    prec1 sq_num = seqq(gr, {dep, seq1(gr, aftdep)});
    prec sq_num = seqq(gr, {befdep, prec1});
    push(&precs, prec.~);
  }
  np var = addx(gr, freeze(&precs), @[gr_op]GrXNop(void));
  gn sq_num = seqq(gr, {ngn, seq1(gr, np)});
  *out = gn.~;
  return true;
}

func gr_deref_field(clq *clqueue, gr *frame_graph, x *ast_expr, a *ast_deref_field, out *gr_num) bool {
  rp gr_num;
  if !gr_expr_consume(clq, gr, oo(&a->lhs), &rp) {
    return false;
  }
  info *ast_deref_field_info = unHas(&a->info);
  ap gr_num;
  if !gr_later_discard(clq, gr, &a->ptr_discard, &ap) {
    return false;
  }
  switch info {
    case &DerefArrayLength(count u32): {
      cp var = addx(gr, @[gr_op]GrWriteConst({rval_cell(x), ConstInt(~count)}));
      sp var = seqq(gr, {rp, seq1(gr, ap)});
      gn var = addx(gr, mk_shray(sp.~, cp), @[gr_op]GrXNop(void));
      *out = gn;
      return true;
    }
    case &DerefFieldName(offset u32): {
      name cell_num = ellval_cell(x);
      dp var = addx(gr, mk_shray(rp), @[gr_op]GrDeref({name, result_cell(oo(&a->lhs)), OffsetConst(offset)}));
      sp sq_num = seqq(gr, {dp, seq1(gr, ap)});
      *out = sp.~;
      return true;
    }
  }
}

func gr_local_field(clq *clqueue, gr *frame_graph, x *ast_expr, a *ast_local_field, out *gr_num) bool {
  info *ast_local_field_info = unHas(&a->info);
  lp gr_num;
  if !gr_expr(clq, gr, oo(&a->lhs), &lp) {
    return false;
  }
  switch info {
    case &ArrayLength(alinfo ast_arraylength_info): {
      dp1 gr_num;
      if !gr_expr_after_discard(clq, gr, &alinfo.after, &dp1) {
        return false;
      }
      dp var = seqq(gr, {lp, seq1(gr, dp1)});
      cp var = addx(gr, @[gr_op]GrWriteConst({rval_cell(x), ConstInt(~alinfo.count)}));
      gn var = addx(gr, mk_shray(dp.~, cp), @[gr_op]GrXNop(void));
      *out = gn;
      return true;
    }
    case &FieldName(offset u32): {
      gn1 var = addx(gr, mk_shray(lp), @[gr_op]GrSubcell({value_cell(x), value_cell(oo(&a->lhs)), OffsetConst(offset)}));
      gn gr_num;
      switch &expr_complete_info(oo(&a->lhs))->lval {
      case &IsLvalYes(desc lval_description):
        if case DeadMe(v void) = desc.deadme {
          gn = addx(gr, mk_shray(gn1), @[gr_op]GrVirtualDead({desc.num}));
        } else {
          gn = gn1;
        }
      case &IsLvalNo(desc rval_description):
        if !gr_chain_virtualdead(clq, gr, gn1, desc.partial_num, &gn) {
          return false;
        }
      }
      *out = gn;
      return true;
    }
  }
}

func gr_lambda_expr(clq *clqueue, gr *frame_graph, x *ast_expr, a *ast_lambda, out *gr_num) bool {
  info *ast_fullbody_info = unHas(&a->body.info);
  lambda_gr frame_graph = init_frame_graph_from_cells(gr->informal_name, info->cells);
  fullbody_gn gr_num;
  return_cell cell_num;
  if !gr_fullbody(clq, &lambda_gr, &a->body, &fullbody_gn, &return_cell) {
    return false;
  }

  id fn_body_id = add_fn_body(clq->cs, {gr->informal_name, NotComputed@[sti](), NotComputed@[u32](), @[fn_body_entry_enum]GraphedFnBody({FnBodyLambda(a), {lambda_gr, fullbody_gn, return_cell}, info->arg_cells, parsed_inline_to_state_inline(a->is_inline)})});
  gn var = addx(gr, @[gr_op]GrWriteConst({rval_cell(x), ConstFnBody(id)}));
  *out = gn;
  return true;
}

func parsed_inline_to_state_inline(a ast_isinline) should_inline {
  switch a {
  case IsInline(v void): return InlineMust(void);
  case IsNotInline(v void): return InlineYawn(void);
  }
}

func gr_index_expr(clq *clqueue, gr *frame_graph, x *ast_expr, a *ast_index_expr, out *gr_num) bool {
  info *ast_index_expr_info = unHas(&a->info);
  rp gr_num;
  if !gr_expr_consume(clq, gr, oo(&a->rhs), &rp) {
    return false;
  }
  lp gr_num;
  if !gr_expr(clq, gr, oo(&a->lhs), &lp) {
    return false;
  }
  rhs_later gr_num;
  if !gr_later_discard(clq, gr, &info->rhs_later, &rhs_later) {
    return false;
  }
  if case &Has(aft tup[ast_expr_after_consume, ast_later_discard_info]) = &info->lhs_after {
    // It's a pointer.
    name cell_num = ellval_cell(x);
    flat_size u32 = ref_cell(gr, name)->props.flat_size;
    lgn gr_num;
    if !gr_consume_actions(clq, gr, lp, &aft.car.actions, &lgn) {
      return false;
    }
    gp var = addx(gr, mk_shray(rp, lgn), @[gr_op]GrDeref({name, result_cell(&aft.car), OffsetComputed(cons(flat_size, result_cell(oo(&a->rhs))))}));
    lhs_later gr_num;
    if !gr_later_discard(clq, gr, &aft.cdr, &lhs_later) {
      return false;
    }
    laters var = addx(gr, mk_shray(lhs_later, rhs_later), @[gr_op]GrXNop(void));
    gp_laters var = seqq(gr, {gp, seq1(gr, laters)});
    *out = gp_laters.~;
    return true;
  } else {
    name cell_num = value_cell(x);
    flat_size u32 = ref_cell(gr, name)->props.flat_size;
    gp1 var = addx(gr, mk_shray(rp, lp), @[gr_op]GrSubcell({name, value_cell(oo(&a->lhs)), OffsetComputed(cons(flat_size, result_cell(oo(&a->rhs))))}));
    gp gr_num;
    // TODO: Dedup with local_field code?
    switch &expr_complete_info(oo(&a->lhs))->lval {
    case &IsLvalYes(desc lval_description):
      if case DeadMe(v void) = desc.deadme {
        gp = addx(gr, mk_shray(gp1), @[gr_op]GrVirtualDead({desc.num}));
      } else {
        gp = gp1;
      }
    case &IsLvalNo(desc rval_description):
      if !gr_chain_virtualdead(clq, gr, gp1, desc.partial_num, &gp) {
        return false;
      }
    }
    gp_later sq_num = seqq(gr, {gp, seq1(gr, rhs_later)});
    *out = gp_later.~;
    return true;
  }
}

func gr_later_discard(clq *clqueue, gr *frame_graph, a *ast_later_discard_info, out *gr_num) bool {
  da *destroy_action = unHas(&a->action);
  return gr_destroy_action(clq, gr, da, DeadAfterDestroyYes(void), out);
}

func gr_mk_deref(clq *clqueue, gr *frame_graph, x *ast_expr, a *ast_deref, out *gr_num) bool {
  rp gr_num;
  if !gr_expr_consume(clq, gr, oo(&a->rhs), &rp) {
    return false;
  }
  dp var = addx(gr, mk_shray(rp), @[gr_op]GrDeref({ellval_cell(x), result_cell(oo(&a->rhs)), OffsetConst(0)}));
  ap gr_num;
  if !gr_later_discard(clq, gr, &a->ptr_discard, &ap) {
    return false;
  }
  gn sq_num = seqq(gr, {dp, seq1(gr, ap)});
  *out = gn.~;
  return true;
}

func gr_mk_addressof(clq *clqueue, gr *frame_graph, x *ast_expr, a *ast_addressof, out *gr_num) bool {
  rp gr_num;
  if !gr_expr(clq, gr, oo(&a->rhs), &rp) {
    return false;
  }
  desc *lval_description = ellval_desc(oo(&a->rhs));
  ap1 gr_num = addx(gr, mk_shray(rp), @[gr_op]GrAddressof({rval_cell(x), desc->num}));
  ap gr_num;
  if case DeadMe(v void) = desc->deadme {
    ap = addx(gr, mk_shray(ap1), @[gr_op]GrVirtualDead({ellval_cell(oo(&a->rhs))}));
  } else {
    ap = ap1;
  }
  *out = ap;
  return true;
}

func gr_assignment(clq *clqueue, gr *frame_graph, x *ast_expr, a *ast_assignment, out *gr_num) bool {
  lp gr_num;
  if !gr_expr(clq, gr, oo(&a->lhs), &lp) {
    return false;
  }
  rp gr_num;
  if !gr_expr(clq, gr, oo(&a->rhs), &rp) {
    return false;
  }
  lp_rp_nop gr_num = addx(gr, mk_shray(lp, rp), @[gr_op]GrXNop(void));
  switch unHas(&a->info) {
    case &StaticSelfAssignment(v void): {
      *out = lp_rp_nop;
      return true;
    }
    case &SimpleMoveAssignment(smi ast_simple_move_assignment_info): {
      dgn gr_num;
      if !gr_destroy_action(clq, gr, &smi.target_destroy, DeadAfterDestroyNo(void), &dgn) {
        return false;
      }
      mgn gr_num;
      if !gr_move_action(clq, gr, &smi.rhs_move, &mgn) {
        return false;
      }
      gn1 sq_num = seqq(gr, {dgn, seq1(gr, mgn)});
      gn2 sq_num = seqq(gr, {lp_rp_nop, gn1});
      *out = gn2.~;
      return true;
    }
    case &SimpleCopyDestroyAssignment(scdi ast_simple_copydestroy_assignment_info): {
      dgn gr_num;
      if !gr_destroy_action(clq, gr, &scdi.target_destroy, DeadAfterDestroyNo(void), &dgn) {
        return false;
      }
      mgn1 gr_num;
      if !gr_copy_action(clq, gr, &scdi.rhs_copy, &mgn1) {
        return false;
      }
      mgn gr_num;
      if !gr_chain_virtualdead(clq, gr, mgn1, scdi.rhs_copy.src, &mgn) {
        return false;
      }
      drgn gr_num;
      if !gr_destroy_action(clq, gr, &scdi.rhs_cleanup, DeadAfterDestroyYes(void), &drgn) {
        return false;
      }
      gn1 sq_num = seqq(gr, {mgn, seq1(gr, drgn)});
      gn2 sq_num = seqq(gr, {dgn, gn1});
      gn3 sq_num = seqq(gr, {lp_rp_nop, gn2});
      *out = gn3.~;
      return true;
    }
    case &SimpleCopyAssignment(sci ast_simple_copy_assignment_info): {
      // TODO: This is disgusting.  We have a trivial destructor, trivial copy assignment.  Why go through this rigamarole?
      dgn gr_num;
      if !gr_destroy_action(clq, gr, &sci.target_destroy, DeadAfterDestroyNo(void), &dgn) {
        return false;
      }
      mgn gr_num;
      if !gr_copy_action(clq, gr, &sci.rhs_copy, &mgn) {
        return false;
      }
      if case DeadMe(v void) = sci.rhs_deadme {
        if !gr_chain_virtualdead(clq, gr, mgn, sci.rhs_copy.src, &mgn) {
          return false;
        }
      }
      gn1 sq_num = seqq(gr, {dgn, seq1(gr, mgn)});
      gn2 sq_num = seqq(gr, {lp_rp_nop, gn1});
      *out = gn2.~;
      return true;
    }
    case &ConditionalAssignment(ci ast_conditional_assignment_info): {
      destcell cell_num = value_cell(oo(&a->lhs));
      valuetype *cu_typeexpr = &ref_cell(gr, destcell)->type;
      ptrtype cu_typrop = computed_ptr_type(clq, valuetype);
      booltype cu_typrop = compute_prim(clq, primitive_bool_type(clq->cs));
      fntype cu_typrop = compute_prim(clq, fn_type(clq->cs, ptrtype.cu.~, ptrtype.cu.~, booltype.cu.~));

      funcell cell_num = add_cell(gr, {LocationStatic, fntype.cu, fntype.props});
      destptr cell_num = add_cell(gr, {LocationStatic, ptrtype.cu, ptrtype.props});
      srcptr cell_num = add_cell(gr, {LocationStatic, ptrtype.cu, ptrtype.props});
      cmp_result cell_num = add_cell(gr, {LocationStatic, booltype.cu, booltype.props});

      fc var = addx(gr, @[gr_op]GrWriteConst({funcell, ConstDef(ci.comparecells)}));
      dp var = addx(gr, @[gr_op]GrAddressof({destptr, destcell}));
      sp var = addx(gr, @[gr_op]GrAddressof({srcptr, value_cell(oo(&a->rhs))}));
      ap var = addx(gr, mk_shray(fc, dp, sp), @[gr_op]GrApply({funcell, mk_shray(destptr, srcptr), cmp_result}));

      just_dead var = addx(gr, @[gr_op]GrDead({cmp_result}));
      if case DeadMe(v void) = ci.rhs_deadme {
        // TODO: It would be nice if we just had a closing node for virtualdead, maybe also for just_dead, instead of these duplicate tails.
        if !gr_chain_virtualdead(clq, gr, just_dead, ci.conditional_copy.src, &just_dead) {
          return false;
        }
      }

      assign_destroy gr_num;
      if !gr_destroy_action(clq, gr, &ci.conditional_destroy, DeadAfterDestroyNo(void), &assign_destroy) {
        return false;
      }
      assign_copy gr_num;
      if !gr_copy_action(clq, gr, &ci.conditional_copy, &assign_copy) {
        return false;
      }
      assign sq_num = seqq(gr, {assign_destroy, seq1(gr, assign_copy)});
      dead_before_assign gr_num = addx(gr, @[gr_op]GrDead({cmp_result}));
      dead_then_assign gr_num = seqq(gr, {dead_before_assign, assign}).~;
      if case DeadMe(v void) = ci.rhs_deadme {
        if !gr_chain_virtualdead(clq, gr, dead_then_assign, ci.conditional_copy.src, &dead_then_assign) {
          return false;
        }
      }
      cases shray[tup[gr_const, sq_num]] = mk_shray(cons(@[gr_const]ConstInt(~ @[u32] 0), seq1(gr, dead_then_assign)), cons(@[gr_const]ConstInt(~ @[u32] 1), seq1(gr, just_dead)));

      br var = seqq(gr, {ap,
        addq(gr, @[gr_op]GrBranch({cmp_result, cases, None()}))});
      seq_lp_rp_nop var = seqq(gr, {lp_rp_nop, br});
      *out = seq_lp_rp_nop.~;
      return true;
    }
  }
}

func gr_logical_conjunction(clq *clqueue, gr *frame_graph, x *ast_expr, a *ast_logical_conjunction, out *gr_num) bool {
  lhs_dep gr_num;
  if !gr_expr_consume(clq, gr, oo(&a->lhs), &lhs_dep) {
    return false;
  }
  rhs_dep gr_num;
  if !gr_expr_consume(clq, gr, oo(&a->rhs), &rhs_dep) {
    return false;
  }

  rhs_cp_gn gr_num = addx(gr, mk_shray(rhs_dep), @[gr_op]GrMemCopy({rval_cell(x), result_cell(oo(&a->rhs))}));
  rhs_dead_gn gr_num = addx(gr, mk_shray(rhs_cp_gn), @[gr_op]GrDead({result_cell(oo(&a->rhs))}));

  rhs_lhs_dead_gn gr_num = addx(gr, @[gr_op]GrDead({result_cell(oo(&a->lhs))}));
  lhs_dead_then_rhs sq_num = seqq(gr, {rhs_lhs_dead_gn, seq1(gr, rhs_dead_gn)});

  lhs_cp_gn gr_num = addx(gr, @[gr_op]GrMemCopy({rval_cell(x), result_cell(oo(&a->lhs))}));
  lhs_dead_gn gr_num = addx(gr, mk_shray(lhs_cp_gn), @[gr_op]GrDead({result_cell(oo(&a->lhs))}));

  cases array[tup[gr_const, gr_num]];
  short_circuit_case gr_const;
  eval_rhs_case gr_const;
  if a->is_logical_or {
    short_circuit_case = ConstInt(~ @[u32] 1);
    eval_rhs_case = ConstInt(~ @[u32] 0);
  } else {
    short_circuit_case = ConstInt(~ @[u32] 0);
    eval_rhs_case = ConstInt(~ @[u32] 1);
  }
  bn sq_num = seqq(gr, {lhs_dep,
    addq(gr, @[gr_op]GrBranch({result_cell(oo(&a->lhs)), mk_shray({short_circuit_case, seq1(gr, lhs_dead_gn)}, {eval_rhs_case, lhs_dead_then_rhs}), None()}))});
  *out = bn.~;
  return true;
}

func gr_funcall(clq *clqueue, gr *frame_graph, x *ast_expr, a *ast_funcall, out *gr_num) bool {
  nparams size = count(&a->params);
  precs array[gr_num];
  reserve(&precs, nparams + 1);
  dep gr_num;
  if !gr_expr_consume(clq, gr, oo(&a->fun), &dep) {
    return false;
  }
  push(&precs, dep);
  paramcells array[cell_num];
  reserve(&paramcells, nparams);
  for i size = 0; i < nparams; i = i + 1 {
    param *ast_expr_consume = ref(&a->params, i);
    if !gr_expr_consume(clq, gr, param, &dep) {
      return false;
    }
    push(&precs, dep);
    push(&paramcells, result_cell(param));
  }
  ap var = addx(gr, freeze(&precs), @[gr_op]GrApply({result_cell(oo(&a->fun)), freeze(&paramcells), rval_cell(x)}));
  *out = ap;
  return true;
}

func gr_string_literal(clq *clqueue, gr *frame_graph, x *ast_expr, a *ast_string_literal, out *gr_num) bool {
  bytes array[u8];
  nchars size = count(&a->charspecs);
  reserve(&bytes, nchars);
  for i size = 0; i < nchars; i = i + 1 {
    ch i32 = get(&a->charspecs, i).value;
    if ch < 0 || ch > 255 {
      ice(_u8("gr_string_literal char values out of range"));
    }
    push(&bytes, ~ch);
  }
  gn var = addx(gr, @[gr_op]GrWriteConst({rval_cell(x), ConstBytes(freeze(&bytes))}));
  *out = gn;
  return true;
}

func gr_literal(clq *clqueue, gr *frame_graph, x *ast_expr, value bigint, out *gr_num) bool {
  gn var = addx(gr, @[gr_op]GrWriteConst({rval_cell(x), ConstInt(value)}));
  *out = gn;
  return true;
}

func gr_name_expr(clq *clqueue, gr *frame_graph, x *ast_expr, a *ast_name_expr, out *gr_num) bool {
  switch unHas(&a->name_info) {
    case &LocalResolve(li local_info): {
      *out = addx(gr, @[gr_op]GrXNop(void));
      return true;
    }
    case &GlobalResolve(gi global_info): {
      *out = addx(gr, @[gr_op]GrWriteConst({rval_cell(x), ConstDef({gi.ent, gi.inst})}));
      return true;
    }
    case &EnumConstructor(ei enum_constructor_info): {
      *out = addx(gr, @[gr_op]GrWriteConst({rval_cell(x), ConstDef(ei.ip)}));
      return true;
    }
    case &EnumVoidConstructed(vi enum_voidconstructed_info): {
      info var = expr_complete_info(x);
      if case &TeEnum(et te_enum) = &info->cu.~ {
        x_cell cell_num = rval_cell(x);
        cu cu_typeexpr;
        props type_properties;
        compute_prim(clq->cs, clq, enum_tag_type(clq->cs, &et), &cu, &props);
        tag_cell cell_num = add_cell(gr, {LocationVirtual(void), cu, props});
        field_offset u32 = enum_field_offset(clq->cs, &et, vi.constructor_tag);
        backtick_gn var = addx(gr, @[gr_op]GrWriteNothing({x_cell}));
        a_gn var = addx(gr, mk_shray(backtick_gn), @[gr_op]GrSubcell({tag_cell, x_cell, OffsetConst(enum_tag_offset)}));
        b_gn var = addx(gr, mk_shray(a_gn), @[gr_op]GrWriteConst({tag_cell, ConstInt(~vi.constructor_tag.~)}));
        tag_end u32 = enum_tag_offset + props.flat_size;
        postpadding_ogn opt[gr_num]
          = gr_bzero_subcell(clq, gr, x_cell, tag_end, info->cu_props.flat_size - tag_end);
        c_gn var = addx(gr, concat(@[opt[gr_num]]Has(b_gn), postpadding_ogn), @[gr_op]GrVirtualDead({tag_cell}));
        *out = c_gn;
        return true;
      } else {
        ice(_u8("EnumVoidConstructed on non-enum type"));
        return fake();
      }
    }
  }
}

func ellval_desc(x *is_lval) *lval_description {
  switch x {
    case &IsLvalYes(desc lval_description): { return &desc; }
    case &IsLvalNo(desc rval_description): {
      ice(_u8("lvalue_value_cell expects lvalue"));
      return fake();
    }
  }
}

func ellval_cell(x *is_lval) cell_num {
  return ellval_desc(x)->num;
}

func ellval_cell(a *ast_expr) cell_num {
  return ellval_desc(a)->num;
}

func ellval_desc(a *ast_expr) *lval_description {
  return ellval_desc(&expr_complete_info(a)->lval);
}

func rval_cell(x *ast_expr) cell_num {
  return rval_cell(&expr_complete_info(x)->lval);
}

func rval_cell(x *is_lval) cell_num {
  switch x {
    case &IsLvalNo(desc rval_description): {
      if desc.whole_num != desc.partial_num {
        ice(_u8("rval_cell on non-whole"));
      }
      return desc.whole_num;
    }
    case &IsLvalYes(desc lval_description): {
      ice(_u8("rval_cell sees lvalue"));
      return fake();
    }
  }
}

defenum dead_after_destroy {
  DeadAfterDestroyYes void;
  DeadAfterDestroyNo void;
};

func gr_after_actions(clq *clqueue, gr *frame_graph, prec gr_num, x *opt[destroy_action], out *gr_num) bool {
  if case &Has(da destroy_action) = x {
    dep gr_num;
    if !gr_destroy_action(clq, gr, &da, DeadAfterDestroyYes(void), &dep) {
      return false;
    }
    prec = seqq(gr, {prec, seq1(gr, dep)}).~;
  }
  *out = prec;
  return true;
}

func gr_chain_virtualdead(clq *clqueue, gr *frame_graph, prec gr_num, c cell_num, out *gr_num) bool {
  switch location(ref_cell(gr, c)) {
  case LocationVirtual(v void):
    *out = addx(gr, mk_shray(prec), @[gr_op]GrVirtualDead({c}));
  case LocationStatic(v void):
    *out = prec;
  }
  return true;
}

func gr_consume_actions(clq *clqueue, gr *frame_graph, prec gr_num, x *consume_actions, out *gr_num) bool {
  switch x {
  case &ConsumeByInPlace(v void): { }
  case &ConsumeByCopyDestroy(cd copy_destroy_action):
    dep gr_num;
    if !gr_copy_action(clq, gr, &cd.copy, &dep) {
      return false;
    }
    if !gr_chain_virtualdead(clq, gr, dep, cd.copy.src, &dep) {
      return false;
    }
    prec = seqq(gr, {prec, seq1(gr, dep)}).~;
    if !gr_destroy_action(clq, gr, &cd.destroy, DeadAfterDestroyYes(void), &dep) {
      return false;
    }
    prec = seqq(gr, {prec, seq1(gr, dep)}).~;
  case &ConsumeByCopy(cc tup[copy_action, lval_deadme]):
    dep gr_num;
    if !gr_copy_action(clq, gr, &cc.car, &dep) {
      return false;
    }
    if case DeadMe(v void) = cc.cdr {
      if !gr_chain_virtualdead(clq, gr, dep, cc.car.src, &dep) {
        return false;
      }
    }
    prec = seqq(gr, {prec, seq1(gr, dep)}).~;
  case &ConsumeByMove(m move_action):
    dep gr_num;
    if !gr_move_action(clq, gr, &m, &dep) {
      return false;
    }
    prec = seqq(gr, {prec, seq1(gr, dep)}).~;
  }
  *out = prec;
  return true;
}

func gr_copy_action(clq *clqueue, gr *frame_graph, x *copy_action, out *gr_num) bool {
  return gr_bi_action(clq, gr, &x->~, out);
}

func gr_move_action(clq *clqueue, gr *frame_graph, x *move_action, out *gr_num) bool {
  dep gr_num;
  if !gr_bi_action(clq, gr, &x->~, &dep) {
    return false;
  }
  *out = addx(gr, mk_shray(dep), @[gr_op]GrDead({x->src}));
  return true;
}

func gr_uni_fun(clq *clqueue, gr *frame_graph, ip instpair, arg cell_num) gr_num {
  argptr cu_typrop = computed_ptr_type(clq, &ref_cell(gr, arg)->type);
  voidret cu_typrop = compute_prim(clq, primitive_void_type(clq->cs));
  fnptr cu_typrop = compute_prim(clq, fn_type(clq->cs, argptr.cu.~, voidret.cu.~));
  funcell cell_num = add_cell(gr, {LocationStatic, fnptr.cu, fnptr.props});
  argptrcell cell_num = add_cell(gr, {LocationStatic, argptr.cu, argptr.props});
  retvoid cell_num = add_cell(gr, {LocationStatic, voidret.cu, voidret.props});

  fc gr_num = addx(gr, @[gr_op]GrWriteConst({funcell, ConstDef(ip)}));
  arp gr_num = addx(gr, @[gr_op]GrAddressof({argptrcell, arg}));
  ap gr_num = addx(gr, mk_shray(fc, arp), @[gr_op]GrApply({funcell, mk_shray(argptrcell), retvoid}));
  deadret gr_num = addx(gr, mk_shray(ap), @[gr_op]GrDead({retvoid}));
  return deadret;
}

func gr_init_action(clq *clqueue, gr *frame_graph, x *init_action, out *gr_num) bool {
  switch &x->ctor {
    case &TrivialCtor(v void): {
      dp var = addx(gr, @[gr_op]GrWriteConst({x->arg, ConstInt(~ @[u32] 0)}));
      *out = dp;
      return true;
    }
    case &FunCtor(ip instpair): {
      *out = gr_uni_fun(clq, gr, ip, x->arg);
      return true;
    }
  }
}

// TODO: The dead_after_destroy parameter here is definitely unnecessary, but not too harmful now.
func gr_destroy_action(clq *clqueue, gr *frame_graph, x *destroy_action, dad dead_after_destroy, out *gr_num) bool {
  switch &x->ctor {
    case &TrivialCtor(v void): {
      dp gr_num;
      if case DeadAfterDestroyYes(v2 void) = dad {
        dp = addx(gr, @[gr_op]GrDead({x->arg}));
      } else {
        dp = addx(gr, @[gr_op]GrXNop(void));
      }
      *out = dp;
      return true;
    }
    case &FunCtor(ip instpair): {
      gn gr_num = gr_uni_fun(clq, gr, ip, x->arg);
      dp gr_num;
      if case DeadAfterDestroyYes(v2 void) = dad {
        dp = addx(gr, mk_shray(gn), @[gr_op]GrDead({x->arg}));
      } else {
        dp = gn;
      }
      *out = dp;
      return true;
    }
  }
}

func gr_bi_fun(clq *clqueue, gr *frame_graph, ip instpair, dest cell_num, src cell_num) gr_num {
  // In our "bi_fun" uses the dest and src have the same type.  It seems wrong for this menial code to know that, though.
  destptr cu_typrop = computed_ptr_type(clq, &ref_cell(gr, dest)->type);
  srcptr cu_typrop = computed_ptr_type(clq, &ref_cell(gr, src)->type);
  voidret cu_typrop = compute_prim(clq, primitive_void_type(clq->cs));
  fnptr cu_typrop = compute_prim(clq, fn_type(clq->cs, destptr.cu.~, srcptr.cu.~, voidret.cu.~));
  funcell cell_num = add_cell(gr, {LocationStatic, fnptr.cu, fnptr.props});
  destptrcell cell_num = add_cell(gr, {LocationStatic, destptr.cu, destptr.props});
  srcptrcell cell_num = add_cell(gr, {LocationStatic, srcptr.cu, srcptr.props});
  retvoid cell_num = add_cell(gr, {LocationStatic, voidret.cu, voidret.props});

  fc gr_num = addx(gr, @[gr_op]GrWriteConst({funcell, ConstDef(ip)}));
  dp gr_num = addx(gr, @[gr_op]GrAddressof({destptrcell, dest}));
  sp gr_num = addx(gr, @[gr_op]GrAddressof({srcptrcell, src}));
  ap gr_num = addx(gr, mk_shray(fc, dp, sp), @[gr_op]GrApply({funcell, mk_shray(destptrcell, srcptrcell), retvoid}));
  deadret var = addx(gr, mk_shray(ap), @[gr_op]GrDead({retvoid}));
  return deadret;
}

func gr_bi_action(clq *clqueue, gr *frame_graph, x *bi_action, out *gr_num) bool {
  switch &x->ctor {
    case &TrivialCtor(v void): {
      cp var = addx(gr, @[gr_op]GrMemCopy({x->dest, x->src}));
      *out = cp;
      return true;
    }
    case &FunCtor(ip instpair): {
      *out = gr_bi_fun(clq, gr, ip, x->dest, x->src);
      return true;
    }
  }
}

// TODO: There's a lot of duplicated code in the splay-out of this function.
func gr_magic(cs *checkstate, clq *clqueue, mag *def_magic, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num], inline_out *should_inline) bool {
  switch mag {
  case &MagicBzero(mb magic_bzero):
    if !gr_magic_bzero(cs, clq, &mb, gr_out, gn_out, return_cell_out, arg_cells_out) {
      return false;
    }
    *inline_out = InlineMust(void);
    return true;
  case &MagicMemcopy(mm magic_memcopy):
    if !gr_magic_memcopy(cs, clq, &mm, gr_out, gn_out, return_cell_out, arg_cells_out) {
      return false;
    }
    *inline_out = InlineMust(void);
    return true;
  case &MagicNopdestroy(v void):
    if !gr_magic_nopdestroy(cs, clq, gr_out, gn_out, return_cell_out, arg_cells_out) {
      return false;
    }
    *inline_out = InlineMust(void);
    return true;
  case &MagicCtor(wmc which_magic_ctor):
    if !gr_magic_ctor(cs, clq, wmc.wc, &wmc.mc, gr_out, gn_out, return_cell_out, arg_cells_out) {
      return false;
    }
    *inline_out = InlineYawn(void);
    return true;
  case &MagicEnumConstruct(mec magic_enum_construct):
    arg_cell cell_num;
    if !gr_magic_enum_construct(cs, clq, &mec, gr_out, gn_out, return_cell_out, &arg_cell) {
      return false;
    }
    *arg_cells_out = mk_array(arg_cell);
    *inline_out = InlineMust(void);
    return true;
  }
}

deftype gr_minimal_basics struct {
  return_cell cell_num;
  argcells array[cell_num];
};

deftype gr_basics struct {
  minimal gr_minimal_basics;
  pointeecells array[cell_num];
  derefs shray[gr_num];
};

func add_minimal_basics(cs *checkstate, clq *clqueue, gr *frame_graph, size u32, arity size, out *gr_minimal_basics) void {
  pointee_tp cu_typrop = compute_prim(clq, primitive_padding_type(cs, size));
  argtp cu_typrop = compute_prim(clq, ptr_type(cs, pointee_tp.cu.~));
  voidtp cu_typrop = compute_prim(clq, primitive_void_type(cs));
  ret gr_minimal_basics;
  ret.return_cell = add_cell(gr, {LocationStatic(void), voidtp.cu, voidtp.props});
  for i size = 0; i < arity; i = i + 1 {
    ac cell_num = add_cell(gr, {LocationStatic(void), argtp.cu, argtp.props});
    push(&ret.argcells, ac);
  }
  *out = ret;
}

func add_basics(cs *checkstate, clq *clqueue, gr *frame_graph, size u32, arity size, out *gr_basics) void {
  ret gr_basics;
  add_minimal_basics(cs, clq, gr, size, arity, &ret.minimal);

  pointee_tp cu_typrop = compute_prim(clq, primitive_padding_type(cs, size));
  derefs array[gr_num];
  for i size = 0; i < arity; i = i + 1 {
    pc cell_num = add_cell(gr, {LocationVirtual(void), pointee_tp.cu, pointee_tp.props});
    push(&ret.pointeecells, pc);
    dn gr_num = addx(gr, @[gr_op]GrDeref({pc, get(&ret.minimal.argcells, i), OffsetConst(0)}));
    push(&derefs, dn);
  }
  ret.derefs = freeze(&derefs);
  *out = ret;
}

func minimal_basics_cleanup_precs(gr *frame_graph, bas *gr_minimal_basics, out *array[gr_num]) void {
  precs array[gr_num];
  ncells size = count(&bas->argcells);
  for i size = 0; i < ncells; i = i + 1 {
    gd gr_num = addx(gr, @[gr_op]GrDead({get(&bas->argcells, i)}));
    push(&precs, gd);
  }
  retset var = addx(gr, @[gr_op]GrWriteConst({bas->return_cell, ConstInt(bigu(0))}));
  push(&precs, retset);
  swap(out, &precs);
}

func minimal_basics_cleanup(cs *checkstate, clq *clqueue, gr *frame_graph, bas *gr_minimal_basics, gn gr_num, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num]) void {
  precs array[gr_num];
  minimal_basics_cleanup_precs(gr, bas, &precs);
  nopgn var = addx(gr, freeze(&precs), @[gr_op]GrXNop(void));
  fingn var = seqq(gr, {gn, seq1(gr, nopgn)});
  *gr_out = *gr;
  *gn_out = fingn.~;
  *return_cell_out = bas->return_cell;
  *arg_cells_out = bas->argcells;
}

func basics_cleanup(cs *checkstate, clq *clqueue, gr *frame_graph, bas *gr_basics, gn gr_num, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num]) void {
  precs array[gr_num];
  minimal_basics_cleanup_precs(gr, &bas->minimal, &precs);
  ncells size = count(&bas->pointeecells);
  for i size = 0; i < ncells; i = i + 1 {
    pd gr_num = addx(gr, @[gr_op]GrVirtualDead({get(&bas->pointeecells, i)}));
    push(&precs, pd);
  }
  nopgn var = addx(gr, freeze(&precs), @[gr_op]GrXNop(void));
  fingn var = seqq(gr, {gn, seq1(gr, nopgn)});
  *gr_out = *gr;
  *gn_out = fingn.~;
  *return_cell_out = bas->minimal.return_cell;
  *arg_cells_out = bas->minimal.argcells;
}

func gr_magic_nopdestroy(cs *checkstate, clq *clqueue, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num]) bool {
  gr frame_graph = init_frame_graph_empty(intern(cs->im, _s("magic_nopdestroy")));
  bas gr_minimal_basics;
  // TODO: How about make the size parameter opt[u32], don't deref if no size.
  add_minimal_basics(cs, clq, &gr, 0 /* Pass a made-up size. */, 1, &bas);
  gn gr_num = addx(&gr, @[gr_op]GrXNop(void));
  minimal_basics_cleanup(cs, clq, &gr, &bas, gn, gr_out, gn_out, return_cell_out, arg_cells_out);
  return true;
}

func gr_magic_memcopy(cs *checkstate, clq *clqueue, mm *magic_memcopy, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num]) bool {
  gr frame_graph = init_frame_graph_empty(intern(cs->im, _s("magic_memcopy")));
  bas gr_basics;
  add_basics(cs, clq, &gr, *unHas(&mm->size), 2, &bas);
  gn gr_num = addx(&gr, bas.derefs, @[gr_op]GrMemCopy({get(&bas.pointeecells, 0), get(&bas.pointeecells, 1)}));
  basics_cleanup(cs, clq, &gr, &bas, gn, gr_out, gn_out, return_cell_out, arg_cells_out);
  return true;
}

func gr_magic_bzero(cs *checkstate, clq *clqueue, mb *magic_bzero, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num]) bool {
  gr frame_graph = init_frame_graph_empty(intern(cs->im, _s("magic_bzero")));
  bas gr_basics;
  add_basics(cs, clq, &gr, *unHas(&mb->size), 1, &bas);
  gn gr_num = addx(&gr, bas.derefs, @[gr_op]GrWriteConst({get(&bas.pointeecells, 0), ConstInt(bigu(0))}));
  basics_cleanup(cs, clq, &gr, &bas, gn, gr_out, gn_out, return_cell_out, arg_cells_out);
  return true;
}

func gr_magic_ctor(cs *checkstate, clq *clqueue, wc which_ctor, mc *magic_ctor, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num]) bool {
  info *magic_ctor_info = ref_info(mc);
  switch info {
  case &MagicWholeFieldInfo(mwfi magic_whole_field_info):
    return gr_magic_whole_field_info(cs, clq, wc, &mwfi, gr_out, gn_out, return_cell_out, arg_cells_out);
  case &MagicStructInfo(msi magic_struct_info):
    return gr_magic_struct_info(cs, clq, wc, &msi, gr_out, gn_out, return_cell_out, arg_cells_out);
  case &MagicEnumInfo(mei magic_enum_info):
    return gr_magic_enum_info(cs, clq, wc, &mei, gr_out, gn_out, return_cell_out, arg_cells_out);
  case &MagicArraytypeInfo(mai magic_arraytype_info):
    return gr_magic_arraytype_info(cs, clq, wc, &mai, gr_out, gn_out, return_cell_out, arg_cells_out);
  }
}

func gr_magic_arraytype_info(cs *checkstate, clq *clqueue, wc which_ctor, mai *magic_arraytype_info, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num]) bool {
  gr frame_graph = init_frame_graph_empty(intern(cs->im, _s("magic_arraytype")));
  argtp cu_typrop = compute_prim(clq, ptr_type(cs, mai->cu_type.~));

  voidtp cu_typrop = compute_prim(clq, primitive_void_type(cs));

  param *te_typeexpr;
  arraycount u32;
  if case &TeArraytype(at te_arraytype) = &mai->cu_type.~ {
    param = oo(&at.param);
    if case Has(atcount u32) = at.count {
      arraycount = atcount;
    } else {
      ice(_u8("gr_magic_arraytype_info missing count"));
    }
  } else {
    ice(_u8("gr_magic_arraytype_info sees non-array type"));
  }

  param_props type_properties;
  if !compute_complete_type_properties(cs, clq, param, &param_props) {
    return false;
  }

  elemptrtype cu_typeexpr;
  elemptrtype_props type_properties;
  compute_prim(cs, clq, ptr_type(cs, *param), &elemptrtype, &elemptrtype_props);

  nargs size = num_args(wc);

  fntype cu_typeexpr;
  fntype_props type_properties;
  compute_prim(cs, clq, fn_type(cs, @[shray[_]]repeat(nargs, elemptrtype.~), voidtp.cu.~), &fntype, &fntype_props);

  size_type cu_typeexpr;
  size_type_props type_properties;
  compute_prim(cs, clq, primitive_size_type(clq->cs), &size_type, &size_type_props);

  argcells array[cell_num];
  pointeecells array[cell_num];
  derefgns array[gr_num];
  for i size = 0; i < nargs; i = i + 1 {
    ac cell_num = add_cell(&gr, {LocationStatic(void), argtp.cu, argtp.props});
    push(&argcells, ac);
    pc cell_num = add_cell(&gr, {LocationVirtual(void), mai->cu_type, mai->cu_props});
    push(&pointeecells, pc);

    gn1 gr_num = addx(&gr, @[gr_op]GrDeref({pc, ac, OffsetConst(0)}));
    gn gr_num = addx(&gr, mk_shray(gn1), @[gr_op]GrDead({ac}));
    push(&derefgns, gn);
  }

  derefgn gr_num = addx(&gr, freeze(&derefgns), @[gr_op]GrXNop(void));

  return_cell cell_num = add_cell(&gr, {LocationStatic(void), voidtp.cu, voidtp.props});

  indexcell cell_num = add_cell(&gr, {LocationStatic(void), size_type, size_type_props});

  deadprecs array[gr_num];
  if true {
    setret gr_num = addx(&gr, @[gr_op]GrWriteConst({return_cell, ConstInt(bigu(0))}));
    push(&deadprecs, setret);
    indexdead gr_num = addx(&gr, @[gr_op]GrDead({indexcell}));
    push(&deadprecs, indexdead);

    for i size = 0; i < nargs; i = i + 1 {
      pd gr_num = addx(&gr, @[gr_op]GrVirtualDead({get(&pointeecells, i)}));
      push(&deadprecs, pd);
    }
  }

  deadseq sq_num = seq1(&gr, addx(&gr, freeze(&deadprecs), @[gr_op]GrXNop(void)));

  topgn sq_num = nopq(&gr);

  elemptrcells array[cell_num];
  precs array[gr_num];
  for j size = 0; j < nargs; j = j + 1 {
    ec cell_num = add_cell(&gr, {LocationVirtual(void), ~ *param, param_props});
    indexcopycell cell_num = add_cell(&gr, {LocationStatic(void), size_type, size_type_props});
    copygn gr_num = addx(&gr, @[gr_op]GrMemCopy({indexcopycell, indexcell}));
    gn gr_num = addx(&gr, mk_shray(copygn), @[gr_op]GrSubcell({ec, get(&pointeecells, j), OffsetComputed({param_props.flat_size, indexcopycell})}));
    deadcopy gr_num = addx(&gr, mk_shray(gn), @[gr_op]GrDead({indexcopycell}));
    epc cell_num = add_cell(&gr, {LocationStatic(void), elemptrtype, elemptrtype_props});
    push(&elemptrcells, epc);
    ptrgn gr_num = addx(&gr, mk_shray(deadcopy), @[gr_op]GrAddressof({epc, ec}));
    ecdeadgn gr_num = addx(&gr, mk_shray(ptrgn), @[gr_op]GrVirtualDead({ec}));
    push(&precs, ecdeadgn);
  }

  elemretcell cell_num = add_cell(&gr, {LocationStatic(void), voidtp.cu, voidtp.props});
  func_cell cell_num = add_cell(&gr, {LocationStatic(void), fntype, fntype_props});

  func_gn gr_num = addx(&gr, @[gr_op]GrWriteConst({func_cell, ConstDef(mai->ip)}));
  push(&precs, func_gn);

  ap gr_num = addx(&gr, freeze(&precs), @[gr_op]GrApply({func_cell, freeze(&elemptrcells), elemretcell}));
  vd gr_num = addx(&gr, mk_shray(ap), @[gr_op]GrDead({elemretcell}));

  ic2cell cell_num = add_cell(&gr, {LocationStatic(void), size_type, size_type_props});
  ic2gn gr_num = addx(&gr, @[gr_op]GrMemCopy({ic2cell, indexcell}));
  onecell cell_num = add_cell(&gr, {LocationStatic(void), size_type, size_type_props});
  onegn gr_num = addx(&gr, @[gr_op]GrWriteConst({onecell, ConstInt(bigu(1))}));
  op_action primitive_numeric_op_action;
  if case CtorDestroy(v void) = wc {
    op_action = NumSub(void);
  } else {
    op_action = NumAdd(void);
  }
  incrgn gr_num = addx(&gr, mk_shray(ic2gn, onegn), @[gr_op]GrPrimApply({PrimNum({cs->plat.sizetraits.flat.size, cs->plat.sizetraits.numeric, op_action}), mk_shray(ic2cell, onecell), indexcell}));

  terminal_case u32;
  init_value u32;
  body_gn sq_num;
  if case CtorDestroy(v void) = wc {
    body_gn = seqq(&gr, {incrgn, seq1(&gr, vd)});
    init_value = arraycount;
    terminal_case = 0;
  } else {
    body_gn = seqq(&gr, {vd, seq1(&gr, incrgn)});
    init_value = 0;
    terminal_case = arraycount;
  }

  tie_gn sq_num = seqq(&gr, {body_gn.~, topgn});

  branch_gn sq_num = addq(&gr, @[gr_op]GrBranch({indexcell, mk_shray(cons(@[gr_const]ConstInt(bigu(terminal_case)), deadseq)), Has(tie_gn)}));

  mut_qnop_node(&gr, topgn, node0(@[gr_op]GrJmp({branch_gn})));

  init_indexcell_gn gr_num = addx(&gr, @[gr_op]GrWriteConst({indexcell, ConstInt(bigu(init_value))}));
  it_gn sq_num = seqq(&gr, {init_indexcell_gn, topgn});
  gn var = seqq(&gr, {derefgn, it_gn});
  *gr_out = gr;
  *gn_out = gn.~;
  *return_cell_out = return_cell;
  *arg_cells_out = argcells;
  return true;
}

func gr_magic_enum_info(cs *checkstate, clq *clqueue, wc which_ctor, mei *magic_enum_info, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num]) bool {
  init_padding bool = false;
  switch wc {
  case CtorInit(v void):
    ice(_u8("Magic CtorInit on enum type"));
  case CtorCopy(v void):
    init_padding = true;
  case CtorMove(v void):
    init_padding = true;
  case CtorDestroy(v void): { /* don't init padding. */ }
  }
  gr frame_graph = init_frame_graph_empty(intern(cs->im, _s("magic_enum_info")));
  argtp cu_typrop = compute_prim(clq, ptr_type(cs, mei->cu_type.~));

  voidtp cu_typrop = compute_prim(clq, primitive_void_type(clq->cs));

  et *te_enum;
  if case &TeEnum(t te_enum) = &mei->cu_type.~ {
    et = &t;
  } else {
    ice(_u8("gr_magic_enum_info called on non-enum"));
  }

  tagtype cu_typeexpr;
  tagtype_props type_properties;
  compute_prim(cs, clq, enum_tag_type(cs, et), &tagtype, &tagtype_props);

  argcells array[cell_num];
  pointeecells array[cell_num];
  tagcells array[cell_num];
  deref_gns array[gr_num];
  tagcell_gns array[gr_num];
  nargs size = num_args(wc);
  for i size = 0; i < nargs; i = i + 1 {
    ac cell_num = add_cell(&gr, {LocationStatic(void), argtp.cu, argtp.props});
    push(&argcells, ac);
    pc cell_num = add_cell(&gr, {LocationVirtual(void), mei->cu_type, mei->cu_props});
    push(&pointeecells, pc);
    tc cell_num = add_cell(&gr, {LocationVirtual(void), tagtype, tagtype_props});
    push(&tagcells, tc);

    derefgn1 gr_num = addx(&gr, @[gr_op]GrDeref({pc, ac, OffsetConst(0)}));
    derefgn gr_num = addx(&gr, mk_shray(derefgn1), @[gr_op]GrDead({ac}));
    push(&deref_gns, derefgn);
    tcgn gr_num = addx(&gr, mk_shray(derefgn), @[gr_op]GrSubcell({tc, pc, OffsetConst(enum_tag_offset)}));
    push(&tagcell_gns, tcgn);
  }

  deref_gn gr_num = addx(&gr, freeze(&tagcell_gns), @[gr_op]GrXNop(void));

  return_cell cell_num = add_cell(&gr, {LocationStatic(void), voidtp.cu, voidtp.props});
  deadprecs array[gr_num];
  if true {
    setret gr_num = addx(&gr, @[gr_op]GrWriteConst({return_cell, ConstInt(~ @[u32] 0)}));
    push(&deadprecs, setret);
    for i size = 0; i < nargs; i = i + 1 {
      pd gr_num = addx(&gr, @[gr_op]GrVirtualDead({get(&pointeecells, i)}));
      push(&deadprecs, pd);
      td gr_num = addx(&gr, @[gr_op]GrVirtualDead({get(&tagcells, i)}));
      push(&deadprecs, td);
    }
  }
  deadseq sq_num = seq1(&gr, addx(&gr, freeze(&deadprecs), @[gr_op]GrXNop(void)));

  cases_gn array[tup[gr_const, sq_num]];
  nconstructors size = count(&et->constructors);
  for i size = 0; i < nconstructors; i = i + 1 {
    tagval enum_tag_value = mk_enum_tag_value(i);

    fieldtype cu_typeexpr = ~ref(&et->constructors, i)->type;
    fieldtype_props type_properties;
    if !compute_type_properties(cs, clq, &fieldtype, &fieldtype_props) {
      return false;
    }

    field_offset u32 = enum_field_offset(cs, et, tagval);
    field_end u32 = field_offset + fieldtype_props.flat_size;
    tag_end u32 = enum_tag_offset + tagtype_props.flat_size;
    prepadding_ogn opt[gr_num]
      = gr_bzero_subcell(clq, &gr, get(&pointeecells, 0), tag_end, field_offset - tag_end);
    postpadding_ogn opt[gr_num]
      = gr_bzero_subcell(clq, &gr, get(&pointeecells, 0), field_end, mei->cu_props.flat_size - field_end);

    fieldcella array[cell_num];
    fieldcellgn array[gr_num];
    for j size = 0; j < nargs; j = j + 1 {
      fc cell_num = add_cell(&gr, {LocationVirtual(void), fieldtype, fieldtype_props});
      push(&fieldcella, fc);
      sn gr_num = addx(&gr, @[gr_op]GrSubcell({get(&fieldcella, j), get(&pointeecells, j), OffsetConst(field_offset)}));
      push(&fieldcellgn, sn);
    }

    last_ogn gr_num;
    if case &Has(ip instpair) = ref(&mei->cips, i) {
      fieldptrtype cu_typeexpr;
      fieldptrtype_props type_properties;
      compute_prim(cs, clq, ptr_type(cs, fieldtype.~), &fieldptrtype, &fieldptrtype_props);

      fieldptrcella array[cell_num];
      precs array[gr_num];
      for j size = 0; j < nargs; j = j + 1 {
        fpc cell_num = add_cell(&gr, {LocationStatic(void), fieldptrtype, fieldptrtype_props});
        push(&fieldptrcella, fpc);
        an1 gr_num = addx(&gr, mk_shray(get(&fieldcellgn, j)), @[gr_op]GrAddressof({fpc, get(&fieldcella, j)}));
        an gr_num = addx(&gr, mk_shray(an1), @[gr_op]GrVirtualDead({get(&fieldcella, j)}));
        push(&precs, an);
      }

      fieldretcell cell_num = add_cell(&gr, {LocationStatic(void), voidtp.cu, voidtp.props});

      fntype cu_typeexpr;
      fntype_props type_properties;
      compute_prim(cs, clq, fn_type(cs, @[shray[_]]repeat(nargs, fieldptrtype.~), voidtp.cu.~), &fntype, &fntype_props);

      func_cell cell_num = add_cell(&gr, {LocationStatic(void), fntype, fntype_props});
      func_gn gr_num = addx(&gr, @[gr_op]GrWriteConst({func_cell, ConstDef(ip)}));
      push(&precs, func_gn);

      ap gr_num = addx(&gr, freeze(&precs), @[gr_op]GrApply({func_cell, freeze(&fieldptrcella), fieldretcell}));
      vd gr_num = addx(&gr, mk_shray(ap), @[gr_op]GrDead({fieldretcell}));
      last_ogn = vd;
    } else {
      ogn opt[gr_num];
      switch wc {
      case CtorInit(v void):
        ice(_u8("CtorInit on enum type"));
      case CtorCopy(v void):
        cgn var = addx(&gr, freeze(&fieldcellgn), @[gr_op]GrMemCopy({get(&fieldcella, 0), get(&fieldcella, 1)}));
        ogn = Has(cgn);
      case CtorMove(v void):
        cgn var = addx(&gr, freeze(&fieldcellgn), @[gr_op]GrMemCopy({get(&fieldcella, 0), get(&fieldcella, 1)}));
        ogn = Has(cgn);
      case CtorDestroy(v void):
        ogn = None();
        // do nothing.
      }
      if case Has(gn gr_num) = ogn {
        dfcprecs array[gr_num];
        for j size = 0; j < nargs; j = j + 1 {
          dfc var = addx(&gr, @[gr_op]GrVirtualDead({get(&fieldcella, j)}));
          push(&dfcprecs, dfc);
        }
        dfcnop gr_num = addx(&gr, freeze(&dfcprecs), @[gr_op]GrXNop(void));
        last_ogn = seqq(&gr, {gn, seq1(&gr, dfcnop)}).~;
      } else {
        // The nodes that create fieldcella were never added to the graph, so we don't dead them.
        last_ogn = nopq(&gr).~;
      }
    }

    tagset_ogn opt[gr_num];
    switch wc {
    case CtorInit(v void):
      ice(_u8("CtorInit on wc type"));
    case CtorCopy(v void):
      tgn var = addx(&gr, @[gr_op]GrWriteConst({get(&tagcells, 0), ConstInt(~ tagval.~)}));
      tagset_ogn = Has(tgn);
    case CtorMove(v void):
      tgn var = addx(&gr, @[gr_op]GrWriteConst({get(&tagcells, 0), ConstInt(~ tagval.~)}));
      tagset_ogn = Has(tgn);
    case CtorDestroy(v void):
      tagset_ogn = None();
    }

    finalgn gr_num = addx(&gr, concat(tagset_ogn, prepadding_ogn, @[opt[gr_num]]Has(last_ogn), postpadding_ogn), @[gr_op]GrXNop(void));

    finalseqgn sq_num = seqq(&gr, {finalgn, deadseq});
    push(&cases_gn, cons(@[gr_const]ConstInt(~ tagval.~), finalseqgn));
  }

  if true {
    if case CtorDestroy(v void) = wc {
      push(&cases_gn, cons(@[gr_const]ConstInt(bigu(0)), deadseq));
    } else {
      ztgn gr_num = addx(&gr, @[gr_op]GrWriteConst({get(&pointeecells, 0), ConstInt(bigu(0))}));
      ztseq sq_num = seqq(&gr, {ztgn, deadseq});
      push(&cases_gn, cons(@[gr_const]ConstInt(bigu(0)), ztseq));
    }
  }

  br sq_num = addq(&gr, @[gr_op]GrBranch({get(&tagcells, nargs - 1), freeze(&cases_gn), None()}));
  sqr sq_num = seqq(&gr, {deref_gn, br});
  *gr_out = gr;
  *gn_out = sqr.~;
  *return_cell_out = return_cell;
  *arg_cells_out = argcells;
  return true;
}

func gr_magic_struct_info(cs *checkstate, clq *clqueue, wc which_ctor, msi *magic_struct_info, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num]) bool {
  // Destructors go in reverse order (which means we prepend them in the reverse of reverse order).
  reverse_order bool = false;
  // Init, copy, and move requires initializing intervening padding.
  init_padding bool = false;
  switch wc {
  case CtorInit(v void):
    init_padding = true;
  case CtorCopy(v void):
    init_padding = true;
  case CtorMove(v void):
    init_padding = true;
  case CtorDestroy(v void):
    reverse_order = true;
  }

  gr frame_graph = init_frame_graph_empty(intern(cs->im, _s("magic_struct_info")));
  argtp cu_typrop = compute_prim(clq, ptr_type(cs, msi->cu_type.~));

  voidtp cu_typrop = compute_prim(clq, primitive_void_type(clq->cs));

  st *te_struct;
  if case &TeStruct(t te_struct) = &msi->cu_type.~ {
    st = &t;
  } else {
    ice(_u8("gr_magic_struct_info called on non-struct"));
  }

  psd partial_struct_data;
  if !compute_partial_struct_data(cs, clq, &st->fields, None(), &psd) {
    return false;
  }

  argcells array[cell_num];
  pointeecells array[cell_num];
  derefgns array[gr_num];
  nargs size = num_args(wc);
  for i size = 0; i < nargs; i = i + 1 {
    ac cell_num = add_cell(&gr, {LocationStatic(void), argtp.cu, argtp.props});
    push(&argcells, ac);
    pc cell_num = add_cell(&gr, {LocationVirtual(void), msi->cu_type, msi->cu_props});
    push(&pointeecells, pc);

    gn1 gr_num = addx(&gr, @[gr_op]GrDeref({pc, ac, OffsetConst(0)}));
    gn gr_num = addx(&gr, mk_shray(gn1), @[gr_op]GrDead({ac}));
    push(&derefgns, gn);
  }

  derefgn gr_num = addx(&gr, freeze(&derefgns), @[gr_op]GrXNop(void));

  return_cell cell_num = add_cell(&gr, {LocationStatic(void), voidtp.cu, voidtp.props});

  deadprecs array[gr_num];
  if true {
    setret gr_num = addx(&gr, @[gr_op]GrWriteConst({return_cell, ConstInt(~ @[u32] 0)}));
    push(&deadprecs, setret);

    for i size = 0; i < nargs; i = i + 1 {
      pd gr_num = addx(&gr, @[gr_op]GrVirtualDead({get(&pointeecells, i)}));
      push(&deadprecs, pd);
    }
  }

  bn sq_num = seq1(&gr, addx(&gr, freeze(&deadprecs), @[gr_op]GrXNop(void)));

  nfields size = count(&msi->fips);
  check(nfields == count(&st->fields));
  for i2 size = 0; i2 < nfields; i2 = i2 + 1 {
    i size;
    if reverse_order {
      i = i2;
    } else {
      i = nfields - i2 - 1;
    }

    fieldcella array[cell_num];
    fieldcellgn array[gr_num];
    for j size = 0; j < nargs; j = j + 1 {
      fc cell_num = add_cell(&gr, {LocationVirtual(void), ~ ref(&st->fields, i)->type, ref(&psd.fields, i)->props});
      push(&fieldcella, fc);

      gn gr_num = addx(&gr, @[gr_op]GrSubcell({fc, get(&pointeecells, j), OffsetConst(ref(&psd.fields, i)->offset)}));
      push(&fieldcellgn, gn);
    }

    field_gn gr_num;
    if case Has(ip instpair) = get(&msi->fips, i) {
      fieldptrtype cu_typeexpr;
      fieldptrtype_props type_properties;
      compute_prim(cs, clq, ptr_type(cs, ref(&st->fields, i)->type), &fieldptrtype, &fieldptrtype_props);

      fieldptrcella array[cell_num];
      precs array[gr_num];
      for j size = 0; j < nargs; j = j + 1 {
        fpc cell_num = add_cell(&gr, {LocationStatic(void), fieldptrtype, fieldptrtype_props});
        push(&fieldptrcella, fpc);
        gn1 gr_num = addx(&gr, mk_shray(get(&fieldcellgn, j)), @[gr_op]GrAddressof({fpc, get(&fieldcella, j)}));
        gn gr_num = addx(&gr, mk_shray(gn1), @[gr_op]GrVirtualDead({get(&fieldcella, j)}));
        push(&precs, gn);
      }

      fieldretcell cell_num = add_cell(&gr, {LocationStatic(void), voidtp.cu, voidtp.props});

      fntype cu_typeexpr;
      fntype_props type_properties;
      compute_prim(cs, clq, fn_type(cs, @[shray[_]]repeat(nargs, fieldptrtype.~), voidtp.cu.~), &fntype, &fntype_props);

      func_cell cell_num = add_cell(&gr, {LocationStatic(void), fntype, fntype_props});

      func_gn gr_num = addx(&gr, @[gr_op]GrWriteConst({func_cell, ConstDef(ip)}));
      push(&precs, func_gn);

      ap gr_num = addx(&gr, freeze(&precs), @[gr_op]GrApply({func_cell, freeze(&fieldptrcella), fieldretcell}));

      vd gr_num = addx(&gr, mk_shray(ap), @[gr_op]GrDead({fieldretcell}));

      field_gn = vd;
    } else {
      ogn opt[gr_num];
      switch wc {
      case CtorInit(v void):
        // zero-initialize.
        gn1 var = addx(&gr, freeze(&fieldcellgn), @[gr_op]GrWriteConst({get(&fieldcella, 0), ConstInt(~ @[u32] 0)}));
        ogn = Has(gn1);
      case CtorCopy(v void):
        gn1 var = addx(&gr, freeze(&fieldcellgn), @[gr_op]GrMemCopy({get(&fieldcella, 0), get(&fieldcella, 1)}));
        ogn = Has(gn1);
      case CtorMove(v void):
        gn1 var = addx(&gr, freeze(&fieldcellgn), @[gr_op]GrMemCopy({get(&fieldcella, 0), get(&fieldcella, 1)}));
        ogn = Has(gn1);
      case CtorDestroy(v void):
        // do nothing.
        ogn = None();
      }

      if case Has(gn gr_num) = ogn {
        dfcprecs array[gr_num];
        for j size = 0; j < nargs; j = j + 1 {
          dfc var = addx(&gr, @[gr_op]GrVirtualDead({get(&fieldcella, j)}));
          push(&dfcprecs, dfc);
        }
        dfcnop gr_num = addx(&gr, freeze(&dfcprecs), @[gr_op]GrXNop(void));
        field_gn = seqq(&gr, {gn, seq1(&gr, dfcnop)}).~;
      } else {
        field_gn = addx(&gr, @[gr_op]GrXNop(void));
      }
    }

    field_and_padding_gn gr_num;
    if init_padding {
      padding_offset u32;
      padding_count u32;
      postpadding_offset_and_count(&psd, i, &padding_offset, &padding_count);
      if case Has(bzero_gn gr_num) = gr_bzero_subcell(clq, &gr, get(&pointeecells, 0), padding_offset, padding_count) {
        nop2_gn var = addx(&gr, mk_shray(bzero_gn, field_gn), @[gr_op]GrXNop(void));
        field_and_padding_gn = nop2_gn;
      } else {
        field_and_padding_gn = field_gn;
      }
    } else {
      field_and_padding_gn = field_gn;
    }

    bn = seqq(&gr, {field_and_padding_gn, bn});
  }

  gn var = seqq(&gr, {derefgn, bn});

  *gr_out = gr;
  *gn_out = gn.~;
  *return_cell_out = return_cell;
  *arg_cells_out = argcells;
  return true;
}

func gr_bzero_subcell(clq *clqueue, gr *frame_graph, c cell_num, offset u32, size u32) opt[gr_num] {
  if size == 0 {
    return None();
  }
  padtype cu_typrop = compute_prim(clq, primitive_padding_type(clq->cs, size));
  pad_cell cell_num = add_cell(gr, {LocationVirtual(void), padtype.cu, padtype.props});
  subcell_gn var = addx(gr, @[gr_op]GrSubcell({pad_cell, c, OffsetConst(offset)}));
  bzero_gn var = addx(gr, mk_shray(subcell_gn), @[gr_op]GrWriteConst({pad_cell, ConstInt(bigu(0))}));
  vd_gn var = addx(gr, mk_shray(bzero_gn), @[gr_op]GrVirtualDead({pad_cell}));
  return Has(vd_gn);
}

func postpadding_offset_and_count(psd *partial_struct_data, i size, offset_out *u32, count_out *u32) void {
  check(i < psd_index(psd));
  begin u32 = ref(&psd->fields, i)->offset + ref(&psd->fields, i)->props.flat_size;
  end u32;
  if i + 1 < psd_index(psd) {
    end = ref(&psd->fields, i + 1)->offset;
  } else {
    end = psd->offset;
  }
  *offset_out = begin;
  *count_out = end - begin;
}

func gr_magic_whole_field_info(cs *checkstate, clq *clqueue, wc which_ctor, mwfi *magic_whole_field_info, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num]) bool {
  gr frame_graph = init_frame_graph_empty(intern(cs->im, _s("magic_whole_field_info")));
  argtp cu_typrop = compute_prim(clq, ptr_type(cs, mwfi->cu_type.~));

  fieldptrtype cu_typeexpr;
  fieldptrtype_props type_properties;
  compute_prim(cs, clq, ptr_type(cs, mwfi->rhs_type.~), &fieldptrtype, &fieldptrtype_props);

  voidtp cu_typrop = compute_prim(clq, primitive_void_type(clq->cs));

  nargs size = num_args(wc);
  fntype cu_typeexpr;
  fntype_props type_properties;
  compute_prim(cs, clq, fn_type(cs, @[shray[_]]repeat(nargs, fieldptrtype.~), voidtp.cu.~), &fntype, &fntype_props);

  argcells array[cell_num];
  fieldptrcells array[cell_num];
  precs array[gr_num];
  for i size = 0; i < nargs; i = i + 1 {
    ac cell_num = add_cell(&gr, {LocationStatic(void), argtp.cu, argtp.props});
    push(&argcells, ac);
    pc cell_num = add_cell(&gr, {LocationVirtual(void), mwfi->cu_type, mwfi->cu_props});
    fc cell_num = add_cell(&gr, {LocationVirtual(void), mwfi->rhs_type, mwfi->rhs_props});
    fpc cell_num = add_cell(&gr, {LocationStatic(void), fieldptrtype, fieldptrtype_props});
    push(&fieldptrcells, fpc);

    pointee_gn1 var = addx(&gr, @[gr_op]GrDeref({pc, ac, OffsetConst(0)}));
    pointee_gn var = addx(&gr, mk_shray(pointee_gn1), @[gr_op]GrDead({ac}));
    fieldcell_gn1 var = addx(&gr, mk_shray(pointee_gn), @[gr_op]GrSubcell({fc, pc, OffsetConst(0)}));
    fieldcell_gn var = addx(&gr, mk_shray(fieldcell_gn1), @[gr_op]GrVirtualDead({pc}));
    fieldptr_gn1 var = addx(&gr, mk_shray(fieldcell_gn), @[gr_op]GrAddressof({fpc, fc}));
    fieldptr_gn var = addx(&gr, mk_shray(fieldptr_gn1), @[gr_op]GrVirtualDead({fc}));
    push(&precs, fieldptr_gn);
  }

  retcell cell_num = add_cell(&gr, {LocationStatic(void), voidtp.cu, voidtp.props});
  fncell cell_num = add_cell(&gr, {LocationStatic(void), fntype, fntype_props});
  fn_gn var = addx(&gr, @[gr_op]GrWriteConst({fncell, ConstDef(mwfi->ip)}));
  push(&precs, fn_gn);

  ap var = addx(&gr, freeze(&precs), @[gr_op]GrApply({fncell, freeze(&fieldptrcells), retcell}));

  *gr_out = gr;
  *gn_out = ap;
  // We sort of make this look like a "tail call," informally -- is that bad?
  *return_cell_out = retcell;
  *arg_cells_out = argcells;
  return true;
}

func gr_magic_enum_construct(cs *checkstate, clq *clqueue, mec *magic_enum_construct, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cell_out *cell_num) bool {
  gr frame_graph = init_frame_graph_empty(intern(cs->im, _s("magic_enum_construct")));
  retnum cell_num = add_cell(&gr, {LocationStatic(void), mec->enum_type, mec->enum_type_props});

  tagval enum_tag_value = mk_enum_tag_value(mec->constructor_index);

  argtype *te_typeexpr;
  field_offset u32;
  tag_end u32;
  tag_cell cell_num;
  if case &TeEnum(et te_enum) = &mec->enum_type.~ {
    argtype = &ref(&et.constructors, mec->constructor_index)->type;
    field_offset = enum_field_offset(cs, &et, tagval);
    cu cu_typeexpr;
    props type_properties;
    compute_prim(cs, clq, enum_tag_type(cs, &et), &cu, &props);
    tag_end = props.flat_size;
    tag_cell = add_cell(&gr, {LocationVirtual(void), cu, props});
  } else {
    ice(_u8("magic_enum_construct on non-enum type"));
  }

  prepadding_ogn opt[gr_num]
    = gr_bzero_subcell(clq, &gr, retnum, tag_end, field_offset - tag_end);
  field_end u32 = field_offset + mec->rhs_props.flat_size;
  postpadding_ogn opt[gr_num]
    = gr_bzero_subcell(clq, &gr, retnum, field_end, mec->enum_type_props.flat_size - field_end);

  argnum cell_num = add_cell(&gr, {LocationStatic(void), ~ *argtype, mec->rhs_props});
  retpart cell_num = add_cell(&gr, {LocationVirtual(void), ~ *argtype, mec->rhs_props});

  retpart_gn var = addx(&gr, @[gr_op]GrSubcell({retpart, retnum, OffsetConst(field_offset)}));

  ctor_gn gr_num;
  switch &mec->operational {
  case &EnumConstructMove(cd ctor_desc):
    bi_ctor_gn1 gr_num;
    if !gr_bi_ctor(cs, clq, &gr, argtype, retpart, argnum, &cd, &bi_ctor_gn1) {
      return false;
    }
    bi_ctor_gn gr_num = addx(&gr, mk_shray(bi_ctor_gn1), @[gr_op]GrVirtualDead({retpart}));
    ctor_gn = addx(&gr, mk_shray(bi_ctor_gn), @[gr_op]GrDead({argnum}));

  case &EnumConstructCopyDestroy(cdd copy_destroy_desc):
    cpgn1 gr_num;
    if !gr_bi_ctor(cs, clq, &gr, argtype, retpart, argnum, &cdd.copy_desc, &cpgn1) {
      return false;
    }
    cpgn gr_num = addx(&gr, mk_shray(cpgn1), @[gr_op]GrVirtualDead({retpart}));
    destgn gr_num;
    if !gr_destroy_ctor(cs, clq, &gr, argtype, argnum, &cdd.destroy_desc, &destgn) {
      return false;
    }
    ctor_gn = seqq(&gr, {cpgn, seq1(&gr, destgn)}).~;
  }

  assign_gn var = seqq(&gr, {retpart_gn, seq1(&gr, ctor_gn)});

  tagcell_gn var = addx(&gr, @[gr_op]GrSubcell({tag_cell, retnum, OffsetConst(enum_tag_offset)}));
  tag_gn1 var = addx(&gr, mk_shray(tagcell_gn), @[gr_op]GrWriteConst({tag_cell, ConstInt(~tagval.~)}));
  tag_gn var = addx(&gr, mk_shray(tag_gn1), @[gr_op]GrVirtualDead({tag_cell}));
  gn var = addx(&gr, concat(@[opt[gr_num]]Has(tag_gn), prepadding_ogn, @[opt[gr_num]]Has(assign_gn.~), postpadding_ogn), @[gr_op]GrXNop(void));
  *gr_out = gr;
  *gn_out = gn;
  *return_cell_out = retnum;
  *arg_cell_out = argnum;
  return true;
}

func gr_bi_ctor(cs *checkstate, clq *clqueue, gr *frame_graph, ty *te_typeexpr, destnum cell_num, srcnum cell_num, cd *ctor_desc, gn_out *gr_num) bool {
  switch cd {
  case &TrivialCtor(v void):
    *gn_out = addx(gr, @[gr_op]GrMemCopy({destnum, srcnum}));
  case &FunCtor(ip instpair):
    *gn_out = gr_bi_fun(clq, gr, ip, destnum, srcnum);
  }
  return true;
}

func gr_destroy_ctor(cs *checkstate, clq *clqueue, gr *frame_graph, ty *te_typeexpr, argnum cell_num, cd *ctor_desc, gn_out *gr_num) bool {
  switch cd {
  case &TrivialCtor(v void):
    dp var = addx(gr, @[gr_op]GrDead({argnum}));
    *gn_out = dp;
  case &FunCtor(ip instpair):
    gn gr_num = gr_uni_fun(clq, gr, ip, argnum);
    dp var = addx(gr, mk_shray(gn), @[gr_op]GrDead({argnum}));
    *gn_out = dp;
  }
  return true;
}

func add_prim_fn_body(cs *checkstate, clq *clqueue, informal_name sym, type *cu_typeexpr, op primitive_op) fn_body_id {
  gr frame_graph = init_frame_graph_empty(informal_name);
  typarams *shray[te_typeexpr];
  if !decompose_typeapp(&type->~, primitive_function_puretype(clq->cs), &typarams) {
    ice(_u8("add_prim_fn_body called with non-fn type"));
  }
  argcells array[cell_num];
  ntyparams size = count(typarams);
  nfn_params size = ntyparams - 1;
  for i size = 0; i < nfn_params; i = i + 1 {
    ty *te_typeexpr = ref(typarams, i);
    props type_properties;
    if !compute_complete_type_properties(cs, clq, ty, &props) {
      ice(_u8("add_prim_fn_body typrops"));
    }
    c cell_num = add_cell(&gr, {LocationStatic(void), ~ *ty, props});
    push(&argcells, c);
  }
  retty *te_typeexpr = ref(typarams, ntyparams - 1);
  retprops type_properties;
  if !compute_complete_type_properties(cs, clq, retty, &retprops) {
    ice(_u8("add_prim_fn_body retprops"));
  }
  retcell cell_num = add_cell(&gr, {LocationStatic(void), ~ *retty, retprops});

  argcells_copy array[cell_num] = argcells;
  argshray shray[cell_num] = freeze(&argcells_copy);
  gn gr_num = addx(&gr, @[gr_op]GrPrimApply({op, argshray, retcell}));
  return add_fn_body(cs, {informal_name, NotComputed@[sti](), NotComputed@[u32](), @[fn_body_entry_enum]GraphedFnBody({FnBodyPrim(op), {gr, gn, retcell}, argcells, InlineMust(void)})});
}

func ensure_def_inst_graphed(cs *checkstate, clq *clqueue, ent_id def_entry_id, inst_id def_inst_id) bool {
  if !ensure_def_inst_checked(cs, clq, ent_id, inst_id) {
    return false;
  }

  ent *def_entry = ref_def_entry(cs, ent_id);
  inst *def_inst = ref_inst(cs, inst_id);
  switch &inst->graph {
    case &NotComputed(v0 void): {
      inst->graph = BeganComputing();
      switch &inst->rhs {
        case &InstRhsPrim(op primitive_op): {
          id fn_body_id = add_prim_fn_body(cs, clq, ent->def_name, &inst->computed_type, op);
          frg frame_regraphed = mk_const_frame_regraphed(ent->def_name, &inst->computed_type, &inst->computed_type_properties, ConstFnBody(id));
          inst->graph = Computed(Has(frg));
          return true;
        }
        case &InstRhsExtern(v void): {
          // TODO: What if an extern def isn't a function?
          id fn_body_id = add_fn_body(cs, {ent->def_name, NotComputed@[sti](), NotComputed@[u32](), @[fn_body_entry_enum]ExternFnBody({ent->def_name})});
          frg frame_regraphed = mk_const_frame_regraphed(ent->def_name, &inst->computed_type, &inst->computed_type_properties, ConstFnBody(id));
          inst->graph = Computed(Has(frg));
          return true;
        }
        case &InstRhsExpr(dire def_inst_rhs_expr): {
          info *frame_info;
          if case &Has(finfo) = &dire.frame_info {
            info = &finfo;
          } else {
            ice(_u8("ensure_def_inst_graphed missing 'dire' info"));
          }
          gr frame_graph = init_frame_graph_from_cells(ent->def_name, info->cells);
          gn gr_num;
          if !gr_expr_consume(clq, &gr, &dire.ec, &gn) {
            inst->graph = FailedComputation();
            return false;
          }
          inst->graph = Computed(Has(@[frame_regraphed]{gr, gn, result_cell(&dire.ec)}));
          return true;
        }

        case &InstRhsNonMagic(nonmag def_non_magic): {
          switch &nonmag {
          case &NonMagicCtor(wnmc which_non_magic_ctor):
            info *non_magic_ctor_info = unHas(&wnmc.nmc.info);
            frg frame_regraphed = mk_const_frame_regraphed(ent->def_name, &inst->computed_type, &inst->computed_type_properties, ConstDef(info->ip));
            inst->graph = Computed(Has(frg));
            return true;
          case &NonMagicProp(nmp non_magic_prop):
            info u32 = *unHas(&nmp.info);
            frg frame_regraphed = mk_const_frame_regraphed(ent->def_name, &inst->computed_type, &inst->computed_type_properties, @[gr_const]ConstInt(~info));
            inst->graph = Computed(Has(frg));
            return true;
          }
        }

        case &InstRhsMagic(mag def_magic): {
          id fn_body_id;
          if true {
            body_gr frame_graph;
            body_gn gr_num;
            return_cell cell_num;
            arg_cells array[cell_num];
            inline should_inline;
            if !gr_magic(cs, clq, &mag, &body_gr, &body_gn, &return_cell, &arg_cells, &inline) {
              return false;
            }
            id = add_fn_body(cs, {ent->def_name, NotComputed@[sti](), NotComputed@[u32](), @[fn_body_entry_enum]GraphedFnBody({FnBodyMagic(&mag), {body_gr, body_gn, return_cell}, arg_cells, inline})});
          }

          frg frame_regraphed = mk_const_frame_regraphed(ent->def_name, &inst->computed_type, &inst->computed_type_properties, ConstFnBody(id));
          inst->graph = Computed(Has(frg));
          return true;
        }
      }
    }
    case &BeganComputing(v void): {
      ice(_u8("ensure_def_inst_graphed recursively computing"));
      return fake();
    }
    case &FailedComputation(v void): {
      ERR(_u8("ensure_def_inst_graphed fails again on same def"));
      return false;
    }
    case &Computed(odr opt[frame_regraphed]): {
      return true;
    }
  }
}

func mk_const_frame_regraphed(informal_name sym, type *cu_typeexpr, props *type_properties, c gr_const) frame_regraphed {
  gr frame_graph = init_frame_graph_empty(informal_name);
  cell cell_num = add_cell(&gr, {LocationStatic(void), *type, *props});
  gn gr_num = addx(&gr, @[gr_op]GrWriteConst({cell, c}));
  return {gr, gn, cell};
}
