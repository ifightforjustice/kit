import hash;
import string;
import stdlib;

deftype sym size;

func to_u8str(v sym) array[u8] {
  return as_hex(v.~);
}

def `~` fn[size, sym] = wrapconvert;

func `==`(x sym, y sym) bool {
  return x.~ == y.~;
}
func `!=`(x sym, y sym) bool {
  return x.~ != y.~;
}

func hash_compute_hash(x *sym) osize {
  return ~x->~;
}

func hash_equal(x *sym, y *sym) bool {
  return *x == *y;
}

defclass[T] copy symmap struct {
  // A map from T's to ident values.
  table hash[T, sym];
  // A map from ident values to T's.
  backmap array[T];
};

access symmap[_] {
  func[T] do_init(im *symmap[T]) void {
    init(&im->table);
    init(&im->backmap);
  }

  func[T] intern(im *symmap[T], s T) sym {
    val size = count(&im->backmap);
    if try_insert(&im->table, s, ~val) {
      push(&im->backmap, s);
      return ~val;
    } else {
      switch lookup(&im->table, s) {
        case Has(value): {
          return value;
        }
      }
    }
  }

  func[T] is_interned(im *symmap[T], s T) opt[sym] {
    return lookup(&im->table, s);
  }

  func[T] lookup(im *symmap[T], ident sym) T {
    return get(&im->backmap, ident.~);
  }
}

deftype identmap symmap[string];

func intern(im *identmap, s string) sym {
  return intern(&im->~, s);
}

func is_interned(im *identmap, s string) opt[sym] {
  return is_interned(&im->~, s);
}

func lookup(im *identmap, ident sym) string {
  return lookup(&im->~, ident);
}
