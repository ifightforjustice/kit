import state;

// TODO: Should the primitive types returned here include their deftype_inst info?

func primitive_bool_type(cs *checkstate) te_typeexpr {
  return TeName({cs->cym.boolsym, None()});
}

func primitive_void_type(cs *checkstate) te_typeexpr {
  return TeName({cs->cym.voidsym, None()});
}

func primitive_u8_type(cs *checkstate) te_typeexpr {
  return TeName({cs->cym.u8sym, None()});
}

func primitive_i32_type(cs *checkstate) te_typeexpr {
  return TeName({cs->cym.i32sym, None()});
}

func primitive_size_type(cs *checkstate) te_typeexpr {
  return TeName({cs->cym.sizesym, None()});
}

func primitive_string_literal_type(cs *checkstate, n size) te_typeexpr {
  return TeArraytype({Has(~n), embox(primitive_u8_type(cs))});
}

func primitive_function_puretype(cs *checkstate) te_puretype {
  return TePureName(cs->cym.fnsym);
}

func primitive_pointer_puretype(cs *checkstate) te_puretype {
  return TePureName(cs->cym.ptrtype_sym);
}

func pointer_to(cs *checkstate, t te_typeexpr) te_typeexpr {
  params array[te_typeexpr];
  push(&params, t);
  return TeApp({embox(primitive_pointer_puretype(cs)), params, None()});
}

func add_primitives(cs *checkstate) void {
  add_simple_primitive(cs, cs->cym.boolsym, cs->platform.boolsize, cs->platform.boolalign);
  add_simple_primitive(cs, cs->cym.i32sym, cs->platform.u32size, cs->platform.u32align);
  add_simple_primitive(cs, cs->cym.u32sym, cs->platform.u32size, cs->platform.u32align);
}

func is_numeric_type(cs *checkstate, pt *te_typeexpr, out *numeric_type_properties) bool {
  // TODO: This implementation is completely bogus.
  if case &TeName(a te_name) = pt {
    if a.value == cs->cym.i32sym {
      m bigint = ~ @[u32]0x7FFFFFFF;
      *out = {-(m + ~ @[u32]1), m};
      return true;
    } else if a.value == cs->cym.u32sym {
      m bigint = ~ @[u32]0xFFFFFFFF;
      *out = {~ @[u32]0, m};
      return true;
    } else {
      return false;
    }
  }
  return false;
}

func add_simple_primitive(cs *checkstate, name sym, flat_size u32, flat_alignment u32) void {
  inst_id deftype_inst_id
      = add_deftype_inst(cs, {NoParms(void),
                              FinishedChecking(void),
                              Has({None(),
                                   @[type_properties]{
                                   flat_size,
                                   flat_alignment,
                                   DerivedMethodTrivial(void),
                                   DerivedMethodTrivial(void),
                                   DerivedMethodTrivial(void),
                                   DerivedMethodTrivial(void)}})});
  insts array[deftype_inst_id];
  push(&insts, inst_id);
  // TODO: access_scope is not relevant to a primitive def.
  access_scope array[access_entry_id];
  ent deftype_entry = {cs->cym.primitive_module_sym, name, access_scope, NoGenerics(void), None(), insts};
  id deftype_entry_id = add_deftype_entry(cs, ent);
  // TODO: We probably want to put the id in some kind of "primitive" module.
}

