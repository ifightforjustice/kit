        Kit v0.00.2C.x

Current status:  "This is a test!  Ignore!!!"

Definitions:
   s1: A compiler, written in C.  It can compile s3.  Located in trc/.
   s2: A compiler, written in proto-Kit-v0.00.2A.x.  It can
       compile itself and s3.  Located in urc/.
   s3: A compiler, written in proto-Kit-v0.00.2B.x.  It can
       compile s4.  (Maybe it can't compile itself.)  Located in vrc/.
   s4: A compiler, to be written in proto-Kit-v0.00.2C.x.  

   s2-by-s1: s2, as compiled by s1.
   s2-self: s2, as compiled by s2.
   sX-by-sY: (for any X and Y) sX, as compiled by sY.
   sX-self: (for any X) sX, as compiled by sX.

  BUILD INSTRUCTIONS

# Prerequisites: An x86 CPU.  Windows or Linux.  On Windows, MSVC
# 2013 or 2015 (something with basic C99 support) -- for example,
# run these commands from a "Developer Command Prompt for VS2015".
# On Linux, gcc with 32-bit support, which usually means some
# gcc-multilib package.  Maybe clang works too.

# Step 1. Build s1 -- creates executable "out.exe" (or "out")
   windows_build.bat  (or ./linux_build.sh)
# Step 2. Build s2 -- creates executable "s2.exe" (or "s2")
   windows_build_s2.bat  (or ./linux_build_s2.sh)
# Step 3. Build s3
   windows_build_s3.bat
# Step 4. Build s4
   windows_build_s4.bat
# Step 5. Run parsing/typechecking+codegen tests.
   s4 --build  (or ./s4 --build)
# Step 6. If you wish, run s4-self on itself
   cd src
   move main.obj old_main.obj
   ..\s4 main
   sha1sum old_main.obj main.obj
# The sha1sums should match.

  DIRECTORY STRUCTURE

The current directory structure is:

   trc - s1, implemented in C.  Compiles s2.
   urc - s2, implemented in proto-Kit.  Compiles s2 and s3.
   vrc - s3, implemented in proto-Kit.  Compiles s4 (and s3?).
   src - s4, implemented in proto-Kit.  Compiles itself?
   examples - examples to run, disorganized junk

  COMMAND USAGE

"out" is the name of the s1 executable, "s3" is the name of the s3 executable, and "s4" is the name of the s4 executable.

   out --test    # runs tests.
   out <modulename>    # builds <modulename>.ki and its imports.
   s2    # runs parsing/typechecking tests without codegen.
   s2 --build    # runs parsing/typechecking tests with codegen.
   s2 <modulename>  # builds <modulename>.ki and its imports.
   s3 ...    # same as s2.
   s4 ...    # same as s3.

  PROJECT TIMELINE

Here's the project timeline:

   1. Parsing.  (DONE)
   2. Typechecking/name-resolving.  (DONE)
   3. Generate code, i.e. have a working compiler.  (DONE)
   4. Cleanup error messages to have useful source information. (BETTER)
   5. Cleanup the language to make it more usable. (GOOD ENOUGH)
      Wishlist (waiting for these features specifically needed):
       A. Structure / array initialization syntax. (DONE)
       B. Packed struct types.  (DON'T CARE for now -- use le_u32)
       C. Destructuring assignment.
       D. Incr/decr and "+="-type operators. (DONE in s2 but user-defined)
   6. Linux support. (DONE)
   7. Make a self-hosted implementation (adding improvements and
      fixes to the C implementation when useful). (DONE)
   8. Give the self-hosted implementation "respectable" codegen.
   9. Basic cleanup of the language.
      Wishlist:
       A. defstruct, no more naked structs.  (DONE)
       B. type aliases.
       C. a non-truncative conversion operator (prefix +).  (DONE)
       D. negative integer literals.
       E. var keyword after variable.  (DONE)
       F. o8, o16, o32.  (DONE in s2)
       G. u64, i64, o64.
       H. a signed size type ("diff").  (DONE in s2)
       I. negation for o-verflow types.  (DONE in s2)
       J. smart move/allocate-in-the-spot semantics.
       K. scoped types or scoped vars.
       L. better syntax for defining copy/init/move/destroy.
       M. defer statements (or scoped statements).
       N. handlers for overflow errors.
       O. enum types with "default" values instead of zero-tag.
       P. cute enum syntax for voids.  (DONE)
       Q. better type-checking, see-through-negation.
       R. explicit overloading/specialization.
       S. support for multiple calling conventions.
       T. cross-function goto statements of the IInd kind.
       U. capturing closures.
       V. actual modules/namespaces.
       W. pretentious quotes in the binaries.
       X. removal of pretentious quotes in the binaries.
       Y. field names in struct literals.
       Z. array literals (struct literals in an array place).  (DONE)

  ABOUT THE VERSIONS

s1's language, v0.00.2A.x, is merely "C, with templates,
constructors and destructors, elementary encapsulation, tagged enum
types, no implicit conversions."  s2's, v0.00.2B.x, is very similar
to s1's, but with some basic convenience enhancements that should
be easy to backport to s1 -- the differences are described in
FEATURES.  s3 defines a language with ever-more-advanced features.
s4 uses (or will use) those features.

Right now, s1 can compile s2, and it can almost compile s3.  In the
long run, as soon as s4 is the actively developed version, s2 will
go away.
