import state;

deftype exprscope struct {
  cs *checkstate;
  // Same as cs->im.
  im *identmap;
  // Generics and their _complete_ replacements.
  generics *array[ast_ident];
  generic_replacements *array[te_typeexpr];
};

defenum allow_incomplete {
  AllowIncompleteNo void;
  AllowIncompleteYes void;
};

func check_expr(cs *checkstate, g *ast_generics, parms *genparms, x *ast_expr, pt *te_typeexpr) bool {
  empty_generics array[ast_ident];
  g_ptr *array[ast_ident];
  switch g {
    case &NoGenerics(v void): {
      g_ptr = &empty_generics;
    }
    case &HasGenerics(a array[ast_ident]): {
      g_ptr = &a;
    }
  }
  empty_parms array[te_typeexpr];
  p_ptr *array[te_typeexpr];
  switch parms {
    case &NoParms(v void): {
      p_ptr = &empty_parms;
    }
    case &HasParms(a array[te_typeexpr]): {
      p_ptr = &a;
    }
  }
  es exprscope = {cs, cs->im, g_ptr, p_ptr};
  return check_expr_ai(&es, AllowIncompleteNo(void), x, pt);
}

deftype global_info struct {
  ent def_entry_id;
  inst def_inst_id;
};

defenum name_info {
  Local void;
  Global global_info;
};

deftype es_match_res struct {
  NoMatch void;
  AmbigGlobalMatch void;
  OneGlobalMatch global_info;
  OneLocalMatch void;
};

func check_expr_ai(es *exprscope, ai allow_incomplete, x *ast_expr, pt *te_typeexpr) bool {
  switch &x->u {
    case &NameExpr(a ast_name_expr): {
      return TODO();
    }
    case &ParenExpr(a ast_paren_expr): {
      return TODO();
    }
    case &NumericLiteral(a ast_numeric_literal): {
      return TODO();
    }
    case &BoolLiteral(a ast_bool_literal): {
      return TODO();
    }
    case &VoidLiteral(a ast_void_literal): {
      return TODO();
    }
    case &NullLiteral(a ast_null_literal): {
      return TODO();
    }
    case &CharLiteral(a ast_char_literal): {
      return TODO();
    }
    case &StringLiteral(a ast_string_literal): {
      return TODO();
    }
    case &Funcall(a ast_funcall): {
      return TODO();
    }
    case &IndexExpr(a ast_index_expr): {
      return TODO();
    }
    case &Lambda(a ast_lambda): {
      return TODO();
    }
    case &LocalField(a ast_local_field): {
      return TODO();
    }
    case &DerefField(a ast_deref_field): {
      return TODO();
    }
    case &TypedExpr(a ast_typed_expr): {
      return TODO();
    }
    case &Strinit(a ast_strinit): {
      return TODO();
    }
  }
}
