import ast;
import box;
import deferred;
import identmap;
import kitutil;
import magic;
import shp;
import typeexpr;
import u8ast;

deftype numeric_traits struct {
  signed bool;
  minval bigint;
  maxval bigint;
};

deftype flat_traits struct {
  size u32;
  alignment u32;
};

deftype integral_traits struct {
  flat flat_traits;
  numeric numeric_traits;
};

def enum_tag_offset u32 = 0;
def enum_tag_min u32 = 1;

deftype platform_info struct {
  // How many bits are in a byte (not necessarily octet)?
  bnno_size u32;
  enum_tag_size u32;

  voidtraits flat_traits;
  booltraits flat_traits;
  i8traits integral_traits;
  u8traits integral_traits;
  i16traits integral_traits;
  u16traits integral_traits;
  i32traits integral_traits;
  u32traits integral_traits;
  sizetraits integral_traits;
  osizetraits integral_traits;
  ptrtraits flat_traits;
  fntraits flat_traits;
};

deftype cs_primitives struct {
  ptr_eq opt[def_entry_id];
};

deftype checkstate struct {
  im *identmap;
  instantiation_depth u32;
  platform platform_info;
  loader_ctx *void;
  loader fn[*checkstate, sym, opt[array[u8]]];

  modules array[shp[module]];
  modules_by_name hash[sym, module_id];

  instantiations array[shp[def_inst]];
  type_instantiations array[shp[deftype_inst]];

  deftypes array[shp[deftype_entry]];
  deftypes_by_name hash[sym, array[deftype_entry_id]];

  defs array[shp[def_entry]];
  defs_by_name hash[sym, array[def_entry_id]];

  fn_bodies array[shp[fn_body_entry]];

  access_blocks array[shp[access_entry]];

  prims cs_primitives;
};

func make_checkstate(im *identmap, platform platform_info, loader_ctx *void, loader fn[*checkstate, sym, opt[array[u8]]]) checkstate {
  ret checkstate;
  ret.im = im;
  ret.instantiation_depth = 0;
  ret.platform = platform;
  ret.loader_ctx = loader_ctx;
  ret.loader = loader;
  return ret;
}

// An index into checkstate's modules array.
deftype module_id size;
def `~` fn[size, module_id] = wrapconvert;

// An index into checkstate's instantiations array.
deftype def_inst_id size;
def `~` fn[size, def_inst_id] = wrapconvert;

// An index into checkstate's type_instantiations array.
deftype deftype_inst_id size;
def `~` fn[size, deftype_inst_id] = wrapconvert;
def `==` fn[deftype_inst_id, deftype_inst_id, bool] = wrapequate;

// An index into checkstate's defs array.
deftype def_entry_id size;
def `~` fn[size, def_entry_id] = wrapconvert;

// An index into checkstate's deftypes array.
deftype deftype_entry_id size;
def `~` fn[size, deftype_entry_id] = wrapconvert;
def `==` fn[deftype_entry_id, deftype_entry_id, bool] = wrapequate;

// An index into checkstate's fn_bodies array.
deftype fn_body_id size;
def `~` fn[size, fn_body_id] = wrapconvert;
def `==` fn[fn_body_id, fn_body_id, bool] = wrapequate;

// An index into checkstate's access_blocks array.
deftype access_entry_id size;
def `~` fn[size, access_entry_id] = wrapconvert;

func ref_module(cs *checkstate, id module_id) *module {
  return oo(ref(&cs->modules, id.~));
}

func ref_def_entry(cs *checkstate, id def_entry_id) *def_entry {
  return oo(ref(&cs->defs, id.~));
}

func ref_deftype_entry(cs *checkstate, id deftype_entry_id) *deftype_entry {
  return oo(ref(&cs->deftypes, id.~));
}

func ref_fn_body(cs *checkstate, id fn_body_id) *fn_body_entry {
  return oo(ref(&cs->fn_bodies, id.~));
}

func ref_access_entry(cs *checkstate, id access_entry_id) *access_entry {
  return oo(ref(&cs->access_blocks, id.~));
}

func ref_inst(cs *checkstate, id def_inst_id) *def_inst {
  return oo(ref(&cs->instantiations, id.~));
}

func ref_deftype_inst(cs *checkstate, id deftype_inst_id) *deftype_inst {
  return oo(ref(&cs->type_instantiations, id.~));
}

func add_def_entry(cs *checkstate, ent def_entry) def_entry_id {
  shent shp[def_entry] = emshp(ent);
  id def_entry_id = ~count(&cs->defs);
  push(&cs->defs, shent);
  arr *array[def_entry_id] = try_insert_lookup(&cs->defs_by_name, oo(&shent)->def_name, default());
  push(arr, id);
  return id;
}

func add_deftype_entry(cs *checkstate, ent deftype_entry) deftype_entry_id {
  shent shp[deftype_entry] = emshp(ent);
  id deftype_entry_id = ~count(&cs->deftypes);
  push(&cs->deftypes, shent);
  arr *array[deftype_entry_id] = try_insert_lookup(&cs->deftypes_by_name, oo(&shent)->name, default());
  push(arr, id);
  return id;
}

func add_access_entry(cs *checkstate, ent access_entry) access_entry_id {
  shent shp[access_entry] = emshp(ent);
  id access_entry_id = ~count(&cs->access_blocks);
  push(&cs->access_blocks, shent);
  return id;
}

func add_inst(cs *checkstate, val def_inst) def_inst_id {
  id def_inst_id = ~count(&cs->instantiations);
  push(&cs->instantiations, emshp(val));
  return id;
}

func add_deftype_inst(cs *checkstate, val deftype_inst) deftype_inst_id {
  id deftype_inst_id = ~count(&cs->type_instantiations);
  push(&cs->type_instantiations, emshp(val));
  return id;
}

func add_fn_body(cs *checkstate, ent fn_body_entry) fn_body_id {
  id fn_body_id = ~count(&cs->fn_bodies);
  push(&cs->fn_bodies, emshp(ent));
  return id;
}

defenum module_process_state {
  Unprocessed void;
  Processing void;
  DoneProcessing void;
};

func `==`(a module_process_state, b module_process_state) bool {
  return enumnum(&a) == enumnum(&b);
}

deftype module struct {
  module_name sym;
  file ast_file;
  buf array[u8];
  process_state module_process_state;
  // vvv  Valid when process_state == DoneProcessing.  vvv
  defs array[def_entry_id];
  deftypes array[deftype_entry_id];
  access_blocks array[access_entry_id];
};

// Describes the behavior of init/copy/move/destroy methods.
defenum derived_method_behavior {
  // Behavior would be explicitly defined by a method, but it doesn't exist -- behavior is not allowed.
  DerivedMethodAbsent void;
  // Behavior's explicitly defined by a method.
  DerivedMethodExplicit instpair;
  // Behavior's derived structurally, and one of its fields/constructors has an explicit method call.  Maybe the method doesn't exist, because one of its fields' doesn't.
  DerivedMethodNontrivial instpair;
  // Behavior's derived from the type definition (or it's primitive) and it's trivial. init: Fills with zero.  copy/move: memcpy.  destroy: no-op.
  DerivedMethodTrivial void;
};

func isTrivial(behav derived_method_behavior) bool {
  if case DerivedMethodTrivial(v void) = behav {
    return true;
  }
  return false;
}

deftype type_properties struct {
  flat_size u32;
  flat_alignment u32;
  init_behavior derived_method_behavior;
  move_behavior derived_method_behavior;
  copy_behavior derived_method_behavior;
  destroy_behavior derived_method_behavior;
};

func type_from_inst(cs *checkstate, ent_id deftype_entry_id, inst_id deftype_inst_id) cu_typeexpr {
  name sym = ref_deftype_entry(cs, ent_id)->name;
  switch &ref_deftype_inst(cs, inst_id)->parms {
    case &NoParms(v void): {
      return ~TeName({name, Has({ent_id, inst_id})});
    }
    case &HasParms(a array[cu_typeexpr]): {
      converted array[te_typeexpr];
      n size = count(&a);
      for i size = 0; i < n; i = i + 1 {
        push(&converted, ref(&a, i)->~);
      }
      return ~TeApp({embox(TePureName(name)), converted, Has({ent_id, inst_id})});
    }
  }
}

// True if the type is trivial enough to be used in a def.  In other words, it has trivial copy/move/destroy constructors, but initialization could be non-trivial.  (It could default-initialize to a nonzero value.)
func is_defwise_trivial(props *type_properties) bool {
  return isTrivial(props->move_behavior) && isTrivial(props->copy_behavior) && isTrivial(props->destroy_behavior);
}

func lookup_explicit_method_or_lack_thereof(cs *checkstate, clq *clqueue, fntype *te_typeexpr, impl_name sym, behavior_out *derived_method_behavior) bool {
  res match_def_res;
  gp genparms = NoParms(void);
  if !match_def(cs, impl_name, &gp, fntype, &res) {
    return false;
  }

  switch &res {
    case &NoMatch(v void): {
      *behavior_out = DerivedMethodAbsent(void);
      return true;
    }
    case &MultiMatch(v void): {
      ERR(_u8("Multiple explicit methods '"), lookup(cs->im, impl_name), _u8("'"));
      return false;
    }
    case &OneMatch(m struct { ent def_entry_id; parms genparms; }): {
      inst_id def_inst_id;
      if !make_inst(cs, clq, m.ent, &m.parms, &inst_id) {
        return false;
      }
      *behavior_out = DerivedMethodExplicit({m.ent, inst_id});
      return true;
    }
  }
}

func to_defclass_properties(cs *checkstate, clq *clqueue, ent_id deftype_entry_id, inst_id deftype_inst_id, a ast_defclass_disposition, props type_properties, out *type_properties) bool {
  ret type_properties = props;
  switch a {
    case DefaultCopyMoveDestroy(v void): {
      type cu_typeexpr = type_from_inst(cs, ent_id, inst_id);
      ptrtype te_typeexpr = ptr_type(cs, type.~);
      fntype1 te_typeexpr = fn_type(cs, ptrtype, primitive_void_type(cs));
      if !lookup_explicit_method_or_lack_thereof(cs, clq, &fntype1, intern(cs->im, from_u8(_u8("do_init"))), &ret.init_behavior) {
        return false;
      }
    }
    case DefaultMove(v void): {
      type cu_typeexpr = type_from_inst(cs, ent_id, inst_id);
      ptrtype te_typeexpr = ptr_type(cs, type.~);
      fntype1 te_typeexpr = fn_type(cs, ptrtype, primitive_void_type(cs));
      fntype2 te_typeexpr = fn_type(cs, ptrtype, ptrtype, primitive_void_type(cs));
      if !lookup_explicit_method_or_lack_thereof(cs, clq, &fntype1, intern(cs->im, from_u8(_u8("do_init"))), &ret.init_behavior) {
        return false;
      }
      if !lookup_explicit_method_or_lack_thereof(cs, clq, &fntype2, intern(cs->im, from_u8(_u8("do_copy"))), &ret.copy_behavior) {
        return false;
      }
      if !lookup_explicit_method_or_lack_thereof(cs, clq, &fntype1, intern(cs->im, from_u8(_u8("do_destroy"))), &ret.destroy_behavior) {
        return false;
      }
    }
    case NoDefaults(v void): {
      type cu_typeexpr = type_from_inst(cs, ent_id, inst_id);
      ptrtype te_typeexpr = ptr_type(cs, type.~);
      fntype1 te_typeexpr = fn_type(cs, ptrtype, primitive_void_type(cs));
      fntype2 te_typeexpr = fn_type(cs, ptrtype, ptrtype, primitive_void_type(cs));
      if !lookup_explicit_method_or_lack_thereof(cs, clq, &fntype1, intern(cs->im, from_u8(_u8("do_init"))), &ret.init_behavior) {
        return false;
      }
      if !lookup_explicit_method_or_lack_thereof(cs, clq, &fntype2, intern(cs->im, from_u8(_u8("do_move"))), &ret.move_behavior) {
        return false;
      }
      if !lookup_explicit_method_or_lack_thereof(cs, clq, &fntype2, intern(cs->im, from_u8(_u8("do_copy"))), &ret.copy_behavior) {
        return false;
      }
      if !lookup_explicit_method_or_lack_thereof(cs, clq, &fntype1, intern(cs->im, from_u8(_u8("do_destroy"))), &ret.destroy_behavior) {
        return false;
      }
    }
  }
  *out = ret;
  return true;
}

deftype deftype_inst_rhs_info struct {
  rhs_cu cu_typeexpr;
  rhs_props type_properties;
};

deftype deftype_inst_info struct {
  // This is None() if the type is primitive.
  rhs opt[deftype_inst_rhs_info];
  props type_properties;
};

deftype deftype_inst struct {
  parms cu_genparms;
  info nbfc[deftype_inst_info];
};

deftype deftype_nonprim struct {
  tl *ast_type_def;
  // The RHS typeexpr, if computed, without generics replaced, of course.
  rhs nbfc[te_typeexpr];
};

defenum rhs_accessibility {
  RhsPublic void;
  RhsPrivate void;
  RhsImpossible void;
};

deftype deftype_entry struct {
  module_name sym;
  name sym;
  accessible array[access_entry_id];
  accessibility rhs_accessibility;
  generics ast_generics;
  // nonprim/default_info are mutually exclusive Has-havers.
  // Info relevant for non-primitive types.
  nonprim opt[deftype_nonprim];
  // Info for primitive types.
  default_info opt[deftype_inst_info];
  insts array[deftype_inst_id];
};

func mk(module_name sym, name sym, accessible array[access_entry_id], accessibility rhs_accessibility, g ast_generics, tl *ast_type_def) deftype_entry {
  return {module_name, name, accessible, accessibility, g, Has({tl, NotComputed()}), None(), default@[array[deftype_inst_id]]()};
}

defenum fn_body_spec {
  // Points to the annotated lambda within the def_inst rhs sub-expr.
  FnBodyLambda *ast_lambda;
  // Likewise, points to the checked def_magic within the def_inst definition.
  FnBodyMagic *def_magic;
};

deftype fn_body_entry struct {
  spec fn_body_spec;
};

deftype access_entry struct {
  name sym;
  arity ast_access_arity;
  ent_id nbfc[deftype_entry_id];
};

func mk(name sym, arity ast_access_arity) access_entry {
  return {name, arity, NotComputed()};
}

defenum genparms {
  NoParms void;
  HasParms array[te_typeexpr];
};

defenum cu_genparms {
  NoParms void;
  HasParms array[cu_typeexpr];
};

defenum def_inst_status {
  DidNotStartComputingType void;
  BeganComputingType void;
  FinishedComputingType void;
  // The following are OK, if the def_inst's rhs is None().  (Non-ephemerally, you'll only see FinishedCheckingRhs.)
  BeganCheckingRhs void;
  FinishedCheckingRhs void;
};

func `==`(x def_inst_status, y def_inst_status) bool {
  return enumnum(&x) == enumnum(&y);
}

func `!=`(x def_inst_status, y def_inst_status) bool {
  return !(x == y);
}

deftype frame_info struct {
  cells array[cell_info];
};

deftype def_inst_rhs_expr struct {
  ec ast_expr_consume;
  // This becomes Has(...) when the def_inst status == FinishedCheckingRhs(void).
  frame_info opt[frame_info];
};

defenum def_inst_rhs {
  // Prim defs... don't have an rhs to check.
  InstRhsPrim void;
  // Extern defs don't have an rhs.
  InstRhsExtern void;
  InstRhsExpr def_inst_rhs_expr;
  InstRhsMagic def_magic;
};

deftype def_regraphed struct {
  fg frame_graph;
  gn gr_num;
};

deftype def_inst struct {
  parms cu_genparms;
  // Our own copy of the def's rhs, which we can annotate.  It does not have its generics replaced.  This is None() if we have an extern def or primitive def.
  rhs def_inst_rhs;
  status def_inst_status;
  // TODO: Use nbfc or something.
  // Becomes the concrete type (with generics replaced) once we've computed it and checked it (see status).
  computed_type cu_typeexpr;
  // Right now, these type properties _must_ indicate that the type is defwise trivial.
  computed_type_properties type_properties;
  // This is None() for InstRhsPrim and InstRhsExtern.
  graph nbfc[opt[def_regraphed]];
  evaled_value nbfc[st_value];
};

func mk(parms cu_genparms, rhs def_inst_rhs) def_inst {
  return {parms, rhs, DidNotStartComputingType(void), default@[cu_typeexpr](), default@[type_properties](), NotComputed@[opt[def_regraphed]](), NotComputed@[st_value]()};
}

deftype def_nonprim struct {
  // This is either the syntactic typeexpr or converted from a shallow look at the RHS.
  quick_typeexpr ast_typeexpr;
  tl *ast_toplevel;
};

defenum def_definition {
  // The def is a primitive (+, -, etc), has no RHS.
  DefnPrim void;
  DefnHasRhs def_nonprim;
  DefnMagic def_magic;
};

deftype def_entry struct {
  module_name sym;
  def_name sym;
  accessible array[access_entry_id];
  // A copy of the ast_def's generics field -- if it's an ast_extern_def, this is NoGenerics.
  generics ast_generics;
  definition def_definition;
  converted_typeexpr nbfc[te_typeexpr];

  insts array[def_inst_id];
};

func mk(module_name sym, def_name sym, accessible array[access_entry_id], generics ast_generics, quick_typeexpr ast_typeexpr, tl *ast_toplevel) def_entry {
  return {module_name, def_name, accessible, generics, DefnHasRhs({quick_typeexpr, tl}), NotComputed(), default@[array[def_inst_id]]()};
}

deftype clqueue_deftype_entry struct {
  ent_id deftype_entry_id;
  inst_id deftype_inst_id;
  // The instantiation depth when we _push_ the entry.
  instantiation_depth u32;
};

deftype clqueue_def_entry struct {
  ent_id def_entry_id;
  inst_id def_inst_id;
  // The instantiation depth when we _push_ the entry.
  instantiation_depth u32;
};

defenum clqueue_entry {
  ClqDeftypeEntry clqueue_deftype_entry;
  ClqDefEntry clqueue_def_entry;
};

deftype clqueue struct {
  entries array[clqueue_entry];
};


defclass move depth_rewinder struct {
  cs *checkstate;
  old_depth u32;
};

def template_instantiation_limit u32 = 50;

access depth_rewinder {
  func do_init(d *depth_rewinder) void {
    init(&d->cs);
    init(&d->old_depth);
  }
  func do_destroy(d *depth_rewinder) void {
    check(d->old_depth <= template_instantiation_limit);
    if d->cs != null {
      d->cs->instantiation_depth = d->old_depth;
    }
    d->cs = null;
    d->old_depth = 0;
  }
  func set_instantiation_depth(cs *checkstate, depth u32, rw *depth_rewinder) bool {
    check(rw->cs == null);
    if depth > template_instantiation_limit {
      ERR(_u8("Instantiation depth too deep."));
      return false;
    }
    rw->cs = cs;
    rw->old_depth = cs->instantiation_depth;
    cs->instantiation_depth = depth;
    return true;
  }
}
