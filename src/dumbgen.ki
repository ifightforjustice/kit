import state;

deftype gn_annot struct {
  // Which cells are guaranteed to be live when the gn starts.
  live hash[cell_num, void];
};

deftype frame struct {
  cs *checkstate;
  gr *frame_graph;
  bas *basic_analyze_state;
  // by_gn[i].fs shows what the state must is _before_ evaluating node i.  (All incoming nodes must agree!)
  by_gn array[opt[gn_annot]];
};

func dumbly_gen_graphed_fn_body(cs *checkstate, f *objfile, bas *basic_analyze_state, g *graphed_fn_body) bool {
  h frame = {cs, &g->graph.gr, bas, repeat(count(&g->graph.gr.ops), None())};

  prelive hash[cell_num, void];
  check_add_all(&prelive, &g->argcells);
  check_add(&prelive, g->graph.cell);

  mut genexpr_result;
  if !dumbly_gen_expression(cs, f, &h, &g->graph.gr, g->graph.gn, &prelive, &mut) {
    return false;
  }

  // TODO: Is there something I should assert about mut?  (It can be None if the function infinite-loops.)

  return true;
}

deftype exprmut struct {
  // Cells that weren't live, that are used.
  made_live hash[cell_num, void];
  // Cells that were live, that are used (and not made dead).
  used hash[cell_num, void];
  // Cells that were not live, that are used.
  encapsulated hash[cell_num, void];
  // Cells that were live, that are made dead.
  made_dead hash[cell_num, void];
};

deftype partial_exprmut struct {
  used hash[cell_num, void];
  encapsulated hash[cell_num, void];
};

func dumbly_gen_returning_expression(cs *checkstate, f *objfile, h *frame, gr *frame_graph, gn gr_num, prelive *hash[cell_num, void], mut_out *exprmut) bool {
  mbmut genexpr_result;
  if !dumbly_gen_expression(cs, f, h, gr, gn, prelive, &mbmut) {
    return false;
  }
  switch &mbmut {
  case &Terminal(m exprmut):
    *mut_out = m;
    return true;
  case &NonTerminal(pm partial_exprmut):
    ERR(_u8("ICE: Expecting terminal expression"));
    return false;
  }
}

defenum genexpr_result {
  Terminal exprmut;
  NonTerminal partial_exprmut;
};

func dumbly_gen_expression(cs *checkstate, f *objfile, h *frame, gr *frame_graph, gn gr_num, prelive *hash[cell_num, void], mut_out *genexpr_result) bool {
  gnc *opt[gn_annot] = ref_annot(h, gn);
  if case &Has(annot gn_annot) = gnc {
    // TODO: We should also check that we're part of the same sequential _family_ of exprs.
    if !sets_equal(prelive, &annot.live) {
      ERR(_u8("Inconsistent liveness state when revisiting node."));
      return false;
    }
    *mut_out = NonTerminal({mk_hash@[cell_num, void](), mk_hash@[cell_num, void]()});
    return true;
  }

  set(gnc, {*prelive});

  prec_muts exprmut;

  node *gr_node = ref_node(gr, gn);
  nprecs size = count(&node->precs);
  for i size = 0; i < nprecs; i = i + 1 {
    i_mut exprmut;
    if !dumbly_gen_returning_expression(cs, f, h, gr, get(&node->precs, i), prelive, &i_mut) {
      return false;
    }
    if !add_parallel_mut(prelive, &prec_muts, &i_mut) {
      return false;
    }
  }

  switch &node->op {
  case &GrApply(a gr_apply):
    deaden(prelive, &prec_muts, a.funcell);
    nparams size = count(&a.params);
    for i size = 0; i < nparams; i = i + 1 {
      deaden(prelive, &prec_muts, get(&a.params, i));
    }
    output(prelive, &prec_muts, a.retcell);
    *mut_out = Terminal(prec_muts);
    return true;
  case &GrMemCopy(a gr_memcopy):
    output(prelive, &prec_muts, a.dest);
    input(prelive, &prec_muts, a.src);
    *mut_out = Terminal(prec_muts);
    return true;
  case &GrWriteConst(a gr_writeconst):
    output(prelive, &prec_muts, a.dest);
    *mut_out = Terminal(prec_muts);
    return true;
  case &GrAddressof(a gr_addressof):
    input(prelive, &prec_muts, a.addressee);
    output(prelive, &prec_muts, a.dest);
    *mut_out = Terminal(prec_muts);
    return true;
  case &GrDeref(a gr_deref):
    input(prelive, &prec_muts, a.pointer);
    // Location should always be virtual.
    virtual(prelive, &prec_muts, a.name);
    *mut_out = Terminal(prec_muts);
    return true;
  case &GrSubcell(a gr_subcell):
    input(prelive, &prec_muts, a.partof);
    deaden_offset(prelive, &prec_muts, &a.offset);
    virtual(prelive, &prec_muts, a.name);
    *mut_out = Terminal(prec_muts);
    return true;
  case &GrBranch(a gr_branch):
    input(prelive, &prec_muts, a.src);
    new_live hash[cell_num, void] = *prelive;
    compose_live(&new_live, &prec_muts);

    combined_mut genexpr_result = NonTerminal({mk_hash(), mk_hash()});
    ncases size = count(&a.cases);
    for i size = 0; i < ncases; i = i + 1 {
      cas *tup[gr_const, gr_num] = ref(&a.cases, i);
      casmut genexpr_result;
      if !dumbly_gen_expression(cs, f, h, gr, cas->cdr, &new_live, &casmut) {
        return false;
      }
      combine_branch_mut(&combined_mut, &casmut);
    }

    if case Has(def_gn gr_num) = a.default_case {
      defcasmut genexpr_result;
      if !dumbly_gen_expression(cs, f, h, gr, def_gn, &new_live, &defcasmut) {
        return false;
      }
      combine_branch_mut(&combined_mut, &defcasmut);
    }

    compose_result(&prec_muts, &combined_mut, mut_out);
    return true;
  case &GrSequence(a gr_sequence):
    new_live hash[cell_num, void] = *prelive;
    compose_live(&new_live, &prec_muts);
    firstmut exprmut;
    if !dumbly_gen_returning_expression(cs, f, h, gr, a.first, &new_live, &firstmut) {
      return false;
    }
    prec_muts = compose_muts(&prec_muts, &firstmut);
    compose_live(&new_live, &firstmut);
    secondmut genexpr_result;
    if !dumbly_gen_expression(cs, f, h, gr, a.second, &new_live, &secondmut) {
      return false;
    }

    compose_result(&prec_muts, &secondmut, mut_out);
    return true;
  case &GrJmp(a gr_jmp):
    new_live hash[cell_num, void] = *prelive;
    compose_live(&new_live, &prec_muts);
    exitmut genexpr_result;
    if !dumbly_gen_expression(cs, f, h, gr, a.next, &new_live, &exitmut) {
      return false;
    }
    compose_result(&prec_muts, &exitmut, mut_out);
    return true;
  case &GrWriteNothing(a gr_writenothing):
    output(prelive, &prec_muts, a.dest);
    *mut_out = Terminal(prec_muts);
    return true;
  case &GrDead(a gr_dead):
    deaden(prelive, &prec_muts, a.cell);
    *mut_out = Terminal(prec_muts);
    return true;
  case &GrNop(v void):
    *mut_out = Terminal(prec_muts);
    return true;
  }
}

func combine_branch_mut(onto *genexpr_result, a *genexpr_result) void {
  switch onto {
  case &Terminal(tm exprmut):
    switch a {
    case &Terminal(cm exprmut):
      check(sets_equal(&tm.made_live, &cm.made_live));
      check(sets_equal(&tm.made_dead, &cm.made_dead));
      add_union(&tm.used, &cm.used);
      add_union(&tm.encapsulated, &cm.encapsulated);
    case &NonTerminal(ncm partial_exprmut):
      // Can made_live/made_dead be wrong?  No, because all paths to Terminal must have the same value.  (We _do_ check liveness state when revisiting the node.)
      // We can track what cells are used and encapsulated by _expressions_ but we do _not_ gather such information from various points amid sequences of statements.  (Not when there's a loop.)
      add_union_difference(&tm.used, &ncm.used, &tm.made_dead);
      add_union_difference(&tm.encapsulated, &ncm.encapsulated, &tm.made_live);
    }
  case &NonTerminal(ntm partial_exprmut):
    switch a {
    case &Terminal(cm exprmut):
      // This is just like the Terminal/NonTerminal case.
      new_combined exprmut = cm;
      add_union_difference(&new_combined.used, &ntm.used, &new_combined.made_dead);
      add_union_difference(&new_combined.encapsulated, &ntm.encapsulated, &new_combined.made_live);
      *onto = Terminal(new_combined);
    case &NonTerminal(ncm partial_exprmut):
      add_union(&ntm.used, &ncm.used);
      add_union(&ntm.encapsulated, &ncm.encapsulated);
    }
  }
}

func deaden(prelive *hash[cell_num, void], prec_muts *exprmut, c cell_num) void {
  // TODO(): Implement
}

// input requires that the cell already be live.
func input(prelive *hash[cell_num, void], prec_muts *exprmut, c cell_num) void {
  // TODO(): Implement
}

// output either makes the cell live, if it wasn't already, or it means we use the cell.
func output(prelive *hash[cell_num, void], prec_muts *exprmut, c cell_num) void {
  // TODO(): Implement
}

// Says that we're naming a virtual cell.
func virtual(prelive *hash[cell_num, void], prec_muts *exprmut, c cell_num) void {
  // TODO(): Implement
}

func deaden_offset(prelive *hash[cell_num, void], prec_muts *exprmut, goff *gr_offset) void {
  switch goff {
  case &OffsetConst(n u32): { }
  case &OffsetComputed(p tup[u32, cell_num]):
    deaden(prelive, prec_muts, p.cdr);
  }
}

func compose_live(live *hash[cell_num, void], muts *exprmut) void {
  check_add_disjoint(live, &muts->made_live);
  remove_exactly(live, &muts->made_dead);
}

func compose_muts(before *exprmut, after *exprmut) exprmut {
  ret exprmut;

  it hash_iter[cell_num, void] = iter(&before->made_live);
  while case Has(p *_) = next(&it) {
    c cell_num = p->car;
    if case Has(v *void) = lookup_ref(&after->made_live, &c) {
      ice(_u8("compose_muts made_live->made_live"));
    } else if case Has(v *void) = lookup_ref(&after->used, &c) {
      check_insert(&ret.made_live, &c, void);
    } else if case Has(v *void) = lookup_ref(&after->encapsulated, &c) {
      ice(_u8("compose_muts made_live->encapsulated"));
    } else if case Has(v *void) = lookup_ref(&after->made_dead, &c) {
      check_insert(&ret.encapsulated, &c, void);
    } else {
      check_insert(&ret.made_live, &c, void);
    }
  }

  it = iter(&before->used);
  while case Has(p *_) = next(&it) {
    c cell_num = p->car;
    if case Has(v *void) = lookup_ref(&after->made_live, &c) {
      ice(_u8("compose_muts used->made_live"));
    } else if case Has(v *void) = lookup_ref(&after->used, &c) {
      check_insert(&ret.used, &c, void);
    } else if case Has(v *void) = lookup_ref(&after->encapsulated, &c) {
      ice(_u8("compose_muts used->encapsulated"));
    } else if case Has(v *void) = lookup_ref(&after->made_dead, &c) {
      check_insert(&ret.made_dead, &c, void);
    } else {
      check_insert(&ret.used, &c, void);
    }
  }

  it = iter(&before->encapsulated);
  while case Has(p *_) = next(&it) {
    c cell_num = p->car;
    if case Has(v *void) = lookup_ref(&after->made_live, &c) {
      check_insert(&ret.made_live, &c, void);
    } else if case Has(v *void) = lookup_ref(&after->used, &c) {
      ice(_u8("compose_muts encapsulated->used"));
    } else if case Has(v *void) = lookup_ref(&after->encapsulated, &c) {
      check_insert(&ret.encapsulated, &c, void);
    } else if case Has(v *void) = lookup_ref(&after->made_dead, &c) {
      ice(_u8("compose_muts encapsulated->made_dead"));
    } else {
      check_insert(&ret.encapsulated, &c, void);
    }
  }

  it = iter(&before->made_dead);
  while case Has(p *_) = next(&it) {
    c cell_num = p->car;
    if case Has(v *void) = lookup_ref(&after->made_live, &c) {
      check_insert(&ret.used, &c, void);
    } else if case Has(v *void) = lookup_ref(&after->used, &c) {
      ice(_u8("compose_muts made_dead->used"));
    } else if case Has(v *void) = lookup_ref(&after->encapsulated, &c) {
      check_insert(&ret.made_dead, &c, void);
    } else if case Has(v *void) = lookup_ref(&after->made_dead, &c) {
      ice(_u8("compose_muts made_dead->made_dead"));
    } else {
      check_insert(&ret.made_dead, &c, void);
    }
  }

  compose_not_present(&ret, after, before);
  return ret;
}

// Adds to build those of from that aren't in np.
func compose_not_present(build *exprmut, from *exprmut, np *exprmut) void {
  add_not_present(&build->made_live, &from->made_live, np);
  add_not_present(&build->used, &from->used, np);
  add_not_present(&build->encapsulated, &from->encapsulated, np);
  add_not_present(&build->made_dead, &from->made_dead, np);
}

func add_not_present(onto *hash[cell_num, void], from *hash[cell_num, void], np *exprmut) void {
  it hash_iter[cell_num, void] = iter(from);
  while case Has(p *tup[cell_num, void]) = next(&it) {
    c cell_num = p->car;
    if !(member(&np->made_live, &c) || member(&np->used, &c) || member(&np->encapsulated, &c) || member(&np->made_dead, &c)) {
      check_insert(onto, &c, void);
    }
  }
}

func compose_result(before *exprmut, after *genexpr_result, out *genexpr_result) void {
  switch after {
  case &Terminal(am exprmut):
    *out = Terminal(compose_muts(before, &am));
  case &NonTerminal(nam partial_exprmut):
    ret partial_exprmut = nam;
    add_union(&ret.used, &before->used);
    add_union(&ret.encapsulated, &before->encapsulated);
    *out = NonTerminal(ret);
  }
}

// This function should have a symmetry about it.
func add_parallel_mut(prelive *hash[cell_num, void], onto *exprmut, from *exprmut) bool {
  if intersects(&onto->made_dead, &from->used) || intersects(&onto->used, &from->made_dead) {
    ERR(_u8("ICE: One prec-expr marks cell dead that another uses"));
    return false;
  }
  if intersects(&onto->made_live, &from->encapsulated) || intersects(&onto->encapsulated, &from->made_live) {
    ERR(_u8("ICE: One prec-expr makes cell live that another encapsulates"));
    return false;
  }
  if !add_disjoint(&onto->made_live, &from->made_live) {
    ERR(_u8("ICE: multiple prec-exprs made the same cell live"));
    return false;
  }
  if !add_disjoint(&onto->made_dead, &from->made_dead) {
    ERR(_u8("ICE: multiple prec-exprs made the same cell dead"));
    return false;
  }
  if !add_disjoint(&onto->encapsulated, &from->encapsulated) {
    ERR(_u8("ICE: multiple prec-exprs use and discard the same cell"));
    return false;
  }

  add_union(&onto->used, &from->used);
  return true;
}

func ref_annot(h *frame, gn gr_num) *opt[gn_annot] {
  return ref(&h->by_gn, gn.~);
}
