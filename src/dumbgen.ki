import dumbanal;
import state;

func mk_gn_annot() gn_annot {
  return {NotComputed(), NotComputed(), mk_hash@[gr_num, void]()};
}

// Some Hungarian notation:  The "dumbly_" prefix means the code's really dumb.

func dumbly_gen_graphed_fn_body(cs *checkstate, f *objfile, bas *basic_analyze_state, g *graphed_fn_body) bool {
  h frame = {cs, cs->im, &g->graph.gr, bas, repeat(count(&g->graph.gr.ops), mk_gn_annot())};

  prelive lives;
  check_add_all(&prelive.all, &g->argcells);
  check_add(&prelive.all, g->graph.cell);

  DBG(_u8("gen graphed fn body for "), lookup(cs->im, g->graph.gr.informal_name));
  mut genexpr_result;
  if !dumbly_analyze_expression(&h, &g->graph.gr, g->graph.gn, &prelive, &mut) {
    return false;
  }

  switch &mut {
  case &Terminal(m exprmut):
    new_live lives = prelive;
    compose_live(&new_live, &m);
    expected lives = {mk_hash(g->graph.cell, void)};
    if !lives_equal(&new_live, &expected) {
      ice(_u8("fn_body leaves cells alive, expected "), g->graph.cell, _u8(", saw "), new_live);
    }
  case &NonTerminal(pm partial_exprmut):
    // nothing to assert
  }

  if !dumbly_layout_frame_cells(&h) {
    return false;
  }

  // TODO(): Implement.
  return true;
}

func paramlist_cells(gr *frame_graph, gn gr_num) *shray[cell_num] {
  switch &ref_node(gr, gn)->op {
  case &GrApply(a gr_apply):
    return &a.params;
  case &GrPrimApply(a gr_prim_apply):
    return &a.params;
  default:
    ice(_u8("paramlist_cells called on non-paramlist op"));
    return fake();
  }
}

func dumbly_layout_frame_cells(h *frame) bool {
  // Left-most paramlist goes first.
  paramlist_ordering array[gr_num];
  if !dumbly_linearize_paramlist_ordering(h, &paramlist_ordering) {
    return false;
  }

  // Offsets of either a static cell or a virtual cell's pointer.
  offsets array[opt[i32]] = repeat(count(&h->gr->cells), None());
  // TODO: Maybe after we push ebp, the alignment is 4 or something -- in cases where we need 8-byte or 16-byte alignment for some things.
  low_offset i32 = 0;

  ncalls size = count(&paramlist_ordering);
  for i size = 0; i < ncalls; i = i + 1 {
    gn gr_num = get(&paramlist_ordering, i);
    live *lives = unHas(&ref_annot(h, gn)->live);

    // 1. Layout any cells live during the funcall, that are _not_ part of the paramlist.
    it hash_iter[cell_num, void] = iter(&live->all);
    while case Has(p *tup[cell_num, void]) = next(&it) {
      c cell_num = p->car;
      if isNone(ref(&offsets, c.~)) {
        if case &Has(cell_paramlistgn gr_num) = &ref(&h->bas->celldisp, c.~)->paramlist {
          // Cells in other paramlists should already been processed -- and would have failed the isNone check just above.
          check(cell_paramlistgn == gn);
        } else {
          ci *cell_info = ref_cell(h->gr, c);
          offset i32 = next_stack_offset(h->cs, low_offset, ci);
          low_offset = offset;
          set(&offsets, c.~, Has(offset));
        }
      }
    }

    // 2. Layout cells that _are_ part of the paramlist.
    pcells *shray[cell_num] = paramlist_cells(h->gr, gn);
    npcells size = count(pcells);
    for j size = npcells; j > 0; {
      j = j - 1;
      c cell_num = get(pcells, j);
      ci *cell_info = ref_cell(h->gr, c);
      offset i32 = next_stack_offset(h->cs, low_offset, ci);
      low_offset = offset;
      check(isNone(ref(&offsets, c.~)));
      set(&offsets, c.~, Has(offset));
    }
  }

  // 3. Layout cells that aren't live during any function call.
  ncells size = count(&offsets);
  for i size = 0; i < ncells; i = i + 1 {
    if isNone(ref(&offsets, i)) {
      c cell_num = ~i;
      ci *cell_info = ref_cell(h->gr, c);
      offset i32 = next_stack_offset(h->cs, low_offset, ci);
      low_offset = offset;
      set(&offsets, c.~, Has(offset));
    }
  }
  return true;
}

func next_stack_offset(cs *checkstate, low_offset i32, ci *cell_info) i32 {
  switch ci->location {
  case LocationVirtual(v void):
    return floor_aligned(low_offset - ~cs->plat.ptrtraits.size, max(cs->plat.min_stackvar_alignment, cs->plat.ptrtraits.size));
  case LocationStatic(v void):
    return floor_aligned(low_offset - ~ci->props.flat_size, max(cs->plat.min_stackvar_alignment, ci->props.flat_alignment));
  }
}


func dumbly_linearize_paramlist_ordering(h *frame, paramlist_ordering_out *array[gr_num]) bool {
  // Paramlists by in-degree, which is < the number of paramlists (since they can't point at themselves).
  nparamlists size = count(&h->bas->paramlists);
  // nparamlists is an impossible in-degree, and nparamlists + 1 is more impossible -- there's no way it could be decremented to zero while having count(&ordering) end up equalling nparamlists, below.
  backmap array[size] = repeat(count(&h->by_gn), nparamlists + 1);
  nreachable_paramlists size = 0;
  zeroset hash[gr_num, void];
  for i size = 0; i < nparamlists; i = i + 1 {
    gn gr_num = get(&h->bas->paramlists, i);
    // Nodes without lower_paramlists are unreachable.  So we don't need to worry about those!
    // TODO: Maybe, don't gen graphs with dead nodes!
    if case &Computed(arr array[gr_num]) = &ref(&h->by_gn, gn.~)->lower_paramlists {
      nlower size = count(unHas(&ref(&h->by_gn, gn.~)->lower_paramlists));
      if nlower == 0 {
        check_insert(&zeroset, &gn, void);
      }
      set(&backmap, gn.~, nlower);
      nreachable_paramlists = nreachable_paramlists + 1;
    }
  }

  ordering array[gr_num];

  while count(&zeroset) != 0 {
    gn gr_num;
    if true {
      var it = iter(&zeroset);
      gn = unHas(next(&it))->car;
    }
    check_remove(&zeroset, &gn);
    push(&ordering, gn);
    it hash_iter[gr_num, void] = iter(&ref_annot(h, gn)->higher_paramlists);
    while case Has(p *tup[gr_num, void]) = next(&it) {
      upn gr_num = p->car;
      bucket size = get(&backmap, upn.~);
      check(bucket > 0);
      nextbucket size = bucket - 1;
      if nextbucket == 0 {
        check_insert(&zeroset, &upn, void);
      }
      set(&backmap, upn.~, nextbucket);
    }
  }

  if count(&ordering) != nreachable_paramlists {
    ERR(_u8("ICE: paramlist ordering has a cyclic dependency."));
    return false;
  }

  *paramlist_ordering_out = ordering;
  return true;
}

