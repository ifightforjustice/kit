import array;
import graph;

struct vt_state { }

func mk_vt_state() vt_state {
  return { };
}

enum freshness {
  Stale void;
  // There's a change in the information formed by unification.
  Fresh void;
}

func `==`(x freshness, y freshness) bool {
  return enumnum(&x) == enumnum(&y);
}

func any_fresh(x freshness, y freshness) freshness {
  return x == Fresh || y == Fresh then Fresh else Stale;
}

// Returns whether "onto" changed.
func unify_vt_state(onto *opt[vt_state], from *vt_state) cr[freshness] {
  if case &Has(s vt_state) = onto {
    return unify_vt_state(&s, from);
  } else {
    *onto = Has(*from);
    return NoFail(Fresh);
  }
}

// Returns whether "onto" changed.
func unify_vt_state(onto *vt_state, from *vt_state) cr[freshness] {
  return NoFail(Stale);
}

func unify_vs_checksum(onto *vs_checksum, from *vs_checksum) np {
  if onto->live_count == from->live_count && onto->active_count == from->active_count {
    return NoFail;
  } else {
    return ERR(_u8("ICE? unify_vt_state active/live count mismatch"));
  }
}

struct vs_unify_pairage {
  for_onto vs_unify_half_pairage;
  for_from vs_unify_half_pairage;
}

inline func vs_xop(c cgt, gn gr_num, xn *gr_xnode) np {
  xn->vs_xopped = true;
  return NoFail;
}



// TODO: Get rid of null pointers (from the language).
