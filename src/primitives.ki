import state;

func primitive_bool_type(cs *checkstate) te_typeexpr {
  return TeName({cs->im->cym.boolsym, None()});
}

func primitive_void_type(cs *checkstate) te_typeexpr {
  return TeName({cs->im->cym.voidsym, None()});
}

func primitive_u8_type(cs *checkstate) te_typeexpr {
  return TeName({cs->im->cym.u8sym, None()});
}

func primitive_i32_type(cs *checkstate) te_typeexpr {
  return TeName({cs->im->cym.i32sym, None()});
}

func primitive_size_type(cs *checkstate) te_typeexpr {
  return TeName({cs->im->cym.sizesym, None()});
}

func primitive_string_literal_type(cs *checkstate, n size) te_typeexpr {
  return TeArraytype({Has(~n), embox(primitive_u8_type(cs))});
}

func primitive_function_puretype(cs *checkstate) te_puretype {
  return TePureName(cs->im->cym.fnsym);
}

func primitive_pointer_puretype(cs *checkstate) te_puretype {
  return TePureName(cs->im->cym.ptrtype_sym);
}

func add_conversion(cs *checkstate, from sym, to sym) void {
  type te_typeexpr = fn_type(cs, TeName({from, None()}), TeName({to, None()}));
  add_def_primitive(cs, cs->im->cym.convertsym, type);
}

func add_integral_primitives(cs *checkstate) void {
  // See also is_numeric_type.
  add_integral_primitive(cs, cs->im->cym.i8sym, cs->platform.i8traits);
  add_integral_primitive(cs, cs->im->cym.u8sym, cs->platform.u8traits);
  add_integral_primitive(cs, cs->im->cym.i16sym, cs->platform.i16traits);
  add_integral_primitive(cs, cs->im->cym.u16sym, cs->platform.u16traits);
  add_integral_primitive(cs, cs->im->cym.i32sym, cs->platform.i32traits);
  add_integral_primitive(cs, cs->im->cym.u32sym, cs->platform.u32traits);
  add_integral_primitive(cs, cs->im->cym.sizesym, cs->platform.sizetraits);
  add_integral_primitive(cs, cs->im->cym.osizesym, cs->platform.osizetraits);

  names array[sym] = mk_array(cs->im->cym.i8sym, cs->im->cym.u8sym, cs->im->cym.i16sym, cs->im->cym.u16sym, cs->im->cym.i32sym, cs->im->cym.u32sym, cs->im->cym.sizesym, cs->im->cym.osizesym);
  n size = count(&names);
  for i size = 0; i < n; i = i + 1 {
    for j size = 0; j < n; j = j + 1 {
      add_conversion(cs, get(&names, i), get(&names, j));
    }
  }
}

func add_primitives(cs *checkstate) void {
  add_integral_primitives(cs);
  add_void_primitive(cs);
  add_bool_primitive(cs);
  add_pointer_primitive(cs);
  add_function_primitive(cs);
  add_magic_constructor_primitives(cs);
}

func is_numeric_type(cs *checkstate, pt *te_typeexpr, out *numeric_traits) bool {
  // TODO: This implementation should work on complete types, use proper scoping rules (once we get scoping rules).
  if case &TeName(a te_name) = pt {
    if a.value == cs->im->cym.i8sym {
      *out = cs->platform.i8traits.numeric;
    } else if a.value == cs->im->cym.u8sym {
      *out = cs->platform.u8traits.numeric;
    } else if a.value == cs->im->cym.i16sym {
      *out = cs->platform.i16traits.numeric;
    } else if a.value == cs->im->cym.u16sym {
      *out = cs->platform.u16traits.numeric;
    } else if a.value == cs->im->cym.i32sym {
      *out = cs->platform.i32traits.numeric;
    } else if a.value == cs->im->cym.u32sym {
      *out = cs->platform.u32traits.numeric;
    } else if a.value == cs->im->cym.sizesym {
      *out = cs->platform.sizetraits.numeric;
    } else if a.value == cs->im->cym.osizesym {
      *out = cs->platform.osizetraits.numeric;
    } else {
      return false;
    }
    return true;
  }
  return false;
}

func add_def_primitive(cs *checkstate, name sym, generics ast_generics, type te_typeexpr) void {
  // access_scope is not relevant to a primitive def.
  access_scope array[access_entry_id];
  ent def_entry = {cs->im->cym.primitive_module_sym, name, access_scope, generics, None(), Computed(type), default@[array[def_inst_id]]()};
  id def_entry_id = add_def_entry(cs, ent);
  // DBG(_u8("Added def with name '"), lookup(cs->im, name), _u8("', type = '"), to_u8str(cs->im, type), _u8("'"));
  // TODO: We probably want to put the id in some kind of "primitive" module.
}

func add_def_primitive(cs *checkstate, name sym, type te_typeexpr) void {
  add_def_primitive(cs, name, NoGenerics(void), type);
}

func add_op_primitive(cs *checkstate, oper sym, typename sym, arity size) void {
  type te_typeexpr = fn_type(cs, repeat(arity + 1, TeName({typename, None()})));
  add_def_primitive(cs, oper, type);
}

func add_comparison_primitive(cs *checkstate, oper sym, generics ast_generics, type te_typeexpr) void {
  f te_typeexpr = fn_type(cs, type, type, primitive_bool_type(cs));
  add_def_primitive(cs, oper, generics, f);
}

func add_comparison_primitive(cs *checkstate, oper sym, typename sym) void {
  add_comparison_primitive(cs, oper, NoGenerics(void), TeName({typename, None()}));
}

func add_binop_primitive(cs *checkstate, oper sym, typename sym) void {
  add_op_primitive(cs, oper, typename, 2);
}

func add_unop_primitive(cs *checkstate, oper sym, typename sym) void {
  add_op_primitive(cs, oper, typename, 1);
}

func add_integral_primitive(cs *checkstate, name sym, traits integral_traits) void {
  add_simple_primitive(cs, name, traits.flat);
  // TODO: Put all uses of intern into cs->im->cym.
  add_binop_primitive(cs, intern(cs->im, from_u8(_u8("+"))), name);
  add_binop_primitive(cs, intern(cs->im, from_u8(_u8("-"))), name);
  add_binop_primitive(cs, intern(cs->im, from_u8(_u8("*"))), name);
  add_binop_primitive(cs, intern(cs->im, from_u8(_u8("/"))), name);
  add_binop_primitive(cs, intern(cs->im, from_u8(_u8("%"))), name);
  add_binop_primitive(cs, intern(cs->im, from_u8(_u8("&"))), name);
  add_binop_primitive(cs, intern(cs->im, from_u8(_u8("|"))), name);
  add_binop_primitive(cs, intern(cs->im, from_u8(_u8("^"))), name);
  add_unop_primitive(cs, intern(cs->im, from_u8(_u8("^"))), name);
  add_binop_primitive(cs, intern(cs->im, from_u8(_u8("<<"))), name);
  add_binop_primitive(cs, intern(cs->im, from_u8(_u8(">>"))), name);
  add_comparison_primitive(cs, intern(cs->im, from_u8(_u8("=="))), name);
  add_comparison_primitive(cs, intern(cs->im, from_u8(_u8("!="))), name);
  add_comparison_primitive(cs, intern(cs->im, from_u8(_u8("<"))), name);
  add_comparison_primitive(cs, intern(cs->im, from_u8(_u8(">"))), name);
  add_comparison_primitive(cs, intern(cs->im, from_u8(_u8("<="))), name);
  add_comparison_primitive(cs, intern(cs->im, from_u8(_u8(">="))), name);

  if traits.numeric.signed {
    add_unop_primitive(cs, intern(cs->im, from_u8(_u8("-"))), name);
  }
}

func add_void_primitive(cs *checkstate) void {
  add_simple_primitive(cs, cs->im->cym.voidsym, cs->platform.voidtraits);
}

func add_bool_primitive(cs *checkstate) void {
  add_simple_primitive(cs, cs->im->cym.boolsym, cs->platform.booltraits);
  add_binop_primitive(cs, intern(cs->im, from_u8(_u8("&&"))), cs->im->cym.boolsym);
  add_binop_primitive(cs, intern(cs->im, from_u8(_u8("||"))), cs->im->cym.boolsym);
  add_unop_primitive(cs, intern(cs->im, from_u8(_u8("!"))), cs->im->cym.boolsym);
  add_comparison_primitive(cs, intern(cs->im, from_u8(_u8("=="))), cs->im->cym.boolsym);
  add_comparison_primitive(cs, intern(cs->im, from_u8(_u8("!="))), cs->im->cym.boolsym);
}

func add_simple_primitive(cs *checkstate, name sym, flat_traits flat_traits) void {
  info opt[deftype_inst_info] = Has({
    None(),
    @[type_properties]{
      flat_traits.size,
      flat_traits.alignment,
      DerivedMethodTrivial(void),
      DerivedMethodTrivial(void),
      DerivedMethodTrivial(void),
      DerivedMethodTrivial(void)
    }
  });
  inst_id deftype_inst_id
      = add_deftype_inst(cs, {NoParms(void),
                              FinishedChecking(void),
                              info});
  insts array[deftype_inst_id];
  push(&insts, inst_id);
  // access_scope is not relevant to a primitive deftype.
  access_scope array[access_entry_id];
  ent deftype_entry = {cs->im->cym.primitive_module_sym, name, access_scope, RhsImpossible(void), NoGenerics(void), None(), info, insts};
  id deftype_entry_id = add_deftype_entry(cs, ent);
  // TODO: We probably want to put the id in some kind of "primitive" module.
}

func tee_generic(cs *checkstate) ast_generics {
  return HasGenerics(mk_array@[ast_ident]({fake_ast_meta(), cs->im->cym.tee_sym}));
}

func fn_type(cs *checkstate, params array[te_typeexpr]) te_typeexpr {
  return TeApp({embox(primitive_function_puretype(cs)), params, None()});
}

func fn_type(cs *checkstate, t te_typeexpr, u te_typeexpr) te_typeexpr {
  return fn_type(cs, mk_array(t, u));
}

func fn_type(cs *checkstate, t te_typeexpr, u te_typeexpr, v te_typeexpr) te_typeexpr {
  return fn_type(cs, mk_array(t, u, v));
}

func ptr_type(cs *checkstate, t te_typeexpr) te_typeexpr {
  return TeApp({embox(primitive_pointer_puretype(cs)), mk_array(t), None()});
}

func add_pointer_primitive(cs *checkstate) void {
  add_pointer_primitive_type(cs);
  tee_type te_typeexpr = TeName({cs->im->cym.tee_sym, None()});
  bool_type te_typeexpr = primitive_bool_type(cs);
  add_comparison_primitive(cs, intern(cs->im, from_u8(_u8("=="))), tee_generic(cs), ptr_type(cs, tee_type));
  add_comparison_primitive(cs, intern(cs->im, from_u8(_u8("!="))), tee_generic(cs), ptr_type(cs, tee_type));
  add_comparison_primitive(cs, intern(cs->im, from_u8(_u8("<"))), tee_generic(cs), ptr_type(cs, tee_type));
  add_comparison_primitive(cs, intern(cs->im, from_u8(_u8(">"))), tee_generic(cs), ptr_type(cs, tee_type));
  add_comparison_primitive(cs, intern(cs->im, from_u8(_u8("<="))), tee_generic(cs), ptr_type(cs, tee_type));
  add_comparison_primitive(cs, intern(cs->im, from_u8(_u8(">="))), tee_generic(cs), ptr_type(cs, tee_type));
}

func add_pointer_primitive_type(cs *checkstate) void {
  one_generic array[ast_ident];
  push(&one_generic, {fake_ast_meta(), cs->im->cym.tee_sym});
  // It's as if pointers belong in an even _more_ primitive module than integer/bool types.
  ent deftype_entry = {
    cs->im->cym.primitive_module_sym,
    cs->im->cym.ptrtype_sym,
    default@[array[access_entry_id]](),
    RhsImpossible(void),
    HasGenerics(one_generic),
    None(),
    Has({None(),
         @[type_properties]{
           cs->platform.ptrtraits.size,
           cs->platform.ptrtraits.alignment,
           DerivedMethodTrivial(void),
           DerivedMethodTrivial(void),
           DerivedMethodTrivial(void),
           DerivedMethodTrivial(void)
         }}),
    default@[array[deftype_inst_id]]()
  };
  id deftype_entry_id = add_deftype_entry(cs, ent);
  // TODO: We probably want to put the id in some kind of "primitive" or hyper-primitive module.
}

func add_function_primitive(cs *checkstate) void {
  // Likewise as pointers, functions are kind of _more_ primitive than integer/bool types.
  ent deftype_entry = {
    cs->im->cym.primitive_module_sym,
    cs->im->cym.fnsym,
    default@[array[access_entry_id]](),
    RhsImpossible(void),
    VariadicGenerics({default@[array[ast_ident]](), {fake_ast_meta(), cs->im->cym.tee_sym}, mk_array({fake_ast_meta(), cs->im->cym.uee_sym})}),
    None(),
    Has({None(),
         @[type_properties]{
           cs->platform.fntraits.size,
           cs->platform.fntraits.alignment,
           DerivedMethodTrivial(void),
           DerivedMethodTrivial(void),
           DerivedMethodTrivial(void),
           DerivedMethodTrivial(void)
         }}),
    default@[array[deftype_inst_id]]()
  };
  id deftype_entry_id = add_deftype_entry(cs, ent);
  // TODO: We probably want to put the id in some kind of "primitive" or hyper-primitive module.
}

func add_magic_constructor_primitive(cs *checkstate, name sym, args size) void {
  var parms = repeat(args, ptr_type(cs, TeName({cs->im->cym.tee_sym, None()})));
  push(&parms, primitive_void_type(cs));
  type te_typeexpr = fn_type(cs, parms);
  add_def_primitive(cs, name, tee_generic(cs), type);
}

func add_magic_constructor_primitives(cs *checkstate) void {
  add_magic_constructor_primitive(cs, cs->im->cym.magic_init, 1);
  add_magic_constructor_primitive(cs, cs->im->cym.magic_copy, 2);
  add_magic_constructor_primitive(cs, cs->im->cym.magic_move, 2);
  add_magic_constructor_primitive(cs, cs->im->cym.magic_destroy, 1);
}
