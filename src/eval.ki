import check;

/* bnno = b.n.n.o. = "bytes" (not necessarily octets)

"sizes" are in bnno's -- in terms of the minimal addressable unit --
on the HP Saturn that'd be nibbles, on other systems it might be 16
bits.  The term "bnno" is used because "byte" is so likely to be
misinterpreted. */

deftype st_env struct {
  plat platform_info;

  objects array[opt[st_value]];

  // Indexed by cell_num.  Contains the number of the object representing the cell -- if the cell/object currently exists.
  framecells array[opt[st_obj_ref]];
};

func mk_env(plat platform_info, num_cells size) st_env {
  ret st_env = {plat, mk_array(), repeat(num_cells, None())};
  return ret;
}

deftype st_obj_num size;

deftype st_obj_ref struct {
  num st_obj_num;
  // The offset, in terms of bnnos
  offset u32;
  // The size, in terms of bnnos
  count u32;
};

func init_env(env *st_env, plat *platform_info, num_cells size) void {
  *env = {*plat, mk_array@[opt[st_value]](), repeat(num_cells, None())};
}

deftype st_symbol_name sym;

deftype st_symbolref struct {
  name st_symbol_name;
  offset u32;
  count u32;
};

deftype st_value struct {
  // Note: Even when targeting big-endian systems, the lsB of a word is the still the least-addressable byte of that chunk of memory in this code here.  So, a 32-bit value of "5" would be represented by the array {0x05000000} when we target big-endian systems.  (Middle-endian on 16-bit systems could be a thing too.)
  words array[u32];
  // Bits set to 1 for those bits (in [0:length)) that are not garbage, not covered by refs.
  datas array[u32];
  // The length of the value in bnnos.
  length u32;
  // Values of external symbol references -- they start at a bnno offset, and have some size that depends on what kind of symbolref it is (or what platform, some only have one kind).
  symbolrefs array[tup[u32, st_symbolref]];
  // Pointers to other objects -- they start at a bnno offset, and have a specific size (on the HP Saturn, 5 bnnos, or 20 bits).
  objrefs array[tup[u32, st_obj_ref]];
};

func ref_obj(env *st_env, num st_obj_num, out **st_value) bool {
  if case &Has(v st_value) = ref(&env->objects, num.~) {
    *out = &v;
    return true;
  } else {
    ERR(_u8("static evaluation accessing object that has been destroyed"));
    return false;
  }
}

func symbolref_size(plat *platform_info, sref *st_symbolref) u32 {
  return plat->fntraits.size;
}

func objref_size(plat *platform_info, oref *st_obj_ref) u32 {
  return plat->ptrtraits.size;
}

func copy_bnnos(plat *platform_info, src *array[u32], offset u32, count u32, dest *array[u32], dest_offset u32) void {
  bnno_size u32 = plat->bnno_size;
  mask u32 = (1 << bnno_size) - 1;
  per_word u32 = 32 / bnno_size;
  for i u32 = 0; i < count; i = i + 1 {
    si u32 = offset + i;
    x u32 = get(src, ~(si / per_word));
    y u32 = mask & (x >> (bnno_size * (si % per_word)));
    di u32 = dest_offset + i;
    d *u32 = ref(dest, ~(di / per_word));
    sh u32 = bnno_size * (di % per_word);
    z u32 = *d & ^(mask << sh);
    *d = z | (y << sh);
  }
}

func value_read(plat *platform_info, val *st_value, offset u32, ncount u32, out *st_value) void {
  end u32 = offset + ncount;
  if end > val->length {
    ice(_u8("static eval reading object out-of-bounds"));
  }
  refs array[tup[u32, st_symbolref]];
  val_nrefs size = count(&val->symbolrefs);
  for i size = 0; i < val_nrefs; i = i + 1 {
    vref *tup[u32, st_symbolref] = ref(&val->symbolrefs, i);
    vref_offset u32 = vref->car;
    vref_end u32 = vref_offset + symbolref_size(plat, &vref->cdr);
    if offset <= vref_offset && vref_end <= end {
      push(&refs, cons(vref_offset - offset, vref->cdr));
    }
  }

  objrefs array[tup[u32, st_obj_ref]];
  val_nobjrefs size = count(&val->objrefs);
  for i size = 0; i < val_nobjrefs; i = i + 1 {
    vref *tup[u32, st_obj_ref] = ref(&val->objrefs, i);
    vref_offset u32 = vref->car;
    vref_end u32 = vref_offset + objref_size(plat, &vref->cdr);
    if offset <= vref_offset && vref_end <= end {
      push(&objrefs, cons(vref_offset - offset, vref->cdr));
    }
  }

  bnnos_per_word u32 = 32 / plat->bnno_size;
  ws array[u32] = repeat(~ceil_divide(ncount, bnnos_per_word), 0);
  copy_bnnos(plat, &val->words, offset, ncount, &ws, 0);
  ds array[u32] = repeat(~ceil_divide(ncount, bnnos_per_word), 0);
  copy_bnnos(plat, &val->datas, offset, ncount, &ds, 0);

  *out = {ws, ds, ncount, refs, objrefs};
}

func obj_read(env *st_env, oref st_obj_ref, out *st_value) bool {
  val *st_value;
  if !ref_obj(env, oref.num, &val) {
    return false;
  }
  value_read(&env->plat, val, oref.offset, oref.count, out);
  return true;
}

func value_write(plat *platform_info, val *st_value, offset u32, ncount u32, in *st_value) void {
  if ncount != in->length {
    ice(_u8("value_write sees non-matching length"));
  }
  end u32 = offset + ncount;
  if end > val->length {
    ice(_u8("static eval writing object out-of-bounds"));
  }

  w size = 0;
  val_nrefs size = count(&val->symbolrefs);
  for i size = 0; i < val_nrefs; i = i + 1 {
    vref *tup[u32, st_symbolref] = ref(&val->symbolrefs, i);
    vref_offset u32 = vref->car;
    vref_end u32 = vref_offset + symbolref_size(plat, &vref->cdr);
    if vref_end <= offset || end <= vref_offset {
      set(&val->symbolrefs, w, *vref);
      w = w + 1;
    }
  }
  truncate(&val->symbolrefs, w);
  for i size = 0; i < count(&in->symbolrefs); i = i + 1 {
    sref *tup[u32, st_symbolref] = ref(&in->symbolrefs, i);
    push(&val->symbolrefs, cons(sref->car + offset, sref->cdr));
  }

  w = 0;
  val_nobjrefs size = count(&val->objrefs);
  for i size = 0; i < val_nobjrefs; i = i + 1 {
    vref *tup[u32, st_obj_ref] = ref(&val->objrefs, i);
    vref_offset u32 = vref->car;
    vref_end u32 = vref_offset + objref_size(plat, &vref->cdr);
    if vref_end <= offset || end <= vref_offset {
      set(&val->objrefs, w, *vref);
      w = w + 1;
    }
  }
  truncate(&val->objrefs, w);
  for i size = 0; i < count(&in->objrefs); i = i + 1 {
    iref *tup[u32, st_obj_ref] = ref(&in->objrefs, i);
    push(&val->objrefs, cons(iref->car + offset, iref->cdr));
  }

  copy_bnnos(plat, &in->words, 0, in->length, &val->words, offset);
  copy_bnnos(plat, &in->datas, 0, in->length, &val->datas, offset);
}

func obj_write(env *st_env, oref st_obj_ref, in *st_value) bool {
  if oref.count != in->length {
    ice(_u8("static eval writing object with non-matching length"));
  }
  val *st_value;
  if !ref_obj(env, oref.num, &val) {
    return false;
  }
  value_write(&env->plat, val, oref.offset, oref.count, in);
  return true;
}


func cell_obj_ref(env *st_env, num cell_num) st_obj_ref {
  if case &Has(obj_ref st_obj_ref) = ref(&env->framecells, num.~) {
    return obj_ref;
  } else {
    ice(_u8("static eval accessing inactive cell"));
    return fake();
  }
}

func add_obj(env *st_env, size u32) st_obj_num {
  ret st_obj_num;
  ret.~ = count(&env->objects);
  push(&env->objects, Has(mk_st_value(&env->plat, size)));
  return ret;
}

func mk_st_value(plat *platform_info, size u32) st_value {
  zeros array[u32] = repeat(~ceil_divide(size * plat->bnno_size, 32), 0);
  // Importantly, datas is initialized to all-zero, indicating all garbage.
  return {zeros, zeros, size, mk_array(), mk_array()};
}

func mk_ones(plat *platform_info, length u32) array[u32] {
  bitlength u32 = length * plat->bnno_size;
  n size = ~ceil_divide(bitlength, 32);
  ones array[u32] = repeat(n, 0xFFFFFFFF);
  extra u32 = bitlength % 32;
  if extra != 0 {
    set(&ones, n - 1, 0xFFFFFFFF >> (32 - bitlength));
  }
  return ones;
}

func mk_st_value_words(plat *platform_info, words array[u32], length u32) st_value {
  ones array[u32] = mk_ones(plat, length);
  return {words, ones, length, mk_array(), mk_array()};
}


func st_eval_def(cs *checkstate, ent def_entry_id, inst_id def_inst_id, out **st_value) bool {
  inst *def_inst = ref_inst(cs, inst_id);
  if inst->status != FinishedCheckingRhs(void) {
    ice(_u8("Evaling def we have not finished checking."));
  }

  check(is_defwise_trivial(&inst->computed_type_properties));

  fg *frame_regraphed;
  if case &Computed(ofg opt[frame_regraphed]) = &inst->graph {
    if case &Has(fg2 frame_regraphed) = &ofg {
      fg = &fg2;
    } else {
      ice(_u8("st_eval_def on prim or extern def"));
    }
  } else {
    ice(_u8("Evaling def whose graph we have not computed."));
  }

  switch &inst->evaled_value {
    case &NotComputed(v void): {
      inst->evaled_value = BeganComputing();
      env st_env = mk_env(cs->platform, count(&fg->gr.cells));

      result st_obj_ref;
      if !st_eval_frame_regraphed(cs, &env, fg, &result) {
        return false;
      }
      value st_value;
      if !obj_read(&env, result, &value) {
        return false;
      }
      inst->evaled_value = Computed(value);
      if case &Computed(x st_value) = &inst->evaled_value {
        *out = &x;
      } else {
        ice(_u8("locally impossible in st_eval_def"));
      }
      return true;
    }
    case &BeganComputing(v void): {
      ERR(_u8("recursively computing def inst's value"));
      return false;
    }
    case &FailedComputation(v void): {
      ERR(_u8("repeat error of st_eval_def"));
      return false;
    }
    case &Computed(x st_value): {
      *out = &x;
      return true;
    }
  }
}

defenum gr_stackent {
  EvalOpAndPrecs gr_num;
  EvalOp gr_num;
};

func st_eval_frame_regraphed(cs *checkstate, env *st_env, fg *frame_regraphed, out *st_obj_ref) bool {
  // A stack of gr_num's to evaluate, in order.
  stack array[gr_stackent];
  push(&stack, EvalOpAndPrecs(fg->gn));
  while case Has(se gr_stackent) = popval(&stack) {
    switch se {
    case EvalOpAndPrecs(gn gr_num):
      push(&stack, EvalOp(gn));
      node *gr_node = ref_node(&fg->gr, gn);
      // Push the stack such that we eval the precs left-to-right in static eval.
      nprecs size = count(&node->precs);
      for i size = nprecs; i > 0; {
        i = i - 1;
        push(&stack, EvalOpAndPrecs(get(&node->precs, i)));
      }
    case EvalOp(gn gr_num):
      node *gr_node = ref_node(&fg->gr, gn);
      switch &node->op {
      case &GrApply(a gr_apply):
        // TODO: Implement this (for prim ops at least).
        ERR(_u8("GrApply not implemented yet."));
        return false;
      case &GrMemCopy(a gr_memcopy):
        st_maybe_init_static(&fg->gr, env, a.dest);
        destref st_obj_ref = cell_obj_ref(env, a.dest);
        srcref st_obj_ref = cell_obj_ref(env, a.src);
        value st_value;
        obj_read(env, srcref, &value);
        obj_write(env, destref, &value);
      case &GrWriteConst(a gr_writeconst):
        st_maybe_init_static(&fg->gr, env, a.dest);
        destref st_obj_ref = cell_obj_ref(env, a.dest);
        switch &a.value {
        case &ConstInt(n bigint):
          // TODO: This should crash if the constant is out-of-range.
          return TODO();
        case &ConstDef(ip instpair):
          return TODO();
        case &ConstFnBody(fnid fn_body_id):
          return TODO();
        // TODO: Rename ConstBytes to ConstU8s.
        case &ConstBytes(arr array[u8]):
          value st_value = st_u8s_to_value(&env->plat, &arr);
          if !obj_write(env, destref, &value) {
            return false;
          }
        }
      default:
        ice(_u8("EvalOp not completely implemented."));
      }
    }
  }

  return TODO();
}

func st_u8s_to_value(plat *platform_info, arr *array[u8]) st_value {
  n size = count(arr);
  bitlength u32 = ~(n * 8);
  if bitlength % plat->bnno_size != 0 {
    ice(_u8("st_u8s_to_value sees misaligned value (on 16-bit bnno_size?)"));
  }
  length u32 = bitlength / plat->bnno_size;

  ret st_value = mk_st_value(plat, length);
  for i u32 = 0; i < length; i = i + 1 {
    bnno u32 = bnno_index_u8(plat, arr, i);
    tmp st_value = mk_st_value_bnno(plat, bnno);
    value_write(plat, &ret, i, 1, &tmp);
  }

  return ret;
}

func mk_st_value_bnno(plat *platform_info, bnno u32) st_value {
  check(0 == (bnno & ^((1 << plat->bnno_size) - 1)));
  return mk_st_value_words(plat, mk_array(bnno), 1);
}

func bnno_index_u8(plat *platform_info, arr *array[u8], ix u32) u32 {
  if plat->bnno_size == 8 {
    return ~get(arr, ~ix);
  } else if plat->bnno_size == 4 {
    return ~get(arr, ~((ix / 2) >> (4 * (ix % 2))));
  } else if plat->bnno_size == 16 {
    lo u32 = ~get(arr, ~(ix * 2));
    hi u32 = ~get(arr, ~(ix * 2 + 1));
    return lo + (hi << 8);
  } else {
    ice(_u8("bnno_index_u8 does not support bnno_size"));
    return fake();
  }
}

func st_maybe_init_static(gr *frame_graph, env *st_env, cell cell_num) void {
  if isHas(ref(&env->framecells, cell.~)) {
    return;
  }
  info *cell_info = ref_cell(gr, cell);
  if !isLocationStatic(*unHas(&info->location)) {
    ice(_u8("st_maybe_init_static: cell with non-static location"));
  }

  objnum st_obj_num = add_obj(env, info->props.flat_size);
  set(&env->framecells, cell.~, Has@[st_obj_ref]({objnum, 0, info->props.flat_size}));
}