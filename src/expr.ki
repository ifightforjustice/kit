import state;

deftype exprscope struct {
  cs *checkstate;
  // Same as cs->im.
  im *identmap;
  clq *clqueue;
  // Generics and their _complete_ replacements.
  generics *ast_generics;
  parms *genparms;
};

defenum allow_incomplete {
  AllowIncompleteNo void;
  AllowIncompleteYes void;
};

func `==`(x allow_incomplete, y allow_incomplete) bool {
  return enumnum(&x) == enumnum(&y);
}

func check_expr(cs *checkstate, clq *clqueue, g *ast_generics, parms *genparms, x *ast_expr, pt *te_typeexpr) bool {
  es exprscope = {cs, cs->im, clq, g, parms};
  return check_expr_ai(&es, AllowIncompleteNo(void), x, pt);
}

deftype global_info struct {
  ent def_entry_id;
  inst def_inst_id;
};

defenum name_info {
  Local void;
  Global global_info;
};

defenum es_match_res {
  NoMatch void;
  AmbigGlobalMatch void;
  OneGlobalMatch global_info;
  OneLocalMatch void;
};

func replaced_name_parms(es *exprscope, a *ast_name_expr, out *opt[array[te_typeexpr]]) bool {
  if case &Has(arr array[ast_typeexpr]) = &a->generic_params {
    replaced array[te_typeexpr];
    n size = count(&arr);
    for i size = 0; i < n; i = i + 1 {
      converted te_typeexpr;
      if !convert_typeexpr(es->cs, ref(&arr, i), &converted) {
        return false;
      }
      computed te_typeexpr;
      computed_complete bool;
      if !check_and_compute_typeexpr(es->cs, es->clq, es->generics, es->parms, &converted, &computed, &computed_complete) {
        return false;
      }
      push(&replaced, computed);
    }
    *out = Has(replaced);
    return true;
  } else {
    *out = None();
    return true;
  }
}

func es_lookup_name(es *exprscope, name sym, params *opt[array[te_typeexpr]], res_out *es_match_res) bool {
  return TODO();
}


func check_expr_ai(es *exprscope, ai allow_incomplete, x *ast_expr, pt *te_typeexpr) bool {
  switch &x->u {
    case &NameExpr(a ast_name_expr): {
      parms opt[array[te_typeexpr]];
      if !replaced_name_parms(es, &a, &parms) {
        return false;
      }
      match_res es_match_res;
      if !es_lookup_name(es, a.ident.value, &parms, &match_res) {
        return false;
      }
      switch &match_res {
        case &NoMatch(v void): {
          ERR(_u8("Name lookup for '"), lookup(es->im, a.ident.value), _u8("', maybe with parms, not found."));
          return false;
        }
        case &AmbigGlobalMatch(v void): {
          if ai == AllowIncompleteYes(void) {
            return TODO();
          } else {
            ERR(_u8("Name lookup for '"), lookup(es->im, a.ident.value), _u8("', maybe with parms, matches ambiguously."));
            return false;
          }
        }
        case &OneGlobalMatch(gi global_info): {
          return TODO();
        }
        case &OneLocalMatch(v void): {
          return TODO();
        }
      }
      return TODO();
    }
    case &ParenExpr(a ast_paren_expr): {
      return TODO();
    }
    case &NumericLiteral(a ast_numeric_literal): {
      return TODO();
    }
    case &BoolLiteral(a ast_bool_literal): {
      return TODO();
    }
    case &VoidLiteral(a ast_void_literal): {
      return TODO();
    }
    case &NullLiteral(a ast_null_literal): {
      return TODO();
    }
    case &CharLiteral(a ast_char_literal): {
      return TODO();
    }
    case &StringLiteral(a ast_string_literal): {
      return TODO();
    }
    case &Funcall(a ast_funcall): {
      return TODO();
    }
    case &IndexExpr(a ast_index_expr): {
      return TODO();
    }
    case &Lambda(a ast_lambda): {
      return TODO();
    }
    case &LocalField(a ast_local_field): {
      return TODO();
    }
    case &DerefField(a ast_deref_field): {
      return TODO();
    }
    case &TypedExpr(a ast_typed_expr): {
      return TODO();
    }
    case &Strinit(a ast_strinit): {
      return TODO();
    }
  }
}
