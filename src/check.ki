import ast;
import parse;
import tok;
import typeexpr;
import shp;
import u8ast;

deftype common_syms struct {
  fn sym;
};

deftype checkstate struct {
  im *identmap;
  cym common_syms;
  loader fn[sym, opt[array[u8]]];

  modules array[shp[module]];
  modules_by_name hash[sym, module_id];

  instantiations array[shp[def_inst]];
  type_instantiations array[shp[deftype_inst]];
  alias_instantiations array[shp[alias_inst]];

  deftypes array[shp[deftype_entry]];
  deftypes_by_name hash[sym, array[deftype_entry_id]];

  aliases array[shp[alias_entry]];
  aliases_by_name hash[sym, array[alias_entry_id]];

  defs array[shp[def_entry]];
  defs_by_name hash[sym, array[def_entry_id]];
};

// An index into checkstate's modules array.
deftype module_id size;
def `~` fn[size, module_id] = wrapconvert;

// An index into checkstate's instantiations array.
deftype def_inst_id size;
def `~` fn[size, def_inst_id] = wrapconvert;

// An index into checkstate's type_instantiations array.
deftype deftype_inst_id size;
def `~` fn[size, deftype_inst_id] = wrapconvert;
def `==` fn[deftype_inst_id, deftype_inst_id, bool] = wrapequate;

// An index into checkstat's alias_instantiations array.
deftype alias_inst_id size;
def `~` fn[size, alias_inst_id] = wrapconvert;

// An index into checkstate's defs array.
deftype def_entry_id size;
def `~` fn[size, def_entry_id] = wrapconvert;

// An index into checkstate's deftypes array.
deftype deftype_entry_id size;
def `~` fn[size, deftype_entry_id] = wrapconvert;

// An index into checkstate's aliases array.
deftype alias_entry_id size;
def `~` fn[size, alias_entry_id] = wrapconvert;

func ref_module(cs *checkstate, id module_id) *module {
  return oo(ref(&cs->modules, id.~));
}

func ref_def_entry(cs *checkstate, id def_entry_id) *def_entry {
  return oo(ref(&cs->defs, id.~));
}

func ref_deftype_entry(cs *checkstate, id deftype_entry_id) *deftype_entry {
  return oo(ref(&cs->deftypes, id.~));
}

func ref_alias_entry(cs *checkstate, id alias_entry_id) *alias_entry {
  return oo(ref(&cs->aliases, id.~));
}

func ref_inst(cs *checkstate, id def_inst_id) *def_inst {
  return oo(ref(&cs->instantiations, id.~));
}

func ref_deftype_inst(cs *checkstate, id deftype_inst_id) *deftype_inst {
  return oo(ref(&cs->type_instantiations, id.~));
}

func ref_alias_inst(cs *checkstate, id alias_inst_id) *alias_inst {
  return oo(ref(&cs->alias_instantiations, id.~));
}

func add_inst(cs *checkstate, val def_inst) def_inst_id {
  id def_inst_id = ~count(&cs->instantiations);
  push(&cs->instantiations, emshp(val));
  return id;
}

func add_deftype_inst(cs *checkstate, val deftype_inst) deftype_inst_id {
  id deftype_inst_id = ~count(&cs->type_instantiations);
  push(&cs->type_instantiations, emshp(val));
  return id;
}

func add_alias_inst(cs *checkstate, val alias_inst) alias_inst_id {
  id alias_inst_id = ~count(&cs->alias_instantiations);
  push(&cs->alias_instantiations, emshp(val));
  return id;
}

defenum module_process_state {
  Unprocessed void;
  Processing void;
  DoneProcessing void;
};

func `==`(a module_process_state, b module_process_state) bool {
  return enumnum(&a) == enumnum(&b);
}

deftype module struct {
  module_name sym;
  file ast_file;
  buf array[u8];
  process_state module_process_state;
  // vvv  Valid when process_state == DoneProcessing.  vvv
  defs array[def_entry_id];
  deftypes array[deftype_entry_id];
  aliases array[alias_entry_id];
};

defenum deftype_inst_status {
  DidNotStartChecking void;
  StartedChecking void;
  FinishedChecking void;
  FailedChecking void;
};

// Describes the behavior of init/copy/move/destroy methods.
defenum derived_method_behavior {
  // Behavior's explicitly defined by a method.
  DerivedMethodExplicit def_inst_id;
  // Behavior's derived structurally, and one of its fields/constructors has an explicit method call.
  // TODO: This should be defined in one place by a method, and should have a def_inst_id.
  DerivedMethodNontrivial void;
  // Behavior's derived from the type definition (or it's primitive) and it's trivial. init: Fills with zero.  copy/move: memcpy.  destroy: no-op.
  DerivedMethodTrivial void;
};

func isTrivial(behav derived_method_behavior) bool {
  if case DerivedMethodTrivial(v void) = behav {
    return true;
  }
  return false;
}

func trivialOrNot(is_trivial bool) derived_method_behavior {
  if is_trivial {
    return DerivedMethodTrivial(void);
  } else {
    return DerivedMethodNontrivial(void);
  }
}

deftype type_properties struct {
  flat_size u32;
  flat_alignment u32;
  init_behavior derived_method_behavior;
  move_behavior derived_method_behavior;
  copy_behavior derived_method_behavior;
  destroy_behavior derived_method_behavior;
};

// TODO: This function is BS, now that type_properties has behavior fields.
func to_defclass_properties(props type_properties) type_properties {
  return props;
}

deftype deftype_inst struct {
  parms genparms;
  status deftype_inst_status;
  properties opt[type_properties];
};

deftype deftype_entry struct {
  module_name sym;
  name sym;
  tl *ast_type_def;

  insts array[deftype_inst_id];
};

func mk(module_name sym, name sym, tl *ast_type_def) deftype_entry {
  return {module_name, name, tl, default()};
}

deftype alias_inst struct {
  parms genparms;
  // Is None() while we're in the process of expansion -- seeing None() means you're recursively expanding.
  expanded opt[te_typeexpr];
};

deftype alias_entry struct {
  module_name sym;
  alias_name sym;
  tl *ast_type_alias;

  insts array[alias_inst_id];
};

func mk(module_name sym, alias_name sym, tl *ast_type_alias) alias_entry {
  return {module_name, alias_name, tl, default()};
}

defenum genparms {
  NoParms void;
  HasParms array[te_typeexpr];
};

deftype def_inst struct {
  parms genparms;
  // Our own copy of the def, which we can annotate.  It does not have its generics replaced.
  ast ast_def;
  computed_type_computed bool;
  // Valid only if computed_type_computed.
  // Becomes the concrete type (with generics replaced) once we've computed it and checked it.
  computed_type te_typeexpr;
  computed_type_properties opt[type_properties];
};

func mk(parms genparms, a ast_def) def_inst {
  return {parms, a, false, default(), None()};
}

deftype def_entry struct {
  module_name sym;
  def_name sym;
  // A copy of the ast_def's generics field -- if it's an ast_extern_def, this is NoGenerics.
  generics ast_generics;
  // This is either the syntactic typeexpr or converted from a shallow look at the RHS.
  typeexpr ast_typeexpr;
  tl *ast_toplevel;

  insts array[def_inst_id];
};

func mk(module_name sym, def_name sym, generics ast_generics, typeexpr ast_typeexpr, tl *ast_toplevel) def_entry {
  return {module_name, def_name, generics, typeexpr, tl, default()};
}

deftype clqueue_deftype_entry struct {
  ent_id deftype_entry_id;
  inst_id deftype_inst_id;
};

defenum clqueue_entry {
  ClqDeftypeEntry clqueue_deftype_entry;
};

deftype clqueue struct {
  entries array[clqueue_entry];
};

func finish_checking(cs *checkstate, clq *clqueue) bool {
  while case Has(entry clqueue_entry) = popval(&clq->entries) {
    switch &entry {
      case &ClqDeftypeEntry(e clqueue_deftype_entry): {
        if !ensure_deftype_inst_checked(cs, clq, ref_deftype_entry(cs, e.ent_id), e.inst_id) {
          return false;
        }
      }
    }
  }
  return true;
}

func check_module(cs *checkstate, mod_name sym) bool {
  switch process_module(cs, mod_name) {
    case None(v): {
      return false;
    }
    case Has(id module_id): {
      mod *module = ref_module(cs, id);
      ndefs size = count(&mod->defs);
      for i size = 0; i < ndefs; i = i + 1 {
        if !ensure_def_checked(cs, get(&mod->defs, i)) {
          return false;
        }
      }

      ndeftypes size = count(&mod->deftypes);
      for i size = 0; i < ndeftypes; i = i + 1 {
        if !ensure_deftype_checked(cs, get(&mod->deftypes, i)) {
          return false;
        }
      }

      naliases size = count(&mod->aliases);
      for i size = 0; i < naliases; i = i + 1 {
        if !ensure_alias_checked(cs, get(&mod->aliases, i)) {
          return false;
        }
      }

      // I guess that's everything.
      // TODO: Check that access blocks point to an actual type?
      return true;
    }
  }
}

func find_matching_inst(cs *checkstate, insts *array[def_inst_id], parms *genparms) opt[def_inst_id] {
  n size = count(insts);
  for i size = 0; i < n; i = i + 1 {
    id def_inst_id = get(insts, i);
    inst *def_inst = ref_inst(cs, id);
    if parms_equal(cs, parms, &inst->parms) {
      return Has(id);
    }
  }
  return None();
}

func parms_equal(cs *checkstate, a *genparms, b *genparms) bool {
  if enumnum(a) != enumnum(b) {
    return false;
  }
  switch a {
    case &NoParms(v void): { return true; }
    case &HasParms(ah array[te_typeexpr]): {
      switch b {
        case &HasParms(bh array[te_typeexpr]): {
          return typeexpr_list_equal(cs, &ah, &bh);
        }
      }
    }
  }
}

func arity(parms *genparms) generics_arity {
  switch parms {
    case &NoParms(v void): { return NoParamsArity(void); }
    case &HasParms(arr array[te_typeexpr]): { return FiniteArity(~count(&arr)); }
  }
}

func ensure_def_checked_with_parms(cs *checkstate, clq *clqueue, ent *def_entry, a *ast_def, parms *genparms) bool {
  // TODO: Do we know that the def's generics don't shadow something?
  check(arity(&a->generics) == arity(parms));

  if case Has(id) = find_matching_inst(cs, &ent->insts, parms) {
    // If we already have an inst, that means we made an inst.

    inst *def_inst = ref_inst(cs, id);
    if !inst->computed_type_computed {
      ERR(_u8("computing def's type arouses cyclic dependency"), lookup(cs->im, ent->def_name));
      return false;
    }

    return true;
  }

  id def_inst_id = add_inst(cs, mk(*parms, *a));
  inst *def_inst = ref_inst(cs, id);
  // TODO: We ignore is_export entirely.  Is it relevant at all?
  a = &inst->ast;

  // TODO: We need to check exact name shadowing(?), typeexpr, and rhs.

  // Important:  We check the typeexpr first.  If that typeexpr cyclically refers to this def, we fail.  If there is no typeexpr, we need to compute it from the rhs (and that also needs to not depend cyclically on this def's own typeexpr).
  computed_complete bool;
  computed te_typeexpr;
  if !check_and_compute_typeexpr(cs, clq, &a->generics, &inst->parms, &ent->typeexpr, &computed, &computed_complete) {
    return false;
  }
  check(computed_complete);
  props type_properties;
  if !compute_type_properties(cs, clq, &computed, &props) {
    return false;
  }
  inst->computed_type_computed = true;
  inst->computed_type = computed;
  inst->computed_type_properties = Has(props);

  // TODO: How do we know that a->generics doesn't shadow, doesn't self-shadow?
  complete_type te_typeexpr;
  if !check_expr(cs, &a->generics, &inst->parms, &inst->computed_type, &a->rhs, &complete_type) {
    return false;
  }
  return true;
}

func check_and_compute_typeexpr(cs *checkstate, clq *clqueue, g *ast_generics, parms *genparms, t *ast_typeexpr, computed_out *te_typeexpr, computed_complete_out *bool) bool {
  switch t {
    case &Name(a ast_ident): {
      if !check_and_compute_name_type(cs, clq, g, parms, &a, computed_out) {
        return false;
      }
      *computed_complete_out = true;
      return true;
    }
    case &App(a ast_typeapp): {
      return check_and_compute_app_type(cs, clq, g, parms, &a, computed_out, computed_complete_out);
    }
    case &Struct(a ast_struct): {
      computed_fields_complete bool;
      computed_fields array[te_vardecl];
      if !help_check_fields(cs, clq, g, parms, &a.fields, &computed_fields, &computed_fields_complete) {
        return false;
      }
      *computed_out = TeStruct({computed_fields});
      *computed_complete_out = computed_fields_complete;
      return true;
    }
    case &Enum(a ast_enum): {
      // TODO: For enums, field names are constructors.  Check shadowing?
      computed_constructors_complete bool;
      computed_constructors array[te_vardecl];
      if !help_check_fields(cs, clq, g, parms, &a.constructors, &computed_constructors, &computed_constructors_complete) {
        return false;
      }
      *computed_out = TeEnum({computed_constructors});
      *computed_complete_out = computed_constructors_complete;
      return true;
    }
    case &Union(a ast_union): {
      computed_fields_complete bool;
      computed_fields array[te_vardecl];
      if !help_check_fields(cs, clq, g, parms, &a.fields, &computed_fields, &computed_fields_complete) {
        return false;
      }
      *computed_out = TeUnion({computed_fields});
      *computed_complete_out = computed_fields_complete;
      return true;
    }
    case &Arraytype(a ast_arraytype): {
      param box[te_typeexpr];
      param_complete bool;
      if !check_and_compute_typeexpr(cs, clq, g, parms, oo(&a.param), oo(&param), &param_complete) {
        return false;
      }
      if case &Has(b box[ast_expr]) = &a.count {
        count u32;
        if !fake_eval_arraytype_count(oo(&b), &count) {
          return false;
        }
        *computed_out = TeArraytype({Has(count), param});
        *computed_complete_out = param_complete;
        return true;
      } else {
        *computed_out = TeArraytype({None(), param});
        *computed_complete_out = false;
        return true;
      }
    }
    case &Unknown(a ast_unknown): {
      *computed_out = TeUnknown(void);
      *computed_complete_out = false;
      return true;
    }
  }
}

func numeric_literal_to_u32(x *ast_numeric_literal, out *u32) bool {
  switch x {
    case &HexLiteral(a ast_hex_literal): {
      return convert_to_u32(16, &a.digits, out);
    }
    case &DecLiteral(a ast_dec_literal): {
      return convert_to_u32(10, &a.digits, out);
    }
  }
}

func convert_to_u32(base i8, digits *array[i8], out *u32) bool {
  check(base > 0);
  acc u32 = 0;
  n size = count(digits);
  for i size = 0; i < n; i = i + 1 {
    if !try_mul(acc, @[u32]~base, &acc) {
      return false;
    }
    if !try_add(acc, @[u32]~get(digits, i), &acc) {
      return false;
    }
  }
  *out = acc;
  return true;
}

func fake_eval_arraytype_count(x *ast_expr, count_out *u32) bool {
  // TODO: Remove this function and really evaluate an array's count expression.
  switch x {
    case &NumericLiteral(a ast_numeric_literal): {
      return numeric_literal_to_u32(&a, count_out);
    }
    default: {
      ERR(_u8("Array types (for now) must have a numeric literal for length (or _)."));
      return false;
    }
  }
}

func help_check_fields(cs *checkstate, clq *clqueue, g *ast_generics, parms *genparms, a *array[ast_vardecl], computed_fields_out *array[te_vardecl], computed_fields_complete_out *bool) bool {
  n size = count(a);
  all_complete bool = true;
  all_computed array[te_vardecl];
  for i size = 0; i < n; i = i + 1 {
    decl *ast_vardecl = ref(a, i);
    for j size = 0; j < i; j = j + 1 {
      if ref(a, j)->name.value == decl->name.value {
        ERR(_u8("Duplicate field name "), lookup(cs->im, decl->name.value));
        return false;
      }
    }
    complete bool;
    computed te_typeexpr;
    if !check_and_compute_typeexpr(cs, clq, g, parms, &decl->type, &computed, &complete) {
      return false;
    }
    all_complete = all_complete & complete;
    push(&all_computed, {decl->name.value, computed});
  }
  *computed_fields_out = all_computed;
  *computed_fields_complete_out = all_complete;
  return true;
}

func check_and_compute_name_type(cs *checkstate, clq *clqueue, g *ast_generics, parms *genparms, a *ast_ident, computed_out *te_typeexpr) bool {
  // Generic parameters have already been checked.  (I hope so.)
  if lookup_generic(g, parms, a->value, computed_out) {
    return true;
  }

  matching_alias opt[alias_entry_id];
  if !match_alias(cs, a->value, None(), &matching_alias) {
    // An error happened when looking up an alias (multiple matches?).
    return false;
  }
  matching_deftype opt[deftype_entry_id];
  if !match_deftype(cs, a->value, None(), &matching_deftype) {
    // An error happened when looking up a deftype (multiple matches?).
    return false;
  }

  if case Has(id) = matching_alias {
    if case Has(deftype_id) = matching_deftype {
      ERR(_u8("Both an alias and deftype match for name "), lookup(cs->im, a->value));
      return false;
    }
    np genparms = NoParms(void);
    return check_and_compute_alias_with_parms(cs, clq, ref_alias_entry(cs, id), &np, computed_out);
  } else {
    if case Has(id) = matching_deftype {
      np genparms = NoParms(void);
      inst_id deftype_inst_id = enqueue_deftype_inst(cs, clq, id, &np);
      *computed_out = TeName({a->value, {id, inst_id}});
      return true;
    } else {
      ERR(_u8("type name has no match "), lookup(cs->im, a->value));
      return false;
    }
  }
}

func check_and_compute_typeexpr_array(cs *checkstate, clq *clqueue, g *ast_generics, parms *genparms, t *array[ast_typeexpr], computed_out *array[te_typeexpr], computed_complete_out *bool) bool {
  complete bool = true;
  computed array[te_typeexpr];
  n size = count(t);
  for i size = 0; i < n; i = i + 1 {
    c te_typeexpr;
    c_complete bool;
    if !check_and_compute_typeexpr(cs, clq, g, parms, ref(t, i), &c, &c_complete) {
      return false;
    }
    push(&computed, c);
    complete = complete & c_complete;
  }
  *computed_out = computed;
  *computed_complete_out = complete;
  return true;
}

func check_and_compute_app_type(cs *checkstate, clq *clqueue, g *ast_generics, parms *genparms, a *ast_typeapp, computed_out *te_typeexpr, computed_complete_out *bool) bool {
  params_complete bool;
  params array[te_typeexpr];
  if !check_and_compute_typeexpr_array(cs, clq, g, parms, &a->params, &params, &params_complete) {
    return false;
  }

  if case &Name(f ast_ident) = oo(&a->typefunc) {
    matching_alias opt[alias_entry_id];
    if !match_alias(cs, f.value, Has(&params), &matching_alias) {
      return false;
    }
    matching_deftype opt[deftype_entry_id];
    if !match_deftype(cs, f.value, Has(&params), &matching_deftype) {
      return false;
    }

    if case Has(id) = matching_alias {
      if case Has(deftype_id) = matching_deftype {
        ERR(_u8("Both an alias and deftype match for name/params "), lookup(cs->im, f.value));
        return false;
      }
      if params_complete {
        hp genparms = HasParms(params);
        if !check_and_compute_alias_with_parms(cs, clq, ref_alias_entry(cs, id), &hp, computed_out) {
          return false;
        }
        *computed_complete_out = true;
        return true;
      } else {
        *computed_out = TeApp({embox(TePureName(f.value)), params, None()});
        *computed_complete_out = false;
        return true;
      }
    } else {
      if case Has(id) = matching_deftype {
        if params_complete {
          hp genparms = HasParms(params);
          inst_id deftype_inst_id = enqueue_deftype_inst(cs, clq, id, &hp);
          *computed_out = TeApp({embox(TePureName(f.value)), params, Has({id, inst_id})});
        } else {
          *computed_out = TeApp({embox(TePureName(f.value)), params, None()});
        }
        *computed_complete_out = params_complete;
        return true;
      } else {
        ERR(_u8("type name/params has no match "), lookup(cs->im, f.value));
        return false;
      }
    }
  } else if case &Unknown(u ast_unknown) = oo(&a->typefunc) {
    *computed_out = TeApp({embox(TePureUnknown(void)), params, None()});
    *computed_complete_out = false;
    return true;
  } else {
    ERR(_u8("Fancy type expression '"), to_u8str(*oo(&a->typefunc)), _u8("' in typefunc position."));
    return false;
  }
}

func find_matching_alias_inst(cs *checkstate, insts *array[alias_inst_id], parms *genparms) opt[alias_inst_id] {
  n size = count(insts);
  for i size = 0; i < n; i = i + 1 {
    id alias_inst_id = get(insts, i);
    inst *alias_inst = ref_alias_inst(cs, id);
    if parms_equal(cs, parms, &inst->parms) {
      return Has(id);
    }
  }
  return None();
}

func check_and_compute_alias_with_parms(cs *checkstate, clq *clqueue, ent *alias_entry, parms *genparms, computed_out *te_typeexpr) bool {
  // TODO: How do we know the alias's generic parameters don't self-shadow, or shadow something else?

  if case Has(id) = find_matching_alias_inst(cs, &ent->insts, parms) {
    inst *alias_inst = ref_alias_inst(cs, id);
    // If we already have an inst, that means we made an inst.
    if case &Has(computed te_typeexpr) = &inst->expanded {
      // We already computed the expansion for these types!
      *computed_out = computed;
      return true;
    } else {
      // We're in the process of expanding this type.  We recursively expanded.
      ERR(_u8("Recursively expanding alias "), lookup(cs->im, ent->alias_name));
      return false;
    }
  }

  id alias_inst_id = add_alias_inst(cs, {*parms, None()});
  inst *alias_inst = ref_alias_inst(cs, id);

  complete bool;
  computed te_typeexpr;
  if !check_and_compute_typeexpr(cs, clq, &ent->tl->generics, &inst->parms, &ent->tl->rhs, &computed, &complete) {
    return false;
  }
  // There's no way an alias expansion can't be complete, because ast_unknown is disallowed when parsing its RHS (and the parms must be complete).
  check(complete);
  check(isNone(&inst->expanded));
  inst->expanded = Has(computed);
  *computed_out = computed;
  return true;
}

func arity_matches(a *ast_generics, params opt[*array[te_typeexpr]]) bool {
  ar generics_arity;
  if case Has(p) = params {
    ar = FiniteArity(~count(p));
  } else {
    ar = NoParamsArity(void);
  }
  lhs_arity generics_arity = arity(a);
  return lhs_arity == ar;
}

func match_deftype(cs *checkstate, name sym, params opt[*array[te_typeexpr]], out *opt[deftype_entry_id]) bool {
  if case Has(arr *array[deftype_entry_id]) = lookup_ref(&cs->deftypes_by_name, name) {
    n size = count(arr);
    match opt[deftype_entry_id];
    for i size = 0; i < n; i = i + 1 {
      id deftype_entry_id = get(arr, i);
      ent *_ = ref_deftype_entry(cs, id);
      if arity_matches(&ent->tl->generics, params) {
        if case Has(alt_id) = match {
          ERR(_u8("Multiple deftypes named '"), lookup(cs->im, name), _u8("' match arity"));
          return false;
        }
        match = Has(id);
      }
    }
    if case Has(id) = match {
      *out = match;
      return true;
    } else {
      return false;
    }
  } else {
    return false;
  }
}

func match_alias(cs *checkstate, name sym, params opt[*array[te_typeexpr]], out *opt[alias_entry_id]) bool {
  if case Has(arr *array[alias_entry_id]) = lookup_ref(&cs->aliases_by_name, name) {
    n size = count(arr);
    match opt[alias_entry_id];
    for i size = 0; i < n; i = i + 1 {
      id alias_entry_id = get(arr, i);
      ent *_ = ref_alias_entry(cs, id);
      if arity_matches(&ent->tl->generics, params) {
        if case Has(alt_id) = match {
          ERR(_u8("Multiple aliases named '"), lookup(cs->im, name), _u8("' match arity"));
          return false;
        }
        match = Has(id);
      }
    }
    if case Has(id) = match {
      *out = match;
      return true;
    } else {
      return false;
    }
  } else {
    return false;
  }
}

func lookup_generic(g *ast_generics, parms *genparms, name sym, out *te_typeexpr) bool {
  switch g {
    case &NoGenerics(v): { return false; }
    case &HasGenerics(a array[ast_ident]): {
      n size = count(&a);
      for i size = 0; i < n; i = i + 1 {
        if ref(&a, i)->value == name {
          if case &HasParms(ps) = parms {
            *out = *ref(&ps, i);
            return true;
          } else {
            crash(_u8("non-matching parms"));
          }
        }
      }
      return false;
    }
  }
}

func check_expr(cs *checkstate, g *ast_generics, parms *genparms, pt *te_typeexpr, x *ast_expr, computed_out *te_typeexpr) bool {
  return TODO();
}

func ensure_def_checked(cs *checkstate, id def_entry_id) bool {
  ent *def_entry = ref_def_entry(cs, id);
  switch ent->tl {
    case &Def(a ast_def): {
      switch &a.generics {
        case &NoGenerics(v): {
          parms genparms = NoParms(void);
          clq clqueue;
          if !ensure_def_checked_with_parms(cs, &clq, ent, &a, &parms) {
            return false;
          }
          return finish_checking(cs, &clq);
        }
        case &HasGenerics(ig): {
          // We declare success -- we check non-generic defs.
          // TODO: Somewhere we have to check def generics shadowing.
          return true;
        }
      }
    }
    case &ExternDef(a ast_extern_def): {
      // TODO: We could check that function args for C calling convention functions are primitively copyable.
      // TODO: It is unclear that ast_extern_def defs should have a def_entry.
      np genparms = NoParms(void);
      ng ast_generics = NoGenerics(void);
      clq clqueue;
      computed_complete bool;
      computed te_typeexpr;
      if !check_and_compute_typeexpr(cs, &clq, &ng, &np, &a.type, &computed, &computed_complete) {
        return false;
      }
      // The parser shouldn't allow incomplete types.
      check(computed_complete);
      return finish_checking(cs, &clq);
    }
    default: {
      ice(_u8("def_entry has invalid toplevel\n"));
      return fake();
    }
  }
}

func find_matching_deftype_inst(cs *checkstate, insts *array[deftype_inst_id], parms *genparms) opt[deftype_inst_id] {
  n size = count(insts);
  for i size = 0; i < n; i = i + 1 {
    id deftype_inst_id = get(insts, i);
    inst *deftype_inst = ref_deftype_inst(cs, id);
    if parms_equal(cs, parms, &inst->parms) {
      return Has(id);
    }
  }
  return None();
}

func deftype_rhs_type(rhs *ast_type_def_rhs) *ast_typeexpr {
  switch rhs {
    case &TypeexprRhs(a): { return &a; }
    case &ClassexprRhs(a): { return &a.rhs_type; }
  }
}

func enqueue_deftype_inst(cs *checkstate, clq *clqueue, id deftype_entry_id, parms *genparms) deftype_inst_id {
  var res = ensure_deftype_inst(cs, ref_deftype_entry(cs, id), parms);
  if res.created {
    push(&clq->entries, ClqDeftypeEntry({id, res.id}));
  }
  return res.id;
}

func ensure_deftype_inst(cs *checkstate, ent *deftype_entry, parms *genparms) struct { id deftype_inst_id; created bool; } {
  check(arity(&ent->tl->generics) == arity(parms));
  if case Has(id) = find_matching_deftype_inst(cs, &ent->insts, parms) {
    return {id, false};
  }
  var id = add_deftype_inst(cs, {*parms, DidNotStartChecking(void), None()});
  return {id, true};
}

func compute_pack_properties(cs *checkstate, clq *clqueue, pack *te_instpack, out *type_properties) bool {
  if !ensure_deftype_inst_checked(cs, clq, ref_deftype_entry(cs, pack->ent_id), pack->inst_id) {
    return false;
  }
  inst *deftype_inst = ref_deftype_inst(cs, pack->inst_id);
  if case &Has(props) = &inst->properties {
    *out = props;
    return true;
  } else {
    ice(_u8("ensure_deftype_inst_checked did not compute properties."));
    return fake();
  }
}

// t had better be complete.
func compute_type_properties(cs *checkstate, clq *clqueue, t *te_typeexpr, out *type_properties) bool {
  switch t {
    case &TeName(a te_name): {
      return compute_pack_properties(cs, clq, &a.pack, out);
    }
    case &TeApp(a te_typeapp): {
      if case &Has(pack te_instpack) = &a.pack {
        return compute_pack_properties(cs, clq, &pack, out);
      } else {
        ice(_u8("compute_type_properties called on incomplete app type."));
        return fake();
      }
    }
    case &TeStruct(a te_struct): {
      offset u32 = 0;
      max_alignment u32 = 1;
      init_trivial bool = true;
      move_trivial bool = true;
      copy_trivial bool = true;
      destroy_trivial bool = true;
      n size = count(&a.fields);
      for i size = 0; i < n; i = i + 1 {
        props type_properties;
        if !compute_type_properties(cs, clq, &ref(&a.fields, i)->type, &props) {
          return false;
        }
        offset = ceil_aligned(offset, props.flat_alignment);
        offset = offset + props.flat_size;
        max_alignment = max(max_alignment, props.flat_alignment);
        init_trivial = init_trivial & isTrivial(props.init_behavior);
        move_trivial = move_trivial & isTrivial(props.move_behavior);
        copy_trivial = copy_trivial & isTrivial(props.copy_behavior);
        destroy_trivial = destroy_trivial & isTrivial(props.destroy_behavior);
      }
      check(offset % max_alignment == 0);
      *out = {offset, max_alignment, trivialOrNot(init_trivial),
              trivialOrNot(move_trivial), trivialOrNot(copy_trivial),
              trivialOrNot(destroy_trivial)};
      return true;
    }
    case &TeEnum(a te_enum): {
      // TODO: This is deeply married to implementation-specific behavior.
      tag_size u32 = 4;
      max_size u32 = tag_size;
      max_alignment u32 = tag_size;
      init_trivial bool = true;
      move_trivial bool = true;
      copy_trivial bool = true;
      destroy_trivial bool = true;
      n size = count(&a.constructors);
      for i size = 0; i < n; i = i + 1 {
        props type_properties;
        if !compute_type_properties(cs, clq, &ref(&a.constructors, i)->type, &props) {
          return false;
        }
        tagged_size u32 = ceil_aligned(tag_size, props.flat_alignment) + props.flat_size;
        max_size = max(max_size, tagged_size);
        max_alignment = max(max_alignment, props.flat_alignment);
        init_trivial = init_trivial & isTrivial(props.init_behavior);
        move_trivial = move_trivial & isTrivial(props.move_behavior);
        copy_trivial = copy_trivial & isTrivial(props.copy_behavior);
        destroy_trivial = destroy_trivial & isTrivial(props.destroy_behavior);
      }
      // See TeUnion for explanation of final_size.
      final_size u32 = ceil_aligned(max_size, max_alignment);
      *out = {final_size, max_alignment, trivialOrNot(init_trivial),
              trivialOrNot(move_trivial), trivialOrNot(copy_trivial),
              trivialOrNot(destroy_trivial)};
      return true;
    }
    case &TeUnion(a te_union): {
      // This is very similar to TeEnum, but TeEnum will change and this will not.
      max_size u32 = 0;
      max_alignment u32 = 1;
      n size = count(&a.fields);
      for i size = 0; i < n; i = i + 1 {
        props type_properties;
        if !compute_type_properties(cs, clq, &ref(&a.fields, i)->type, &props) {
          return false;
        }
        max_size = max(max_size, props.flat_size);
        max_alignment = max(max_alignment, props.flat_alignment);
        if !(isTrivial(props.init_behavior) && isTrivial(props.move_behavior) && isTrivial(props.copy_behavior) && isTrivial(props.destroy_behavior)) {
          ERR(_u8("union type has non-trivial field"));
          return false;
        }
      }
      // Consider the case where you have a union of {uint32_t, uint32_t, uint32_t} and {uint64_t}.  We have alignment 8, thus we need size 16.
      final_size u32 = ceil_aligned(max_size, max_alignment);
      *out = {final_size, max_alignment, DerivedMethodTrivial(void),
              DerivedMethodTrivial(void), DerivedMethodTrivial(void),
              DerivedMethodTrivial(void)};
      return true;
    }
    case &TeArraytype(a te_arraytype): {
      if case Has(c u32) = a.count {
        props type_properties;
        if !compute_type_properties(cs, clq, oo(&a.param), &props) {
          return false;
        }

        // We _should_ maintain alignment for a zero-element array because the pointer to such an array might hack in tag-bit logic.
        *out = {props.flat_size * c, props.flat_alignment,
                trivialOrNot(isTrivial(props.init_behavior)),
                trivialOrNot(isTrivial(props.move_behavior)),
                trivialOrNot(isTrivial(props.copy_behavior)),
                trivialOrNot(isTrivial(props.destroy_behavior))};
        return true;
      } else {
        ice(_u8("compute_type_properties called on incomplete arraytype."));
        return fake();
      }
    }
    case &TeUnknown(a void): {
      ice(_u8("compute_type_properties called on incomplete type."));
      return fake();
    }
  }
}

func quick_typeexpr(cym *common_syms, a *ast_def, out *ast_typeexpr) bool {
  if case &Has(s ast_typeexpr) = &a->syntactic_typeexpr {
    *out = s;
    return true;
  } else {
    switch &a->rhs {
      case &Lambda(b ast_lambda): {
        type_params array[ast_typeexpr];
        n size = count(&b.args);
        for i size = 0; i < n; i = i + 1 {
          push(&type_params, ref(&b.args, i)->type);
        }
        push(&type_params, b.return_type);
        // TODO: Something about the meta value and zero literal.
        *out = App({embox(Name({@[ast_meta]~0, cym->fn})), type_params});
        return true;
      }
      default: {
        ERR(_u8("Def does not have immediately conceivable typeexpr."));
        return false;
      }
    }
  }
}

func ensure_deftype_inst_checked(cs *checkstate, clq *clqueue, ent *deftype_entry, id deftype_inst_id) bool {
  inst *deftype_inst = ref_deftype_inst(cs, id);

  switch inst->status {
    case DidNotStartChecking(v): {
      inst->status = StartedChecking(void);
      rhs_computed te_typeexpr;
      rhs_complete bool;
      if !check_and_compute_typeexpr(cs, clq, &ent->tl->generics, &inst->parms, deftype_rhs_type(&ent->tl->rhs), &rhs_computed, &rhs_complete) {
        inst->status = FailedChecking(void);
        return false;
      }
      check(rhs_complete);

      check(isNone(&inst->properties));
      properties type_properties;
      if !compute_type_properties(cs, clq, &rhs_computed, &properties) {
        inst->status = FailedChecking(void);
        return false;
      }
      check(isNone(&inst->properties));
      switch &ent->tl->rhs {
        case &TypeexprRhs(a): {
          inst->properties = Has(properties);
        }
        case &ClassexprRhs(a): {
          inst->properties = Has(to_defclass_properties(properties));
        }
      }
      inst->status = FinishedChecking(void);
      return true;
    }
    case StartedChecking(v): {
      ERR(_u8("deftype for '"), lookup(cs->im, ent->name), _u8("' recursively checking"));
      return false;
    }
    case FinishedChecking(v): {
      check(isHas(&inst->properties));
      return true;
    }
    case FailedChecking(v): {
      ERR(_u8("deftype for '"), lookup(cs->im, ent->name), _u8("' already failed checking"));
      return false;
    }
  }
}

func ensure_deftype_checked(cs *checkstate, id deftype_entry_id) bool {
  ent *deftype_entry = ref_deftype_entry(cs, id);
  switch &ent->tl->generics {
    case &NoGenerics(v): {
      parms genparms = NoParms(void);
      clq clqueue;
      discard deftype_inst_id = enqueue_deftype_inst(cs, &clq, id, &parms);
      return finish_checking(cs, &clq);
    }
    case &HasGenerics(ig): {
      // We declare success -- we check non-generic defs.
      // TODO: Somewhere we have to check deftype generics shadowing.
      return true;
    }
  }
}

func ensure_alias_checked(cs *checkstate, id alias_entry_id) bool {
  ent *alias_entry = ref_alias_entry(cs, id);
  switch &ent->tl->generics {
    case &NoGenerics(v): {
      np genparms = NoParms(void);
      clq clqueue;
      computed te_typeexpr;
      if !check_and_compute_alias_with_parms(cs, &clq, ent, &np, &computed) {
        return false;
      }
      return finish_checking(cs, &clq);
    }
    case &HasGenerics(ig): {
      // We declare success -- we check non-generic defs.
      // TODO: Somewhere we have to check alias generics shadowing.
      return true;
    }
  }
}

func load_module(cs *checkstate, mod_name sym) opt[module_id] {
  switch lookup(&cs->modules_by_name, mod_name) {
    case Has(id module_id): {
      return Has(id);
    }
    case None(v): {
      switch (cs->loader)(mod_name) {
        case None(v2): {
          ERR(_u8("Could not open file for module "), lookup(cs->im, mod_name));
          return None();
        }
        case Has(arr array[u8]): {
          mod shp[module];
          oo(&mod)->process_state = Unprocessed(void);
          oo(&mod)->module_name = mod_name;
          oo(&mod)->buf = arr;
          p ps = make_ps(cs->im, data(&oo(&mod)->buf), count(&oo(&mod)->buf));
          if !parse_file(&p, &oo(&mod)->file) {
            ERR(_u8("Trouble parsing module "), lookup(cs->im, mod_name));
            return None();
          }
          mod_id module_id = ~count(&cs->modules);
          push(&cs->modules, mod);
          if !try_insert(&cs->modules_by_name, mod_name, mod_id) {
            ERR(_u8("ICE: modules_by_name already has name "), lookup(cs->im, mod_name));
            return None();
          }
          return Has(mod_id);
        }
      }
    }
  }
}

func process_module(cs *checkstate, mod_name sym) opt[module_id] {
  switch load_module(cs, mod_name) {
    case None(v): {
      return None();
    }
    case Has(id module_id): {
      mod *module = ref_module(cs, id);
      if mod->process_state == Unprocessed(void) {
         if !process_defs(cs, mod) {
           return None();
         }
      }
      return Has(id);
    }
  }
}

func process_defs(cs *checkstate, mod *module) bool {
  check_mutate(&mod->process_state, Unprocessed(void), Processing(void));
  if !process_toplevels(cs, mod, &mod->file.toplevels) {
    return false;
  }
  check_mutate(&mod->process_state, Processing(void), DoneProcessing(void));
  return true;
}

func add_def_entry(cs *checkstate,
                   module_name sym,
                   module_defs *array[def_entry_id],
                   ent shp[def_entry]) void {
  id def_entry_id = ~count(&cs->defs);
  push(&cs->defs, ent);
  arr *array[def_entry_id] = try_insert_lookup(
    &cs->defs_by_name, oo(ent)->def_name, default());
  push(arr, id);
  push(module_defs, id);
}

func process_toplevels(cs *checkstate,
                       mod *module,
                       toplevels *array[ast_toplevel]) bool {
  for i size = 0; i < count(toplevels); i = i + 1 {
    toplevel *ast_toplevel = ref(toplevels, i);
    switch toplevel {
      case &Import(a ast_import): {
        switch process_module(cs, a.name.value) {
          case None(v): {
            return false;
          }
          case Has(id module_id): {
            // Do nothing!  We've processed the module successfully.
          }
        }
      }
      case &Def(a ast_def): {
        typeexpr ast_typeexpr;
        if !quick_typeexpr(&cs->cym, &a, &typeexpr) {
          return false;
        }
        ent shp[def_entry] = emshp(mk(mod->module_name, a.name.value, a.generics, typeexpr, toplevel));
        add_def_entry(cs, mod->module_name, &mod->defs, ent);
      }
      case &ExternDef(a ast_extern_def): {
        ent shp[def_entry] = emshp(mk(mod->module_name, a.name.value, NoGenerics(void), a.type, toplevel));
        add_def_entry(cs, mod->module_name, &mod->defs, ent);
      }
      case &TypeDef(a ast_type_def): {
        ent shp[deftype_entry] = emshp(mk(mod->module_name, a.name.value, &a));
        id deftype_entry_id = ~count(&cs->deftypes);
        push(&cs->deftypes, ent);
        arr *array[deftype_entry_id] = try_insert_lookup(
          &cs->deftypes_by_name, oo(ent)->name, default());
        push(arr, id);
        push(&mod->deftypes, id);
      }
      case &TypeAlias(a ast_type_alias): {
        ent shp[alias_entry] = emshp(mk(mod->module_name, a.name.value, &a));
        id alias_entry_id = ~count(&cs->aliases);
        push(&cs->aliases, ent);
        arr *array[alias_entry_id] = try_insert_lookup(
          &cs->aliases_by_name, oo(ent)->alias_name, default());
        push(arr, id);
        push(&mod->aliases, id);
      }
      case &Access(a ast_access): {
        if !process_toplevels(cs, mod, &a.toplevels) {
          return false;
        }
      }
    }
  }
  return true;
}

defenum match_def_res {
  NoMatch void;
  MultiMatch void;
  // TODO: We'll want to include any simplification of the instantiated parms, or other type information, that we can get.
  OneMatch struct { ent def_entry_id; };
};

// Note that gp could be incomplete.
func match_def(cs *checkstate, name sym, gp *genparms, pt *te_typeexpr,
               res_out *match_def_res) bool {
  // TODO: What about defenum constructors?
  if case Has(arr *array[def_entry_id]) = lookup_ref(&cs->defs_by_name, name) {
    n size = count(arr);
    matches array[def_entry_id];
    for i size = 0; i < n; i = i + 1 {
      id def_entry_id = get(arr, i);
      ent *def_entry = ref_def_entry(cs, id);
      match_result bool;
      if !entry_matches(cs, &ent->generics, gp, pt, &ent->typeexpr, &match_result) {
        return false;
      }
      if match_result {
        push(&matches, id);
      }
    }
    num_matches size = count(&matches);
    if num_matches == 0 {
      *res_out = NoMatch(void);
      return true;
    } else if num_matches == 1 {
      *res_out = OneMatch({get(&matches, 0)});
      return true;
    } else {
      *res_out = MultiMatch(void);
      return true;
    }
  } else {
    *res_out = NoMatch(void);
    return true;
  }
}

func entry_matches(cs *checkstate, generics *ast_generics, gp *genparms, pt *te_typeexpr, typeexpr *ast_typeexpr, matches_out *bool) bool {
  switch generics {
    case &NoGenerics(v void): {
      switch gp {
        case &HasParms(arr array[te_typeexpr]): {
          *matches_out = false;
          return true;
        }
        case &NoParms(u void): {
          if !unify_directionally(cs->im, pt, typeexpr) {
            *matches_out = false;
            return true;
          } else {
            *matches_out = true;
            return true;
          }
        }
      }
    }
    case &HasGenerics(names array[ast_ident]): {
      return TODO();
    }
  }
}

func unify_directionally(im *identmap, pt *te_typeexpr, t *ast_typeexpr) bool {
  switch pt {
    case &TeName(pta te_name): {
      return TODO();
    }
    case &TeApp(pta te_typeapp): {
      return TODO();
    }
    case &TeStruct(pta te_struct): {
      return TODO();
    }
    case &TeEnum(pta te_enum): {
      return TODO();
    }
    case &TeUnion(pta te_union): {
      return TODO();
    }
    case &TeArraytype(pta te_arraytype): {
      return TODO();
    }
    case &TeUnknown(v void): {
      return true;
    }
  }
  return false;
}

func[T, U, V, W] ERR(x T, y U, z V, p W) void {
  ERR(cons(cons(x, y), cons(z, p)));
}

func[T, U, V] ERR(x T, y U, z V) void {
  ERR(cons(cons(x, y), z));
}

func[T, U] ERR(x T, y U) void {
  ERR(cons(x, y));
}

func[T] ERR(x T) void {
  print(Stderr(), to_u8str(x));
  print(Stderr(), _u8("\n"));
  fflush(Stderr());
}

func ice(msg array[u8]) void {
  x _ = _u8("ICE: ");
  append(&x, &msg);
  crash(x);
}

