struct vt_state {
  supports array[vs_support];
  checksum vs_checksum;
}

struct vs_checksum {
  // These counts may go negative, because we start them from zero after a paramlist is set-up.  They just have to be consistent, they're a basic sanity-check.
  live_count i32;
  active_count i32;
}

func mk_vt_state() vt_state {
  return {mk_array@[vs_support](), @[vs_checksum]{0, 0}};
}

struct vs_support {
  supporter vs_supporter;
  supportee cell_num;
}

enum vs_supporter {
  // A pointer, it points at the supportee.
  PointerFrom cell_num;
  // Supportee is a field of the given cell.
  FieldOf cell_num;
  // A descoping element.
  DescopingElement cell_num;
  // We've lost track of the cell's support.  TODO: Get rid of this.
  LostTrack void;
}

enum freshness {
  Stale void;
  // There's a change in the information formed by unification.
  Fresh void;
}

func `==`(x freshness, y freshness) bool {
  return enumnum(&x) == enumnum(&y);
}

// Returns whether "onto" changed.
func unify_vt_state(onto *opt[vt_state], from *vt_state) cr[freshness] {
  if case &Has(s vt_state) = onto {
    return unify_vt_state(&s, from);
  } else {
    *onto = Has(*from);
    return NoFail(Fresh);
  }
}

// Returns whether "onto" changed.
func unify_vt_state(onto *vt_state, from *vt_state) cr[freshness] {
  #unify_vs_checksum(&onto->checksum, &from->checksum);
  return NoFail(Stale);
}

func unify_vs_checksum(onto *vs_checksum, from *vs_checksum) np {
  if onto->live_count == from->live_count && onto->active_count == from->active_count {
    return NoFail;
  } else {
    return ERR(_u8("ICE? unify_vt_state active/live count mismatch"));
  }
}

func vs_xop(c cgt, gn gr_num, xn *gr_xnode) np {
  xn->vs_xopped = true;
  vs *vt_state = &c.track->current;

  vs_checksum_xop(&vs->checksum, &xn->op);

  #vs_support_xop(vs, &xn->op);

  return NoFail;
}

func vs_support_xop(vs *vt_state, op *gr_xop) np {
  switch op {
  case &GrApply(a gr_apply): {
    // We don't know what we're doing yet so we just call these do-nothing functions.
    #vs_support_descope(vs, a.funcell);
    foreach c cell_num in elems(&a.params) {
      // This is the opposite of typical destruction order.  But it shouldn't matter because we don't really know the order, do we?
      #vs_support_descope(vs, c);
    }

    #vs_support_activate(vs, a.retcell);

    switch a.semantic {
    case NoSemantic: { }
    case MoveSemantic(bs gr_apply_bi_semantic):
      #vs_support_copy_properties(vs, bs.dest, bs.src);
      #vs_support_activate(vs, bs.dest);
      #vs_support_deactivate(vs, bs.src);
    case CopySemantic(bs gr_apply_bi_semantic):
      #vs_support_copy_properties(vs, bs.dest, bs.src);
      #vs_support_activate(vs, bs.dest);
    case InitSemantic(us gr_apply_uni_semantic):
      #vs_support_activate(vs, us.cell);
    case DestroySemantic(us gr_apply_uni_semantic):
      #vs_support_deactivate(vs, us.cell);
    }
    return NoFail;
  }
  case &GrPrimApply(a gr_prim_apply): {
    foreach c cell_num in elems(&a.params) {
      #vs_support_descope(vs, c);
    }
    #vs_support_activate(vs, a.retcell);
    return NoFail;
  }
  case &GrMemCopy(a gr_memcopy):
    #vs_support_copy_properties(vs, a.dest, a.src);
    return NoFail;
  case &GrWriteConst(a gr_writeconst):
    #vs_support_const_properties(vs, a.dest);
    return NoFail;
  case &GrAddressof(a gr_addressof):
    // TODO(): Implement.
    return NoFail;
  case &GrDeref(a gr_deref):
    // TODO(): Implement.
    return NoFail;
  case &GrSubcell(a gr_subcell):
    // TODO(): Implement.
    return NoFail;
  case &GrLive(a gr_live):
    // TODO(): Implement.
    return NoFail;
  case &GrAssertLive(a gr_assert_live):
    return NoFail;
  case &GrDead(a gr_dead):
    // TODO(): Implement.
    return NoFail;
  case &GrVirtualDead(a gr_virtual_dead):
    // TODO(): Implement.
    return NoFail;
  case &GrActiveXop(a gr_active_xop):
    #vs_support_active_op(vs, a.op1);
    #vs_support_active_op(vs, a.op2);
    return NoFail;
  case &GrManyActiveXop(a gr_many_active_xop):
    // TODO(): Implement.
    return NoFail;
  }
}

func vs_support_active_op(vs *vt_state, op gr_active_op) np {
  switch op {
  case Nothing: { }
  case Activate(c cell_num):
    #vs_support_activate(vs, c);
  case Deactivate(c cell_num):
    #vs_support_deactivate(vs, c);
  }
  return NoFail;
}

func vs_support_enscope(vs *vt_state, c cell_num) np {
  // TODO(): Do something
  return NoFail;
}

func vs_support_descope(vs *vt_state, c cell_num) np {
  // TODO(): Do something
  return NoFail;
}

func vs_support_activate(vs *vt_state, c cell_num) np {
  // TODO(): Do something
  return NoFail;
}

func vs_support_deactivate(vs *vt_state, c cell_num) np {
  // TODO(): Do something
  return NoFail;
}

func vs_support_copy_properties(vs *vt_state, dest cell_num, src cell_num) np {
  // TODO(): Do something
  return NoFail;
}

func vs_support_const_properties(vs *vt_state, dest cell_num) np {
  // TODO(): Do something
  // We'll probably need the const value, too...
  return NoFail;
}

func vs_checksum_xop(vs *vs_checksum, op *gr_xop) void {
  switch op {
  case &GrApply(a gr_apply):
    switch a.act {
    case TwoExtraOps(ops gr_active_xop):
      vs_checksum_active_op(vs, ops.op1);
      vs_checksum_active_op(vs, ops.op2);
    case StandardApply: { }
    }
    nparams i32 = ~count(&a.params);
    // funcell deactivates, params deactivate, return cell activates
    vs->active_count += -nparams;
    // funcell dead, params dead, return cell was already live
    vs->live_count += -nparams - 1;
  case &GrPrimApply(a gr_prim_apply):
    nparams i32 = ~count(&a.params);
    // Same as GrApply except without the funcell.
    vs->active_count += -nparams + 1;
    vs->live_count += -nparams;
  case &GrMemCopy(a gr_memcopy): { }
  case &GrWriteConst(a gr_writeconst): { }
  case &GrAddressof(a gr_addressof):
    vs->active_count++;
  case &GrDeref(a gr_deref):
    vs->live_count++;
  case &GrSubcell(a gr_subcell):
    vs->live_count++;
  case &GrLive(a gr_live):
    vs->live_count++;
  case &GrAssertLive(a gr_assert_live): { }
  case &GrDead(a gr_dead):
    vs->live_count--;
  case &GrVirtualDead(a gr_virtual_dead):
    vs->live_count--;
  case &GrActiveXop(a gr_active_xop):
    vs_checksum_active_op(vs, a.op1);
    vs_checksum_active_op(vs, a.op2);
  case &GrManyActiveXop(a gr_many_active_xop):
    foreach aop gr_active_op in elems(&a.ops) {
      vs_checksum_active_op(vs, aop);
    }
  }
}

func vs_checksum_active_op(vs *vs_checksum, op gr_active_op) void {
  switch op {
  case Nothing: { }
  case Activate(c cell_num):
    vs->active_count++;
  case Deactivate(c cell_num):
    vs->active_count--;
  }
}
