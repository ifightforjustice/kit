import check;

deftype frame_graph struct {
  cells array[cell_info];
  ops array[gr_node];
};

deftype gr_num size;

func add_node(gr *frame_graph, node gr_node) gr_num {
  ret gr_num;
  ret.~ = count(&gr->ops);
  push(&gr->ops, node);
  return ret;
}

func ref_cell(gr *frame_graph, c cell_num) *cell_info {
  return ref(&gr->cells, c.~);
}

// To "evaluate" an op, first we evaluate its precs (in unspecified order), then we ealuate the op.
deftype gr_node struct {
  precs array[gr_num];
  op gr_op;
};

func node(precs array[gr_num], op gr_op) gr_node {
  return {precs, op};
}

defenum gr_op {
  GrApply gr_apply;
  GrMemCopy gr_memcopy;
  GrWriteConst gr_writeconst;
  GrAddressof gr_addressof;
  GrDeref gr_deref;
  GrSubcell gr_subcell;
  GrStrinit gr_strinit;
  GrBranch gr_branch;
  GrSequence gr_sequence;
  GrDead gr_dead;
  GrNop void;
};

deftype gr_apply struct {
  funcell cell_num;
  params array[cell_num];
  retcell cell_num;
};

deftype gr_memcopy struct {
  dest cell_num;
  src cell_num;
};

deftype gr_addressof struct {
  dest cell_num;
  addressee cell_num;
};

deftype gr_deref struct {
  name cell_num;
  pointer cell_num;
  offset gr_offset;
};

deftype gr_subcell struct {
  name cell_num;
  partof cell_num;
  offset gr_offset;
};

defenum gr_offset {
  OffsetConst u32;
  OffsetComputed tup[u32, cell_num];
};

deftype gr_writeconst struct {
  dest cell_num;
  value gr_const;
};

deftype gr_strinit struct {
  dest cell_num;
  parts array[tup[u32, cell_num]];
};

deftype gr_branch struct {
  src cell_num;
  cases array[tup[gr_const, gr_num]];
  default_case opt[gr_num];
};

deftype gr_sequence struct {
  first gr_num;
  second gr_num;
};

deftype gr_dead struct {
  cell cell_num;
};

defenum gr_const {
  ConstInt bigint;
  ConstDef instpair;
  ConstBytes array[u8];
};

func gr_expr_consume(cs *checkstate, gr *frame_graph, x *ast_expr_consume, out *gr_num) bool {
  if case &Has(aft ast_expr_after) = &x->after {
    return gr_expr_and_consume(cs, gr, &x->expr, &aft, out);
  } else {
    ice(_u8("gr_expr_consume missing after"));
    return fake();
  }
}

func gr_expr_and_consume(cs *checkstate, gr *frame_graph, x *ast_expr, aft *ast_expr_after, out *gr_num) bool {
  expr_gn gr_num;
  if !gr_expr(cs, gr, x, &expr_gn) {
    return false;
  }
  after_gn gr_num;
  if !gr_after_actions(cs, gr, expr_gn, &aft->actions, &after_gn) {
    return false;
  }
  *out = after_gn;
  return true;
}

func gr_expr(cs *checkstate, gr *frame_graph, x *ast_expr, out *gr_num) bool {
  switch &x->u {
    case &NameExpr(a ast_name_expr): {
      return gr_name_expr(cs, gr, x, &a, out);
    }
    case &ParenExpr(a ast_paren_expr): {
      return gr_expr(cs, gr, oo(&a.expr), out);
    }
    case &NumericLiteral(a ast_numeric_literal): {
      return gr_literal(cs, gr, x, numeric_literal_value(&a), out);
    }
    case &BoolLiteral(a ast_bool_literal): {
      value bigint;
      if a.value {
        value = ~ @[u32] 1;
      } else {
        value = ~ @[u32] 0;
      }
      return gr_literal(cs, gr, x, value, out);
    }
    case &VoidLiteral(a ast_void_literal): {
      value bigint = ~ @[u32] 0;
      return gr_literal(cs, gr, x, value, out);
    }
    case &NullLiteral(a ast_null_literal): {
      value bigint = ~ @[u32] 0;
      return gr_literal(cs, gr, x, value, out);
    }
    case &CharLiteral(a ast_char_literal): {
      value bigint = ~ a.charspec.value;
      return gr_literal(cs, gr, x, value, out);
    }

    case &StringLiteral(a ast_string_literal): {
      return gr_string_literal(cs, gr, x, &a, out);
    }
    case &Funcall(a ast_funcall): {
      return gr_funcall(cs, gr, x, &a, out);
    }
    case &Assignment(a ast_assignment): {
      return gr_assignment(cs, gr, x, &a, out);
    }
    case &AddressOf(a ast_addressof): {
      return gr_mk_addressof(cs, gr, x, &a, out);
    }
    case &Deref(a ast_deref): {
      return gr_mk_deref(cs, gr, x, &a, out);
    }
    case &IndexExpr(a ast_index_expr): {
      return gr_index_expr(cs, gr, x, &a, out);
    }
    case &Lambda(a ast_lambda): {
      return TODO();
    }
    case &LocalField(a ast_local_field): {
      return gr_local_field(cs, gr, x, &a, out);
    }
    case &DerefField(a ast_deref_field): {
      return gr_deref_field(cs, gr, x, &a, out);
    }
    case &TypedExpr(a ast_typed_expr): {
      return gr_expr(cs, gr, oo(&a.expr), out);
    }

    default: {
      return TODO();
    }
  }
}

func gr_deref_field(cs *checkstate, gr *frame_graph, x *ast_expr, a *ast_deref_field, out *gr_num) bool {
  rp gr_num;
  if !gr_expr_consume(cs, gr, oo(&a->lhs), &rp) {
    return false;
  }
  if case &Has(info ast_deref_field_info) = &a->info {
    ap gr_num;
    if !gr_later_discard(cs, gr, &a->ptr_discard, &ap) {
      return false;
    }
    switch info {
      case DerefArrayLength(count u32): {
        var cp = add_node(gr, node(mk_array(), GrWriteConst({rval_cell(x), ConstInt(~count)})));
        var sp = add_node(gr, node(mk_array(), GrSequence({rp, ap})));
        var gn = add_node(gr, node(mk_array(sp, cp), GrNop(void)));
        *out = gn;
        return true;
      }
      case DerefFieldName(offset u32): {
        name cell_num = ellval_cell(x);
        var dp = add_node(gr, node(mk_array(rp), GrDeref({name, result_cell(oo(&a->lhs)), OffsetConst(offset)})));
        var sp = add_node(gr, node(mk_array(), GrSequence({dp, ap})));
        *out = sp;
        return true;
      }
    }
    return TODO();
  } else {
    ice(_u8("gr_deref_field sees ast_deref_field not annotated"));
    return fake();
  }
}

func gr_local_field(cs *checkstate, gr *frame_graph, x *ast_expr, a *ast_local_field, out *gr_num) bool {
  if case &Has(info ast_local_field_info) = &a->info {
    lp gr_num;
    if !gr_expr(cs, gr, oo(&a->lhs), &lp) {
      return false;
    }
    switch &info {
      case &ArrayLength(alinfo ast_arraylength_info): {
        dp gr_num;
        if !gr_after_actions(cs, gr, lp, &alinfo.after.actions, &dp) {
          return false;
        }
        var cp = add_node(gr, node(mk_array(), GrWriteConst({rval_cell(x), ConstInt(~alinfo.count)})));
        var gn = add_node(gr, node(mk_array(dp, cp), GrNop(void)));
        *out = gn;
        return true;
      }
      case &FieldName(offset u32): {
        var gn = add_node(gr, node(mk_array(lp), GrSubcell({value_cell(x), value_cell(oo(&a->lhs)), OffsetConst(offset)})));
        *out = gn;
        return true;
      }
    }
  } else {
    ice(_u8("ast_local_field missing info"));
    return fake();
  }
}

func gr_index_expr(cs *checkstate, gr *frame_graph, x *ast_expr, a *ast_index_expr, out *gr_num) bool {
  if case &Has(info ast_index_expr_info) = &a->info {
    rp gr_num;
    if !gr_expr_consume(cs, gr, oo(&a->rhs), &rp) {
      return false;
    }
    lp gr_num;
    if !gr_expr(cs, gr, oo(&a->lhs), &lp) {
      return false;
    }
    if case &Has(aft ast_expr_after) = &info.after {
      // It's a pointer.
      name cell_num = ellval_cell(x);
      flat_size u32 = ref_cell(gr, name)->props.flat_size;
      var gp = add_node(gr, node(mk_array(rp, lp), GrDeref({name, result_cell(&aft), OffsetComputed(cons(flat_size, result_cell(oo(&a->rhs))))})));
      gn gr_num;
      if !gr_after_actions(cs, gr, gp, &aft.actions, &gn) {
        return false;
      }
      *out = gn;
      return true;
    } else {
      name cell_num = value_cell(x);
      flat_size u32 = ref_cell(gr, name)->props.flat_size;
      var gp = add_node(gr, node(mk_array(rp, lp), GrSubcell({name, value_cell(oo(&a->lhs)), OffsetComputed(cons(flat_size, result_cell(oo(&a->rhs))))})));
      *out = gp;
      return true;
    }
  } else {
    ice(_u8("gr_index_expr sees unannotated ast_index_expr"));
    return fake();
  }
}

func gr_later_discard(cs *checkstate, gr *frame_graph, a *ast_later_discard_info, out *gr_num) bool {
  if case &Has(da destroy_action) = &a->action {
    return gr_destroy_action(cs, gr, &da, out);
  } else {
    ice(_u8("ast_later_discard_info not annotated"));
    return fake();
  }
}

func gr_mk_deref(cs *checkstate, gr *frame_graph, x *ast_expr, a *ast_deref, out *gr_num) bool {
  rp gr_num;
  if !gr_expr_consume(cs, gr, oo(&a->rhs), &rp) {
    return false;
  }
  var dp = add_node(gr, node(mk_array(rp), GrDeref({ellval_cell(x), result_cell(oo(&a->rhs)), OffsetConst(0)})));
  ap gr_num;
  if !gr_later_discard(cs, gr, &a->ptr_discard, &ap) {
    return false;
  }
  var gn = add_node(gr, node(mk_array(), GrSequence({dp, ap})));
  *out = gn;
  return true;
}

func gr_mk_addressof(cs *checkstate, gr *frame_graph, x *ast_expr, a *ast_addressof, out *gr_num) bool {
  rp gr_num;
  if !gr_expr(cs, gr, oo(&a->rhs), &rp) {
    return false;
  }
  ap gr_num = add_node(gr, node(mk_array(rp), GrAddressof({rval_cell(x), ellval_cell(oo(&a->rhs))})));
  *out = ap;
  return true;
}

func gr_assignment(cs *checkstate, gr *frame_graph, x *ast_expr, a *ast_assignment, out *gr_num) bool {
  lp gr_num;
  if !gr_expr(cs, gr, oo(&a->lhs), &lp) {
    return false;
  }
  rp gr_num;
  if !gr_expr(cs, gr, oo(&a->rhs), &rp) {
    return false;
  }
  switch assignment_info(a) {
    case &StaticSelfAssignment(v void): {
      var nop = add_node(gr, node(mk_array(lp, rp), GrNop(void)));
      *out = nop;
      return true;
    }
    case &ConditionalAssignment(ci ast_conditional_assignment_info): {
      var fc = add_node(gr, node(mk_array(), GrWriteConst({ci.comparecells.funcell, ConstDef(ci.comparecells.ip)})));
      var dp = add_node(gr, node(mk_array(), GrAddressof({ci.comparecells.destptr, value_cell(oo(&a->lhs))})));
      var sp = add_node(gr, node(mk_array(), GrAddressof({ci.comparecells.srcptr, value_cell(oo(&a->rhs))})));
      var ap = add_node(gr, node(mk_array(fc, dp, sp), GrApply({ci.comparecells.funcell, mk_array(ci.comparecells.destptr, ci.comparecells.srcptr), ci.comparecells.cmp_result})));

      var nop = add_node(gr, node(mk_array(), GrNop(void)));
      var assignnop = add_node(gr, node(mk_array(), GrNop(void)));
      assign gr_num;
      if !gr_after_actions(cs, gr, assignnop, &ci.conditional_actions, &assign) {
        return false;
      }
      cases array[tup[gr_const, gr_num]] = mk_array(cons(ConstInt(~ @[u32] 0), assign), cons(ConstInt(~ @[u32] 1), nop));

      var br = add_node(gr, node(mk_array(ap), GrBranch({ci.comparecells.cmp_result, cases, None()})));
      unc gr_num;
      if !gr_after_actions(cs, gr, br, &ci.unconditional_actions, &unc) {
        return false;
      }
      *out = unc;
      return true;
    }
  }
}

func gr_funcall(cs *checkstate, gr *frame_graph, x *ast_expr, a *ast_funcall, out *gr_num) bool {
  precs array[gr_num];
  dep gr_num;
  if !gr_expr_consume(cs, gr, oo(&a->fun), &dep) {
    return false;
  }
  push(&precs, dep);
  paramcells array[cell_num];
  nparams size = count(&a->params);
  for i size = 0; i < nparams; i = i + 1 {
    param *ast_expr_consume = ref(&a->params, i);
    if !gr_expr_consume(cs, gr, param, &dep) {
      return false;
    }
    push(&precs, dep);
    push(&paramcells, result_cell(param));
  }
  var ap = add_node(gr, node(precs, GrApply({result_cell(oo(&a->fun)), paramcells, rval_cell(x)})));
  *out = ap;
  return true;
}

func gr_string_literal(cs *checkstate, gr *frame_graph, x *ast_expr, a *ast_string_literal, out *gr_num) bool {
  bytes array[u8];
  nchars size = count(&a->charspecs);
  for i size = 0; i < nchars; i = i + 1 {
    ch i32 = get(&a->charspecs, i).value;
    if ch < 0 || ch > 255 {
      ice(_u8("gr_string_literal char values out of range"));
    }
    push(&bytes, ~ch);
  }
  var gn = add_node(gr, node(mk_array(), GrWriteConst({rval_cell(x), ConstBytes(bytes)})));
  *out = gn;
  return true;
}

func gr_literal(cs *checkstate, gr *frame_graph, x *ast_expr, value bigint, out *gr_num) bool {
  var gn = add_node(gr, node(mk_array(), GrWriteConst({rval_cell(x), ConstInt(value)})));
  *out = gn;
  return true;
}

func gr_name_expr(cs *checkstate, gr *frame_graph, x *ast_expr, a *ast_name_expr, out *gr_num) bool {
  switch name_info(a) {
    case &LocalResolve(li local_info): {
      *out = add_node(gr, node(mk_array(), GrNop(void)));
      return true;
    }
    case &GlobalResolve(gi global_info): {
      *out = add_node(gr, node(mk_array(), GrWriteConst({rval_cell(x), ConstDef({gi.ent, gi.inst})})));
      return true;
    }
    case &EnumConstructor(v void): {
      return TODO();
    }
  }
}

func ellval_cell(x *is_lval) cell_num {
  switch x {
    case &IsLvalYes(desc lval_description): { return desc.num; }
    case &IsLvalNo(desc rval_description): {
      ice(_u8("lvalue_value_cell expects lvalue"));
      return fake();
    }
  }
}

func ellval_cell(a *ast_expr) cell_num {
  return ellval_cell(&expr_complete_info(a)->lval);
}

func rval_cell(x *ast_expr) cell_num {
  return rval_cell(&expr_complete_info(x)->lval);
}

func rval_cell(x *is_lval) cell_num {
  switch x {
    case &IsLvalNo(desc rval_description): {
      return desc.whole_num;
    }
    case &IsLvalYes(desc lval_description): {
      ice(_u8("rval_cell sees lvalue"));
      return fake();
    }
  }
}

func gr_after_actions(cs *checkstate, gr *frame_graph, prec gr_num, x *array[after_action], out *gr_num) bool {
  nacts size = count(x);
  for i size = 0; i < nacts; i = i + 1 {
    dep gr_num;
    if !gr_after_action(cs, gr, ref(x, i), &dep) {
      return false;
    }
    prec = add_node(gr, node(mk_array(), GrSequence({prec, dep})));
  }
  *out = prec;
  return true;
}

func gr_after_action(cs *checkstate, gr *frame_graph, x *after_action, out *gr_num) bool {
  switch x {
    case &CopyAfter(ca copy_action): {
      return gr_bi_action(cs, gr, &ca.~, out);
    }
    case &MoveAfter(ma move_action): {
      dep gr_num;
      if !gr_bi_action(cs, gr, &ma.~, &dep) {
        return false;
      }
      *out = add_node(gr, node(mk_array(dep), GrDead({ma.src})));
      return true;
    }
    case &DestroyAfter(da destroy_action): {
      return gr_destroy_action(cs, gr, &da, out);
    }
  }
}

func gr_destroy_action(cs *checkstate, gr *frame_graph, x *destroy_action, out *gr_num) bool {
  switch &x->ctor {
    case &UniTrivialCtor(v void): {
      var dp = add_node(gr, node(mk_array(), GrDead({x->arg})));
      *out = dp;
      return true;
    }
    case &UniFunCtor(desc uni_fun_ctor_desc): {
      var fc = add_node(gr, node(mk_array(), GrWriteConst({desc.funcell, ConstDef(desc.ip)})));
      var arp = add_node(gr, node(mk_array(), GrAddressof({desc.argptr, x->arg})));
      var ap = add_node(gr, node(mk_array(fc, arp), GrApply({desc.funcell, mk_array(desc.argptr), desc.retvoid})));
      var deadret = add_node(gr, node(mk_array(ap), GrDead({desc.retvoid})));
      var dp = add_node(gr, node(mk_array(deadret), GrDead({x->arg})));
      *out = dp;
      return true;
    }
  }
}

func gr_bi_action(cs *checkstate, gr *frame_graph, x *bi_action, out *gr_num) bool {
  switch &x->ctor {
    case &BiTrivialCtor(v void): {
      var cp = add_node(gr, node(mk_array(), GrMemCopy({x->dest, x->src})));
      *out = cp;
      return true;
    }
    case &BiFunCtor(desc bi_fun_ctor_desc): {
      var fc = add_node(gr, node(mk_array(), GrWriteConst({desc.funcell, ConstDef(desc.ip)})));
      var dp = add_node(gr, node(mk_array(), GrAddressof({desc.destptr, x->dest})));
      var sp = add_node(gr, node(mk_array(), GrAddressof({desc.srcptr, x->src})));
      var ap = add_node(gr, node(mk_array(fc, dp, sp), GrApply({desc.funcell, mk_array(desc.destptr, desc.srcptr), desc.retvoid})));
      var deadret = add_node(gr, node(mk_array(ap), GrDead({desc.retvoid})));
      *out = deadret;
      return true;
    }
  }
}
