import array;
import stdlib;

// The type K must have the following functions implemented:
// func hash_compute_hash(x *K) osize;
// func hash_equal(x *K, y *K) bool;

defclass[K, V] copy hash struct {
  // count(&arr) is zero or a power of two.
  arr array[opt[tup[K, V]]];
  // count is less than half count(&arr);
  count size;
};

access hash[_, _] {
  func[K, V] do_init(h *hash[K, V]) void {
    init(&h->arr);
    h->count = 0;
  }

  func[K, V] rebuild_(h *hash[K, V], new_limit size) void {
    new_mask size = new_limit - 1;
    check(0 == (new_limit & new_mask));
    check(h->count * 2 < new_limit);

    new_array array[opt[tup[K, V]]] = repeat(new_limit, None@[tup[K, V]]());
    old_limit size = count(&h->arr);
    for i size = 0; i < old_limit; i = i + 1 {
      if case &Has(p tup[K, V]) = ref(&h->arr, i) {
        offset size = ~ @[osize]hash_compute_hash(&p.car) & new_mask;
        step size = 1;
        done bool = false;
        while !done {
          switch ref(&new_array, offset) {
            case &None(v): { done = true; }
            case &Has(new_p): {
              offset = (offset + step) & new_mask;
              step = step + 1;
            }
          }
        }

        set(&new_array, offset, get(&h->arr, i));
      }
    }

    swap(&h->arr, &new_array);
  }

  func[K, V] try_insert(h *hash[K, V], key *K, value V) bool {
    if count(&h->arr) == 0 {
      rebuild_(h, 8);
    }

    mask size = count(&h->arr) - 1;
    offset size = ~ @[osize]hash_compute_hash(key) & mask;
    step size = 1;
    for ;; {
      switch ref(&h->arr, offset) {
        case &None(v): {
          set(&h->arr, offset, Has(cons(*key, value)));
          h->count = h->count + 1;
          if h->count * 2 >= count(&h->arr) {
            rebuild_(h, count(&h->arr) * 2);
          }
          return true;
        }
        case &Has(p tup[K, V]): {
          if hash_equal(&p.car, key) {
            return false;
          }
          offset = (offset + step) & mask;
          step = step + 1;
        }
      }
    }
  }

  // Return value's invalidated by any modification to the hash.
  func[K, V] lookup_ref(h *hash[K, V], key *K) opt[*V] {
    hash_count size = count(&h->arr);
    if hash_count == 0 {
      return None();
    }
    mask size = hash_count - 1;
    offset size = ~ @[osize]hash_compute_hash(key) & mask;
    step size = 1;
    for ;; {
      switch ref(&h->arr, offset) {
        case &None(v): {
          return None();
        }
        case &Has(p): {
          if hash_equal(&p.car, key) {
            return Has(&p.cdr);
          }
          offset = (offset + step) & mask;
          step = step + 1;
        }
      }
    }
  }

  func[K, V] count(h *hash[K, V]) size {
    return h->count;
  }


  func[T] sets_equal(a *hash[T, void], b *hash[T, void]) bool {
    n size = count(a);
    if n != count(b) {
      return false;
    }
    e size = count(&a->arr);
    for i size = 0; i < e; i = i + 1 {
      if case &Has(p tup[T, void]) = ref(&a->arr, i) {
        if !isHas(lookup_ref(b, &p.car)) {
          return false;
        }
      }
    }
    return true;
  }

  func[T] intersects(a *hash[T, void], b *hash[T, void]) bool {
    n size = count(a);
    bn size = count(b);
    if bn < n {
      n = bn;
      tmp _ = a;
      a = b;
      b = tmp;
    }
    e size = count(&a->arr);
    for i size = 0; i < e; i = i + 1 {
      if case &Has(p tup[T, void]) = ref(&a->arr, i) {
        if isHas(lookup_ref(b, &p.car)) {
          return true;
        }
      }
    }
    return false;
  }

  func[K, V] add_disjoint(onto *hash[K, V], from *hash[K, V]) bool {
    e size = count(&from->arr);
    for i size = 0; i < e; i = i + 1 {
      if case &Has(p tup[K, void]) = ref(&from->arr, i) {
        if !try_insert(onto, &p.car, void) {
          return false;
        }
      }
    }
    return true;
  }

  func[T] add_union(onto *hash[T, void], from *hash[T, void]) void {
    e size = count(&from->arr);
    for i size = 0; i < e; i = i + 1 {
      if case &Has(p tup[T, void]) = ref(&from->arr, i) {
        try_insert(onto, &p.car, void);
      }
    }
  }
}

func[K, V] check_insert(h *hash[K, V], key *K, value V) void {
  success bool = try_insert(h, key, value);
  check(success);
}

func[K, V] lookup(h *hash[K, V], key *K) opt[V] {
  if case Has(p *V) = lookup_ref(h, key) {
    return Has(*p);
  }
  return None();
}

// Returns an unstable reference -- use it right away.
func[K, V] try_insert_lookup(h *hash[K, V], key *K, value V) *V {
  switch lookup_ref(h, key) {
    case Has(p *V): { return p; }
    case None(v): {
      try_insert(h, key, value);
      switch lookup_ref(h, key) {
        case Has(p *V): { return p; }
        case None(v2): {
          check(false);
          return fake();
        }
      }
    }
  }
}

func[K, V] mk_hash() hash[K, V] {
  ret hash[K, V];
  return ret;
}

func[T] check_add(h *hash[T, void], key T) void {
  check_insert(h, &key, void);
}

func[T] check_add_all(h *hash[T, void], arr *array[T]) void {
  n size = count(arr);
  for i size = 0; i < n; i = i + 1 {
    check_insert(h, ref(arr, i), void);
  }
}

