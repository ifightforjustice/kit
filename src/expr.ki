import bigint;
import body;
import check;
import primitives;

/* A cell location is tricky: the location of an expr's return value
is defined both by the expr itself and the context it's found
in. Location should be specified when:

   - for lvalues, whenever we create the cell (by calling add_cell) for the lvalue.
   - for rvalues, when we annotate the disposal for the rvalue.
*/

defenum cell_location {
  // The "cell" is actually caused by dereferencing something, or maybe accessing something's field?
  LocationVirtual void;
  // The cell's on the stack, its location flexible.
  LocationFlex void;
  // The cell is in a "rigid" location.  Used for function parameters, strinit fields, and the like, what this really says is that the value is used "once."  The only rigid cells that truly must spend their lives in a calculated real-memory location are those without a trivial move constructor.
  LocationRigid void;
};

deftype cell_info struct {
  // Location must be specified by type-checking, but it spends time in an unspecified state.
  location opt[cell_location];
  type cu_typeexpr;
};

// Used with the variable name "es" -- its name used to be different.
deftype framescope struct {
  ds *defscope;
  // Same as ds->cs.
  cs *checkstate;
  // Same as ds->im, same as cs->im.
  im *identmap;
  // Same as ds->clq.
  clq *clqueue;

  cells array[cell_info];
};

func mk(ds *defscope) framescope {
  return {ds, ds->cs, ds->im, ds->clq, mk_array@[cell_info]()};
}

deftype cell_num size;

def `~` fn[size, cell_num] = wrapconvert;
def `==` fn[cell_num, cell_num, bool] = wrapequate;

func help_add_cell(es *framescope, info cell_info) cell_num {
  ret size = count(&es->cells);
  push(&es->cells, info);
  return ~ret;
}

func add_cell(es *framescope, type cu_typeexpr) cell_num {
  return help_add_cell(es, {None(), type});
}

func add_flex_cell(es *framescope, type cu_typeexpr) cell_num {
  return help_add_cell(es, {Has(LocationFlex(void)), type});
}

func add_virtual_cell(es *framescope, type cu_typeexpr) cell_num {
  return help_add_cell(es, {Has(LocationVirtual(void)), type});
}

func add_rigid_cell(es *framescope, type cu_typeexpr) cell_num {
  return help_add_cell(es, {Has(LocationRigid(void)), type});
}

func ref_cell(es *framescope, num cell_num) *cell_info {
  return ref(&es->cells, num.~);
}

deftype frame_cell_count size;

func count_cells(es *framescope) frame_cell_count {
  ret frame_cell_count;
  ret.~ = count(&es->cells);
  return ret;
}


func annotate_cell_location(es *framescope, num cell_num, loc cell_location) void {
  info *cell_info = ref_cell(es, num);
  if isHas(&info->location) {
    ice(_u8("framescope cell already has a location"));
  }
  info->location = Has(loc);
}

deftype defscope struct {
  cs *checkstate;
  // Same as cs->im.
  im *identmap;
  clq *clqueue;
  accessible array[access_entry_id];
  // Generics and their _complete_ replacements.
  generics *ast_generics;
  parms *cu_genparms;

  all_vars array[var_info];

  // These var_numbers are always in increasing order.
  current_vars array[var_number];
};

deftype var_number size;

def `~` fn[size, var_number] = wrapconvert;
def `==` fn[var_number, var_number, bool] = wrapequate;
func `!=`(x var_number, y var_number) bool { return !(x == y); }
func `<`(x var_number, y var_number) bool {
  return x.~ < y.~;
}

defenum var_autoinit {
  AutoInitNo void;
  AutoInitYes void;
};

func `==`(x var_autoinit, y var_autoinit) bool {
  return enumnum(&x) == enumnum(&y);
}

deftype var_info struct {
  num var_number;
  // A complete, checked, type, with generics replaced.
  type cu_typeexpr;
  props type_properties;
  cell cell_num;
  name sym;
  // Can a goto statement enter this var's scope and construct the var?  I.e. true if the variable is not bound by a case-pattern.  (Also true for lambda parameters, out of general principle.)
  autoinit var_autoinit;
  initter opt[ctor_desc];
  destroyer opt[ctor_desc];
};

func ref_var(ds *defscope, num var_number) *var_info {
  return ref(&ds->all_vars, num.~);
}

func vars_in_scope(ds *defscope) array[var_number] {
  return ds->current_vars;
}


defenum allow_incomplete {
  AllowIncompleteNo void;
  AllowIncompleteYes void;
};

func `==`(x allow_incomplete, y allow_incomplete) bool {
  return enumnum(&x) == enumnum(&y);
}

defclass move varpopper struct {
  ds *defscope;
  nums array[var_number];
};

access varpopper {

func do_init(vp *varpopper) void {
  init(&vp->ds);
  init(&vp->nums);
}

func init_vp(vp *varpopper, ds *defscope) void {
  check(vp->ds == null);
  vp->ds = ds;
}

func do_destroy(vp *varpopper) void {
  if vp->ds != null {
    descope_vars(vp);
  }
  destroy(&vp->nums);
  vp->ds = null;
}

func ds_push_var(ds *defscope, vp *varpopper, cell cell_num, name *ast_ident, computed_type *cu_typeexpr, autoinit var_autoinit, vn_out *var_number) bool {
  if case Has(num var_number) = ds_find_current_local(ds, name->value) {
    ERR(_u8("Local variable '"), lookup(ds->im, name->value), _u8("' shadows another"));
    return false;
  }
  props type_properties;
  if !compute_type_properties(ds->cs, ds->clq, computed_type, &props) {
    return false;
  }
  num var_number = ~count(&ds->all_vars);
  push(&ds->all_vars, {num, *computed_type, props, cell, name->value, autoinit, None(), None()});
  push(&ds->current_vars, num);
  push(&vp->nums, num);
  *vn_out = num;
  return true;
}

func descope_vars(vp *varpopper) void {
  ds *defscope = vp->ds;
  check(ds != null);
  while case Has(expected var_number) = popval(&vp->nums) {
    num var_number;
    if !popval(&ds->current_vars, &num) {
      ice(_u8("varpopper sees empty local_vars"));
    }
    if num != expected {
      ice(_u8("varpopper sees mismatch"));
    }
  }
}

}  // access varpopper

defclass varsaver struct {
  ds *defscope;
  current_vars array[var_number];
};

access varsaver {
func do_init(vp *varsaver) void {
  init(&vp->ds);
  init(&vp->current_vars);
}
func save_and_wipe_current_vars(vp *varsaver, ds *defscope) void {
  check(vp->ds == null);
  vp->ds = ds;
  vp->current_vars = ds->current_vars;
  ds->current_vars = mk_array();
}
func do_destroy(vp *varsaver) void {
  if vp->ds != null {
    vp->ds->current_vars = vp->current_vars;
  }
  destroy(&vp->current_vars);
  vp->ds = null;
}
}

func ds_note_var_initter(ds *defscope, vn var_number) bool {
  info *var_info = ref_var(ds, vn);
  if case &Has(desc ctor_desc) = &info->initter {
    return true;
  }
  desc ctor_desc;
  if !get_init_ctor(ds, &info->type, &desc) {
    return false;
  }
  info->initter = Has(desc);
  return true;
}

func ds_note_var_destroyer(ds *defscope, vn var_number) bool {
  info *var_info = ref_var(ds, vn);
  if case &Has(desc ctor_desc) = &info->destroyer {
    return true;
  }
  desc ctor_desc;
  if !get_destroy_ctor(ds, &info->type, &desc) {
    return false;
  }
  info->destroyer = Has(desc);
  return true;
}

func check_expr(cs *checkstate, clq *clqueue, accessible array[access_entry_id], g *ast_generics, parms *cu_genparms, x *ast_expr, pt *te_typeexpr, num_cells_out *frame_cell_count) bool {
  ds defscope = {cs, cs->im, clq, accessible, g, parms, default@[array[var_info]](), default@[array[var_number]]()};
  es framescope = mk(&ds);
  if !check_consume_expr(&es, x, pt) {
    return false;
  }
  *num_cells_out = count_cells(&es);
  return true;
}

func check_consume_expr(es *framescope, x *ast_expr, pt *te_typeexpr) bool {
  if !check_expr_ai(es, AllowIncompleteNo(void), x, pt) {
    return false;
  }
  if !annotate_disposal_for_consume(es, x) {
    return false;
  }
  return true;
}

func replaced_name_parms(ds *defscope, a *ast_name_expr, out *genparms) bool {
  if case &Has(arr array[ast_typeexpr]) = &a->generic_params {
    replaced array[te_typeexpr];
    n size = count(&arr);
    for i size = 0; i < n; i = i + 1 {
      converted te_typeexpr;
      if !convert_typeexpr(ds->cs, ref(&arr, i), &converted) {
        return false;
      }
      computed cac_typeexpr;
      if !check_and_compute_typeexpr(ds->cs, ds->clq, ds->generics, ds->parms, &converted, &computed) {
        return false;
      }
      push(&replaced, computed.te);
    }
    *out = HasParms(replaced);
    return true;
  } else {
    *out = NoParms(void);
    return true;
  }
}

deftype constructor_info struct {
  type cu_typeexpr;
};

defenum ds_constructor_res {
  NoMatchConstructor void;
  AmbigMatchConstructor void;
  MatchedConstructor constructor_info;
};

func ds_lookup_constructor(ds *defscope, name sym, gp *genparms, pt *te_typeexpr, res_out *ds_constructor_res) bool {
  if case &HasParms(a) = gp {
    *res_out = NoMatchConstructor(void);
    return true;
  }
  arg_type *te_typeexpr;
  return_type *te_typeexpr;
  if !decompose_typeapp(pt, primitive_function_puretype(ds->cs), &arg_type, &return_type) {
    *res_out = NoMatchConstructor(void);
    return true;
  }
  if !is_complete(return_type) {
    *res_out = AmbigMatchConstructor(void);
    return true;
  }
  // enum_type is complete.
  enum_type *te_typeexpr;
  if !complete_structural_rhs(ds, return_type, &enum_type) {
    return false;
  }
  if case &TeEnum(et te_enum) = enum_type {
    rhs_type *te_typeexpr;
    if !find_vardecl(&et.constructors, name, &rhs_type) {
      *res_out = NoMatchConstructor(void);
      return true;
    }
    // rhs_type is complete.
    unified te_typeexpr;
    if !unify_types(arg_type, rhs_type, &unified) {
      *res_out = NoMatchConstructor(void);
      return true;
    }
    cons_type te_typeexpr = fn_type(ds->cs, *rhs_type, *return_type);
    cac_cons_type cac_typeexpr;
    if !noscoped_check_and_compute_typeexpr(ds->cs, ds->clq, &cons_type, &cac_cons_type) {
      return false;
    }
    check(cac_cons_type.complete);
    *res_out = MatchedConstructor({~cac_cons_type.te});
    return true;
  } else {
    *res_out = NoMatchConstructor(void);
    return true;
  }
}

defenum es_match_res {
  NoMatch void;
  AmbigGlobalMatch void;
  OneGlobalMatch global_info;
  OneLocalMatch local_info;
  OneEnumConstructorMatch constructor_info;
};

func ds_lookup_name(ds *defscope, name sym, gp *genparms, pt *te_typeexpr, res_out *es_match_res) bool {
  if case &NoParms(v void) = gp {
    if case Has(num var_number) = ds_find_current_local(ds, name) {
      type te_typeexpr;
      vartype *cu_typeexpr = &ref_var(ds, num)->type;
      if !unify_types(pt, &vartype->~, &type) {
        ERR(_u8("local '"), lookup(ds->im, name), _u8("' has wrong type: '"), to_u8str(ds->im, *vartype), _u8("' where '"), to_u8str(ds->im, *pt), _u8("' expected"));
        return false;
      }
      *res_out = OneLocalMatch({num});
      return true;
    }
  }

  res match_def_res;
  if !match_def(ds->cs, name, gp, pt, &res) {
    return false;
  }

  switch &res {
    case &NoMatch(v void): {
      constructor_res ds_constructor_res;
      if !ds_lookup_constructor(ds, name, gp, pt, &constructor_res) {
        return false;
      }
      switch &constructor_res {
        case &NoMatchConstructor(u void): {
          *res_out = NoMatch(void);
        }
        case &AmbigMatchConstructor(u void): {
          *res_out = AmbigGlobalMatch(void);
        }
        case &MatchedConstructor(inf constructor_info): {
          *res_out = OneEnumConstructorMatch(inf);
        }
      }
      return true;
    }
    case &MultiMatch(void): {
      *res_out = AmbigGlobalMatch(void);
      return true;
    }
    case &OneMatch(m struct { ent def_entry_id; parms genparms; }): {
      // TODO: This is duplicated with lookup_explicit_method_or_lack_thereof.  Put logic in match_def or a wrapper?
      cu_parms cu_genparms;
      if !check_and_compute_parms(ds->cs, ds->clq, &m.parms, &cu_parms) {
        return false;
      }
      inst_id def_inst_id = enqueue_def_inst(ds->cs, ds->clq, m.ent, &cu_parms);
      *res_out = OneGlobalMatch({m.ent, inst_id});
      return true;
    }
  }
}

func ds_find_current_local(ds *defscope, name sym) opt[var_number] {
  n size = count(&ds->current_vars);
  for i size = 0; i < n; i = i + 1 {
    num var_number = get(&ds->current_vars, i);
    inf *var_info = ref_var(ds, num);
    if inf->name == name {
      return Has(num);
    }
  }
  return None();
}

func help_check_simple_literal(es *framescope, pt *te_typeexpr, type te_typeexpr, errmsg_name array[u8], x *ast_expr) bool {
  unified te_typeexpr;
  if !unify_types(pt, &type, &unified) {
    ERR(errmsg_name, _u8(" literal in bad place"));
    return false;
  }
  if is_complete(&unified) {
    c cac_typeexpr;
    if !noscoped_check_and_compute_typeexpr(es->cs, es->clq, &unified, &c) {
      ice(_u8("help_check_simple_literal passed bad type"));
    }
    check(c.complete);
    props type_properties;
    if !compute_complete_type_properties(es->cs, es->clq, &c.te, &props) {
      ice(_u8("help_check_simple_literal passed type with bad properties"));
    }

    annotate_info(x, CompleteCheck(mk(wholeRval(add_cell(es, ~c.te)), ~c.te, props)));
  } else {
    annotate_info(x, IncompleteCheck(type));
  }
  return true;
}

// pt is either (a) incomplete, or (b) complete and computed.
func check_expr_ai(es *framescope, ai allow_incomplete, x *ast_expr, pt *te_typeexpr) bool {
  if case &CompleteCheck(t ast_expr_complete_info) = &x->info {
    return true;
  }

  switch &x->u {
    case &NameExpr(a ast_name_expr): {
      return check_expr_name(es, ai, &a, pt, x);
    }

    case &ParenExpr(a ast_paren_expr): {
      if !check_expr_ai(es, ai, oo(&a.expr), pt) {
        return false;
      }
      // Same annotations as TypedExpr.
      if expr_type_complete(oo(&a.expr)) {
        annotate_disposal(oo(&a.expr), mk_after(Has(value_cell(oo(&a.expr)))));
      }
      annotate_info(x, inner_info(&oo(&a.expr)->info));
      return true;
    }

    case &NumericLiteral(a ast_numeric_literal): {
      return check_numeric_literal(es, ai, pt, numeric_literal_value(&a), x);
    }

    case &BoolLiteral(a ast_bool_literal): {
      return help_check_simple_literal(es, pt, primitive_bool_type(es->cs), _u8("bool"), x);
    }

    case &VoidLiteral(a ast_void_literal): {
      return help_check_simple_literal(es, pt, primitive_void_type(es->cs), _u8("void"), x);
    }

    case &NullLiteral(a ast_null_literal): {
      return help_check_simple_literal(es, pt, pointer_to(es->cs, TeUnknown(void)), _u8("null"), x);
    }

    case &CharLiteral(a ast_char_literal): {
      return check_numeric_literal(es, ai, pt, ~a.charspec.value, x);
    }

    case &StringLiteral(a ast_string_literal): {
      return check_expr_string_literal(es, &a, pt, x);
    }

    case &Funcall(a ast_funcall): {
      return check_expr_funcall(es, ai, &a, pt, x);
    }

    case &Assignment(a ast_assignment): {
      // We check the lhs independently of the rhs, deliberately, to ensure clarity.
      if !check_expr_ai(es, AllowIncompleteNo(void), oo(&a.lhs), pt) {
        return false;
      }
      lhs_info *ast_expr_complete_info = expr_complete_info(oo(&a.lhs));
      switch &lhs_info->lval {
        case &IsLvalNo(desc rval_description): {
          ERR(_u8("Assigning to non-lvalue"));
          return false;
        }
        case &IsLvalYes(desc lval_description): {
          annotate_disposal(oo(&a.lhs), mk_after(Has(value_cell(oo(&a.lhs)))));
          if !check_expr_ai(es, AllowIncompleteNo(void), oo(&a.rhs), &lhs_info->cu.~) {
            return false;
          }
          if !annotate_disposal_for_assignment(es, desc.num, oo(&a.rhs), &a) {
            return false;
          }
          annotate_info(x, CompleteCheck(mk(lhs_info->lval, lhs_info->cu, lhs_info->cu_props)));
          return true;
        }
      }
    }

    case &AddressOf(a ast_addressof): {
      ptr_unknown te_typeexpr = pointer_to(es->cs, TeUnknown(void));
      unif_pt te_typeexpr;
      if !unify_types(pt, &ptr_unknown, &unif_pt) {
        ERR(_u8("AddressOf expr in non-pointer context"));
      }
      param *te_typeexpr;
      if !decompose_typeapp(&unif_pt, primitive_pointer_puretype(es->cs), &param) {
        ice(_u8("AddressOf sees non-pointer after unifying with pointer."));
      }
      // We require complete matching, because, meh, the rhs should be some crystal clear lvalue anyway.
      if !check_expr_ai(es, AllowIncompleteNo(void), oo(&a.rhs), param) {
        return false;
      }
      rhs_info *ast_expr_complete_info = expr_complete_info(oo(&a.rhs));
      if isNo(rhs_info->lval) {
        ERR(_u8("Taking address of a non-lvalue"));
        return false;
      }
      annotate_disposal(oo(&a.rhs), mk_after(Has(value_cell(oo(&a.rhs)))));

      ptr_type te_typeexpr = pointer_to(es->cs, rhs_info->cu.~);
      ptr_computed cac_typeexpr;
      if !noscoped_check_and_compute_typeexpr(es->cs, es->clq, &ptr_type, &ptr_computed) {
        return false;
      }
      check(ptr_computed.complete);
      ptr_props type_properties;
      if !compute_complete_type_properties(es->cs, es->clq, &ptr_computed.te, &ptr_props) {
        return false;
      }
      annotate_info(x, CompleteCheck(mk(wholeRval(add_cell(es, ~ptr_computed.te)), ~ptr_computed.te, ptr_props)));
      return true;
    }
    case &Deref(a ast_deref): {
      // TODO: Shouldn't have to do this traversal.  Make pt carry such flags.
      pt_cc bool = is_complete_computed(pt).computed;
      ptr_pt te_typeexpr = pointer_to(es->cs, *pt);
      ptr_cac cac_typeexpr;
      if !noscoped_check_and_compute_typeexpr(es->cs, es->clq, &ptr_pt, &ptr_cac) {
        return false;
      }
      // Seems like no point to allowing an incomplete rhs.
      if !check_expr_ai(es, AllowIncompleteNo(void), oo(&a.rhs), &ptr_cac.te) {
        return false;
      }
      if !annotate_disposal_for_consume(es, oo(&a.rhs)) {
        return false;
      }
      param *te_typeexpr;
      if !decompose_typeapp(&expr_complete_type(oo(&a.rhs))->~, primitive_pointer_puretype(es->cs), &param) {
        ice(_u8("Deref sees rhs type being non-pointer."));
      }
      props type_properties;
      if !compute_complete_type_properties(es->cs, es->clq, param, &props) {
        return false;
      }
      annotate_info(x, CompleteCheck(mk(IsLvalYes({add_virtual_cell(es, ~ *param)}), ~ *param, props)));
      return true;
    }

    case &IndexExpr(a ast_index_expr): {
      return check_expr_index(es, &a, pt, x);
    }

    case &Lambda(a ast_lambda): {
      return check_expr_lambda(es, &a, pt, x);
    }

    case &LocalField(a ast_local_field): {
      unknown te_typeexpr = TeUnknown(void);
      if !check_expr_ai(es, AllowIncompleteNo(void), oo(&a.lhs), &unknown) {
        return false;
      }
      info *ast_expr_complete_info = expr_complete_info(oo(&a.lhs));
      fieldtype cu_typeexpr;
      inherits_lval bool;
      if !check_field(es, &info->cu, &a.fieldname, pt, &fieldtype, &inherits_lval) {
        return false;
      }
      lval is_lval;
      if inherits_lval {
        annotate_disposal_for_field(oo(&a.lhs));
        switch &info->lval {
          case &IsLvalYes(desc lval_description): {
            lval = IsLvalYes({add_virtual_cell(es, fieldtype)});
          }
          case &IsLvalNo(desc rval_description): {
            lval = IsLvalNo({desc.whole_num, add_virtual_cell(es, fieldtype)});
          }
        }
      } else {
        if !annotate_disposal_for_discard(es, oo(&a.lhs)) {
          return false;
        }
        lval = wholeRval(add_cell(es, fieldtype));
      }
      props type_properties;
      if !compute_type_properties(es->cs, es->clq, &fieldtype, &props) {
        return false;
      }
      annotate_info(x, CompleteCheck(mk(lval, fieldtype, props)));
      return true;
    }

    case &DerefField(a ast_deref_field): {
      // The fact that our partial type isn't a pointer type is deliberate.
      unknown te_typeexpr = TeUnknown(void);
      if !check_expr_ai(es, AllowIncompleteNo(void), oo(&a.lhs), &unknown) {
        return false;
      }
      if !annotate_disposal_for_consume(es, oo(&a.lhs)) {
        return false;
      }
      info *ast_expr_complete_info = expr_complete_info(oo(&a.lhs));
      param *te_typeexpr;
      if !decompose_typeapp(&info->cu.~, primitive_pointer_puretype(es->cs), &param) {
        ERR(_u8("Expected pointer for lhs of deref field"));
        return false;
      }
      cu_param cu_typeexpr = ~ *param;
      fieldtype cu_typeexpr;
      inherits_lval bool;
      if !check_field(es, &cu_param, &a.fieldname, pt, &fieldtype, &inherits_lval) {
        return false;
      }
      lval is_lval;
      if inherits_lval {
        // We deref, so it's always an lval.
        lval = IsLvalYes({add_virtual_cell(es, fieldtype)});
      } else {
        lval = wholeRval(add_cell(es, fieldtype));
      }
      props type_properties;
      if !compute_type_properties(es->cs, es->clq, &fieldtype, &props) {
        return false;
      }
      annotate_info(x, CompleteCheck(mk(lval, fieldtype, props)));
      return true;
    }

    case &TypedExpr(a ast_typed_expr): {
      // TODO: Cache converted.
      converted te_typeexpr;
      if !convert_typeexpr(es->cs, &a.type, &converted) {
        return false;
      }
      // We call check_and_compute_typeexpr to disallow totally bogus typeexprs more directly than the eventual type error that would happen.
      computed cac_typeexpr;
      if !check_and_compute_typeexpr(es->cs, es->clq, es->ds->generics, es->ds->parms, &converted, &computed) {
        return false;
      }
      unified te_typeexpr;
      if !unify_types(pt, &computed.te, &unified) {
        ERR(_u8("TypedExpr is incompatible with contextual type."));
        return false;
      }
      unified_computed cac_typeexpr;
      if computed.complete {
        unified_computed = computed;
      } else {
        if !noscoped_check_and_compute_typeexpr(es->cs, es->clq, &unified, &unified_computed) {
          ERR(_u8("TypedExpr encounters un-computable unified type."));
          return false;
        }
      }
      if !check_expr_ai(es, ai, oo(&a.expr), &unified_computed.te) {
        return false;
      }
      // Same annotations as ParenExpr.
      if expr_type_complete(oo(&a.expr)) {
        annotate_disposal(oo(&a.expr), mk_after(Has(value_cell(oo(&a.expr)))));
      }
      annotate_info(x, inner_info(&oo(&a.expr)->info));
      return true;
    }

    case &Strinit(a ast_strinit): {
      return check_expr_strinit(es, ai, &a, pt, x);
    }
  }
}

func behavior_to_desc(b *derived_method_behavior, out *ctor_desc) bool {
  switch b {
    case &DerivedMethodAbsent(v void): {
      ERR(_u8("Cannot find derived method."));
      return false;
    }
    case &DerivedMethodExplicit(ip instpair): {
      *out = FunCtor(ip);
      return true;
    }
    case &DerivedMethodNontrivial(ip instpair): {
      *out = FunCtor(ip);
      return true;
    }
    case &DerivedMethodTrivial(v void): {
      *out = TrivialCtor(void);
      return true;
    }
  }
}

func get_init_ctor(ds *defscope, t *cu_typeexpr, out *ctor_desc) bool {
  props type_properties;
  if !compute_type_properties(ds->cs, ds->clq, t, &props) {
    return false;
  }
  return behavior_to_desc(&props.init_behavior, out);
}

func get_copy_ctor(ds *defscope, t *cu_typeexpr, out *ctor_desc) bool {
  props type_properties;
  if !compute_type_properties(ds->cs, ds->clq, t, &props) {
    return false;
  }
  return behavior_to_desc(&props.copy_behavior, out);
}

func get_move_ctor(ds *defscope, t *cu_typeexpr, out *ctor_desc) bool {
  props type_properties;
  if !compute_type_properties(ds->cs, ds->clq, t, &props) {
    return false;
  }
  return behavior_to_desc(&props.move_behavior, out);
}

func get_destroy_ctor(ds *defscope, t *cu_typeexpr, out *ctor_desc) bool {
  props type_properties;
  if !compute_type_properties(ds->cs, ds->clq, t, &props) {
    return false;
  }
  return behavior_to_desc(&props.destroy_behavior, out);
}

// Annotates the disposal to "consume" the value -- i.e. what happens if it's a function param or otherwise a "use-once" value (i.e. to be copied/moved into a param list, or whatever).
func annotate_disposal_for_consume(es *framescope, a *ast_expr) bool {
  info *ast_expr_complete_info = expr_complete_info(a);
  switch &info->lval {
    case &IsLvalNo(desc rval_description): {
      if whole_temporary(&desc) {
        annotate_disposal(a, mk_after(Has(desc.whole_num)));
        annotate_cell_location(es, desc.whole_num, LocationRigid(void));
      } else {
        copy ctor_desc;
        if !get_copy_ctor(es->ds, &info->cu, &copy) {
          return false;
        }
        destroy ctor_desc;
        if !get_destroy_ctor(es->ds, &ref_cell(es, desc.whole_num)->type, &destroy) {
          return false;
        }
        dest cell_num = add_rigid_cell(es, info->cu);
        annotate_disposal(a,
          mk_after(CopyAfter({copy, dest, desc.partial_num}),
                   DestroyAfter({destroy, desc.whole_num}),
                   Has(dest)));
        annotate_cell_location(es, desc.whole_num, LocationFlex(void));
      }
    }
    case &IsLvalYes(desc lval_description): {
      copy ctor_desc;
      if !get_copy_ctor(es->ds, &info->cu, &copy) {
        return false;
      }
      dest cell_num = add_rigid_cell(es, info->cu);
      annotate_disposal(a, mk_after(CopyAfter({copy, dest, desc.num}), Has(dest)));
    }
  }
  return true;
}

// Annotates the disposal of the expr for local field access -- depends on whether it's an lvalue/rvalue.
func annotate_disposal_for_field(a *ast_expr) void {
  // We don't need to annotate any cell locations.
  annotate_disposal(a, mk_after(Has(value_cell(a))));
}

// Annotates the disposal of an Expr statement's expr, or some other value we are done using.
func annotate_disposal_for_discard(es *framescope, a *ast_expr) bool {
  info *ast_expr_complete_info = expr_complete_info(a);
  switch &info->lval {
    case &IsLvalNo(desc rval_description): {
      destroy ctor_desc;
      if !get_destroy_ctor(es->ds, &ref_cell(es, desc.whole_num)->type, &destroy) {
        return false;
      }
      annotate_disposal(a, mk_after(DestroyAfter({destroy, desc.whole_num}), None()));
      annotate_cell_location(es, desc.whole_num, LocationFlex(void));
    }
    case &IsLvalYes(desc lval_description): {
      // This could ostensibly be Has(desc.num), but there's no reason to be inconsistent with the rvalue case.
      annotate_disposal(a, mk_after(None()));
    }
  }
  return true;
}

// Annotates the disposal for a value we'll use but then discard.
func annotate_disposal_for_consume_then_discard(es *framescope, a *ast_expr, later *ast_later_discard_info) bool {
  info *ast_expr_complete_info = expr_complete_info(a);
  switch &info->lval {
    case &IsLvalNo(desc rval_description): {
      destroy ctor_desc;
      if !get_destroy_ctor(es->ds, &ref_cell(es, desc.whole_num)->type, &destroy) {
        return false;
      }
      if whole_temporary(&desc) {
        annotate_disposal(a, mk_after(Has(desc.whole_num)));
        annotate_cell_location(es, desc.whole_num, LocationFlex(void));
        annotate_later(later, {destroy, desc.whole_num});
      } else {
        copy ctor_desc;
        if !get_copy_ctor(es->ds, &info->cu, &copy) {
          return false;
        }
        destroy_the_copy ctor_desc;
        if !get_destroy_ctor(es->ds, &info->cu, &destroy_the_copy) {
          return false;
        }
        dest cell_num = add_flex_cell(es, info->cu);
        annotate_disposal(a,
          mk_after(CopyAfter({copy, dest, desc.partial_num}),
                   DestroyAfter({destroy, desc.whole_num}),
                   Has(dest)));
        annotate_cell_location(es, desc.whole_num, LocationFlex(void));
        annotate_later(later, {destroy, dest});
      }
    }
    case &IsLvalYes(desc lval_description): {
      copy ctor_desc;
      if !get_copy_ctor(es->ds, &info->cu, &copy) {
        return false;
      }
      destroy_the_copy ctor_desc;
      if !get_destroy_ctor(es->ds, &info->cu, &destroy_the_copy) {
        return false;
      }
      dest cell_num = add_flex_cell(es, info->cu);
      annotate_disposal(a,
        mk_after(CopyAfter({copy, dest, desc.num}), Has(dest)));
      annotate_later(later, {destroy_the_copy, dest});
    }
  }
  return true;
}


func annotate_disposal_for_assignment(es *framescope, dest cell_num, a *ast_expr, assignment *ast_assignment) bool {
  info *ast_expr_complete_info = expr_complete_info(a);
  switch &info->lval {
    case &IsLvalNo(desc rval_description): {
      if whole_temporary(&desc) {
        move ctor_desc;
        if !get_move_ctor(es->ds, &ref_cell(es, dest)->type, &move) {
          return false;
        }
        destroy ctor_desc;
        if !get_destroy_ctor(es->ds, &ref_cell(es, dest)->type, &destroy) {
          return false;
        }
        annotate_disposal(a, mk_after(Has(desc.whole_num)));
        annotate_cell_location(es, desc.whole_num, LocationFlex(void));
        annotate_assignment(assignment,
          {mk_array(DestroyAfter({destroy, dest}),
                    MoveAfter({move, dest, desc.whole_num})),
           mk_array()});
      } else {
        // TODO: This dups code with other makers of DisposeCopyAndDestroy.
        copy ctor_desc;
        if !get_copy_ctor(es->ds, &ref_cell(es, dest)->type, &copy) {
          return false;
        }
        destroy ctor_desc;
        if !get_destroy_ctor(es->ds, &ref_cell(es, desc.whole_num)->type, &destroy) {
          return false;
        }
        target_destroy ctor_desc;
        if !get_destroy_ctor(es->ds, &ref_cell(es, dest)->type, &target_destroy) {
          return false;
        }

        annotate_disposal(a, mk_after(Has(desc.partial_num)));
        annotate_cell_location(es, desc.whole_num, LocationFlex(void));
        annotate_assignment(assignment,
          {mk_array(DestroyAfter({target_destroy, dest}),
                    CopyAfter({copy, dest, desc.partial_num})),
           mk_array(DestroyAfter({destroy, desc.whole_num}))});
      }
    }
    case &IsLvalYes(desc lval_description): {
      copy ctor_desc;
      if !get_copy_ctor(es->ds, &ref_cell(es, dest)->type, &copy) {
        return false;
      }
      annotate_disposal(a, mk_after(Has(desc.num)));
      annotate_assignment(assignment,
        {mk_array(CopyAfter({copy, dest, desc.num})), mk_array()});
    }
  }
  return true;
}

func check_expr_name(es *framescope, ai allow_incomplete, a *ast_name_expr, pt *te_typeexpr, x *ast_expr) bool {
  parms genparms;
  if !replaced_name_parms(es->ds, a, &parms) {
    return false;
  }
  match_res es_match_res;
  if !ds_lookup_name(es->ds, a->ident.value, &parms, pt, &match_res) {
    return false;
  }
  switch &match_res {
    case &NoMatch(v void): {
      ERR(_u8("Name lookup for '"), lookup(es->im, a->ident.value), _u8("', maybe with parms, not found, matching type '"), to_u8str(es->im, *pt), _u8("'"));
      return false;
    }
    case &AmbigGlobalMatch(v void): {
      if ai == AllowIncompleteYes(void) {
        // NOTE: We could annotate this more precisely in ambiguous-single-match cases.
        annotate_info(x, IncompleteCheck(TeUnknown(void)));
        return true;
      } else {
        ERR(_u8("Name lookup for '"), lookup(es->im, a->ident.value), _u8("', maybe with parms, matches ambiguously."));
        return false;
      }
    }
    case &OneEnumConstructorMatch(ci constructor_info): {
      annotate_name_info(a, EnumConstructor(void));
      props type_properties;
      if !compute_type_properties(es->cs, es->clq, &ci.type, &props) {
        return false;
      }
      annotate_info(x, CompleteCheck(mk(wholeRval(add_cell(es, ci.type)), ci.type, props)));
      return true;
    }
    case &OneGlobalMatch(gi global_info): {
      if !ensure_def_inst_type_computed(es->cs, es->clq, ref_def_entry(es->cs, gi.ent), gi.inst) {
        return false;
      }
      annotate_name_info(a, GlobalResolve({gi.ent, gi.inst}));
      inst *def_inst = ref_inst(es->cs, gi.inst);
      annotate_info(x, CompleteCheck(mk(wholeRval(add_cell(es, inst->computed_type)), inst->computed_type, inst->computed_type_properties)));
      return true;
    }
    case &OneLocalMatch(v local_info): {
      annotate_name_info(a, LocalResolve({v.varnum}));
      vi *var_info = ref_var(es->ds, v.varnum);
      annotate_info(x, CompleteCheck(mk(IsLvalYes({vi->cell}), vi->type, vi->props)));
      return true;
    }
  }
}

func check_expr_string_literal(es *framescope, a *ast_string_literal, pt *te_typeexpr, x *ast_expr) bool {
  type cu_typeexpr;
  props type_properties;
  compute_prim(es->ds, primitive_string_literal_type(es->cs, count(&a->charspecs)),
               &type, &props);
  unified te_typeexpr;
  if !unify_types(pt, &type.~, &unified) {
    ERR(_u8("string literal in bad place"));
    return false;
  }
  annotate_info(x, CompleteCheck(mk(wholeRval(add_cell(es, type)), type, props)));
  return true;
}

func check_expr_strinit(es *framescope, ai allow_incomplete, a *ast_strinit, pt *te_typeexpr, x *ast_expr) bool {
  if !is_complete(pt) {
    if ai == AllowIncompleteYes(void) {
      // NOTE: We could have more specific info, like number of fields and their incomplete types.
      annotate_info(x, IncompleteCheck(TeUnknown(void)));
      return true;
    } else {
      ERR(_u8("Structure literal used ambiguously."));
      return false;
    }
  }

  // Since pt is complete, and since it's a pt, it's computed.
  if !is_complete_computed(pt).computed {
    ice(_u8("check_expr_strinit has non-computed pt"));
  }
  cu_pt cu_typeexpr = ~ *pt;
  structural_type *cu_typeexpr;
  if !structural_rhs(es->ds, &cu_pt, &structural_type) {
    return false;
  }

  // NOTE: We could allow arrays, especially if ambig matching returns number of fields and their type.
  if case &TeStruct(b te_struct) = &structural_type->~ {
    n size = count(&b.fields);
    if n != count(&a->exprs) {
      ERR(_u8("Structure literal has wrong number of fields."));
      return false;
    }

    for i size = 0; i < n; i = i + 1 {
      x_i *ast_expr = ref(&a->exprs, i);
      if !check_expr_ai(es, AllowIncompleteNo(void), x_i, &ref(&b.fields, i)->type) {
        return false;
      }
      if !annotate_disposal_for_consume(es, x_i) {
        return false;
      }
    }

    // We checked is_computed(pt).
    props type_properties;
    if !compute_complete_type_properties(es->cs, es->clq, pt, &props) {
      return false;
    }
    annotate_info(x, CompleteCheck(mk(wholeRval(add_cell(es, ~ *pt)), ~ *pt, props)));
    return true;
  } else {
    ERR(_u8("Structure literal used on non-struct type."));
    return false;
  }
}

func check_expr_lambda(es *framescope, a *ast_lambda, pt *te_typeexpr, x *ast_expr) bool {
  // TODO: Cache type.
  type ast_typeexpr = lambda_declared_type(es->im, a);
  // TODO: Cache converted.
  converted te_typeexpr;
  if !convert_typeexpr(es->cs, &type, &converted) {
    return false;
  }
  // TODO: I see some duplicated logic with the TypedExpr case.
  computed cac_typeexpr;
  if !check_and_compute_typeexpr(es->cs, es->clq, es->ds->generics, es->ds->parms, &converted, &computed) {
    return false;
  }
  // Lambda exprs can't have partial types (yet!).
  check(computed.complete);
  unified te_typeexpr;
  if !unify_types(pt, &computed.te, &unified) {
    ERR(_u8("Lambda is incompatible with contextual type."));
    return false;
  }

  computed_params *array[te_typeexpr];
  if !decompose_typeapp(&computed.te, primitive_function_puretype(es->cs), &computed_params) {
    ice(_u8("lambda type is not a function type"));
  }

  // Lambdas can't capture variables (yet).
  vs varsaver;
  save_and_wipe_current_vars(&vs, es->ds);

  if true {
    nargs size = count(&a->args);
    return_type cu_typeexpr = ~get(computed_params, nargs);
    bs bodystate = mk(es->ds, &return_type);

    vp varpopper;
    init_vp(&vp, es->ds);
    for i size = 0; i < nargs; i = i + 1 {
      cu_param cu_typeexpr = ~get(computed_params, i);
      cell cell_num = add_rigid_cell(&bs.es, cu_param);
      vn var_number;
      // AutoInitYes means a goto from "outside" the lambda could ostensibly construct the variable and initialize it.  That's complete haberdash, of course.
      if !ds_push_var(es->ds, &vp, cell, &ref(&a->args, i)->name, &cu_param, AutoInitYes(void), &vn) {
        return false;
      }
      if !ds_note_var_destroyer(es->ds, vn) {
        return false;
      }
    }

    if true {
      ee entryexit;
      if !check_body(&bs, &a->body.bb, &ee) {
        return false;
      }
      if !finish_lambda_body(&bs, ee) {
        return false;
      }
    }
  }

  props type_properties;
  if !compute_complete_type_properties(es->cs, es->clq, &computed.te, &props) {
    return false;
  }
  annotate_info(x, CompleteCheck(mk(wholeRval(add_cell(es, ~computed.te)), ~computed.te, props)));
  return true;
}

func numeric_literal_value(a *ast_numeric_literal) bigint {
  switch a {
    case &HexLiteral(b ast_hex_literal): {
      return convert_to_bigint(16, &b.digits);
    }
    case &DecLiteral(b ast_dec_literal): {
      return convert_to_bigint(10, &b.digits);
    }
  }
}

func check_numeric_literal(es *framescope, ai allow_incomplete, pt *te_typeexpr, n bigint, x *ast_expr) bool {
  if case &TeUnknown(v void) = pt {
    if ai == AllowIncompleteYes(void) {
      annotate_info(x, IncompleteCheck(TeUnknown(void)));
      return true;
    } else {
      ERR(_u8("Numeric literal usage is ambiguous."));
      return false;
    }
  }

  facts numeric_traits;
  if !is_numeric_type(es->cs, pt, &facts) {
    ERR(_u8("Numeric literal in bad place."));
    return false;
  }
  if n < facts.minval || n > facts.maxval {
    ERR(_u8("Numeric literal out of range."));
    return false;
  }
  // It's a pt, and it's a numeric type, which means it must be a complete pt, which means it's computed.
  check(is_complete_computed(pt).computed);
  props type_properties;
  if !compute_complete_type_properties(es->cs, es->clq, pt, &props) {
    return false;
  }
  annotate_info(x, CompleteCheck(mk(wholeRval(add_cell(es, ~ *pt)), ~ *pt, props)));
  return true;
}

func decompose_typeapp(t *te_typeexpr, expected_puretype te_puretype, params_out **array[te_typeexpr]) bool {
  // This could be implemented in terms of unify_under_generics, you know.
  if case &TeApp(app te_typeapp) = t {
    unified te_puretype;
    if !unify_puretypes(oo(&app.typefunc), &expected_puretype, &unified) {
      return false;
    }
    *params_out = &app.params;
    return true;
  } else {
    return false;
  }
}

func decompose_typeapp(t *te_typeexpr, expected_puretype te_puretype, oneparam_out **te_typeexpr) bool {
  params *array[te_typeexpr];
  if !decompose_typeapp(t, expected_puretype, &params) {
    return false;
  }
  if count(params) != 1 {
    return false;
  }
  *oneparam_out = ref(params, 0);
  return true;
}

func decompose_typeapp(t *te_typeexpr, expected_puretype te_puretype, oneparam_out **te_typeexpr, twoparam_out **te_typeexpr) bool {
  params *array[te_typeexpr];
  if !decompose_typeapp(t, expected_puretype, &params) {
    return false;
  }
  if count(params) != 2 {
    return false;
  }
  *oneparam_out = ref(params, 0);
  *twoparam_out = ref(params, 1);
  return true;
}

func check_field(es *framescope, t *cu_typeexpr, a *ast_fieldname, pt *te_typeexpr, fieldtype_out *cu_typeexpr, inherits_lval_out *bool) bool {
  fieldtype cu_typeexpr;
  inherits_lval bool;
  if !lookup_field(es, t, a, &fieldtype, &inherits_lval) {
    return false;
  }
  unified te_typeexpr;
  if !unify_types(pt, &fieldtype.~, &unified) {
    ERR(_u8("field has wrong type."));
    return false;
  }
  *fieldtype_out = fieldtype;
  *inherits_lval_out = inherits_lval;
  return true;
}

func deftype_rhs_accessible(ds *defscope, id deftype_entry_id, result_out *bool) bool {
  ent *deftype_entry = ref_deftype_entry(ds->cs, id);
  switch ent->accessibility {
    case RhsPublic(v void): {
      *result_out = true;
      return true;
    }
    case RhsPrivate(v void): {
      n size = count(&ds->accessible);
      for i size = 0; i < n; i = i + 1 {
        aid access_entry_id = get(&ds->accessible, i);
        dti deftype_entry_id;
        if !get_accessible_deftype(ds->cs, aid, &dti) {
          return false;
        }
        if dti == id {
          *result_out = true;
          return true;
        }
      }
      *result_out = false;
      return true;
    }
    case RhsImpossible(v void): {
      *result_out = false;
      return true;
    }
  }
}

// t must be complete.
func complete_structural_rhs(ds *defscope, t *te_typeexpr, rhs_type_out **te_typeexpr) bool {
  switch t {
    case &TeName(a te_name): {
      cu_rhs *cu_typeexpr;
      if !help_structural_rhs(ds, &a.pack, &cu_rhs) {
        return false;
      }
      *rhs_type_out = &cu_rhs->~;
      return true;
    }
    case &TeApp(a te_typeapp): {
      cu_rhs *cu_typeexpr;
      if !help_structural_rhs(ds, &a.pack, &cu_rhs) {
        return false;
      }
      *rhs_type_out = &cu_rhs->~;
      return true;
    }
    default: {
      if case &TeUnknown(v void) = t {
        ice(_u8("structural_rhs called on incomplete type"));
      }
      *rhs_type_out = t;
      return true;
    }
  }
}

func structural_rhs(ds *defscope, t *cu_typeexpr, rhs_type_out **cu_typeexpr) bool {
  switch &t->~ {
    case &TeName(a te_name): {
      return help_structural_rhs(ds, &a.pack, rhs_type_out);
    }
    case &TeApp(a te_typeapp): {
      return help_structural_rhs(ds, &a.pack, rhs_type_out);
    }
    default: {
      if case &TeUnknown(v void) = &t->~ {
        ice(_u8("structural_rhs called on incomplete type"));
      }
      *rhs_type_out = t;
      return true;
    }
  }
}

func help_structural_rhs(ds *defscope, mbpack *opt[te_instpack], rhs_type_out **cu_typeexpr) bool {
  if case &Has(pack te_instpack) = mbpack {
    accessible_result bool;
    if !deftype_rhs_accessible(ds, pack.ent_id, &accessible_result) {
      return false;
    }
    if !accessible_result {
      ERR(_u8("Looking for structural type information on inaccessible defclass type"));
      return false;
    }
    if !ensure_deftype_inst_checked(ds->cs, ds->clq, pack.ent_id, pack.inst_id) {
      return false;
    }
    inst *deftype_inst = ref_deftype_inst(ds->cs, pack.inst_id);
    if case &Has(info deftype_inst_info) = &inst->info {
      if case &Has(t cu_typeexpr) = &info.rhs {
        *rhs_type_out = &t;
        return true;
      } else {
        ice(_u8("deftype_rhs_accessible permitted a primitive type."));
        return fake();
      }
    } else {
      ice(_u8("inst checked, info still None()"));
      return fake();
    }
  } else {
    ice(_u8("lhs type in type_structural_rhs is not computed."));
    return fake();
  }
}

func lookup_whole_field(es *framescope, mbpack *opt[te_instpack], fieldtype_out *cu_typeexpr) bool {
  p *cu_typeexpr;
  if !help_structural_rhs(es->ds, mbpack, &p) {
    return false;
  }
  *fieldtype_out = *p;
  return true;
}

func lookup_name_field(es *framescope, mbpack *opt[te_instpack], fieldname *ast_ident, fieldtype_out *cu_typeexpr, inherits_lval_out *bool) bool {
  p *cu_typeexpr;
  if !help_structural_rhs(es->ds, mbpack, &p) {
    return false;
  }
  return help_lookup_name_field(es, p, fieldname, fieldtype_out, inherits_lval_out);
}

func help_lookup_name_field(es *framescope, t *cu_typeexpr, fieldname *ast_ident, fieldtype_out *cu_typeexpr, inherits_lval_out *bool) bool {
  switch &t->~ {
    case &TeName(a te_name): {
      return lookup_name_field(es, &a.pack, fieldname, fieldtype_out, inherits_lval_out);
    }
    case &TeApp(a te_typeapp): {
      return lookup_name_field(es, &a.pack, fieldname, fieldtype_out, inherits_lval_out);
    }
    case &TeStruct(a te_struct): {
      if !lookup_field_from_list(es->cs, &a.fields, fieldname->value, fieldtype_out) {
        return false;
      }
      *inherits_lval_out = true;
      return true;
    }
    case &TeEnum(a te_enum): {
      ERR(_u8("field lookup on an enum type"));
      return false;
    }
    case &TeUnion(a te_union): {
      if !lookup_field_from_list(es->cs, &a.fields, fieldname->value, fieldtype_out) {
        return false;
      }
      *inherits_lval_out = true;
      return true;
    }
    case &TeArraytype(a te_arraytype): {
      if fieldname->value != es->im->cym.lengthsym {
        ERR(_u8("field lookup (not .length) on array type"));
        return false;
      }
      *fieldtype_out = compute_prim(es->ds, primitive_size_type(es->cs));
      *inherits_lval_out = false;
      return true;
    }
    case &TeUnknown(v void): {
      ice(_u8("lookup_field sees incomplete type"));
      return fake();
    }
  }
}

func lookup_field(es *framescope, t *cu_typeexpr, f *ast_fieldname, fieldtype_out *cu_typeexpr, inherits_lval_out *bool) bool {
  switch f {
    case &WholeField(v void): {
      switch &t->~ {
        case &TeName(a te_name): {
          if !lookup_whole_field(es, &a.pack, fieldtype_out) {
            return false;
          }
          *inherits_lval_out = true;
          return true;
        }
        case &TeApp(a te_typeapp): {
          if !lookup_whole_field(es, &a.pack, fieldtype_out) {
            return false;
          }
          *inherits_lval_out = true;
          return true;
        }
        default: {
          ERR(_u8("whole field lookup on 'bare' type"));
          return false;
        }
        case &TeUnknown(u void): {
          ice(_u8("lookup_field sees incomplete type."));
          return fake();
        }
      }
    }
    case &NameField(b ast_ident): {
      return help_lookup_name_field(es, t, &b, fieldtype_out, inherits_lval_out);
    }
  }
}

func find_vardecl(a *array[te_vardecl], name sym, out **te_typeexpr) bool {
  n size = count(a);
  for i size = 0; i < n; i = i + 1 {
    d *te_vardecl = ref(a, i);
    if d->name == name {
      *out = &d->type;
      return true;
    }
  }
  return false;
}

// fields is supposed to be complete.
func lookup_field_from_list(cs *checkstate, fields *array[te_vardecl], fieldname sym, fieldtype_out *cu_typeexpr) bool {
  fieldtype *te_typeexpr;
  if !find_vardecl(fields, fieldname, &fieldtype) {
    ERR(_u8("fieldname '"), lookup(cs->im, fieldname), _u8("' not found"));
    return false;
  }
  *fieldtype_out = ~ *fieldtype;
  return true;
}

func ai_incomplete(yes bool) allow_incomplete {
  if yes {
    return AllowIncompleteYes(void);
  } else {
    return AllowIncompleteNo(void);
  }
}

func check_expr_funcall(es *framescope, ai allow_incomplete, a *ast_funcall, pt *te_typeexpr, x *ast_expr) bool {
  a_param_incomplete bool;
  if !check_funcall_params_firsttime(es, &a->params, &a_param_incomplete) {
    return false;
  }

  func_pt te_typeexpr = make_fn_partial_type(es->cs, pt, &a->params);
  if !check_expr_ai(es, ai_incomplete(!a_param_incomplete && ai == AllowIncompleteYes(void)), oo(&a->fun), &func_pt) {
    return false;
  }

  if expr_type_incomplete(oo(&a->fun)) {
    check(ai == AllowIncompleteYes(void));
    annotate_info(x, IncompleteCheck(TeUnknown(void)));
    return true;
  }

  if !check_funcall_params_secondtime(es, expr_complete_type(oo(&a->fun)), &a->params) {
    return false;
  }

  if !annotate_disposal_for_consume(es, oo(&a->fun)) {
    return false;
  }

  return_type *te_typeexpr = fn_return_type(es->cs, &expr_complete_type(oo(&a->fun))->~);
  props type_properties;
  if !compute_complete_type_properties(es->cs, es->clq, return_type, &props) {
    return false;
  }
  annotate_info(x, CompleteCheck(mk(wholeRval(add_cell(es, ~ *return_type)), ~ *return_type, props)));
  return true;
}

func check_funcall_params_firsttime(es *framescope, params *array[ast_expr], a_param_incomplete_out *bool) bool {
  n size = count(params);
  unknown te_typeexpr = TeUnknown(void);
  all_params_complete bool = true;
  for i size = 0; i < n; i = i + 1 {
    expr *ast_expr = ref(params, i);
    if !check_expr_ai(es, AllowIncompleteYes(void), expr, &unknown) {
      return false;
    }
    complete bool = expr_type_complete(expr);
    all_params_complete = all_params_complete & complete;
  }
  *a_param_incomplete_out = !all_params_complete;
  return true;
}

func check_funcall_params_secondtime(es *framescope, functype *cu_typeexpr, params *array[ast_expr]) bool {
  n size = count(params);

  type_params *array[te_typeexpr];
  if !decompose_typeapp(&functype->~, primitive_function_puretype(es->cs), &type_params) {
    ice(_u8("Expecting a TeApp for fn-type."));
  }
  check(count(type_params) == n + 1);

  for i size = 0; i < n; i = i + 1 {
    expr *ast_expr = ref(params, i);
    if !check_expr_ai(es, AllowIncompleteNo(void), expr, ref(type_params, i)) {
      return false;
    }
    if !annotate_disposal_for_consume(es, expr) {
      return false;
    }
  }
  return true;
}

func compute_prim(ds *defscope, t te_typeexpr) cu_typeexpr {
  cac cac_typeexpr;
  if !noscoped_check_and_compute_typeexpr(ds->cs, ds->clq, &t, &cac) {
    ice(_u8("compute_prim encounters uncomputable type"));
  }
  check(cac.complete);
  return ~cac.te;
}

func compute_prim(ds *defscope, t te_typeexpr, out *cu_typeexpr, props_out *type_properties) void {
  type cu_typeexpr = compute_prim(ds, t);
  if !compute_type_properties(ds->cs, ds->clq, &type, props_out) {
    ice(_u8("compute_prim fails to compute type properties"));
  }
  *out = type;
}

func check_expr_index(es *framescope, a *ast_index_expr, pt *te_typeexpr, x *ast_expr) bool {
  unknown te_typeexpr = TeUnknown(void);
  if !check_expr_ai(es, AllowIncompleteNo(void), oo(&a->lhs), &unknown) {
    return false;
  }
  sizetype cu_typeexpr = compute_prim(es->ds, primitive_size_type(es->cs));

  if !check_expr_ai(es, AllowIncompleteNo(void), oo(&a->rhs), &sizetype.~) {
    return false;
  }

  if !annotate_disposal_for_consume(es, oo(&a->rhs)) {
    return false;
  }

  lhs_info *ast_expr_complete_info = expr_complete_info(oo(&a->lhs));

  ixtype *te_typeexpr;
  is_arraytype bool;
  if !decompose_indexable(es->cs, &lhs_info->cu.~, &ixtype, &is_arraytype) {
    ERR(_u8("indexing on non-indexable type"));
    return false;
  }

  unified te_typeexpr;
  if !unify_types(pt, ixtype, &unified) {
    ERR(_u8("index expr returns wrong type"));
    return false;
  }

  lval is_lval;
  if is_arraytype {
    // TODO: This is totally duplicating field access logic.
    switch &lhs_info->lval {
      case &IsLvalYes(desc lval_description): {
        lval = IsLvalYes({add_virtual_cell(es, ~ *ixtype)});
      }
      case &IsLvalNo(desc rval_description): {
        lval = IsLvalNo({desc.whole_num, add_virtual_cell(es, ~ *ixtype)});
      }
    }
    // Just like field access.
    annotate_disposal_for_field(oo(&a->lhs));
  } else {
    // Dereferencing a pointer always makes an lvalue.
    lval = IsLvalYes({add_virtual_cell(es, ~ *ixtype)});
    if !annotate_disposal_for_consume(es, oo(&a->lhs)) {
      return false;
    }
  }
  props type_properties;
  if !compute_complete_type_properties(es->cs, es->clq, ixtype, &props) {
    return false;
  }
  annotate_info(x, CompleteCheck(mk(lval, ~ *ixtype, props)));
  return true;
}

func decompose_indexable(cs *checkstate, t *te_typeexpr, out **te_typeexpr, is_arraytype_out *bool) bool {
  if decompose_typeapp(t, primitive_pointer_puretype(cs), out) {
    *is_arraytype_out = false;
    return true;
  }
  if decompose_arraytype(t, out) {
    *is_arraytype_out = true;
    return true;
  }
  return false;
}

func decompose_arraytype(t *te_typeexpr, out **te_typeexpr) bool {
  if case &TeArraytype(a te_arraytype) = t {
    *out = oo(&a.param);
    return true;
  } else {
    return false;
  }
}

func expr_type(a *ast_expr) te_typeexpr {
  switch &a->info {
    case &NoInfo(v void): {
      ice(_u8("expr_type sees NoInfo"));
      return fake();
    }
    case &IncompleteCheck(t te_typeexpr): {
      return t;
    }
    case &CompleteCheck(t ast_expr_complete_info): {
      return t.cu.~;
    }
  }
}

func expr_complete_info(a *ast_expr) *ast_expr_complete_info {
  if case &CompleteCheck(inf ast_expr_complete_info) = &a->info {
    return &inf;
  } else {
    ice(_u8("expr_complete_info sees... not a complete type"));
    return fake();
  }
}

func expr_complete_type(a *ast_expr) *cu_typeexpr {
  return &expr_complete_info(a)->cu;
}

func expr_type_complete(a *ast_expr) bool {
  switch &a->info {
    case &NoInfo(v void): {
      ice(_u8("expr_type_complete sees NoInfo"));
      return fake();
    }
    case &IncompleteCheck(t te_typeexpr): { return false; }
    case &CompleteCheck(t ast_expr_complete_info): { return true; }
  }
}


func expr_type_incomplete(a *ast_expr) bool {
  return !expr_type_complete(a);
}

func make_fn_partial_type(cs *checkstate, return_type *te_typeexpr, params *array[ast_expr]) te_typeexpr {
  type_params array[te_typeexpr];
  n size = count(params);
  for i size = 0; i < n; i = i + 1 {
    push(&type_params, expr_type(ref(params, i)));
  }
  push(&type_params, *return_type);
  return TeApp({embox(primitive_function_puretype(cs)), type_params, None()});
}

func fn_return_type(cs *checkstate, func_type *te_typeexpr) *te_typeexpr {
  params *array[te_typeexpr];
  if !decompose_typeapp(func_type, primitive_function_puretype(cs), &params) {
    ice(_u8("Expected TeApp for fn-type in fn_return_type."));
  }
  n size = count(params);
  check(n > 0);
  return ref(params, n - 1);
}
