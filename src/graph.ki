import check;

deftype frame_graph struct {
  informal_name sym;
  cells array[cell_info];
  ops array[gr_node];
};

// To "evaluate" an op, first we evaluate its precs (in unspecified order), then we ealuate the op.
deftype gr_node struct {
  precs shray[gr_num];
  op gr_op;
};

// TODO: Maybe gr_num should start from 1, so that 0 is an invalid value.
deftype gr_num size;
def `~` fn[size, gr_num] = wrapconvert;
func `==`(x gr_num, y gr_num) bool { return x.~ == y.~; }
func `!=`(x gr_num, y gr_num) bool { return x.~ != y.~; }
func `<`(x gr_num, y gr_num) bool { return x.~ < y.~; }
func hash_compute_hash(n *gr_num) osize {
  return hash_compute_hash(&n->~);
}
func hash_equal(x *gr_num, y *gr_num) bool {
  return x->~ == y->~;
}

defenum gr_op {
  GrApply gr_apply;
  GrPrimApply gr_prim_apply;
  GrMemCopy gr_memcopy;
  GrWriteConst gr_writeconst;
  GrAddressof gr_addressof;
  GrDeref gr_deref;
  GrSubcell gr_subcell;
  GrBranch gr_branch;
  GrSequence gr_sequence;
  GrJmp gr_jmp;
  GrWriteNothing gr_writenothing;
  GrDead gr_dead;
  GrVirtualDead gr_virtual_dead;
  GrNop void;
};

func init_frame_graph_from_cells(informal_name sym, cells array[cell_info]) frame_graph {
  return {informal_name, cells, mk_array@[gr_node]()};
}

func init_frame_graph_empty(informal_name sym) frame_graph {
  return {informal_name, mk_array@[cell_info](), mk_array@[gr_node]()};
}

func add_cell(gr *frame_graph, info cell_info) cell_num {
  num cell_num = ~count(&gr->cells);
  push(&gr->cells, info);
  return num;
}

func add_node(gr *frame_graph, node gr_node) gr_num {
  ret gr_num = ~count(&gr->ops);
  push(&gr->ops, node);
  return ret;
}

func mut_nop_node(gr *frame_graph, ix gr_num, newnode gr_node) void {
  node *gr_node = ref(&gr->ops, ix.~);
  if case &GrNop(v void) = &node->op {
    *node = newnode;
  } else {
    ice(_u8("mut_nop_node sees non-nop node"));
  }
}

func ref_cell(gr *frame_graph, c cell_num) *cell_info {
  return ref(&gr->cells, c.~);
}

func ref_node(gr *frame_graph, gn gr_num) *gr_node {
  return ref(&gr->ops, gn.~);
}

func node(precs shray[gr_num], op gr_op) gr_node {
  return {precs, op};
}

func node0(op gr_op) gr_node {
  return node(mk_shray(), op);
}

deftype gr_apply struct {
  funcell cell_num;
  params shray[cell_num];
  retcell cell_num;
};

deftype gr_prim_apply struct {
  primop primitive_op;
  params shray[cell_num];
  retcell cell_num;
};

deftype gr_memcopy struct {
  dest cell_num;
  src cell_num;
};

deftype gr_writeconst struct {
  dest cell_num;
  value gr_const;
};

deftype gr_addressof struct {
  dest cell_num;
  addressee cell_num;
};

deftype gr_deref struct {
  name cell_num;
  pointer cell_num;
  offset gr_offset;
};

deftype gr_subcell struct {
  name cell_num;
  partof cell_num;
  offset gr_offset;
};

defenum gr_offset {
  OffsetConst u32;
  OffsetComputed tup[u32, cell_num];
};

deftype gr_branch struct {
  src cell_num;
  cases shray[tup[gr_const, gr_num]];
  default_case opt[gr_num];
};

deftype gr_sequence struct {
  first gr_num;
  second gr_num;
};

deftype gr_jmp struct {
  next gr_num;
};

deftype gr_writenothing struct {
  dest cell_num;
};

deftype gr_dead struct {
  cell cell_num;
};

deftype gr_virtual_dead struct {
  cell cell_num;
};

defenum gr_const {
  ConstInt bigint;
  ConstDef instpair;
  ConstFnBody fn_body_id;
  ConstBytes shray[u8];
};

deftype fullbody_state struct {
  // all_vars and labels is from the ast_fullbody_info.
  // We use the cell field, to know the name of the var's cell.
  all_vars array[var_info];

  final_node gr_num;
  // count(&label_gn) == count(&info->labels), they start off as nop nodes until we see the label.
  label_gn array[gr_num];
  // Cells that are used as return cells.
  return_cells array[cell_num];
};

func gr_fullbody(cs *checkstate, gr *frame_graph, x *ast_fullbody, out *gr_num, return_cell_out *cell_num) bool {
  var final_node = add_node(gr, node0(@[gr_op]GrNop(void)));

  info *ast_fullbody_info = unHas(&x->info);
  exit_node gr_num;
  if !gr_unwind_vars(cs, gr, &info->parameter_destructions, final_node, &exit_node) {
    return false;
  }

  label_gn array[gr_num];
  n size = count(&info->labels);
  for i size = 0; i < n; i = i + 1 {
    ngn gr_num = add_node(gr, node0(@[gr_op]GrNop(void)));
    push(&label_gn, ngn);
  }

  fb fullbody_state = {info->all_vars, final_node, label_gn, mk_array@[cell_num]()};

  body_gn gr_num;
  if !gr_bracebody(cs, gr, &fb, &x->bb, exit_node, &body_gn) {
    return false;
  }

  // This assumes it's okay to have a subcell op produce the identical type -- it's the only place we do that.
  return_subcell_ops array[gr_num];
  return_subcell_deads array[gr_num];
  nreturncells size = count(&fb.return_cells);
  reserve(&return_subcell_ops, nreturncells);
  reserve(&return_subcell_deads, nreturncells);
  for i size = 0; i < nreturncells; i = i + 1 {
    var subn = add_node(gr, node0(@[gr_op]GrSubcell({get(&fb.return_cells, i), info->return_cell, OffsetConst(0)})));
    push(&return_subcell_ops, subn);
    var deadn = add_node(gr, node0(@[gr_op]GrVirtualDead({get(&fb.return_cells, i)})));
    push(&return_subcell_deads, deadn);
  }

  nopdep gr_num = add_node(gr, node(freeze(&return_subcell_ops), GrNop(void)));
  seqop gr_num = add_node(gr, node0(@[gr_op]GrSequence({nopdep, body_gn})));

  mut_nop_node(gr, fb.final_node, node(freeze(&return_subcell_deads), GrNop(void)));

  *out = seqop;
  *return_cell_out = info->return_cell;
  return true;
}

func gr_bracebody(cs *checkstate, gr *frame_graph, fb *fullbody_state, x *ast_bracebody, outflow gr_num, out *gr_num) bool {
  bn gr_num;
  if !gr_unwind_vars(cs, gr, &unHas(&x->info)->destructions, outflow, &bn) {
    return false;
  }
  n size = count(&x->statements);
  for i size = n; i > 0; {
    i = i - 1;
    gn gr_num;
    if !gr_statement(cs, gr, fb, ref(&x->statements, i), bn, &gn) {
      return false;
    }
    bn = gn;
  }
  *out = bn;
  return true;
}

func gr_statement(cs *checkstate, gr *frame_graph, fb *fullbody_state, x *ast_statement, outflow gr_num, out *gr_num) bool {
  switch x {
    case &Expr(a ast_expr_discard): {
      gn gr_num;
      if !gr_expr_discard(cs, gr, &a, &gn) {
        return false;
      }
      *out = add_node(gr, node0(@[gr_op]GrSequence({gn, outflow})));
      return true;
    }
    case &Return(a ast_return_statement): {
      if !gr_return_statement(cs, gr, fb, &a, out) {
        return false;
      }
      return true;
    }
    case &Var(a ast_var_statement): {
      gn gr_num;
      if !gr_var_statement(cs, gr, fb, &a, &gn) {
        return false;
      }
      *out = add_node(gr, node0(@[gr_op]GrSequence({gn, outflow})));
      return true;
    }

    case &IfThen(a ast_ifthen_statement): {
      if !gr_ifthen_statement(cs, gr, fb, &a, outflow, out) {
        return false;
      }
      return true;
    }
    case &IfThenElse(a ast_ifthenelse_statement): {
      if !gr_ifthenelse_statement(cs, gr, fb, &a, outflow, out) {
        return false;
      }
      return true;
    }
    case &While(a ast_while_statement): {
      if !gr_while_statement(cs, gr, fb, &a, outflow, out) {
        return false;
      }
      return true;
    }

    case &For(a ast_for_statement): {
      if !gr_for_statement(cs, gr, fb, &a, outflow, out) {
        return false;
      }
      return true;
    }
    case &Switch(a ast_switch_statement): {
      if !gr_switch_statement(cs, gr, fb, &a, outflow, out) {
        return false;
      }
      return true;
    }
    case &Label(a ast_label_statement): {
      if !gr_label_statement(cs, gr, fb, &a, outflow, out) {
        return false;
      }
      return true;
    }
    case &Goto(a ast_goto_statement): {
      if !gr_goto_statement(cs, gr, fb, &a, outflow, out) {
        return false;
      }
      return true;
    }
  }
}

func gr_goto_statement(cs *checkstate, gr *frame_graph, fb *fullbody_state, a *ast_goto_statement, outflow gr_num, out *gr_num) bool {
  info *ast_goto_statement_info = unHas(&a->info);
  jmp gr_num = get(&fb->label_gn, info->label_number.~);
  wn gr_num;
  if !gr_wind_vars(cs, gr, &info->initializations, jmp, &wn) {
    return false;
  }
  un gr_num;
  if !gr_unwind_vars(cs, gr, &info->destructions, wn, &un) {
    return false;
  }
  *out = un;
  return true;
}

func gr_label_statement(cs *checkstate, gr *frame_graph, fb *fullbody_state, a *ast_label_statement, outflow gr_num, out *gr_num) bool {
  gn gr_num = get(&fb->label_gn, unHas(&a->info)->label_number.~);
  mut_nop_node(gr, gn, node0(@[gr_op]GrJmp({outflow})));
  // Should we set *out to gn or outflow?  When labels get fancier, the answer will matter.
  *out = gn;
  return true;
}

func gr_switch_statement(cs *checkstate, gr *frame_graph, fb *fullbody_state, a *ast_switch_statement, outflow gr_num, out *gr_num) bool {
  swartch_discard_gn gr_num;
  if !gr_later_discard(cs, gr, &a->swartch_discard, &swartch_discard_gn) {
    return false;
  }

  param_discard *te_typeexpr;
  is_ptr bool = decompose_typeapp(&expr_complete_type(&oo(&a->swartch)->expr)->~, primitive_pointer_puretype(cs), &param_discard);

  var exitseq = add_node(gr, node0(@[gr_op]GrSequence({swartch_discard_gn, outflow})));

  info *ast_enum_deconstruction_info = unHas(&a->info);
  cases array[tup[gr_const, gr_num]];
  default_case opt[gr_num] = None();
  ncases size = count(&a->cases);
  reserve(&cases, ncases);
  for i size = 0; i < ncases; i = i + 1 {
    sc *ast_switch_case = ref(&a->cases, i);

    switch &sc->pattern {
      case &Case(cp ast_constructor_pattern): {
        cp_info *ast_cp_info = unHas(&cp.cp_info);
        vi *var_info = ref(&fb->all_vars, cp_info->vn.~);

        kill_var gr_num = add_node(gr, node0(@[gr_op]GrVirtualDead({vi->cell})));
        bodyexit gr_num = add_node(gr, node0(@[gr_op]GrSequence({kill_var, exitseq})));

        body_gn gr_num;
        if !gr_bracebody(cs, gr, fb, &sc->body, bodyexit, &body_gn) {
          return false;
        }

        vcgn gr_num;
        if is_ptr {
          vcgn = add_node(gr, node0(@[gr_op]GrDeref({vi->cell, result_cell(oo(&a->swartch)), OffsetConst(cp_info->field_offset)})));
        } else {
          vcgn = add_node(gr, node0(@[gr_op]GrSubcell({vi->cell, result_cell(oo(&a->swartch)), OffsetConst(cp_info->field_offset)})));
        }
        var gn1 = add_node(gr, node0(@[gr_op]GrSequence({vcgn, body_gn})));
        kill_tag gr_num = add_node(gr, node0(@[gr_op]GrVirtualDead({info->tag_cell})));
        var gn = add_node(gr, node0(@[gr_op]GrSequence({kill_tag, gn1})));
        push(&cases, cons(@[gr_const]ConstInt(~cp_info->tag_value.~), gn));
      }
      case &Default(v void): {
        body_gn gr_num;
        if !gr_bracebody(cs, gr, fb, &sc->body, exitseq, &body_gn) {
          return false;
        }

        kill_tag gr_num = add_node(gr, node0(@[gr_op]GrVirtualDead({info->tag_cell})));
        var gn = add_node(gr, node0(@[gr_op]GrSequence({kill_tag, body_gn})));
        set(&default_case, gn);
      }
    }
  }

  swartch_gn gr_num;
  if !gr_expr_consume(cs, gr, oo(&a->swartch), &swartch_gn) {
    return false;
  }

  taggn gr_num;
  if is_ptr {
    taggn = add_node(gr, node(mk_shray(swartch_gn), @[gr_op]GrDeref({info->tag_cell, result_cell(oo(&a->swartch)), OffsetConst(enum_tag_offset)})));
  } else {
    taggn = add_node(gr, node(mk_shray(swartch_gn), @[gr_op]GrSubcell({info->tag_cell, result_cell(oo(&a->swartch)), OffsetConst(enum_tag_offset)})));
  }

  var br = add_node(gr, node(mk_shray(taggn), @[gr_op]GrBranch({info->tag_cell, freeze(&cases), default_case})));

  *out = br;
  return true;
}

func gr_for_statement(cs *checkstate, gr *frame_graph, fb *fullbody_state, a *ast_for_statement, outflow gr_num, out *gr_num) bool {
  var topgn = add_node(gr, node0(@[gr_op]GrNop(void)));

  loopcleanupgn gr_num;
  if case &Has(cond ast_for_condition) = &a->condition {
    if !gr_later_discard(cs, gr, &cond.discard, &loopcleanupgn) {
      return false;
    }
  } else {
    loopcleanupgn = add_node(gr, node0(@[gr_op]GrNop(void)));
  }

  continuegn gr_num;
  if case &Has(increment box[ast_expr_discard]) = &a->increment {
    incrgn gr_num;
    if !gr_expr_discard(cs, gr, oo(&increment), &incrgn) {
      return false;
    }
    var totopgn = add_node(gr, node0(@[gr_op]GrSequence({incrgn, topgn})));
    continuegn = add_node(gr, node0(@[gr_op]GrSequence({loopcleanupgn, totopgn})));
  } else {
    continuegn = add_node(gr, node0(@[gr_op]GrSequence({loopcleanupgn, topgn})));
  }

  thengn gr_num;
  if !gr_bracebody(cs, gr, fb, &a->body, continuegn, &thengn) {
    return false;
  }

  gn gr_num;
  if case &Has(cond ast_for_condition) = &a->condition {
    loopexitgn gr_num;
    if !gr_later_discard(cs, gr, &cond.discard, &loopexitgn) {
      return false;
    }

    initseq gr_num;
    if !gr_unwind_vars(cs, gr, &unHas(&a->info)->initter_destructions, outflow, &initseq) {
      return false;
    }

    var exitseq = add_node(gr, node0(@[gr_op]GrSequence({loopexitgn, initseq})));

    if !gr_expr_condition(cs, gr, fb, oo(&cond.expr), thengn, exitseq, &gn) {
      return false;
    }
  } else {
    gn = thengn;
  }

  mut_nop_node(gr, topgn, node0(@[gr_op]GrJmp({gn})));

  fingn gr_num;
  if case &Has(bi box[ast_statement]) = &a->initializer {
    if !gr_statement(cs, gr, fb, oo(&bi), topgn, &fingn) {
      return false;
    }
  } else {
    fingn = topgn;
  }
  *out = fingn;
  return true;
}

func gr_condition_discard(cs *checkstate, gr *frame_graph, a *ast_condition_discard_info, out *gr_num) bool {
  disc gr_num;
  if !gr_later_discard(cs, gr, &a->later, &disc) {
    return false;
  }
  *out = disc;
  return true;
}

func gr_while_statement(cs *checkstate, gr *frame_graph, fb *fullbody_state, a *ast_while_statement, outflow gr_num, out *gr_num) bool {
  var topgn = add_node(gr, node0(@[gr_op]GrNop(void)));

  loopcleanupgn gr_num;
  if !gr_condition_discard(cs, gr, &a->condition_discard_continue, &loopcleanupgn) {
    return false;
  }

  loopexitgn gr_num;
  if !gr_condition_discard(cs, gr, &a->condition_discard_exit, &loopexitgn) {
    return false;
  }

  var exitseq = add_node(gr, node0(@[gr_op]GrSequence({loopexitgn, outflow})));

  var continuegn = add_node(gr, node0(@[gr_op]GrSequence({loopcleanupgn, topgn})));
  thengn gr_num;
  if !gr_condition_body(cs, gr, fb, &a->condition_discard_continue, &a->body, continuegn, &thengn) {
    return false;
  }
  gn gr_num;
  if !gr_condition(cs, gr, fb, &a->condition, thengn, exitseq, &gn) {
    return false;
  }

  mut_nop_node(gr, topgn, node0(@[gr_op]GrJmp({gn})));
  *out = topgn;
  return true;
}

func gr_ifthenelse_statement(cs *checkstate, gr *frame_graph, fb *fullbody_state, a *ast_ifthenelse_statement, outflow gr_num, out *gr_num) bool {
  latergn gr_num;
  if !gr_condition_discard(cs, gr, &a->condition_discard, &latergn) {
    return false;
  }

  var latseq = add_node(gr, node0(@[gr_op]GrSequence({latergn, outflow})));

  thengn gr_num;
  if !gr_condition_body(cs, gr, fb, &a->condition_discard, &a->thenbody, latseq, &thengn) {
    return false;
  }
  elsegn gr_num;
  if !gr_bracebody(cs, gr, fb, &a->elsebody, latseq, &elsegn) {
    return false;
  }
  gn gr_num;
  if !gr_condition(cs, gr, fb, &a->condition, thengn, elsegn, &gn) {
    return false;
  }
  *out = gn;
  return true;
}

func gr_condition_body(cs *checkstate, gr *frame_graph, fb *fullbody_state, cd *ast_condition_discard_info, body *ast_bracebody, outflow gr_num, out *gr_num) bool {
  if case &Has(c cell_num) = unHas(&cd->virtual_cell_dead) {
    vd gr_num = add_node(gr, node0(@[gr_op]GrVirtualDead({c})));
    outflow = add_node(gr, node0(@[gr_op]GrSequence({vd, outflow})));
  }
  return gr_bracebody(cs, gr, fb, body, outflow, out);
}

func gr_ifthen_statement(cs *checkstate, gr *frame_graph, fb *fullbody_state, a *ast_ifthen_statement, outflow gr_num, out *gr_num) bool {
  latergn gr_num;
  if !gr_condition_discard(cs, gr, &a->condition_discard, &latergn) {
    return false;
  }

  var latseq = add_node(gr, node0(@[gr_op]GrSequence({latergn, outflow})));

  bodygn gr_num;
  if !gr_condition_body(cs, gr, fb, &a->condition_discard, &a->body, latseq, &bodygn) {
    return false;
  }
  gn gr_num;
  if !gr_condition(cs, gr, fb, &a->condition, bodygn, latseq, &gn) {
    return false;
  }
  *out = gn;
  return true;
}

func gr_expr_condition(cs *checkstate, gr *frame_graph, fb *fullbody_state, a *ast_expr_consume, thengn gr_num, elsegn gr_num, out *gr_num) bool {
  congn gr_num;
  if !gr_expr_consume(cs, gr, a, &congn) {
    return false;
  }
  cases shray[tup[gr_const, gr_num]] = mk_shray(cons(@[gr_const]ConstInt(~ @[u32] 0), elsegn), cons(@[gr_const]ConstInt(~ @[u32] 1), thengn));
  var br = add_node(gr, node(mk_shray(congn), @[gr_op]GrBranch({result_cell(a), cases, None()})));

  *out = br;
  return true;
}

func gr_condition(cs *checkstate, gr *frame_graph, fb *fullbody_state, a *ast_condition, thengn gr_num, elsegn gr_num, out *gr_num) bool {
  switch a {
    case &ExprCondition(bec box[ast_expr_consume]): {
      return gr_expr_condition(cs, gr, fb, oo(&bec), thengn, elsegn, out);
    }

    case &PatternCondition(pa ast_pattern_assign): {
      rhs gr_num;
      if !gr_expr_consume(cs, gr, oo(&pa.rhs), &rhs) {
        return false;
      }

      info *ast_pattern_assign_info = unHas(&pa.info);
      // TODO: Avoid the duplicate checks for addressof_constructor, only do one GrDeref.
      taggn gr_num;
      if isHas(&pa.pattern.addressof_constructor) {
        taggn = add_node(gr, node(mk_shray(rhs), @[gr_op]GrDeref({info->deconstruct.tag_cell, result_cell(oo(&pa.rhs)), OffsetConst(enum_tag_offset)})));
      } else {
        taggn = add_node(gr, node(mk_shray(rhs), @[gr_op]GrSubcell({info->deconstruct.tag_cell, result_cell(oo(&pa.rhs)), OffsetConst(enum_tag_offset)})));
      }
      cases array[tup[gr_const, gr_num]];
      n size = info->deconstruct.num_enum_constructors;
      reserve(&cases, n);
      for i size = 0; i < n; i = i + 1 {
        tag enum_tag_value = mk_enum_tag_value(i);
        if info->matching_tag_value.~ == tag.~ {
          cp_info *ast_cp_info = unHas(&pa.pattern.cp_info);
          vi *var_info = ref(&fb->all_vars, cp_info->vn.~);
          vcgn gr_num;
          if isHas(&pa.pattern.addressof_constructor) {
            vcgn = add_node(gr, node0(@[gr_op]GrDeref({vi->cell, result_cell(oo(&pa.rhs)), OffsetConst(cp_info->field_offset)})));
          } else {
            vcgn = add_node(gr, node0(@[gr_op]GrSubcell({vi->cell, result_cell(oo(&pa.rhs)), OffsetConst(cp_info->field_offset)})));
          }
          var gn = add_node(gr, node0(@[gr_op]GrSequence({vcgn, thengn})));
          tagdead gr_num = add_node(gr, node0(@[gr_op]GrVirtualDead({info->deconstruct.tag_cell})));
          thenseq gr_num = add_node(gr, node0(@[gr_op]GrSequence({tagdead, gn})));
          push(&cases, cons(@[gr_const]ConstInt(~tag.~), thenseq));
        } else {
          tagdead gr_num = add_node(gr, node0(@[gr_op]GrVirtualDead({info->deconstruct.tag_cell})));
          elseseq gr_num = add_node(gr, node0(@[gr_op]GrSequence({tagdead, elsegn})));
          push(&cases, cons(@[gr_const]ConstInt(~tag.~), elseseq));
        }
      }
      var br = add_node(gr, node(mk_shray(taggn), @[gr_op]GrBranch({info->deconstruct.tag_cell, freeze(&cases), None()})));

      *out = br;
      return true;
    }
  }
}

func gr_var_statement(cs *checkstate, gr *frame_graph, fb *fullbody_state, a *ast_var_statement, out *gr_num) bool {
  switch &a->rhs {
    case &HasExpr(be box[ast_expr_consume]): {
      return gr_expr_consume(cs, gr, oo(&be), out);
    }
    case &AutoInit(x opt[init_action]): {
      if case &Has(ia init_action) = &x {
        return gr_init_action(cs, gr, &ia, out);
      } else {
        ice(_u8("AutoInit action not annotated"));
        return fake();
      }
    }
  }
}

func gr_return_statement(cs *checkstate, gr *frame_graph, fb *fullbody_state, a *ast_return_statement, out *gr_num) bool {
  gn gr_num;
  if case &Has(b box[ast_expr_consume]) = &a->expr {
    if !gr_expr_consume(cs, gr, oo(&b), &gn) {
      return false;
    }
    push(&fb->return_cells, result_cell(oo(&b)));
  } else {
    gn = add_node(gr, node0(@[gr_op]GrNop(void)));
  }
  info *ast_return_statement_info = unHas(&a->info);
  uw gr_num;
  if !gr_unwind_vars(cs, gr, &info->destructions, fb->final_node, &uw) {
    return false;
  }
  var sn = add_node(gr, node0(@[gr_op]GrSequence({gn, uw})));
  *out = sn;
  return true;
}

// "initializations" is in variable declaration order -- the _same_ order as evaluation.
func gr_wind_vars(cs *checkstate, gr *frame_graph, initializations *array[init_action], outflow gr_num, out *gr_num) bool {
  bn gr_num = outflow;
  n size = count(initializations);
  for i size = n; i > 0; {
    i = i - 1;
    gn gr_num;
    if !gr_init_action(cs, gr, ref(initializations, i), &gn) {
      return false;
    }
    bn = add_node(gr, node0(@[gr_op]GrSequence({gn, bn})));
  }
  *out = bn;
  return true;
}

// "destructions" is in variable declaration order -- the _opposite_ order of evaluation.
func gr_unwind_vars(cs *checkstate, gr *frame_graph, destructions *array[var_destruction], outflow gr_num, out *gr_num) bool {
  bn gr_num = outflow;
  n size = count(destructions);
  for i size = 0; i < n; i = i + 1 {
    gn gr_num;
    switch get(destructions, i) {
    case VarSelfContainedDestruction(da destroy_action):
      if !gr_destroy_action(cs, gr, &da, DeadAfterDestroyYes(void), &gn) {
        return false;
      }
    case VarVirtualCellDead(c cell_num):
      gn = add_node(gr, node0(@[gr_op]GrVirtualDead({c})));
    }
    bn = add_node(gr, node0(@[gr_op]GrSequence({gn, bn})));
  }
  *out = bn;
  return true;
}

func gr_expr_discard(cs *checkstate, gr *frame_graph, x *ast_expr_discard, out *gr_num) bool {
  dp gr_num;
  if !gr_expr(cs, gr, &x->expr, &dp) {
    return false;
  }
  after_gn gr_num;
  if !gr_expr_after_discard(cs, gr, unHas(&x->after), &after_gn) {
    return false;
  }
  gn gr_num = add_node(gr, node0(@[gr_op]GrSequence({dp, after_gn})));
  *out = gn;
  return true;
}

func gr_expr_after_discard(cs *checkstate, gr *frame_graph, aft *ast_expr_after_discard, out *gr_num) bool {
  after_gn gr_num;
  switch aft {
  case &DiscardTemporary(da destroy_action):
    if !gr_destroy_action(cs, gr, &da, DeadAfterDestroyYes(void), &after_gn) {
      return false;
    }
  case &DiscardVirtualDead(c cell_num):
    after_gn = add_node(gr, node0(@[gr_op]GrVirtualDead({c})));
  case &DiscardNothing(v void):
    after_gn = add_node(gr, node0(@[gr_op]GrNop(void)));
  }
  *out = after_gn;
  return true;
}

func gr_expr_consume(cs *checkstate, gr *frame_graph, x *ast_expr_consume, out *gr_num) bool {
  return gr_expr_and_consume(cs, gr, &x->expr, unHas(&x->after), out);
}

func gr_expr_and_consume(cs *checkstate, gr *frame_graph, x *ast_expr, aft *ast_expr_after_consume, out *gr_num) bool {
  expr_gn gr_num;
  if !gr_expr(cs, gr, x, &expr_gn) {
    return false;
  }
  after_gn gr_num;
  if !gr_consume_actions(cs, gr, expr_gn, &aft->actions, &after_gn) {
    return false;
  }
  *out = after_gn;
  return true;
}

func gr_expr(cs *checkstate, gr *frame_graph, x *ast_expr, out *gr_num) bool {
  switch &x->u {
    case &NameExpr(a ast_name_expr): {
      return gr_name_expr(cs, gr, x, &a, out);
    }
    case &ParenExpr(a ast_paren_expr): {
      return gr_expr(cs, gr, oo(&a.expr), out);
    }
    case &NumericLiteral(a ast_numeric_literal): {
      return gr_literal(cs, gr, x, numeric_literal_value(&a), out);
    }
    case &BoolLiteral(a ast_bool_literal): {
      value bigint;
      if a.value {
        value = ~ @[u32] 1;
      } else {
        value = ~ @[u32] 0;
      }
      return gr_literal(cs, gr, x, value, out);
    }
    case &VoidLiteral(a ast_void_literal): {
      value bigint = ~ @[u32] 0;
      return gr_literal(cs, gr, x, value, out);
    }
    case &NullLiteral(a ast_null_literal): {
      value bigint = ~ @[u32] 0;
      return gr_literal(cs, gr, x, value, out);
    }
    case &CharLiteral(a ast_char_literal): {
      value bigint = ~ a.charspec.value;
      return gr_literal(cs, gr, x, value, out);
    }

    case &StringLiteral(a ast_string_literal): {
      return gr_string_literal(cs, gr, x, &a, out);
    }
    case &Funcall(a ast_funcall): {
      return gr_funcall(cs, gr, x, &a, out);
    }
    case &LogicalConjunction(a ast_logical_conjunction): {
      return gr_logical_conjunction(cs, gr, x, &a, out);
    }
    case &Assignment(a ast_assignment): {
      return gr_assignment(cs, gr, x, &a, out);
    }
    case &AddressOf(a ast_addressof): {
      return gr_mk_addressof(cs, gr, x, &a, out);
    }
    case &Deref(a ast_deref): {
      return gr_mk_deref(cs, gr, x, &a, out);
    }
    case &IndexExpr(a ast_index_expr): {
      return gr_index_expr(cs, gr, x, &a, out);
    }
    case &Lambda(a ast_lambda): {
      return gr_lambda_expr(cs, gr, x, &a, out);
    }
    case &LocalField(a ast_local_field): {
      return gr_local_field(cs, gr, x, &a, out);
    }
    case &DerefField(a ast_deref_field): {
      return gr_deref_field(cs, gr, x, &a, out);
    }
    case &TypedExpr(a ast_typed_expr): {
      return gr_expr(cs, gr, oo(&a.expr), out);
    }
    case &Strinit(a ast_strinit): {
      return gr_mk_strinit(cs, gr, x, &a, out);
    }
  }
}

func gr_mk_strinit(cs *checkstate, gr *frame_graph, x *ast_expr, a *ast_strinit, out *gr_num) bool {
  ngn gr_num = add_node(gr, node0(@[gr_op]GrWriteNothing({rval_cell(x)})));

  precs array[gr_num];
  nparams size = count(&a->exprs);
  reserve(&precs, nparams);
  for i size = 0; i < nparams; i = i + 1 {
    param *ast_strinit_param = ref(&a->exprs, i);
    befdep gr_num = add_node(gr, node0(@[gr_op]GrSubcell({result_cell(&param->ec), rval_cell(x), OffsetConst(unHas(&param->info)->offset)})));
    dep gr_num;
    if !gr_expr_consume(cs, gr, &param->ec, &dep) {
      return false;
    }
    aftdep gr_num = add_node(gr, node0(@[gr_op]GrVirtualDead({result_cell(&param->ec)})));

    prec1 gr_num = add_node(gr, node0(@[gr_op]GrSequence({dep, aftdep})));
    prec gr_num = add_node(gr, node0(@[gr_op]GrSequence({befdep, prec1})));
    push(&precs, prec);
  }
  var np = add_node(gr, node(freeze(&precs), GrNop(void)));
  var gn = add_node(gr, node0(@[gr_op]GrSequence({ngn, np})));
  *out = gn;
  return true;
}

func gr_deref_field(cs *checkstate, gr *frame_graph, x *ast_expr, a *ast_deref_field, out *gr_num) bool {
  rp gr_num;
  if !gr_expr_consume(cs, gr, oo(&a->lhs), &rp) {
    return false;
  }
  info *ast_deref_field_info = unHas(&a->info);
  ap gr_num;
  if !gr_later_discard(cs, gr, &a->ptr_discard, &ap) {
    return false;
  }
  switch info {
    case &DerefArrayLength(count u32): {
      var cp = add_node(gr, node0(@[gr_op]GrWriteConst({rval_cell(x), ConstInt(~count)})));
      var sp = add_node(gr, node0(@[gr_op]GrSequence({rp, ap})));
      var gn = add_node(gr, node(mk_shray(sp, cp), GrNop(void)));
      *out = gn;
      return true;
    }
    case &DerefFieldName(offset u32): {
      name cell_num = ellval_cell(x);
      var dp = add_node(gr, node(mk_shray(rp), @[gr_op]GrDeref({name, result_cell(oo(&a->lhs)), OffsetConst(offset)})));
      var sp = add_node(gr, node0(@[gr_op]GrSequence({dp, ap})));
      *out = sp;
      return true;
    }
  }
}

func gr_local_field(cs *checkstate, gr *frame_graph, x *ast_expr, a *ast_local_field, out *gr_num) bool {
  info *ast_local_field_info = unHas(&a->info);
  lp gr_num;
  if !gr_expr(cs, gr, oo(&a->lhs), &lp) {
    return false;
  }
  switch info {
    case &ArrayLength(alinfo ast_arraylength_info): {
      dp1 gr_num;
      if !gr_expr_after_discard(cs, gr, &alinfo.after, &dp1) {
        return false;
      }
      var dp = add_node(gr, node0(@[gr_op]GrSequence({lp, dp1})));
      var cp = add_node(gr, node0(@[gr_op]GrWriteConst({rval_cell(x), ConstInt(~alinfo.count)})));
      var gn = add_node(gr, node(mk_shray(dp, cp), GrNop(void)));
      *out = gn;
      return true;
    }
    case &FieldName(offset u32): {
      var gn1 = add_node(gr, node(mk_shray(lp), @[gr_op]GrSubcell({value_cell(x), value_cell(oo(&a->lhs)), OffsetConst(offset)})));
      gn gr_num;
      switch &expr_complete_info(oo(&a->lhs))->lval {
      case &IsLvalYes(desc lval_description):
        if case DeadMe(v void) = desc.deadme {
          gn = add_node(gr, node(mk_shray(gn1), @[gr_op]GrVirtualDead({desc.num})));
        } else {
          gn = gn1;
        }
      case &IsLvalNo(desc rval_description):
        if !gr_chain_virtualdead(cs, gr, gn1, desc.partial_num, &gn) {
          return false;
        }
      }
      *out = gn;
      return true;
    }
  }
}

func gr_lambda_expr(cs *checkstate, gr *frame_graph, x *ast_expr, a *ast_lambda, out *gr_num) bool {
  info *ast_fullbody_info = unHas(&a->body.info);
  lambda_gr frame_graph = init_frame_graph_from_cells(gr->informal_name, info->cells);
  fullbody_gn gr_num;
  return_cell cell_num;
  if !gr_fullbody(cs, &lambda_gr, &a->body, &fullbody_gn, &return_cell) {
    return false;
  }

  id fn_body_id = add_fn_body(cs, {gr->informal_name, NotComputed@[sti](), NotComputed@[u32](), @[fn_body_entry_enum]GraphedFnBody({FnBodyLambda(a), {lambda_gr, fullbody_gn, return_cell}, info->arg_cells})});
  var gn = add_node(gr, node0(@[gr_op]GrWriteConst({rval_cell(x), ConstFnBody(id)})));
  *out = gn;
  return true;
}

func gr_index_expr(cs *checkstate, gr *frame_graph, x *ast_expr, a *ast_index_expr, out *gr_num) bool {
  info *ast_index_expr_info = unHas(&a->info);
  rp gr_num;
  if !gr_expr_consume(cs, gr, oo(&a->rhs), &rp) {
    return false;
  }
  lp gr_num;
  if !gr_expr(cs, gr, oo(&a->lhs), &lp) {
    return false;
  }
  rhs_later gr_num;
  if !gr_later_discard(cs, gr, &info->rhs_later, &rhs_later) {
    return false;
  }
  if case &Has(aft tup[ast_expr_after_consume, ast_later_discard_info]) = &info->lhs_after {
    // It's a pointer.
    name cell_num = ellval_cell(x);
    flat_size u32 = ref_cell(gr, name)->props.flat_size;
    lgn gr_num;
    if !gr_consume_actions(cs, gr, lp, &aft.car.actions, &lgn) {
      return false;
    }
    var gp = add_node(gr, node(mk_shray(rp, lgn), @[gr_op]GrDeref({name, result_cell(&aft.car), OffsetComputed(cons(flat_size, result_cell(oo(&a->rhs))))})));
    lhs_later gr_num;
    if !gr_later_discard(cs, gr, &aft.cdr, &lhs_later) {
      return false;
    }
    var laters = add_node(gr, node(mk_shray(lhs_later, rhs_later), @[gr_op]GrNop(void)));
    var gp_laters = add_node(gr, node0(@[gr_op]GrSequence({gp, laters})));
    *out = gp_laters;
    return true;
  } else {
    name cell_num = value_cell(x);
    flat_size u32 = ref_cell(gr, name)->props.flat_size;
    var gp1 = add_node(gr, node(mk_shray(rp, lp), @[gr_op]GrSubcell({name, value_cell(oo(&a->lhs)), OffsetComputed(cons(flat_size, result_cell(oo(&a->rhs))))})));
    gp gr_num;
    // TODO: Dedup with local_field code?
    switch &expr_complete_info(oo(&a->lhs))->lval {
    case &IsLvalYes(desc lval_description):
      if case DeadMe(v void) = desc.deadme {
        gp = add_node(gr, node(mk_shray(gp1), @[gr_op]GrVirtualDead({desc.num})));
      } else {
        gp = gp1;
      }
    case &IsLvalNo(desc rval_description):
      if !gr_chain_virtualdead(cs, gr, gp1, desc.partial_num, &gp) {
        return false;
      }
    }
    var gp_later = add_node(gr, node0(@[gr_op]GrSequence({gp, rhs_later})));
    *out = gp_later;
    return true;
  }
}

func gr_later_discard(cs *checkstate, gr *frame_graph, a *ast_later_discard_info, out *gr_num) bool {
  da *destroy_action = unHas(&a->action);
  return gr_destroy_action(cs, gr, da, DeadAfterDestroyYes(void), out);
}

func gr_mk_deref(cs *checkstate, gr *frame_graph, x *ast_expr, a *ast_deref, out *gr_num) bool {
  rp gr_num;
  if !gr_expr_consume(cs, gr, oo(&a->rhs), &rp) {
    return false;
  }
  var dp = add_node(gr, node(mk_shray(rp), @[gr_op]GrDeref({ellval_cell(x), result_cell(oo(&a->rhs)), OffsetConst(0)})));
  ap gr_num;
  if !gr_later_discard(cs, gr, &a->ptr_discard, &ap) {
    return false;
  }
  var gn = add_node(gr, node0(@[gr_op]GrSequence({dp, ap})));
  *out = gn;
  return true;
}

func gr_mk_addressof(cs *checkstate, gr *frame_graph, x *ast_expr, a *ast_addressof, out *gr_num) bool {
  rp gr_num;
  if !gr_expr(cs, gr, oo(&a->rhs), &rp) {
    return false;
  }
  desc *lval_description = ellval_desc(oo(&a->rhs));
  ap1 gr_num = add_node(gr, node(mk_shray(rp), @[gr_op]GrAddressof({rval_cell(x), desc->num})));
  ap gr_num;
  if case DeadMe(v void) = desc->deadme {
    ap = add_node(gr, node(mk_shray(ap1), @[gr_op]GrVirtualDead({ellval_cell(oo(&a->rhs))})));
  } else {
    ap = ap1;
  }
  *out = ap;
  return true;
}

func gr_assignment(cs *checkstate, gr *frame_graph, x *ast_expr, a *ast_assignment, out *gr_num) bool {
  lp gr_num;
  if !gr_expr(cs, gr, oo(&a->lhs), &lp) {
    return false;
  }
  rp gr_num;
  if !gr_expr(cs, gr, oo(&a->rhs), &rp) {
    return false;
  }
  lp_rp_nop gr_num = add_node(gr, node(mk_shray(lp, rp), GrNop(void)));
  switch unHas(&a->info) {
    case &StaticSelfAssignment(v void): {
      *out = lp_rp_nop;
      return true;
    }
    case &SimpleMoveAssignment(smi ast_simple_move_assignment_info): {
      dgn gr_num;
      if !gr_destroy_action(cs, gr, &smi.target_destroy, DeadAfterDestroyNo(void), &dgn) {
        return false;
      }
      mgn gr_num;
      if !gr_move_action(cs, gr, &smi.rhs_move, &mgn) {
        return false;
      }
      gn1 gr_num = add_node(gr, node0(@[gr_op]GrSequence({dgn, mgn})));
      gn2 gr_num = add_node(gr, node0(@[gr_op]GrSequence({lp_rp_nop, gn1})));
      *out = gn2;
      return true;
    }
    case &SimpleCopyDestroyAssignment(scdi ast_simple_copydestroy_assignment_info): {
      dgn gr_num;
      if !gr_destroy_action(cs, gr, &scdi.target_destroy, DeadAfterDestroyNo(void), &dgn) {
        return false;
      }
      mgn1 gr_num;
      if !gr_copy_action(cs, gr, &scdi.rhs_copy, &mgn1) {
        return false;
      }
      mgn gr_num;
      if !gr_chain_virtualdead(cs, gr, mgn1, scdi.rhs_copy.src, &mgn) {
        return false;
      }
      drgn gr_num;
      if !gr_destroy_action(cs, gr, &scdi.rhs_cleanup, DeadAfterDestroyYes(void), &drgn) {
        return false;
      }
      gn1 gr_num = add_node(gr, node0(@[gr_op]GrSequence({mgn, drgn})));
      gn2 gr_num = add_node(gr, node0(@[gr_op]GrSequence({dgn, gn1})));
      gn3 gr_num = add_node(gr, node0(@[gr_op]GrSequence({lp_rp_nop, gn2})));
      *out = gn3;
      return true;
    }
    case &ConditionalAssignment(ci ast_conditional_assignment_info): {
      var fc = add_node(gr, node0(@[gr_op]GrWriteConst({ci.comparecells.funcell, ConstDef(ci.comparecells.ip)})));
      var dp = add_node(gr, node0(@[gr_op]GrAddressof({ci.comparecells.destptr, value_cell(oo(&a->lhs))})));
      var sp = add_node(gr, node0(@[gr_op]GrAddressof({ci.comparecells.srcptr, value_cell(oo(&a->rhs))})));
      var ap = add_node(gr, node(mk_shray(fc, dp, sp), @[gr_op]GrApply({ci.comparecells.funcell, mk_shray(ci.comparecells.destptr, ci.comparecells.srcptr), ci.comparecells.cmp_result})));

      var just_dead = add_node(gr, node0(@[gr_op]GrDead({ci.comparecells.cmp_result})));
      if case DeadMe(v void) = ci.rhs_deadme {
        // TODO: It would be nice if we just had a closing node for virtualdead, maybe also for just_dead, instead of these duplicate tails.
        if !gr_chain_virtualdead(cs, gr, just_dead, ci.conditional_copy.src, &just_dead) {
          return false;
        }
      }

      assign_destroy gr_num;
      if !gr_destroy_action(cs, gr, &ci.conditional_destroy, DeadAfterDestroyNo(void), &assign_destroy) {
        return false;
      }
      assign_copy gr_num;
      if !gr_copy_action(cs, gr, &ci.conditional_copy, &assign_copy) {
        return false;
      }
      assign gr_num = add_node(gr, node0(@[gr_op]GrSequence({assign_destroy, assign_copy})));
      dead_before_assign gr_num = add_node(gr, node0(@[gr_op]GrDead({ci.comparecells.cmp_result})));
      dead_then_assign gr_num = add_node(gr, node0(@[gr_op]GrSequence({dead_before_assign, assign})));
      if case DeadMe(v void) = ci.rhs_deadme {
        if !gr_chain_virtualdead(cs, gr, dead_then_assign, ci.conditional_copy.src, &dead_then_assign) {
          return false;
        }
      }
      cases shray[tup[gr_const, gr_num]] = mk_shray(cons(@[gr_const]ConstInt(~ @[u32] 0), dead_then_assign), cons(@[gr_const]ConstInt(~ @[u32] 1), just_dead));

      var br = add_node(gr, node(mk_shray(ap), @[gr_op]GrBranch({ci.comparecells.cmp_result, cases, None()})));
      var seq_lp_rp_nop = add_node(gr, node0(@[gr_op]GrSequence({lp_rp_nop, br})));
      *out = seq_lp_rp_nop;
      return true;
    }
  }
}

func gr_logical_conjunction(cs *checkstate, gr *frame_graph, x *ast_expr, a *ast_logical_conjunction, out *gr_num) bool {
  lhs_dep gr_num;
  if !gr_expr_consume(cs, gr, oo(&a->lhs), &lhs_dep) {
    return false;
  }
  rhs_dep gr_num;
  if !gr_expr_consume(cs, gr, oo(&a->rhs), &rhs_dep) {
    return false;
  }

  rhs_cp_gn gr_num = add_node(gr, node(mk_shray(rhs_dep), @[gr_op]GrMemCopy({rval_cell(x), result_cell(oo(&a->rhs))})));
  rhs_dead_gn gr_num = add_node(gr, node(mk_shray(rhs_cp_gn), @[gr_op]GrDead({result_cell(oo(&a->rhs))})));

  rhs_lhs_dead_gn gr_num = add_node(gr, node0(@[gr_op]GrDead({result_cell(oo(&a->lhs))})));
  lhs_dead_then_rhs gr_num = add_node(gr, node0(@[gr_op]GrSequence({rhs_lhs_dead_gn, rhs_dead_gn})));

  lhs_cp_gn gr_num = add_node(gr, node0(@[gr_op]GrMemCopy({rval_cell(x), result_cell(oo(&a->lhs))})));
  lhs_dead_gn gr_num = add_node(gr, node(mk_shray(lhs_cp_gn), @[gr_op]GrDead({result_cell(oo(&a->lhs))})));

  cases array[tup[gr_const, gr_num]];
  short_circuit_case gr_const;
  eval_rhs_case gr_const;
  if a->is_logical_or {
    short_circuit_case = ConstInt(~ @[u32] 1);
    eval_rhs_case = ConstInt(~ @[u32] 0);
  } else {
    short_circuit_case = ConstInt(~ @[u32] 0);
    eval_rhs_case = ConstInt(~ @[u32] 1);
  }
  bn gr_num = add_node(gr, node(mk_shray(lhs_dep), @[gr_op]GrBranch({result_cell(oo(&a->lhs)), mk_shray({short_circuit_case, lhs_dead_gn}, {eval_rhs_case, lhs_dead_then_rhs}), None()})));
  *out = bn;
  return true;
}

func gr_funcall(cs *checkstate, gr *frame_graph, x *ast_expr, a *ast_funcall, out *gr_num) bool {
  nparams size = count(&a->params);
  precs array[gr_num];
  reserve(&precs, nparams + 1);
  dep gr_num;
  if !gr_expr_consume(cs, gr, oo(&a->fun), &dep) {
    return false;
  }
  push(&precs, dep);
  paramcells array[cell_num];
  reserve(&paramcells, nparams);
  for i size = 0; i < nparams; i = i + 1 {
    param *ast_expr_consume = ref(&a->params, i);
    if !gr_expr_consume(cs, gr, param, &dep) {
      return false;
    }
    push(&precs, dep);
    push(&paramcells, result_cell(param));
  }
  var ap = add_node(gr, node(freeze(&precs), @[gr_op]GrApply({result_cell(oo(&a->fun)), freeze(&paramcells), rval_cell(x)})));
  *out = ap;
  return true;
}

func gr_string_literal(cs *checkstate, gr *frame_graph, x *ast_expr, a *ast_string_literal, out *gr_num) bool {
  bytes array[u8];
  nchars size = count(&a->charspecs);
  reserve(&bytes, nchars);
  for i size = 0; i < nchars; i = i + 1 {
    ch i32 = get(&a->charspecs, i).value;
    if ch < 0 || ch > 255 {
      ice(_u8("gr_string_literal char values out of range"));
    }
    push(&bytes, ~ch);
  }
  var gn = add_node(gr, node0(@[gr_op]GrWriteConst({rval_cell(x), ConstBytes(freeze(&bytes))})));
  *out = gn;
  return true;
}

func gr_literal(cs *checkstate, gr *frame_graph, x *ast_expr, value bigint, out *gr_num) bool {
  var gn = add_node(gr, node0(@[gr_op]GrWriteConst({rval_cell(x), ConstInt(value)})));
  *out = gn;
  return true;
}

func gr_name_expr(cs *checkstate, gr *frame_graph, x *ast_expr, a *ast_name_expr, out *gr_num) bool {
  switch unHas(&a->name_info) {
    case &LocalResolve(li local_info): {
      *out = add_node(gr, node0(@[gr_op]GrNop(void)));
      return true;
    }
    case &GlobalResolve(gi global_info): {
      *out = add_node(gr, node0(@[gr_op]GrWriteConst({rval_cell(x), ConstDef({gi.ent, gi.inst})})));
      return true;
    }
    case &EnumConstructor(ei enum_constructor_info): {
      *out = add_node(gr, node0(@[gr_op]GrWriteConst({rval_cell(x), ConstDef(ei.ip)})));
      return true;
    }
  }
}

func ellval_desc(x *is_lval) *lval_description {
  switch x {
    case &IsLvalYes(desc lval_description): { return &desc; }
    case &IsLvalNo(desc rval_description): {
      ice(_u8("lvalue_value_cell expects lvalue"));
      return fake();
    }
  }
}

func ellval_cell(x *is_lval) cell_num {
  return ellval_desc(x)->num;
}

func ellval_cell(a *ast_expr) cell_num {
  return ellval_desc(a)->num;
}

func ellval_desc(a *ast_expr) *lval_description {
  return ellval_desc(&expr_complete_info(a)->lval);
}

func rval_cell(x *ast_expr) cell_num {
  return rval_cell(&expr_complete_info(x)->lval);
}

func rval_cell(x *is_lval) cell_num {
  switch x {
    case &IsLvalNo(desc rval_description): {
      return desc.whole_num;
    }
    case &IsLvalYes(desc lval_description): {
      ice(_u8("rval_cell sees lvalue"));
      return fake();
    }
  }
}

// TODO: This is a lame and fragile way to specify when to make cells be GrDead.
defenum dead_after_destroy {
  DeadAfterDestroyYes void;
  DeadAfterDestroyNo void;
};

func gr_after_actions(cs *checkstate, gr *frame_graph, prec gr_num, x *opt[destroy_action], out *gr_num) bool {
  if case &Has(da destroy_action) = x {
    dep gr_num;
    if !gr_destroy_action(cs, gr, &da, DeadAfterDestroyYes(void), &dep) {
      return false;
    }
    prec = add_node(gr, node0(@[gr_op]GrSequence({prec, dep})));
  }
  *out = prec;
  return true;
}

func gr_chain_virtualdead(cs *checkstate, gr *frame_graph, prec gr_num, c cell_num, out *gr_num) bool {
  switch location(ref_cell(gr, c)) {
  case LocationVirtual(v void):
    *out = add_node(gr, node(mk_shray(prec), @[gr_op]GrVirtualDead({c})));
  case LocationStatic(v void):
    *out = prec;
  }
  return true;
}

func gr_consume_actions(cs *checkstate, gr *frame_graph, prec gr_num, x *consume_actions, out *gr_num) bool {
  switch x {
  case &ConsumeByInPlace(v void): { }
  case &ConsumeByCopyDestroy(cd copy_destroy_action):
    dep gr_num;
    if !gr_copy_action(cs, gr, &cd.copy, &dep) {
      return false;
    }
    if !gr_chain_virtualdead(cs, gr, dep, cd.copy.src, &dep) {
      return false;
    }
    prec = add_node(gr, node0(@[gr_op]GrSequence({prec, dep})));
    if !gr_destroy_action(cs, gr, &cd.destroy, DeadAfterDestroyYes(void), &dep) {
      return false;
    }
    prec = add_node(gr, node0(@[gr_op]GrSequence({prec, dep})));
  case &ConsumeByCopy(cc tup[copy_action, lval_deadme]):
    dep gr_num;
    if !gr_copy_action(cs, gr, &cc.car, &dep) {
      return false;
    }
    if case DeadMe(v void) = cc.cdr {
      if !gr_chain_virtualdead(cs, gr, dep, cc.car.src, &dep) {
        return false;
      }
    }
    prec = add_node(gr, node0(@[gr_op]GrSequence({prec, dep})));
  }
  *out = prec;
  return true;
}

func gr_copy_action(cs *checkstate, gr *frame_graph, x *copy_action, out *gr_num) bool {
  return gr_bi_action(cs, gr, &x->~, out);
}

func gr_move_action(cs *checkstate, gr *frame_graph, x *move_action, out *gr_num) bool {
  dep gr_num;
  if !gr_bi_action(cs, gr, &x->~, &dep) {
    return false;
  }
  *out = add_node(gr, node(mk_shray(dep), @[gr_op]GrDead({x->src})));
  return true;
}

func gr_uni_fun_ctor_desc(cs *checkstate, gr *frame_graph, desc *uni_fun_ctor_desc, arg cell_num) gr_num {
  var fc = add_node(gr, node0(@[gr_op]GrWriteConst({desc->funcell, ConstDef(desc->ip)})));
  var arp = add_node(gr, node0(@[gr_op]GrAddressof({desc->argptr, arg})));
  var ap = add_node(gr, node(mk_shray(fc, arp), @[gr_op]GrApply({desc->funcell, mk_shray(desc->argptr), desc->retvoid})));
  var deadret = add_node(gr, node(mk_shray(ap), @[gr_op]GrDead({desc->retvoid})));
  return deadret;
}

func gr_init_action(cs *checkstate, gr *frame_graph, x *init_action, out *gr_num) bool {
  switch &x->ctor {
    case &UniTrivialCtor(v void): {
      var dp = add_node(gr, node0(@[gr_op]GrWriteConst({x->arg, ConstInt(~ @[u32] 0)})));
      *out = dp;
      return true;
    }
    case &UniFunCtor(desc uni_fun_ctor_desc): {
      gn gr_num = gr_uni_fun_ctor_desc(cs, gr, &desc, x->arg);
      *out = gn;
      return true;
    }
  }
}

func gr_destroy_action(cs *checkstate, gr *frame_graph, x *destroy_action, dad dead_after_destroy, out *gr_num) bool {
  switch &x->ctor {
    case &UniTrivialCtor(v void): {
      dp gr_num;
      if case DeadAfterDestroyYes(v2 void) = dad {
        dp = add_node(gr, node0(@[gr_op]GrDead({x->arg})));
      } else {
        dp = add_node(gr, node0(@[gr_op]GrNop(void)));
      }
      *out = dp;
      return true;
    }
    case &UniFunCtor(desc uni_fun_ctor_desc): {
      gn gr_num = gr_uni_fun_ctor_desc(cs, gr, &desc, x->arg);
      dp gr_num;
      if case DeadAfterDestroyYes(v2 void) = dad {
        dp = add_node(gr, node(mk_shray(gn), @[gr_op]GrDead({x->arg})));
      } else {
        dp = gn;
      }
      *out = dp;
      return true;
    }
  }
}

func gr_bi_fun_ctor_desc(cs *checkstate, gr *frame_graph, desc *bi_fun_ctor_desc, dest cell_num, src cell_num) gr_num {
  var fc = add_node(gr, node0(@[gr_op]GrWriteConst({desc->funcell, ConstDef(desc->ip)})));
  var dp = add_node(gr, node0(@[gr_op]GrAddressof({desc->destptr, dest})));
  var sp = add_node(gr, node0(@[gr_op]GrAddressof({desc->srcptr, src})));
  var ap = add_node(gr, node(mk_shray(fc, dp, sp), @[gr_op]GrApply({desc->funcell, mk_shray(desc->destptr, desc->srcptr), desc->retvoid})));
  var deadret = add_node(gr, node(mk_shray(ap), @[gr_op]GrDead({desc->retvoid})));
  return deadret;
}

func gr_bi_action(cs *checkstate, gr *frame_graph, x *bi_action, out *gr_num) bool {
  switch &x->ctor {
    case &BiTrivialCtor(v void): {
      var cp = add_node(gr, node0(@[gr_op]GrMemCopy({x->dest, x->src})));
      *out = cp;
      return true;
    }
    case &BiFunCtor(desc bi_fun_ctor_desc): {
      gn gr_num = gr_bi_fun_ctor_desc(cs, gr, &desc, x->dest, x->src);
      *out = gn;
      return true;
    }
  }
}

// TODO: There's a lot of duplicated code in the splay-out of this function.
func gr_magic(cs *checkstate, clq *clqueue, mag *def_magic, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num]) bool {
  switch mag {
  case &MagicBzero(mb magic_bzero):
    return gr_magic_bzero(cs, clq, &mb, gr_out, gn_out, return_cell_out, arg_cells_out);
  case &MagicMemcopy(mm magic_memcopy):
    return gr_magic_memcopy(cs, clq, &mm, gr_out, gn_out, return_cell_out, arg_cells_out);
  case &MagicNopdestroy(v void):
    return gr_magic_nopdestroy(cs, clq, gr_out, gn_out, return_cell_out, arg_cells_out);

  case &MagicCtor(wmc which_magic_ctor):
    return gr_magic_ctor(cs, clq, wmc.wc, &wmc.mc, gr_out, gn_out, return_cell_out, arg_cells_out);
  case &MagicEnumConstruct(mec magic_enum_construct):
    arg_cell cell_num;
    if !gr_magic_enum_construct(cs, clq, &mec, gr_out, gn_out, return_cell_out, &arg_cell) {
      return false;
    }
    *arg_cells_out = mk_array(arg_cell);
    return true;
  }
}

deftype gr_minimal_basics struct {
  return_cell cell_num;
  argcells array[cell_num];
};

deftype gr_basics struct {
  minimal gr_minimal_basics;
  pointeecells array[cell_num];
  derefs shray[gr_num];
};

func add_minimal_basics(cs *checkstate, clq *clqueue, gr *frame_graph, size u32, arity size, out *gr_minimal_basics) void {
  pointee_tp cu_typrop = compute_prim(clq, primitive_padding_type(cs, size));
  argtp cu_typrop = compute_prim(clq, ptr_type(cs, pointee_tp.cu.~));
  voidtp cu_typrop = compute_prim(clq, primitive_void_type(cs));
  ret gr_minimal_basics;
  ret.return_cell = add_cell(gr, {LocationStatic(void), voidtp.cu, voidtp.props});
  for i size = 0; i < arity; i = i + 1 {
    ac cell_num = add_cell(gr, {LocationStatic(void), argtp.cu, argtp.props});
    push(&ret.argcells, ac);
  }
  *out = ret;
}

func add_basics(cs *checkstate, clq *clqueue, gr *frame_graph, size u32, arity size, out *gr_basics) void {
  ret gr_basics;
  add_minimal_basics(cs, clq, gr, size, arity, &ret.minimal);

  pointee_tp cu_typrop = compute_prim(clq, primitive_padding_type(cs, size));
  derefs array[gr_num];
  for i size = 0; i < arity; i = i + 1 {
    pc cell_num = add_cell(gr, {LocationVirtual(void), pointee_tp.cu, pointee_tp.props});
    push(&ret.pointeecells, pc);
    dn gr_num = add_node(gr, node0(@[gr_op]GrDeref({pc, get(&ret.minimal.argcells, i), OffsetConst(0)})));
    push(&derefs, dn);
  }
  ret.derefs = freeze(&derefs);
  *out = ret;
}

func minimal_basics_cleanup_precs(gr *frame_graph, bas *gr_minimal_basics, out *array[gr_num]) void {
  precs array[gr_num];
  ncells size = count(&bas->argcells);
  for i size = 0; i < ncells; i = i + 1 {
    gd gr_num = add_node(gr, node0(@[gr_op]GrDead({get(&bas->argcells, i)})));
    push(&precs, gd);
  }
  var retset = add_node(gr, node0(@[gr_op]GrWriteConst({bas->return_cell, ConstInt(bigu(0))})));
  push(&precs, retset);
  swap(out, &precs);
}

func minimal_basics_cleanup(cs *checkstate, clq *clqueue, gr *frame_graph, bas *gr_minimal_basics, gn gr_num, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num]) void {
  precs array[gr_num];
  minimal_basics_cleanup_precs(gr, bas, &precs);
  var nopgn = add_node(gr, node(freeze(&precs), @[gr_op]GrNop(void)));
  var fingn = add_node(gr, node0(@[gr_op]GrSequence({gn, nopgn})));
  *gr_out = *gr;
  *gn_out = fingn;
  *return_cell_out = bas->return_cell;
  *arg_cells_out = bas->argcells;
}

func basics_cleanup(cs *checkstate, clq *clqueue, gr *frame_graph, bas *gr_basics, gn gr_num, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num]) void {
  precs array[gr_num];
  minimal_basics_cleanup_precs(gr, &bas->minimal, &precs);
  ncells size = count(&bas->pointeecells);
  for i size = 0; i < ncells; i = i + 1 {
    pd gr_num = add_node(gr, node0(@[gr_op]GrVirtualDead({get(&bas->pointeecells, i)})));
    push(&precs, pd);
  }
  var nopgn = add_node(gr, node(freeze(&precs), @[gr_op]GrNop(void)));
  var fingn = add_node(gr, node0(@[gr_op]GrSequence({gn, nopgn})));
  *gr_out = *gr;
  *gn_out = fingn;
  *return_cell_out = bas->minimal.return_cell;
  *arg_cells_out = bas->minimal.argcells;
}

func gr_magic_nopdestroy(cs *checkstate, clq *clqueue, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num]) bool {
  gr frame_graph = init_frame_graph_empty(intern(cs->im, _s("magic_nopdestroy")));
  bas gr_minimal_basics;
  // TODO: How about make the size parameter opt[u32], don't deref if no size.
  add_minimal_basics(cs, clq, &gr, 0 /* Pass a made-up size. */, 1, &bas);
  gn gr_num = add_node(&gr, node0(@[gr_op]GrNop(void)));
  minimal_basics_cleanup(cs, clq, &gr, &bas, gn, gr_out, gn_out, return_cell_out, arg_cells_out);
  return true;
}

func gr_magic_memcopy(cs *checkstate, clq *clqueue, mm *magic_memcopy, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num]) bool {
  gr frame_graph = init_frame_graph_empty(intern(cs->im, _s("magic_memcopy")));
  bas gr_basics;
  add_basics(cs, clq, &gr, *unHas(&mm->size), 2, &bas);
  gn gr_num = add_node(&gr, node(bas.derefs, @[gr_op]GrMemCopy({get(&bas.pointeecells, 0), get(&bas.pointeecells, 1)})));
  basics_cleanup(cs, clq, &gr, &bas, gn, gr_out, gn_out, return_cell_out, arg_cells_out);
  return true;
}

func gr_magic_bzero(cs *checkstate, clq *clqueue, mb *magic_bzero, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num]) bool {
  gr frame_graph = init_frame_graph_empty(intern(cs->im, _s("magic_bzero")));
  bas gr_basics;
  add_basics(cs, clq, &gr, *unHas(&mb->size), 1, &bas);
  gn gr_num = add_node(&gr, node(bas.derefs, @[gr_op]GrWriteConst({get(&bas.pointeecells, 0), ConstInt(bigu(0))})));
  basics_cleanup(cs, clq, &gr, &bas, gn, gr_out, gn_out, return_cell_out, arg_cells_out);
  return true;
}

func gr_magic_ctor(cs *checkstate, clq *clqueue, wc which_ctor, mc *magic_ctor, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num]) bool {
  info *magic_ctor_info = ref_info(mc);
  switch info {
  case &MagicWholeFieldInfo(mwfi magic_whole_field_info):
    return gr_magic_whole_field_info(cs, clq, wc, &mwfi, gr_out, gn_out, return_cell_out, arg_cells_out);
  case &MagicStructInfo(msi magic_struct_info):
    return gr_magic_struct_info(cs, clq, wc, &msi, gr_out, gn_out, return_cell_out, arg_cells_out);
  case &MagicEnumInfo(mei magic_enum_info):
    return gr_magic_enum_info(cs, clq, wc, &mei, gr_out, gn_out, return_cell_out, arg_cells_out);
  case &MagicArraytypeInfo(mai magic_arraytype_info):
    return gr_magic_arraytype_info(cs, clq, wc, &mai, gr_out, gn_out, return_cell_out, arg_cells_out);
  }
}

func gr_magic_arraytype_info(cs *checkstate, clq *clqueue, wc which_ctor, mai *magic_arraytype_info, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num]) bool {
  gr frame_graph = init_frame_graph_empty(intern(cs->im, _s("magic_arraytype")));
  argtp cu_typrop = compute_prim(clq, ptr_type(cs, mai->cu_type.~));

  voidtp cu_typrop = compute_prim(clq, primitive_void_type(cs));

  param *te_typeexpr;
  arraycount u32;
  if case &TeArraytype(at te_arraytype) = &mai->cu_type.~ {
    param = oo(&at.param);
    if case Has(atcount u32) = at.count {
      arraycount = atcount;
    } else {
      ice(_u8("gr_magic_arraytype_info missing count"));
    }
  } else {
    ice(_u8("gr_magic_arraytype_info sees non-array type"));
  }

  param_props type_properties;
  if !compute_complete_type_properties(cs, clq, param, &param_props) {
    return false;
  }

  elemptrtype cu_typeexpr;
  elemptrtype_props type_properties;
  compute_prim(cs, clq, ptr_type(cs, *param), &elemptrtype, &elemptrtype_props);

  nargs size = num_args(wc);

  fntype cu_typeexpr;
  fntype_props type_properties;
  compute_prim(cs, clq, fn_type(cs, @[shray[_]]repeat(nargs, elemptrtype.~), voidtp.cu.~), &fntype, &fntype_props);

  size_type cu_typeexpr;
  size_type_props type_properties;
  compute_prim(cs, clq, primitive_size_type(cs), &size_type, &size_type_props);

  argcells array[cell_num];
  pointeecells array[cell_num];
  derefgns array[gr_num];
  for i size = 0; i < nargs; i = i + 1 {
    ac cell_num = add_cell(&gr, {LocationStatic(void), argtp.cu, argtp.props});
    push(&argcells, ac);
    pc cell_num = add_cell(&gr, {LocationVirtual(void), mai->cu_type, mai->cu_props});
    push(&pointeecells, pc);

    gn1 gr_num = add_node(&gr, node0(@[gr_op]GrDeref({pc, ac, OffsetConst(0)})));
    gn gr_num = add_node(&gr, node(mk_shray(gn1), @[gr_op]GrDead({ac})));
    push(&derefgns, gn);
  }

  derefgn gr_num = add_node(&gr, node(freeze(&derefgns), GrNop(void)));

  return_cell cell_num = add_cell(&gr, {LocationStatic(void), voidtp.cu, voidtp.props});

  indexcell cell_num = add_cell(&gr, {LocationStatic(void), size_type, size_type_props});

  deadprecs array[gr_num];
  if true {
    setret gr_num = add_node(&gr, node0(@[gr_op]GrWriteConst({return_cell, ConstInt(bigu(0))})));
    push(&deadprecs, setret);
    indexdead gr_num = add_node(&gr, node0(@[gr_op]GrDead({indexcell})));
    push(&deadprecs, indexdead);

    for i size = 0; i < nargs; i = i + 1 {
      pd gr_num = add_node(&gr, node0(@[gr_op]GrVirtualDead({get(&pointeecells, i)})));
      push(&deadprecs, pd);
    }
  }

  deadseq gr_num = add_node(&gr, node(freeze(&deadprecs), @[gr_op]GrNop(void)));

  topgn gr_num = add_node(&gr, node0(@[gr_op]GrNop(void)));

  elemptrcells array[cell_num];
  precs array[gr_num];
  for j size = 0; j < nargs; j = j + 1 {
    ec cell_num = add_cell(&gr, {LocationVirtual(void), ~ *param, param_props});
    indexcopycell cell_num = add_cell(&gr, {LocationStatic(void), size_type, size_type_props});
    copygn gr_num = add_node(&gr, node0(@[gr_op]GrMemCopy({indexcopycell, indexcell})));
    gn gr_num = add_node(&gr, node(mk_shray(copygn), @[gr_op]GrSubcell({ec, get(&pointeecells, j), OffsetComputed({param_props.flat_size, indexcopycell})})));
    deadcopy gr_num = add_node(&gr, node(mk_shray(gn), @[gr_op]GrDead({indexcopycell})));
    epc cell_num = add_cell(&gr, {LocationStatic(void), elemptrtype, elemptrtype_props});
    push(&elemptrcells, epc);
    ptrgn gr_num = add_node(&gr, node(mk_shray(deadcopy), @[gr_op]GrAddressof({epc, ec})));
    ecdeadgn gr_num = add_node(&gr, node(mk_shray(ptrgn), @[gr_op]GrVirtualDead({ec})));
    push(&precs, ecdeadgn);
  }

  elemretcell cell_num = add_cell(&gr, {LocationStatic(void), voidtp.cu, voidtp.props});
  func_cell cell_num = add_cell(&gr, {LocationStatic(void), fntype, fntype_props});

  func_gn gr_num = add_node(&gr, node0(@[gr_op]GrWriteConst({func_cell, ConstDef(mai->ip)})));
  push(&precs, func_gn);

  ap gr_num = add_node(&gr, node(freeze(&precs), @[gr_op]GrApply({func_cell, freeze(&elemptrcells), elemretcell})));
  vd gr_num = add_node(&gr, node(mk_shray(ap), @[gr_op]GrDead({elemretcell})));

  ic2cell cell_num = add_cell(&gr, {LocationStatic(void), size_type, size_type_props});
  ic2gn gr_num = add_node(&gr, node0(@[gr_op]GrMemCopy({ic2cell, indexcell})));
  onecell cell_num = add_cell(&gr, {LocationStatic(void), size_type, size_type_props});
  onegn gr_num = add_node(&gr, node0(@[gr_op]GrWriteConst({onecell, ConstInt(bigu(1))})));
  op_action primitive_numeric_op_action;
  if case CtorDestroy(v void) = wc {
    op_action = NumSub(void);
  } else {
    op_action = NumAdd(void);
  }
  incrgn gr_num = add_node(&gr, node(mk_shray(ic2gn, onegn), @[gr_op]GrPrimApply({PrimNum({cs->plat.sizetraits.flat.size, cs->plat.sizetraits.numeric, op_action}), mk_shray(ic2cell, onecell), indexcell})));

  terminal_case u32;
  init_value u32;
  body_gn gr_num;
  if case CtorDestroy(v void) = wc {
    body_gn = add_node(&gr, node0(@[gr_op]GrSequence({incrgn, vd})));
    init_value = arraycount;
    terminal_case = 0;
  } else {
    body_gn = add_node(&gr, node0(@[gr_op]GrSequence({vd, incrgn})));
    init_value = 0;
    terminal_case = arraycount;
  }

  tie_gn gr_num = add_node(&gr, node0(@[gr_op]GrSequence({body_gn, topgn})));

  branch_gn gr_num = add_node(&gr, node0(@[gr_op]GrBranch({indexcell, mk_shray(cons(@[gr_const]ConstInt(bigu(terminal_case)), deadseq)), Has(tie_gn)})));

  mut_nop_node(&gr, topgn, node0(@[gr_op]GrJmp({branch_gn})));

  init_indexcell_gn gr_num = add_node(&gr, node0(@[gr_op]GrWriteConst({indexcell, ConstInt(bigu(init_value))})));
  it_gn gr_num = add_node(&gr, node0(@[gr_op]GrSequence({init_indexcell_gn, topgn})));
  var gn = add_node(&gr, node0(@[gr_op]GrSequence({derefgn, it_gn})));
  *gr_out = gr;
  *gn_out = gn;
  *return_cell_out = return_cell;
  *arg_cells_out = argcells;
  return true;
}

func gr_magic_enum_info(cs *checkstate, clq *clqueue, wc which_ctor, mei *magic_enum_info, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num]) bool {
  init_padding bool = false;
  switch wc {
  case CtorInit(v void):
    ice(_u8("Magic CtorInit on enum type"));
  case CtorCopy(v void):
    init_padding = true;
  case CtorMove(v void):
    init_padding = true;
  case CtorDestroy(v void):
    // don't init padding.
  }
  gr frame_graph = init_frame_graph_empty(intern(cs->im, _s("magic_enum_info")));
  argtp cu_typrop = compute_prim(clq, ptr_type(cs, mei->cu_type.~));

  voidtp cu_typrop = compute_prim(clq, primitive_void_type(cs));

  et *te_enum;
  if case &TeEnum(t te_enum) = &mei->cu_type.~ {
    et = &t;
  } else {
    ice(_u8("gr_magic_enum_info called on non-enum"));
  }

  tagtype cu_typeexpr;
  tagtype_props type_properties;
  compute_prim(cs, clq, enum_tag_type(cs, et), &tagtype, &tagtype_props);

  argcells array[cell_num];
  pointeecells array[cell_num];
  tagcells array[cell_num];
  deref_gns array[gr_num];
  tagcell_gns array[gr_num];
  nargs size = num_args(wc);
  for i size = 0; i < nargs; i = i + 1 {
    ac cell_num = add_cell(&gr, {LocationStatic(void), argtp.cu, argtp.props});
    push(&argcells, ac);
    pc cell_num = add_cell(&gr, {LocationVirtual(void), mei->cu_type, mei->cu_props});
    push(&pointeecells, pc);
    tc cell_num = add_cell(&gr, {LocationVirtual(void), tagtype, tagtype_props});
    push(&tagcells, tc);

    derefgn1 gr_num = add_node(&gr, node0(@[gr_op]GrDeref({pc, ac, OffsetConst(0)})));
    derefgn gr_num = add_node(&gr, node(mk_shray(derefgn1), @[gr_op]GrDead({ac})));
    push(&deref_gns, derefgn);
    tcgn gr_num = add_node(&gr, node(mk_shray(derefgn), @[gr_op]GrSubcell({tc, pc, OffsetConst(enum_tag_offset)})));
    push(&tagcell_gns, tcgn);
  }

  deref_gn gr_num = add_node(&gr, node(freeze(&tagcell_gns), @[gr_op]GrNop(void)));

  return_cell cell_num = add_cell(&gr, {LocationStatic(void), voidtp.cu, voidtp.props});
  deadprecs array[gr_num];
  if true {
    setret gr_num = add_node(&gr, node0(@[gr_op]GrWriteConst({return_cell, ConstInt(~ @[u32] 0)})));
    push(&deadprecs, setret);
    for i size = 0; i < nargs; i = i + 1 {
      pd gr_num = add_node(&gr, node0(@[gr_op]GrVirtualDead({get(&pointeecells, i)})));
      push(&deadprecs, pd);
      td gr_num = add_node(&gr, node0(@[gr_op]GrVirtualDead({get(&tagcells, i)})));
      push(&deadprecs, td);
    }
  }
  deadseq gr_num = add_node(&gr, node(freeze(&deadprecs), @[gr_op]GrNop(void)));

  cases_gn array[tup[gr_const, gr_num]];
  nconstructors size = count(&et->constructors);
  for i size = 0; i < nconstructors; i = i + 1 {
    tagval enum_tag_value = mk_enum_tag_value(i);

    fieldtype cu_typeexpr = ~ref(&et->constructors, i)->type;
    fieldtype_props type_properties;
    if !compute_type_properties(cs, clq, &fieldtype, &fieldtype_props) {
      return false;
    }

    field_offset u32 = enum_field_offset(cs, et, tagval);
    field_end u32 = field_offset + fieldtype_props.flat_size;
    tag_end u32 = enum_tag_offset + tagtype_props.flat_size;
    prepadding_ogn opt[gr_num]
      = gr_bzero_subcell(clq, &gr, get(&pointeecells, 0), tag_end, field_offset - tag_end);
    postpadding_ogn opt[gr_num]
      = gr_bzero_subcell(clq, &gr, get(&pointeecells, 0), field_end, mei->cu_props.flat_size - field_end);

    fieldcella array[cell_num];
    fieldcellgn array[gr_num];
    for j size = 0; j < nargs; j = j + 1 {
      fc cell_num = add_cell(&gr, {LocationVirtual(void), fieldtype, fieldtype_props});
      push(&fieldcella, fc);
      sn gr_num = add_node(&gr, node0(@[gr_op]GrSubcell({get(&fieldcella, j), get(&pointeecells, j), OffsetConst(field_offset)})));
      push(&fieldcellgn, sn);
    }

    last_ogn gr_num;
    if case &Has(ip instpair) = ref(&mei->cips, i) {
      fieldptrtype cu_typeexpr;
      fieldptrtype_props type_properties;
      compute_prim(cs, clq, ptr_type(cs, fieldtype.~), &fieldptrtype, &fieldptrtype_props);

      fieldptrcella array[cell_num];
      precs array[gr_num];
      for j size = 0; j < nargs; j = j + 1 {
        fpc cell_num = add_cell(&gr, {LocationStatic(void), fieldptrtype, fieldptrtype_props});
        push(&fieldptrcella, fpc);
        an1 gr_num = add_node(&gr, node(mk_shray(get(&fieldcellgn, j)), @[gr_op]GrAddressof({fpc, get(&fieldcella, j)})));
        an gr_num = add_node(&gr, node(mk_shray(an1), @[gr_op]GrVirtualDead({get(&fieldcella, j)})));
        push(&precs, an);
      }

      fieldretcell cell_num = add_cell(&gr, {LocationStatic(void), voidtp.cu, voidtp.props});

      fntype cu_typeexpr;
      fntype_props type_properties;
      compute_prim(cs, clq, fn_type(cs, @[shray[_]]repeat(nargs, fieldptrtype.~), voidtp.cu.~), &fntype, &fntype_props);

      func_cell cell_num = add_cell(&gr, {LocationStatic(void), fntype, fntype_props});
      func_gn gr_num = add_node(&gr, node0(@[gr_op]GrWriteConst({func_cell, ConstDef(ip)})));
      push(&precs, func_gn);

      ap gr_num = add_node(&gr, node(freeze(&precs), @[gr_op]GrApply({func_cell, freeze(&fieldptrcella), fieldretcell})));
      vd gr_num = add_node(&gr, node(mk_shray(ap), @[gr_op]GrDead({fieldretcell})));
      last_ogn = vd;
    } else {
      ogn opt[gr_num];
      switch wc {
      case CtorInit(v void):
        ice(_u8("CtorInit on enum type"));
      case CtorCopy(v void):
        var cgn = add_node(&gr, node(freeze(&fieldcellgn), @[gr_op]GrMemCopy({get(&fieldcella, 0), get(&fieldcella, 1)})));
        ogn = Has(cgn);
      case CtorMove(v void):
        var cgn = add_node(&gr, node(freeze(&fieldcellgn), @[gr_op]GrMemCopy({get(&fieldcella, 0), get(&fieldcella, 1)})));
        ogn = Has(cgn);
      case CtorDestroy(v void):
        ogn = None();
        // do nothing.
      }
      if case Has(gn gr_num) = ogn {
        dfcprecs array[gr_num];
        for j size = 0; j < nargs; j = j + 1 {
          var dfc = add_node(&gr, node0(@[gr_op]GrVirtualDead({get(&fieldcella, j)})));
          push(&dfcprecs, dfc);
        }
        dfcnop gr_num = add_node(&gr, node(freeze(&dfcprecs), @[gr_op]GrNop(void)));
        last_ogn = add_node(&gr, node0(@[gr_op]GrSequence({gn, dfcnop})));
      } else {
        // The nodes that create fieldcella were never added to the graph, so we don't dead them.
        last_ogn = add_node(&gr, node0(@[gr_op]GrNop(void)));
      }
    }

    tagset_ogn opt[gr_num];
    switch wc {
    case CtorInit(v void):
      ice(_u8("CtorInit on wc type"));
    case CtorCopy(v void):
      var tgn = add_node(&gr, node0(@[gr_op]GrWriteConst({get(&tagcells, 0), ConstInt(~ tagval.~)})));
      tagset_ogn = Has(tgn);
    case CtorMove(v void):
      var tgn = add_node(&gr, node0(@[gr_op]GrWriteConst({get(&tagcells, 0), ConstInt(~ tagval.~)})));
      tagset_ogn = Has(tgn);
    case CtorDestroy(v void):
      tagset_ogn = None();
    }

    finalgn gr_num = add_node(&gr, node(concat(tagset_ogn, prepadding_ogn, @[opt[gr_num]]Has(last_ogn), postpadding_ogn), GrNop(void)));

    finalseqgn gr_num = add_node(&gr, node0(@[gr_op]GrSequence({finalgn, deadseq})));
    push(&cases_gn, cons(@[gr_const]ConstInt(~ tagval.~), finalseqgn));
  }

  if true {
    if case CtorDestroy(v void) = wc {
      push(&cases_gn, cons(@[gr_const]ConstInt(bigu(0)), deadseq));
    } else {
      ztgn gr_num = add_node(&gr, node0(@[gr_op]GrWriteConst({get(&pointeecells, 0), ConstInt(bigu(0))})));
      ztseq gr_num = add_node(&gr, node0(@[gr_op]GrSequence({ztgn, deadseq})));
      push(&cases_gn, cons(@[gr_const]ConstInt(bigu(0)), ztseq));
    }
  }

  br gr_num = add_node(&gr, node0(@[gr_op]GrBranch({get(&tagcells, nargs - 1), freeze(&cases_gn), None()})));
  sqr gr_num = add_node(&gr, node0(@[gr_op]GrSequence({deref_gn, br})));
  *gr_out = gr;
  *gn_out = sqr;
  *return_cell_out = return_cell;
  *arg_cells_out = argcells;
  return true;
}

func gr_magic_struct_info(cs *checkstate, clq *clqueue, wc which_ctor, msi *magic_struct_info, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num]) bool {
  // Destructors go in reverse order (which means we prepend them in the reverse of reverse order).
  reverse_order bool = false;
  // Init, copy, and move requires initializing intervening padding.
  init_padding bool = false;
  switch wc {
  case CtorInit(v void):
    init_padding = true;
  case CtorCopy(v void):
    init_padding = true;
  case CtorMove(v void):
    init_padding = true;
  case CtorDestroy(v void):
    reverse_order = true;
  }

  gr frame_graph = init_frame_graph_empty(intern(cs->im, _s("magic_struct_info")));
  argtp cu_typrop = compute_prim(clq, ptr_type(cs, msi->cu_type.~));

  voidtp cu_typrop = compute_prim(clq, primitive_void_type(cs));

  st *te_struct;
  if case &TeStruct(t te_struct) = &msi->cu_type.~ {
    st = &t;
  } else {
    ice(_u8("gr_magic_struct_info called on non-struct"));
  }

  psd partial_struct_data;
  if !compute_partial_struct_data(cs, clq, &st->fields, None(), &psd) {
    return false;
  }

  argcells array[cell_num];
  pointeecells array[cell_num];
  derefgns array[gr_num];
  nargs size = num_args(wc);
  for i size = 0; i < nargs; i = i + 1 {
    ac cell_num = add_cell(&gr, {LocationStatic(void), argtp.cu, argtp.props});
    push(&argcells, ac);
    pc cell_num = add_cell(&gr, {LocationVirtual(void), msi->cu_type, msi->cu_props});
    push(&pointeecells, pc);

    gn1 gr_num = add_node(&gr, node0(@[gr_op]GrDeref({pc, ac, OffsetConst(0)})));
    gn gr_num = add_node(&gr, node(mk_shray(gn1), @[gr_op]GrDead({ac})));
    push(&derefgns, gn);
  }

  derefgn gr_num = add_node(&gr, node(freeze(&derefgns), GrNop(void)));

  return_cell cell_num = add_cell(&gr, {LocationStatic(void), voidtp.cu, voidtp.props});

  deadprecs array[gr_num];
  if true {
    setret gr_num = add_node(&gr, node0(@[gr_op]GrWriteConst({return_cell, ConstInt(~ @[u32] 0)})));
    push(&deadprecs, setret);

    for i size = 0; i < nargs; i = i + 1 {
      pd gr_num = add_node(&gr, node0(@[gr_op]GrVirtualDead({get(&pointeecells, i)})));
      push(&deadprecs, pd);
    }
  }

  bn gr_num = add_node(&gr, node(freeze(&deadprecs), @[gr_op]GrNop(void)));

  nfields size = count(&msi->fips);
  check(nfields == count(&st->fields));
  for i2 size = 0; i2 < nfields; i2 = i2 + 1 {
    i size;
    if reverse_order {
      i = i2;
    } else {
      i = nfields - i2 - 1;
    }

    fieldcella array[cell_num];
    fieldcellgn array[gr_num];
    for j size = 0; j < nargs; j = j + 1 {
      fc cell_num = add_cell(&gr, {LocationVirtual(void), ~ ref(&st->fields, i)->type, ref(&psd.fields, i)->props});
      push(&fieldcella, fc);

      gn gr_num = add_node(&gr, node0(@[gr_op]GrSubcell({fc, get(&pointeecells, j), OffsetConst(ref(&psd.fields, i)->offset)})));
      push(&fieldcellgn, gn);
    }

    field_gn gr_num;
    if case Has(ip instpair) = get(&msi->fips, i) {
      fieldptrtype cu_typeexpr;
      fieldptrtype_props type_properties;
      compute_prim(cs, clq, ptr_type(cs, ref(&st->fields, i)->type), &fieldptrtype, &fieldptrtype_props);

      fieldptrcella array[cell_num];
      precs array[gr_num];
      for j size = 0; j < nargs; j = j + 1 {
        fpc cell_num = add_cell(&gr, {LocationStatic(void), fieldptrtype, fieldptrtype_props});
        push(&fieldptrcella, fpc);
        gn1 gr_num = add_node(&gr, node(mk_shray(get(&fieldcellgn, j)), @[gr_op]GrAddressof({fpc, get(&fieldcella, j)})));
        gn gr_num = add_node(&gr, node(mk_shray(gn1), @[gr_op]GrVirtualDead({get(&fieldcella, j)})));
        push(&precs, gn);
      }

      fieldretcell cell_num = add_cell(&gr, {LocationStatic(void), voidtp.cu, voidtp.props});

      fntype cu_typeexpr;
      fntype_props type_properties;
      compute_prim(cs, clq, fn_type(cs, @[shray[_]]repeat(nargs, fieldptrtype.~), voidtp.cu.~), &fntype, &fntype_props);

      func_cell cell_num = add_cell(&gr, {LocationStatic(void), fntype, fntype_props});

      func_gn gr_num = add_node(&gr, node0(@[gr_op]GrWriteConst({func_cell, ConstDef(ip)})));
      push(&precs, func_gn);

      ap gr_num = add_node(&gr, node(freeze(&precs), @[gr_op]GrApply({func_cell, freeze(&fieldptrcella), fieldretcell})));

      vd gr_num = add_node(&gr, node(mk_shray(ap), @[gr_op]GrDead({fieldretcell})));

      field_gn = vd;
    } else {
      ogn opt[gr_num];
      switch wc {
      case CtorInit(v void):
        // zero-initialize.
        var gn1 = add_node(&gr, node(freeze(&fieldcellgn), @[gr_op]GrWriteConst({get(&fieldcella, 0), ConstInt(~ @[u32] 0)})));
        ogn = Has(gn1);
      case CtorCopy(v void):
        var gn1 = add_node(&gr, node(freeze(&fieldcellgn), @[gr_op]GrMemCopy({get(&fieldcella, 0), get(&fieldcella, 1)})));
        ogn = Has(gn1);
      case CtorMove(v void):
        var gn1 = add_node(&gr, node(freeze(&fieldcellgn), @[gr_op]GrMemCopy({get(&fieldcella, 0), get(&fieldcella, 1)})));
        ogn = Has(gn1);
      case CtorDestroy(v void):
        // do nothing.
        ogn = None();
      }

      if case Has(gn gr_num) = ogn {
        dfcprecs array[gr_num];
        for j size = 0; j < nargs; j = j + 1 {
          var dfc = add_node(&gr, node0(@[gr_op]GrVirtualDead({get(&fieldcella, j)})));
          push(&dfcprecs, dfc);
        }
        dfcnop gr_num = add_node(&gr, node(freeze(&dfcprecs), @[gr_op]GrNop(void)));
        field_gn = add_node(&gr, node0(@[gr_op]GrSequence({gn, dfcnop})));
      } else {
        field_gn = add_node(&gr, node0(@[gr_op]GrNop(void)));
      }
    }

    field_and_padding_gn gr_num;
    if init_padding {
      padding_offset u32;
      padding_count u32;
      postpadding_offset_and_count(&psd, i, &padding_offset, &padding_count);
      if case Has(bzero_gn gr_num) = gr_bzero_subcell(clq, &gr, get(&pointeecells, 0), padding_offset, padding_count) {
        var nop2_gn = add_node(&gr, node(mk_shray(bzero_gn, field_gn), GrNop(void)));
        field_and_padding_gn = nop2_gn;
      } else {
        field_and_padding_gn = field_gn;
      }
    } else {
      field_and_padding_gn = field_gn;
    }

    bn = add_node(&gr, node0(@[gr_op]GrSequence({field_and_padding_gn, bn})));
  }

  var gn = add_node(&gr, node0(@[gr_op]GrSequence({derefgn, bn})));

  *gr_out = gr;
  *gn_out = gn;
  *return_cell_out = return_cell;
  *arg_cells_out = argcells;
  return true;
}

func gr_bzero_subcell(clq *clqueue, gr *frame_graph, c cell_num, offset u32, size u32) opt[gr_num] {
  if size == 0 {
    return None();
  }
  padtype cu_typrop = compute_prim(clq, primitive_padding_type(clq->cs, size));
  pad_cell cell_num = add_cell(gr, {LocationVirtual(void), padtype.cu, padtype.props});
  var subcell_gn = add_node(gr, node0(@[gr_op]GrSubcell({pad_cell, c, OffsetConst(offset)})));
  var bzero_gn = add_node(gr, node(mk_shray(subcell_gn), @[gr_op]GrWriteConst({pad_cell, ConstInt(bigu(0))})));
  var vd_gn = add_node(gr, node(mk_shray(bzero_gn), @[gr_op]GrVirtualDead({pad_cell})));
  return Has(vd_gn);
}

func postpadding_offset_and_count(psd *partial_struct_data, i size, offset_out *u32, count_out *u32) void {
  check(psd->index == count(&psd->fields));
  check(i < psd->index);
  begin u32 = ref(&psd->fields, i)->offset + ref(&psd->fields, i)->props.flat_size;
  end u32;
  if i + 1 < psd->index {
    end = ref(&psd->fields, i + 1)->offset;
  } else {
    end = psd->offset;
  }
  *offset_out = begin;
  *count_out = end - begin;
}

func gr_magic_whole_field_info(cs *checkstate, clq *clqueue, wc which_ctor, mwfi *magic_whole_field_info, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num]) bool {
  gr frame_graph = init_frame_graph_empty(intern(cs->im, _s("magic_whole_field_info")));
  argtp cu_typrop = compute_prim(clq, ptr_type(cs, mwfi->cu_type.~));

  fieldptrtype cu_typeexpr;
  fieldptrtype_props type_properties;
  compute_prim(cs, clq, ptr_type(cs, mwfi->rhs_type.~), &fieldptrtype, &fieldptrtype_props);

  voidtp cu_typrop = compute_prim(clq, primitive_void_type(cs));

  nargs size = num_args(wc);
  fntype cu_typeexpr;
  fntype_props type_properties;
  compute_prim(cs, clq, fn_type(cs, @[shray[_]]repeat(nargs, fieldptrtype.~), voidtp.cu.~), &fntype, &fntype_props);

  argcells array[cell_num];
  fieldptrcells array[cell_num];
  precs array[gr_num];
  for i size = 0; i < nargs; i = i + 1 {
    ac cell_num = add_cell(&gr, {LocationStatic(void), argtp.cu, argtp.props});
    push(&argcells, ac);
    pc cell_num = add_cell(&gr, {LocationVirtual(void), mwfi->cu_type, mwfi->cu_props});
    fc cell_num = add_cell(&gr, {LocationVirtual(void), mwfi->rhs_type, mwfi->rhs_props});
    fpc cell_num = add_cell(&gr, {LocationStatic(void), fieldptrtype, fieldptrtype_props});
    push(&fieldptrcells, fpc);

    var pointee_gn1 = add_node(&gr, node0(@[gr_op]GrDeref({pc, ac, OffsetConst(0)})));
    var pointee_gn = add_node(&gr, node(mk_shray(pointee_gn1), @[gr_op]GrDead({ac})));
    var fieldcell_gn1 = add_node(&gr, node(mk_shray(pointee_gn), @[gr_op]GrSubcell({fc, pc, OffsetConst(0)})));
    var fieldcell_gn = add_node(&gr, node(mk_shray(fieldcell_gn1), @[gr_op]GrVirtualDead({pc})));
    var fieldptr_gn1 = add_node(&gr, node(mk_shray(fieldcell_gn), @[gr_op]GrAddressof({fpc, fc})));
    var fieldptr_gn = add_node(&gr, node(mk_shray(fieldptr_gn1), @[gr_op]GrVirtualDead({fc})));
    push(&precs, fieldptr_gn);
  }

  retcell cell_num = add_cell(&gr, {LocationStatic(void), voidtp.cu, voidtp.props});
  fncell cell_num = add_cell(&gr, {LocationStatic(void), fntype, fntype_props});
  var fn_gn = add_node(&gr, node0(@[gr_op]GrWriteConst({fncell, ConstDef(mwfi->ip)})));
  push(&precs, fn_gn);

  var ap = add_node(&gr, node(freeze(&precs), @[gr_op]GrApply({fncell, freeze(&fieldptrcells), retcell})));

  *gr_out = gr;
  *gn_out = ap;
  // We sort of make this look like a "tail call," informally -- is that bad?
  *return_cell_out = retcell;
  *arg_cells_out = argcells;
  return true;
}

func gr_magic_enum_construct(cs *checkstate, clq *clqueue, mec *magic_enum_construct, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cell_out *cell_num) bool {
  gr frame_graph = init_frame_graph_empty(intern(cs->im, _s("magic_enum_construct")));
  retnum cell_num = add_cell(&gr, {LocationStatic(void), mec->enum_type, mec->enum_type_props});

  tagval enum_tag_value = mk_enum_tag_value(mec->constructor_index);

  argtype *te_typeexpr;
  field_offset u32;
  tag_end u32;
  tag_cell cell_num;
  if case &TeEnum(et te_enum) = &mec->enum_type.~ {
    argtype = &ref(&et.constructors, mec->constructor_index)->type;
    field_offset = enum_field_offset(cs, &et, tagval);
    cu cu_typeexpr;
    props type_properties;
    compute_prim(cs, clq, enum_tag_type(cs, &et), &cu, &props);
    tag_end = props.flat_size;
    tag_cell = add_cell(&gr, {LocationVirtual(void), cu, props});
  } else {
    ice(_u8("magic_enum_construct on non-enum type"));
  }

  prepadding_ogn opt[gr_num]
    = gr_bzero_subcell(clq, &gr, retnum, tag_end, field_offset - tag_end);
  field_end u32 = field_offset + mec->rhs_props.flat_size;
  postpadding_ogn opt[gr_num]
    = gr_bzero_subcell(clq, &gr, retnum, field_end, mec->enum_type_props.flat_size - field_end);

  argnum cell_num = add_cell(&gr, {LocationStatic(void), ~ *argtype, mec->rhs_props});
  retpart cell_num = add_cell(&gr, {LocationVirtual(void), ~ *argtype, mec->rhs_props});

  var retpart_gn = add_node(&gr, node0(@[gr_op]GrSubcell({retpart, retnum, OffsetConst(field_offset)})));

  ctor_gn gr_num;
  switch &mec->operational {
  case &EnumConstructMove(cd ctor_desc):
    bi_ctor_gn1 gr_num;
    if !gr_bi_ctor(cs, clq, &gr, argtype, retpart, argnum, &cd, &bi_ctor_gn1) {
      return false;
    }
    bi_ctor_gn gr_num = add_node(&gr, node(mk_shray(bi_ctor_gn1), @[gr_op]GrVirtualDead({retpart})));
    ctor_gn = add_node(&gr, node(mk_shray(bi_ctor_gn), @[gr_op]GrDead({argnum})));

  case &EnumConstructCopyDestroy(cdd copy_destroy_desc):
    cpgn1 gr_num;
    if !gr_bi_ctor(cs, clq, &gr, argtype, retpart, argnum, &cdd.copy_desc, &cpgn1) {
      return false;
    }
    cpgn gr_num = add_node(&gr, node(mk_shray(cpgn1), @[gr_op]GrVirtualDead({retpart})));
    destgn gr_num;
    if !gr_destroy_ctor(cs, clq, &gr, argtype, argnum, &cdd.destroy_desc, &destgn) {
      return false;
    }
    ctor_gn = add_node(&gr, node0(@[gr_op]GrSequence({cpgn, destgn})));
  }

  var assign_gn = add_node(&gr, node0(@[gr_op]GrSequence({retpart_gn, ctor_gn})));

  var tagcell_gn = add_node(&gr, node0(@[gr_op]GrSubcell({tag_cell, retnum, OffsetConst(enum_tag_offset)})));
  var tag_gn1 = add_node(&gr, node(mk_shray(tagcell_gn), @[gr_op]GrWriteConst({tag_cell, ConstInt(~tagval.~)})));
  var tag_gn = add_node(&gr, node(mk_shray(tag_gn1), @[gr_op]GrVirtualDead({tag_cell})));
  var gn = add_node(&gr, node(concat(@[opt[gr_num]]Has(tag_gn), prepadding_ogn, @[opt[gr_num]]Has(assign_gn), postpadding_ogn), GrNop(void)));
  *gr_out = gr;
  *gn_out = gn;
  *return_cell_out = retnum;
  *arg_cell_out = argnum;
  return true;
}

func gr_bi_ctor(cs *checkstate, clq *clqueue, gr *frame_graph, ty *te_typeexpr, destnum cell_num, srcnum cell_num, cd *ctor_desc, gn_out *gr_num) bool {
  switch cd {
  case &TrivialCtor(v void):
    var gn = add_node(gr, node0(@[gr_op]GrMemCopy({destnum, srcnum})));
    *gn_out = gn;
  case &FunCtor(ip instpair):
    pty te_typeexpr = ptr_type(cs, *ty);
    cu_pty cu_typeexpr;
    pty_props type_properties;
    compute_prim(cs, clq, pty, &cu_pty, &pty_props);
    voidtp cu_typrop = compute_prim(clq, primitive_void_type(cs));

    functy te_typeexpr = fn_type(cs, pty, pty, voidtp.cu.~);
    cu_functy cu_typeexpr;
    functy_props type_properties;
    compute_prim(cs, clq, functy, &cu_functy, &functy_props);

    funcptr_cell cell_num = add_cell(gr, {LocationStatic(void), cu_functy, functy_props});
    destptr_cell cell_num = add_cell(gr, {LocationStatic(void), cu_pty, pty_props});
    srcptr_cell cell_num = add_cell(gr, {LocationStatic(void), cu_pty, pty_props});
    return_cell cell_num = add_cell(gr, {LocationStatic(void), voidtp.cu, voidtp.props});

    bi_desc bi_fun_ctor_desc = {ip, funcptr_cell, destptr_cell, srcptr_cell, return_cell};

    gn gr_num = gr_bi_fun_ctor_desc(cs, gr, &bi_desc, destnum, srcnum);
    *gn_out = gn;
  }
  return true;
}

func gr_destroy_ctor(cs *checkstate, clq *clqueue, gr *frame_graph, ty *te_typeexpr, argnum cell_num, cd *ctor_desc, gn_out *gr_num) bool {
  switch cd {
  case &TrivialCtor(v void):
    var dp = add_node(gr, node0(@[gr_op]GrDead({argnum})));
    *gn_out = dp;
  case &FunCtor(ip instpair):
    pty te_typeexpr = ptr_type(cs, *ty);
    cu_pty cu_typeexpr;
    pty_props type_properties;
    compute_prim(cs, clq, pty, &cu_pty, &pty_props);
    voidtp cu_typrop = compute_prim(clq, primitive_void_type(cs));

    functy te_typeexpr = fn_type(cs, pty, voidtp.cu.~);
    cu_functy cu_typeexpr;
    functy_props type_properties;
    compute_prim(cs, clq, functy, &cu_functy, &functy_props);

    funcptr_cell cell_num = add_cell(gr, {LocationStatic(void), cu_functy, functy_props});
    argptr_cell cell_num = add_cell(gr, {LocationStatic(void), cu_pty, pty_props});
    return_cell cell_num = add_cell(gr, {LocationStatic(void), voidtp.cu, voidtp.props});

    uni_desc uni_fun_ctor_desc = {ip, funcptr_cell, argptr_cell, return_cell};
    gn gr_num = gr_uni_fun_ctor_desc(cs, gr, &uni_desc, argnum);
    var dp = add_node(gr, node(mk_shray(gn), @[gr_op]GrDead({argnum})));
    *gn_out = dp;
  }
  return true;
}

func add_prim_fn_body(cs *checkstate, clq *clqueue, informal_name sym, type *cu_typeexpr, op primitive_op) fn_body_id {
  gr frame_graph = init_frame_graph_empty(informal_name);
  typarams *shray[te_typeexpr];
  if !decompose_typeapp(&type->~, primitive_function_puretype(cs), &typarams) {
    ice(_u8("add_prim_fn_body called with non-fn type"));
  }
  argcells array[cell_num];
  ntyparams size = count(typarams);
  nfn_params size = ntyparams - 1;
  for i size = 0; i < nfn_params; i = i + 1 {
    ty *te_typeexpr = ref(typarams, i);
    props type_properties;
    if !compute_complete_type_properties(cs, clq, ty, &props) {
      ice(_u8("add_prim_fn_body typrops"));
    }
    c cell_num = add_cell(&gr, {LocationStatic(void), ~ *ty, props});
    push(&argcells, c);
  }
  retty *te_typeexpr = ref(typarams, ntyparams - 1);
  retprops type_properties;
  if !compute_complete_type_properties(cs, clq, retty, &retprops) {
    ice(_u8("add_prim_fn_body retprops"));
  }
  retcell cell_num = add_cell(&gr, {LocationStatic(void), ~ *retty, retprops});

  argcells_copy array[cell_num] = argcells;
  argshray shray[cell_num] = freeze(&argcells_copy);
  gn gr_num = add_node(&gr, node0(@[gr_op]GrPrimApply({op, argshray, retcell})));
  return add_fn_body(cs, {informal_name, NotComputed@[sti](), NotComputed@[u32](), @[fn_body_entry_enum]GraphedFnBody({FnBodyPrim(op), {gr, gn, retcell}, argcells})});
}

func ensure_def_inst_graphed(cs *checkstate, clq *clqueue, ent_id def_entry_id, inst_id def_inst_id) bool {
  if !ensure_def_inst_checked(cs, clq, ent_id, inst_id) {
    return false;
  }

  ent *def_entry = ref_def_entry(cs, ent_id);
  inst *def_inst = ref_inst(cs, inst_id);
  switch &inst->graph {
    case &NotComputed(v0 void): {
      inst->graph = BeganComputing();
      switch &inst->rhs {
        case &InstRhsPrim(op primitive_op): {
          id fn_body_id = add_prim_fn_body(cs, clq, ent->def_name, &inst->computed_type, op);
          frg frame_regraphed = mk_const_frame_regraphed(ent->def_name, &inst->computed_type, &inst->computed_type_properties, ConstFnBody(id));
          inst->graph = Computed(Has(frg));
          return true;
        }
        case &InstRhsExtern(v void): {
          // TODO: What if an extern def isn't a function?
          id fn_body_id = add_fn_body(cs, {ent->def_name, NotComputed@[sti](), NotComputed@[u32](), @[fn_body_entry_enum]ExternFnBody({ent->def_name})});
          frg frame_regraphed = mk_const_frame_regraphed(ent->def_name, &inst->computed_type, &inst->computed_type_properties, ConstFnBody(id));
          inst->graph = Computed(Has(frg));
          return true;
        }
        case &InstRhsExpr(dire def_inst_rhs_expr): {
          info *frame_info;
          if case &Has(finfo) = &dire.frame_info {
            info = &finfo;
          } else {
            ice(_u8("ensure_def_inst_graphed missing 'dire' info"));
          }
          gr frame_graph = init_frame_graph_from_cells(ent->def_name, info->cells);
          gn gr_num;
          if !gr_expr_consume(cs, &gr, &dire.ec, &gn) {
            inst->graph = FailedComputation();
            return false;
          }
          inst->graph = Computed(Has(@[frame_regraphed]{gr, gn, result_cell(&dire.ec)}));
          return true;
        }

        case &InstRhsNonMagic(nonmag def_non_magic): {
          switch &nonmag {
          case &NonMagicCtor(wnmc which_non_magic_ctor):
            info *non_magic_ctor_info = unHas(&wnmc.nmc.info);
            frg frame_regraphed = mk_const_frame_regraphed(ent->def_name, &inst->computed_type, &inst->computed_type_properties, ConstDef(info->ip));
            inst->graph = Computed(Has(frg));
            return true;
          case &NonMagicProp(nmp non_magic_prop):
            info u32 = *unHas(&nmp.info);
            frg frame_regraphed = mk_const_frame_regraphed(ent->def_name, &inst->computed_type, &inst->computed_type_properties, @[gr_const]ConstInt(~info));
            inst->graph = Computed(Has(frg));
            return true;
          }
        }

        case &InstRhsMagic(mag def_magic): {
          id fn_body_id;
          if true {
            body_gr frame_graph;
            body_gn gr_num;
            return_cell cell_num;
            arg_cells array[cell_num];
            if !gr_magic(cs, clq, &mag, &body_gr, &body_gn, &return_cell, &arg_cells) {
              return false;
            }
            id = add_fn_body(cs, {ent->def_name, NotComputed@[sti](), NotComputed@[u32](), @[fn_body_entry_enum]GraphedFnBody({FnBodyMagic(&mag), {body_gr, body_gn, return_cell}, arg_cells})});
          }

          frg frame_regraphed = mk_const_frame_regraphed(ent->def_name, &inst->computed_type, &inst->computed_type_properties, ConstFnBody(id));
          inst->graph = Computed(Has(frg));
          return true;
        }
      }
    }
    case &BeganComputing(v void): {
      ice(_u8("ensure_def_inst_graphed recursively computing"));
      return fake();
    }
    case &FailedComputation(v void): {
      ERR(_u8("ensure_def_inst_graphed fails again on same def"));
      return false;
    }
    case &Computed(odr opt[frame_regraphed]): {
      return true;
    }
  }
}

func mk_const_frame_regraphed(informal_name sym, type *cu_typeexpr, props *type_properties, c gr_const) frame_regraphed {
  gr frame_graph = init_frame_graph_empty(informal_name);
  cell cell_num = add_cell(&gr, {LocationStatic(void), *type, *props});
  gn gr_num = add_node(&gr, node0(@[gr_op]GrWriteConst({cell, c})));
  return {gr, gn, cell};
}
