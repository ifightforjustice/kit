import check;

/* bnno = b.n.n.o. = "bytes" (not necessarily octets)

"sizes" are in bnno's -- in terms of the minimal addressable unit --
on the HP Saturn that'd be nibbles, on other systems it might be 16
bits.  The term "bnno" is used because "byte" is so likely to be
misinterpreted. */

deftype st_env struct {
  objects array[opt[st_value]];

  // Indexed by cell_num.  Contains the number of the object representing the cell -- if the cell/object currently exists.
  framecells array[opt[st_obj_ref]];
};

deftype st_obj_num size;

deftype st_obj_ref struct {
  num st_obj_num;
  // The offset, in terms of bnnos
  offset size;
  // The size, in terms of bnnos
  count size;
};

func init_env(env *st_env, num_cells frame_cell_count) void {
  *env = {mk_array@[opt[st_value]](), repeat(num_cells.~, None())};
}

deftype st_symbol_name sym;

deftype st_symbolref struct {
  name st_symbol_name;
  offset size;
  count size;
};

deftype st_value struct {
  words array[u32];
  // The length of the value in bnnos.
  length u32;
  // Values of external symbol references -- they start at a bnno offset, and have some size that depends on what kind of symbolref it is (or what platform, some only have one kind).
  symbolrefs array[tup[size, st_symbolref]];
  // Pointers to other objects -- they start at a bnno offset, and have a specific size (on the HP Saturn, 5 bnnos, or 20 bits).
  objrefs array[tup[size, st_obj_ref]];
};

func ref_obj(env *st_env, num st_obj_num, out **st_value) bool {
  if case &Has(v st_value) = ref(&env->objects, num.~) {
    *out = &v;
    return true;
  } else {
    ERR(_u8("static evaluation accessing object that has been destroyed"));
    return false;
  }
}

func cell_obj_ref(env *st_env, num cell_num) st_obj_ref {
  if case &Has(obj_ref st_obj_ref) = ref(&env->framecells, num.~) {
    return obj_ref;
  } else {
    ice(_u8("static eval accessing inactive cell"));
    return fake();
  }
}

func add_obj(env *st_env, plat *platform_info, size u32) st_obj_num {
  ret st_obj_num;
  ret.~ = count(&env->objects);
  push(&env->objects, Has(mk_st_value(plat, size)));
  return ret;
}

func mk_st_value(plat *platform_info, size u32) st_value {
  return {repeat(~ceil_divide(size, plat->bnno_size), 0), size, mk_array(), mk_array()};
}

func expr_after(x *ast_expr) *ast_expr_after {
  if case &Has(aft ast_expr_after) = &expr_complete_info(x)->after {
    return &aft;
  } else {
    ice(_u8("expr_after sees missing after-info"));
    return fake();
  }
}

func expr_result(x *ast_expr) cell_num {
  if case Has(num cell_num) = expr_after(x)->result {
    return num;
  } else {
    ice(_u8("expr_result called on expr that discards result"));
    return fake();
  }
}

func st_eval_def(cs *checkstate, ent def_entry_id, inst_id def_inst_id, out **st_value) bool {
  inst *def_inst = ref_inst(cs, inst_id);
  if inst->status != FinishedCheckingRhs(void) {
    ice(_u8("Evaling def we have not finished checking."));
  }
  if case &Has(e ast_expr) = &inst->rhs {
    check(is_defwise_trivial(&inst->computed_type_properties));
    switch &inst->evaled_value {
      case &NotComputed(v void): {
        inst->evaled_value = BeganComputing();
        env st_env;
        if case Has(num_cells frame_cell_count) = inst->num_frame_cells {
          init_env(&env, num_cells);
        } else {
          ice(_u8("st_eval_def sees inst without num_frame_cells."));
        }
        result st_obj_num;
        if !st_eval_expr(cs, &env, &e, &result) {
          return false;
        }
        value *st_value;
        if !ref_obj(&env, result, &value) {
          return false;
        }
        inst->evaled_value = Computed(*value);
        if case &Computed(x st_value) = &inst->evaled_value {
          *out = &x;
        } else {
          ice(_u8("locally impossible in st_eval_def"));
        }
        return true;
      }
      case &BeganComputing(v void): {
        ERR(_u8("recursively computing def inst's value"));
        return false;
      }
      case &FailedComputation(v void): {
        ERR(_u8("repeat error of st_eval_def"));
        return false;
      }
      case &Computed(x st_value): {
        *out = &x;
        return true;
      }
    }
  } else {
    ice(_u8("st_eval_def on an extern def."));
    return fake();
  }
}

func st_eval_expr(cs *checkstate, env *st_env, x *ast_expr, result_out *st_obj_num) bool {
  switch &x->u {
    case &NameExpr(a ast_name_expr): {
      return st_eval_name_expr(cs, env, x, &a, result_out);
    }
    default: {
      return TODO();
    }
  }
}

func st_eval_name_expr(cs *checkstate, env *st_env, x *ast_expr, a *ast_name_expr, result_out *st_obj_num) bool {
  if case &Has(info ast_name_expr_info) = &a->name_info {
    switch &info {
      case &LocalResolve(loc local_info): {
        // (Right now, there's no way a local variable could come into scope because static eval doesn't support lambda eval.)
        ice(_u8("st_eval_expr sees local variable reference"));
        return fake();
      }
      case &GlobalResolve(glo global_info): {
        val *st_value;
        if !st_eval_def(cs, glo.ent, glo.inst, &val) {
          return false;
        }
        return TODO();
      }
      case &EnumConstructor(v void): {
        // TODO: This should be supported!
        ERR(_u8("enum construction not supported in static evaluation"));
        return false;
      }
    }
  } else {
    ice(_u8("st_eval_expr seeing name_expr without info"));
    return fake();
  }
}
