import bigint;
import body;
import check;
import primitives;

deftype exprscope struct {
  cs *checkstate;
  // Same as cs->im.
  im *identmap;
  clq *clqueue;
  accessible array[access_entry_id];
  // Generics and their _complete_ replacements.
  generics *ast_generics;
  parms *cu_genparms;

  var_counter u32;

  local_vars array[var_info];
};

def initial_var_counter u32 = 0;

deftype var_number u32;

def `==` fn[var_number, var_number, bool] = wrapequate;
func `!=`(x var_number, y var_number) bool { return !(x == y); }

deftype var_info struct {
  num var_number;
  // A complete, checked, type, with generics replaced.
  type cu_typeexpr;
  name sym;
};

func next_varnum(es *exprscope) var_number {
  ret var_number;
  ret.~ = es->var_counter;
  es->var_counter = es->var_counter + 1;
  return ret;
}

defenum allow_incomplete {
  AllowIncompleteNo void;
  AllowIncompleteYes void;
};

func `==`(x allow_incomplete, y allow_incomplete) bool {
  return enumnum(&x) == enumnum(&y);
}

defclass move varpopper struct {
  es *exprscope;
  nums array[var_number];
};

access varpopper {

func do_init(vp *varpopper) void {
  init(&vp->es);
  init(&vp->nums);
}

func init_vp(vp *varpopper, es *exprscope) void {
  check(vp->es == null);
  vp->es = es;
}

func do_destroy(vp *varpopper) void {
  if vp->es != null {
    descope_vars(vp);
  }
  destroy(&vp->nums);
  vp->es = null;
}

func es_push_var(es *exprscope, vp *varpopper, name *ast_ident, computed_type *cu_typeexpr) bool {
  if case Has(ix size) = es_find_local(es, name->value) {
    ERR(_u8("Local variable '"), lookup(es->im, name->value), _u8("' shadows another"));
    return false;
  }
  num var_number = next_varnum(es);
  push(&es->local_vars, {num, *computed_type, name->value});
  push(&vp->nums, num);
  return true;
}

func descope_vars(vp *varpopper) void {
  es *exprscope = vp->es;
  check(es != null);
  while case Has(expected var_number) = popval(&vp->nums) {
    info var_info;
    if !popval(&es->local_vars, &info) {
      ice(_u8("varpopper sees empty local_vars"));
    }
    if info.num != expected {
      ice(_u8("varpopper sees mismatching name"));
    }
  }
}

}  // access varpopper

func check_expr(cs *checkstate, clq *clqueue, accessible array[access_entry_id], g *ast_generics, parms *cu_genparms, x *ast_expr, pt *te_typeexpr) bool {
  es exprscope = {cs, cs->im, clq, accessible, g, parms, initial_var_counter, default@[array[var_info]]()};
  return check_expr_ai(&es, AllowIncompleteNo(void), x, pt);
}

func replaced_name_parms(es *exprscope, a *ast_name_expr, out *genparms) bool {
  if case &Has(arr array[ast_typeexpr]) = &a->generic_params {
    replaced array[te_typeexpr];
    n size = count(&arr);
    for i size = 0; i < n; i = i + 1 {
      converted te_typeexpr;
      if !convert_typeexpr(es->cs, ref(&arr, i), &converted) {
        return false;
      }
      computed cac_typeexpr;
      if !check_and_compute_typeexpr(es->cs, es->clq, es->generics, es->parms, &converted, &computed) {
        return false;
      }
      push(&replaced, computed.te);
    }
    *out = HasParms(replaced);
    return true;
  } else {
    *out = NoParms(void);
    return true;
  }
}

deftype global_info struct {
  ent def_entry_id;
  inst def_inst_id;
};

deftype local_info struct {
  varinfo_ix size;
};

defenum name_info {
  Local void;
  Global global_info;
};

defenum es_match_res {
  NoMatch void;
  AmbigGlobalMatch void;
  OneGlobalMatch global_info;
  OneLocalMatch local_info;
};

func es_lookup_name(es *exprscope, name sym, gp *genparms, pt *te_typeexpr, res_out *es_match_res) bool {
  if case &NoParms(v void) = gp {
    if case Has(ix size) = es_find_local(es, name) {
      type te_typeexpr;
      vartype *cu_typeexpr = &ref(&es->local_vars, ix)->type;
      if !unify_types(pt, &vartype->~, &type) {
        ERR(_u8("local '"), lookup(es->im, name), _u8("' has wrong type: '"), to_u8str(es->im, *vartype), _u8("' where '"), to_u8str(es->im, *pt), _u8("' expected"));
        return false;
      }
      *res_out = OneLocalMatch({ix});
      return true;
    }
  }

  res match_def_res;
  if !match_def(es->cs, name, gp, pt, &res) {
    return false;
  }

  switch res {
    case NoMatch(v void): {
      *res_out = NoMatch(void);
      return true;
    }
    case MultiMatch(void): {
      *res_out = AmbigGlobalMatch(void);
      return true;
    }
    case OneMatch(m struct { ent def_entry_id; parms genparms; }): {
      cu_parms cu_genparms;
      if !check_and_compute_parms(es->cs, es->clq, &m.parms, &cu_parms) {
        return false;
      }
      inst_id def_inst_id = enqueue_def_inst(es->cs, es->clq, m.ent, &cu_parms);
      *res_out = OneGlobalMatch({m.ent, inst_id});
      return true;
    }
  }
}

func es_find_local(es *exprscope, name sym) opt[size] {
  n size = count(&es->local_vars);
  for i size = 0; i < n; i = i + 1 {
    inf *var_info = ref(&es->local_vars, i);
    if inf->name == name {
      return Has(i);
    }
  }
  return None();
}

func help_check_simple_literal(es *exprscope, pt *te_typeexpr, type te_typeexpr, errmsg_name array[u8], x *ast_expr) bool {
  unified te_typeexpr;
  if !unify_types(pt, &type, &unified) {
    ERR(errmsg_name, _u8(" literal in bad place"));
    return false;
  }
  if is_complete(&unified) {
    c cac_typeexpr;
    if !noscoped_check_and_compute_typeexpr(es->cs, es->clq, &unified, &c) {
      ice(_u8("help_check_simple_literal passed bad type"));
    }
    check(c.complete);

    annotate_info(x, CompleteCheck(~c.te));
  } else {
    annotate_info(x, IncompleteCheck(type));
  }
  return true;
}

func check_expr_ai(es *exprscope, ai allow_incomplete, x *ast_expr, pt *te_typeexpr) bool {
  if case &CompleteCheck(t cu_typeexpr) = &x->info {
    return true;
  }

  switch &x->u {
    case &NameExpr(a ast_name_expr): {
      parms genparms;
      if !replaced_name_parms(es, &a, &parms) {
        return false;
      }
      match_res es_match_res;
      if !es_lookup_name(es, a.ident.value, &parms, pt, &match_res) {
        return false;
      }
      switch &match_res {
        case &NoMatch(v void): {
          ERR(_u8("Name lookup for '"), lookup(es->im, a.ident.value), _u8("', maybe with parms, not found, matching type '"), to_u8str(es->im, *pt), _u8("'"));
          return false;
        }
        case &AmbigGlobalMatch(v void): {
          if ai == AllowIncompleteYes(void) {
            // NOTE: We could annotate this more precisely in ambiguous-single-match cases.
            annotate_info(x, IncompleteCheck(TeUnknown(void)));
            return true;
          } else {
            ERR(_u8("Name lookup for '"), lookup(es->im, a.ident.value), _u8("', maybe with parms, matches ambiguously."));
            return false;
          }
        }
        case &OneGlobalMatch(gi global_info): {
          if !ensure_def_inst_type_computed(es->cs, es->clq, ref_def_entry(es->cs, gi.ent), gi.inst) {
            return false;
          }
          inst *def_inst = ref_inst(es->cs, gi.inst);
          annotate_info(x, CompleteCheck(inst->computed_type));
          return true;
        }
        case &OneLocalMatch(v local_info): {
          vi *var_info = ref(&es->local_vars, v.varinfo_ix);
          annotate_info(x, CompleteCheck(vi->type));
          return true;
        }
      }
    }

    case &ParenExpr(a ast_paren_expr): {
      if !check_expr_ai(es, ai, oo(&a.expr), pt) {
        return false;
      }
      annotate_info(x, oo(&a.expr)->info);
      return true;
    }

    case &NumericLiteral(a ast_numeric_literal): {
      return check_numeric_literal(es->cs, ai, pt, numeric_literal_value(&a), x);
    }

    case &BoolLiteral(a ast_bool_literal): {
      return help_check_simple_literal(es, pt, primitive_bool_type(es->cs), _u8("bool"), x);
    }

    case &VoidLiteral(a ast_void_literal): {
      return help_check_simple_literal(es, pt, primitive_void_type(es->cs), _u8("void"), x);
    }

    case &NullLiteral(a ast_null_literal): {
      return help_check_simple_literal(es, pt, pointer_to(es->cs, TeUnknown(void)), _u8("null"), x);
    }

    case &CharLiteral(a ast_char_literal): {
      return check_numeric_literal(es->cs, ai, pt, ~a.charspec.value, x);
    }

    case &StringLiteral(a ast_string_literal): {
      // TODO: At some point we'll want string literals to be more compile-time-magical.  Right now they're of type [N]u8.  And we really want [N]<numeric>?
      type te_typeexpr = primitive_string_literal_type(es->cs, count(&a.charspecs));
      unified te_typeexpr;
      if !unify_types(pt, &type, &unified) {
        ERR(_u8("string literal in bad place"));
        return false;
      }
      c cac_typeexpr;
      if !noscoped_check_and_compute_typeexpr(es->cs, es->clq, &type, &c) {
        ice(_u8("primitive_string_literal_type not computed"));
      }
      check(c.complete);
      annotate_info(x, CompleteCheck(~c.te));
      return true;
    }
    case &Funcall(a ast_funcall): {
      return check_expr_funcall(es, ai, x, &a, pt);
    }
    case &IndexExpr(a ast_index_expr): {
      return check_expr_index(es, x, &a, pt);
    }
    case &Lambda(a ast_lambda): {
      return check_expr_lambda(es, &a, pt, x);
    }
    case &LocalField(a ast_local_field): {
      unknown te_typeexpr = TeUnknown(void);
      if !check_expr_ai(es, AllowIncompleteNo(void), oo(&a.lhs), &unknown) {
        return false;
      }
      type *cu_typeexpr = expr_complete_type(oo(&a.lhs));
      fieldtype cu_typeexpr;
      if !check_field(es, type, &a.fieldname, pt, &fieldtype) {
        return false;
      }
      annotate_info(x, CompleteCheck(fieldtype));
      return true;
    }
    case &DerefField(a ast_deref_field): {
      // The fact that our partial type isn't a pointer type is deliberate.
      unknown te_typeexpr = TeUnknown(void);
      if !check_expr_ai(es, AllowIncompleteNo(void), oo(&a.lhs), &unknown) {
        return false;
      }
      type *cu_typeexpr = expr_complete_type(oo(&a.lhs));
      param *te_typeexpr;
      if !decompose_typeapp(&type->~, primitive_pointer_puretype(es->cs), &param) {
        ERR(_u8("Expected pointer for lhs of deref field"));
        return false;
      }
      cu_param cu_typeexpr = ~ *param;
      fieldtype cu_typeexpr;
      if !check_field(es, &cu_param, &a.fieldname, pt, &fieldtype) {
        return false;
      }
      annotate_info(x, CompleteCheck(fieldtype));
      return true;
    }
    case &TypedExpr(a ast_typed_expr): {
      // TODO: Cache converted.
      converted te_typeexpr;
      if !convert_typeexpr(es->cs, &a.type, &converted) {
        return false;
      }
      // We call check_and_compute_typeexpr to disallow totally bogus typeexprs more directly than the eventual type error that would happen.
      computed cac_typeexpr;
      if !check_and_compute_typeexpr(es->cs, es->clq, es->generics, es->parms, &converted, &computed) {
        return false;
      }
      unified te_typeexpr;
      if !unify_types(pt, &computed.te, &unified) {
        ERR(_u8("TypedExpr is incompatible with contextual type."));
        return false;
      }
      if !check_expr_ai(es, ai, oo(&a.expr), &unified) {
        return false;
      }
      annotate_info(x, oo(&a.expr)->info);
      return true;
    }
    case &Strinit(a ast_strinit): {
      return check_expr_strinit(es, ai, &a, pt, x);
    }
  }
}

func check_expr_strinit(es *exprscope, ai allow_incomplete, a *ast_strinit, pt *te_typeexpr, x *ast_expr) bool {
  if !is_complete(pt) {
    if ai == AllowIncompleteYes(void) {
      // NOTE: We could have more specific info, like number of fields and their incomplete types.
      annotate_info(x, IncompleteCheck(TeUnknown(void)));
      return true;
    } else {
      ERR(_u8("Structure literal used ambiguously."));
      return false;
    }
  }

  // Since pt is complete, and since it's a pt, it's computed.
  if !is_complete_computed(pt).computed {
    ice(_u8("check_expr_strinit has non-computed pt"));
  }
  cu_pt cu_typeexpr = ~ *pt;
  structural_type *cu_typeexpr;
  if !structural_rhs(es, &cu_pt, &structural_type) {
    return false;
  }

  // NOTE: We could allow arrays, especially if ambig matching returns number of fields and their type.
  if case &TeStruct(b te_struct) = &structural_type->~ {
    n size = count(&b.fields);
    if n != count(&a->exprs) {
      ERR(_u8("Structure literal has wrong number of fields."));
      return false;
    }

    for i size = 0; i < n; i = i + 1 {
      if !check_expr_ai(es, AllowIncompleteNo(void), ref(&a->exprs, i), &ref(&b.fields, i)->type) {
        return false;
      }
    }

    // We checked is_computed(pt).
    annotate_info(x, CompleteCheck(~ *pt));
    return true;
  } else {
    ERR(_u8("Structure literal used on non-struct type."));
    return false;
  }
}

func check_expr_lambda(es *exprscope, a *ast_lambda, pt *te_typeexpr, x *ast_expr) bool {
  // TODO: Cache type.
  type ast_typeexpr = lambda_declared_type(&es->cs->cym, a);
  // TODO: Cache converted.
  converted te_typeexpr;
  if !convert_typeexpr(es->cs, &type, &converted) {
    return false;
  }
  // TODO: I see some duplicated logic with the TypedExpr case.
  computed cac_typeexpr;
  if !check_and_compute_typeexpr(es->cs, es->clq, es->generics, es->parms, &converted, &computed) {
    return false;
  }
  // Lambda exprs can't have partial types (yet!).
  check(computed.complete);
  unified te_typeexpr;
  if !unify_types(pt, &computed.te, &unified) {
    ERR(_u8("Lambda is incompatible with contextual type."));
    return false;
  }

  computed_params *array[te_typeexpr];
  if !decompose_typeapp(&computed.te, primitive_function_puretype(es->cs), &computed_params) {
    ice(_u8("lambda type is not a function type"));
  }
  vp varpopper;
  nargs size = count(&a->args);
  for i size = 0; i < nargs; i = i + 1 {
    cu_param cu_typeexpr = ~get(computed_params, i);
    if !es_push_var(es, &vp, &ref(&a->args, i)->name, &cu_param) {
      return false;
    }
  }

  return_type cu_typeexpr = ~get(computed_params, nargs);

  bs bodystate = mk(es, &return_type);
  if !check_body(&bs, &a->body) {
    return false;
  }

  annotate_info(x, CompleteCheck(~computed.te));
  return true;
}

func numeric_literal_value(a *ast_numeric_literal) bigint {
  switch a {
    case &HexLiteral(b ast_hex_literal): {
      return convert_to_bigint(16, &b.digits);
    }
    case &DecLiteral(b ast_dec_literal): {
      return convert_to_bigint(10, &b.digits);
    }
  }
}

func check_numeric_literal(cs *checkstate, ai allow_incomplete, pt *te_typeexpr, n bigint, x *ast_expr) bool {
  if case &TeUnknown(v void) = pt {
    if ai == AllowIncompleteYes(void) {
      annotate_info(x, IncompleteCheck(TeUnknown(void)));
      return true;
    } else {
      ERR(_u8("Numeric literal usage is ambiguous."));
      return false;
    }
  }

  facts numeric_traits;
  if !is_numeric_type(cs, pt, &facts) {
    ERR(_u8("Numeric literal in bad place."));
    return false;
  }
  if n < facts.minval || n > facts.maxval {
    ERR(_u8("Numeric literal out of range."));
    return false;
  }
  // It's a pt, and it's a numeric type, which means it must be a complete pt, which means it's computed.
  check(is_complete_computed(pt).computed);
  annotate_info(x, CompleteCheck(~ *pt));
  return true;
}

func decompose_typeapp(t *te_typeexpr, expected_puretype te_puretype, params_out **array[te_typeexpr]) bool {
  // This could be implemented in terms of unify_under_generics, you know.
  if case &TeApp(app te_typeapp) = t {
    unified te_puretype;
    if !unify_puretypes(oo(&app.typefunc), &expected_puretype, &unified) {
      return false;
    }
    *params_out = &app.params;
    return true;
  } else {
    return false;
  }
}

func decompose_typeapp(t *te_typeexpr, expected_puretype te_puretype, oneparam_out **te_typeexpr) bool {
  params *array[te_typeexpr];
  if !decompose_typeapp(t, expected_puretype, &params) {
    return false;
  }
  if count(params) != 1 {
    return false;
  }
  *oneparam_out = ref(params, 0);
  return true;
}

func check_field(es *exprscope, t *cu_typeexpr, a *ast_fieldname, pt *te_typeexpr, fieldtype_out *cu_typeexpr) bool {
  fieldtype cu_typeexpr;
  if !lookup_field(es, t, a, &fieldtype) {
    return false;
  }
  unified te_typeexpr;
  if !unify_types(pt, &fieldtype.~, &unified) {
    ERR(_u8("field has wrong type."));
    return false;
  }
  *fieldtype_out = fieldtype;
  return true;
}

func deftype_rhs_accessible(es *exprscope, id deftype_entry_id, result_out *bool) bool {
  ent *deftype_entry = ref_deftype_entry(es->cs, id);
  switch ent->accessibility {
    case RhsPublic(v void): {
      *result_out = true;
      return true;
    }
    case RhsPrivate(v void): {
      n size = count(&es->accessible);
      for i size = 0; i < n; i = i + 1 {
        aid access_entry_id = get(&es->accessible, i);
        dti deftype_entry_id;
        if !get_accessible_deftype(es->cs, aid, &dti) {
          return false;
        }
        if dti == id {
          *result_out = true;
          return true;
        }
      }
      *result_out = false;
      return true;
    }
    case RhsImpossible(v void): {
      *result_out = false;
      return true;
    }
  }
}

// t must be complete.
func complete_structural_rhs(es *exprscope, t *te_typeexpr, rhs_type_out **te_typeexpr) bool {
  switch t {
    case &TeName(a te_name): {
      cu_rhs *cu_typeexpr;
      if !help_structural_rhs(es, &a.pack, &cu_rhs) {
        return false;
      }
      *rhs_type_out = &cu_rhs->~;
      return true;
    }
    case &TeApp(a te_typeapp): {
      cu_rhs *cu_typeexpr;
      if !help_structural_rhs(es, &a.pack, &cu_rhs) {
        return false;
      }
      *rhs_type_out = &cu_rhs->~;
      return true;
    }
    default: {
      if case &TeUnknown(v void) = t {
        ice(_u8("structural_rhs called on incomplete type"));
      }
      *rhs_type_out = t;
      return true;
    }
  }
}

func structural_rhs(es *exprscope, t *cu_typeexpr, rhs_type_out **cu_typeexpr) bool {
  switch &t->~ {
    case &TeName(a te_name): {
      return help_structural_rhs(es, &a.pack, rhs_type_out);
    }
    case &TeApp(a te_typeapp): {
      return help_structural_rhs(es, &a.pack, rhs_type_out);
    }
    default: {
      if case &TeUnknown(v void) = &t->~ {
        ice(_u8("structural_rhs called on incomplete type"));
      }
      *rhs_type_out = t;
      return true;
    }
  }
}

func help_structural_rhs(es *exprscope, mbpack *opt[te_instpack], rhs_type_out **cu_typeexpr) bool {
  if case &Has(pack te_instpack) = mbpack {
    accessible_result bool;
    if !deftype_rhs_accessible(es, pack.ent_id, &accessible_result) {
      return false;
    }
    if !accessible_result {
      ERR(_u8("Looking for structural type information on inaccessible defclass type"));
      return false;
    }
    if !ensure_deftype_inst_checked(es->cs, es->clq, pack.ent_id, pack.inst_id) {
      return false;
    }
    inst *deftype_inst = ref_deftype_inst(es->cs, pack.inst_id);
    if case &Has(info deftype_inst_info) = &inst->info {
      if case &Has(t cu_typeexpr) = &info.rhs {
        *rhs_type_out = &t;
        return true;
      } else {
        ice(_u8("deftype_rhs_accessible permitted a primitive type."));
        return false;
      }
    } else {
      ice(_u8("inst checked, info still None()"));
      return fake();
    }
  } else {
    ice(_u8("lhs type in type_structural_rhs is not computed."));
    return fake();
  }
}

func lookup_whole_field(es *exprscope, mbpack *opt[te_instpack], fieldtype_out *cu_typeexpr) bool {
  p *cu_typeexpr;
  if !help_structural_rhs(es, mbpack, &p) {
    return false;
  }
  *fieldtype_out = *p;
  return true;
}

func lookup_name_field(es *exprscope, mbpack *opt[te_instpack], fieldname *ast_ident, fieldtype_out *cu_typeexpr) bool {
  p *cu_typeexpr;
  if !help_structural_rhs(es, mbpack, &p) {
    return false;
  }
  return help_lookup_name_field(es, p, fieldname, fieldtype_out);
}

func help_lookup_name_field(es *exprscope, t *cu_typeexpr, fieldname *ast_ident, fieldtype_out *cu_typeexpr) bool {
  switch &t->~ {
    case &TeName(a te_name): {
      return lookup_name_field(es, &a.pack, fieldname, fieldtype_out);
    }
    case &TeApp(a te_typeapp): {
      return lookup_name_field(es, &a.pack, fieldname, fieldtype_out);
    }
    case &TeStruct(a te_struct): {
      return lookup_field_from_list(es->cs, &a.fields, fieldname->value, fieldtype_out);
    }
    case &TeEnum(a te_enum): {
      ERR(_u8("field lookup on an enum type"));
      return false;
    }
    case &TeUnion(a te_union): {
      return lookup_field_from_list(es->cs, &a.fields, fieldname->value, fieldtype_out);
    }
    case &TeArraytype(a te_arraytype): {
      if fieldname->value != es->cs->cym.lengthsym {
        ERR(_u8("field lookup (not .length) on array type"));
        return false;
      }
      sizetype te_typeexpr = primitive_size_type(es->cs);
      c cac_typeexpr;
      if !noscoped_check_and_compute_typeexpr(es->cs, es->clq, &sizetype, &c) {
        ice(_u8("primitive_size_type failed check"));
      }
      if !c.complete {
        ice(_u8("primitive_size_type was incomplete"));
      }
      *fieldtype_out = ~ c.te;
      return true;
    }
    case &TeUnknown(v void): {
      ice(_u8("lookup_field sees incomplete type"));
      return fake();
    }
  }
}

func lookup_field(es *exprscope, t *cu_typeexpr, f *ast_fieldname, fieldtype_out *cu_typeexpr) bool {
  switch f {
    case &WholeField(v void): {
      switch &t->~ {
        case &TeName(a te_name): {
          return lookup_whole_field(es, &a.pack, fieldtype_out);
        }
        case &TeApp(a te_typeapp): {
          return lookup_whole_field(es, &a.pack, fieldtype_out);
        }
        default: {
          ERR(_u8("whole field lookup on 'bare' type"));
          return false;
        }
        case &TeUnknown(u void): {
          ice(_u8("lookup_field sees incomplete type."));
          return fake();
        }
      }
    }
    case &NameField(b ast_ident): {
      return help_lookup_name_field(es, t, &b, fieldtype_out);
    }
  }
}

func find_vardecl(a *array[te_vardecl], name sym, out **te_typeexpr) bool {
  n size = count(a);
  for i size = 0; i < n; i = i + 1 {
    d *te_vardecl = ref(a, i);
    if d->name == name {
      *out = &d->type;
      return true;
    }
  }
  return false;
}

// fields is supposed to be complete.
func lookup_field_from_list(cs *checkstate, fields *array[te_vardecl], fieldname sym, fieldtype_out *cu_typeexpr) bool {
  fieldtype *te_typeexpr;
  if !find_vardecl(fields, fieldname, &fieldtype) {
    ERR(_u8("fieldname '"), lookup(cs->im, fieldname), _u8("' not found"));
    return false;
  }
  *fieldtype_out = ~ *fieldtype;
  return true;
}

func ai_incomplete(yes bool) allow_incomplete {
  if yes {
    return AllowIncompleteYes(void);
  } else {
    return AllowIncompleteNo(void);
  }
}

func check_expr_funcall(es *exprscope, ai allow_incomplete, x *ast_expr, a *ast_funcall, pt *te_typeexpr) bool {
  a_param_incomplete bool;
  if !check_funcall_params_firsttime(es, &a->params, &a_param_incomplete) {
    return false;
  }

  func_pt te_typeexpr = make_fn_partial_type(es->cs, pt, &a->params);
  if !check_expr_ai(es, ai_incomplete(!a_param_incomplete), oo(&a->fun), &func_pt) {
    return false;
  }

  if expr_type_incomplete(oo(&a->fun)) {
    check(ai == AllowIncompleteYes(void));
    annotate_info(x, IncompleteCheck(TeUnknown(void)));
    return true;
  }

  if a_param_incomplete {
    if !check_funcall_params_secondtime(es, expr_complete_type(oo(&a->fun)), &a->params) {
      return false;
    }
  }

  return_type *te_typeexpr = fn_return_type(&expr_complete_type(oo(&a->fun))->~);
  annotate_info(x, CompleteCheck(~ *return_type));
  return true;
}

func check_funcall_params_firsttime(es *exprscope, params *array[ast_expr], a_param_incomplete_out *bool) bool {
  n size = count(params);
  unknown te_typeexpr = TeUnknown(void);
  all_params_complete bool = true;
  for i size = 0; i < n; i = i + 1 {
    expr *ast_expr = ref(params, i);
    if !check_expr_ai(es, AllowIncompleteYes(void), expr, &unknown) {
      return false;
    }
    all_params_complete = all_params_complete & expr_type_complete(expr);
  }
  *a_param_incomplete_out = !all_params_complete;
  return true;
}

func check_funcall_params_secondtime(es *exprscope, functype *cu_typeexpr, params *array[ast_expr]) bool {
  n size = count(params);

  type_params *array[te_typeexpr];
  if case &TeApp(app te_typeapp) = &functype->~ {
    // TODO: Assert fn-type.
    type_params = &app.params;
    check(count(type_params) == n + 1);
  } else {
    ice(_u8("Expecting a TeApp for fn-type."));
  }

  for i size = 0; i < n; i = i + 1 {
    expr *ast_expr = ref(params, i);
    if !check_expr_ai(es, AllowIncompleteNo(void), expr, ref(type_params, i)) {
      return false;
    }
  }
  return true;
}

func check_expr_index(es *exprscope, x *ast_expr, a *ast_index_expr, pt *te_typeexpr) bool {
  unknown te_typeexpr = TeUnknown(void);
  if !check_expr_ai(es, AllowIncompleteNo(void), oo(&a->lhs), &unknown) {
    return false;
  }
  sizetype te_typeexpr = primitive_size_type(es->cs);
  if !check_expr_ai(es, AllowIncompleteNo(void), oo(&a->rhs), &sizetype) {
    return false;
  }

  ixtype *te_typeexpr;
  if !decompose_indexable(es->cs, &expr_complete_type(oo(&a->lhs))->~, &ixtype) {
    ERR(_u8("indexing on non-indexable type"));
    return false;
  }

  unified te_typeexpr;
  if !unify_types(pt, ixtype, &unified) {
    ERR(_u8("index expr returns wrong type"));
  }

  annotate_info(x, CompleteCheck(~ *ixtype));
  return true;
}

func decompose_indexable(cs *checkstate, t *te_typeexpr, out **te_typeexpr) bool {
  if decompose_typeapp(t, primitive_pointer_puretype(cs), out) {
    return true;
  }
  if decompose_arraytype(t, out) {
    return true;
  }
  return false;
}

func decompose_arraytype(t *te_typeexpr, out **te_typeexpr) bool {
  if case &TeArraytype(a te_arraytype) = t {
    *out = oo(&a.param);
    return true;
  } else {
    return false;
  }
}

func expr_type(a *ast_expr) te_typeexpr {
  switch &a->info {
    case &NoInfo(v void): {
      ice(_u8("expr_type sees NoInfo"));
      return fake();
    }
    case &IncompleteCheck(t te_typeexpr): {
      return t;
    }
    case &CompleteCheck(t cu_typeexpr): {
      return t.~;
    }
  }
}

func expr_complete_type(a *ast_expr) *cu_typeexpr {
  if case &CompleteCheck(t cu_typeexpr) = &a->info {
    return &t;
  } else {
    ice(_u8("expr_complete_type sees... not a complete type"));
    return fake();
  }
}

func expr_type_complete(a *ast_expr) bool {
  switch &a->info {
    case &NoInfo(v void): {
      ice(_u8("expr_type_complete sees NoInfo"));
      return fake();
    }
    case &IncompleteCheck(t te_typeexpr): { return false; }
    case &CompleteCheck(t cu_typeexpr): { return true; }
  }
}


func expr_type_incomplete(a *ast_expr) bool {
  return !expr_type_complete(a);
}

func make_fn_partial_type(cs *checkstate, return_type *te_typeexpr, params *array[ast_expr]) te_typeexpr {
  type_params array[te_typeexpr];
  n size = count(params);
  for i size = 0; i < n; i = i + 1 {
    push(&type_params, expr_type(ref(params, i)));
  }
  push(&type_params, *return_type);
  return TeApp({embox(primitive_function_puretype(cs)), type_params, None()});
}

func fn_return_type(func_type *te_typeexpr) *te_typeexpr {
  if case &TeApp(app te_typeapp) = func_type {
    // TODO: Assert fn-type.
    n size = count(&app.params);
    check(n > 0);
    return ref(&app.params, n - 1);
  } else {
    ice(_u8("Expected TeApp for fn-type in fn_return_type."));
    return fake();
  }
}
