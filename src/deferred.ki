defenum[T] nbfc {
  NotComputed void;
  BeganComputing void;
  FailedComputation void;
  Computed T;
};

inline func[T] NotComputed() nbfc[T] {
  return NotComputed(void);
}

inline func[T] BeganComputing() nbfc[T] {
  return BeganComputing(void);
}

inline func[T] FailedComputation() nbfc[T] {
  return NotComputed(void);
}

func[T] isBeganComputing(x *nbfc[T]) bool {
  if case &BeganComputing(v void) = x {
    return true;
  } else {
    return false;
  }
}

func[T] unComputed(x *nbfc[T]) *T {
  if case &Computed(t T) = x {
    return &t;
  } else {
    ice(_u8("unComputed failed"));
    return fake();
  }
}

defenum[T] nc {
  NotComputed void;
  Computed T;
};

inline func[T] NotComputed() nc[T] {
  return NotComputed(void);
}

func[T] annotate(x *nc[T], y T) void {
  if case &Computed(already T) = x {
    ice(_u8("Already annotated"));
  }
  *x = Computed(y);
}

func[T] annotate_ref(x *nc[T], y *T) void {
  if case &Computed(already T) = x {
    ice(_u8("Already annotated"));
  }
  *x = Computed(*y);
}

func[T] annotate_move(x *nc[T], y *T) void {
  if case &Computed(already T) = x {
    ice(_u8("Already annotated"));
  }
  tmp T;
  *x = Computed(tmp);
  if case &Computed(dest T) = x {
    swap(&dest, y);
  }
}

func[T] unHas(x *nc[T]) *T {
  if case &Computed(y T) = x {
    return &y;
  } else {
    ice(_u8("unHas(nc) sees not-computed"));
    return fake();
  }
}