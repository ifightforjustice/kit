import stdlib;

defclass[T] move array struct {
  count size;
  cap size;
  ptr *T;
};

access array[_] {
  func[T] do_init(r *array[T]) void {
    r->count = 0;
    r->cap = 0;
    r->ptr = null;
  }

  func[T] do_copy(dest *array[T], src *array[T]) void {
    dest->count = src->count;
    dest->cap = src->cap;
    dest->ptr = cast(checkmalloc(src->count * sizeof@[T]));
    e size = src->count;
    for i size = 0; i < e; i = i + 1 {
      dest->ptr[i] = src->ptr[i];
    }
  }

  func[T] do_destroy(r *array[T]) void {
    for i size = r->count; i > 0; {
      i = i - 1;
      destroy(&r->ptr[i]);
    }
    free(@[*void] cast(r->ptr));
  }

  func[T] set(r *array[T], i size, val T) void {
    check(i < r->count);
    r->ptr[i] = val;
  }

  func[T] get(r *array[T], i size) T {
    check(i < r->count);
    return r->ptr[i];
  }

  func[T] ref(r *array[T], i size) *T {
    check(i < r->count);
    return &r->ptr[i];
  }

  func[T] count(r *array[T]) size {
    return r->count;
  }

  func[T] change_cap_(r *array[T], newcap size) void {
    check(newcap >= r->count);
    p *T = cast(checkmalloc(newcap * sizeof@[T]));
    e size = r->count;
    for i size = 0; i < e; i = i + 1 {
      move(&p[i], &r->ptr[i]);
    }
    free(@[*void] cast(r->ptr));
    r->ptr = p;
    r->cap = newcap;
  }

  func[T] pop(r *array[T]) void {
    check(r->count > 0);
    r->count = r->count - 1;
    destroy(&r->ptr[r->count]);
  }

  func[T] append(r *array[T], value T) void {
    if (r->count == r->cap) {
      change_cap_(r, max(4, r->cap * 2));
    }
    // The reason we use copy, not move, here, is because value's
    // destructor will get called when we exit this function.
    copy(&r->ptr[r->count], &value);
    r->count = r->count + 1;
  }

  func[T] append(r *array[T], s *array[T]) void {
    for i size = 0; i < s->count; i = i + 1 {
      append(r, s->ptr[i]);
    }
  }

  func[T] append_raw(r *array[T], p *T, n size) void {
    for i size = 0; i < n; i = i + 1 {
      append(r, p[i]);
    }
  }

  func[T] data(r *array[T]) *T {
    return r->ptr;
  }

  func[T, U] make(raw_arr U) array[T] {
    ret array[T];
    append_raw(&ret, &raw_arr[0], raw_arr.length);
    return ret;
  }

  func[T] repeat(value T, n size) array[T] {
    ret array[T];
    for i size = 0; i < n; i = i + 1 {
      append(&ret, value);
    }
    return ret;
  }
}

func foo() void {
  v array[i32];
  var u = v;
  append(&u, 7);
  append(&u, &v);
  data(&u);
}

