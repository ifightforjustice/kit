import expr;

// What we need to know about bodies:
//   - that labels have unique names.
//   - what variables are in scope at each label (beware duplicate variable names).
//   - what variables need to get init/destroyed for each goto. (Beware case constructor variables that don't get destroyed.  Also, you can't goto into a casebody (because their variables cannot be initialized).)
//   - that no control path reaches the end of the function without a return statement.
//   - that there's no dead code after a goto or return statement.

deftype goto_info struct {
  label_name sym;
  in_scope array[var_number];
};

deftype label_info struct {
  label_name sym;
  in_scope array[var_number];
  hit bool;
};

deftype bodystate struct {
  es *exprscope;
  cs *checkstate;
  im *identmap;
  clq *clqueue;
  return_type *cu_typeexpr;

  gotos array[goto_info];
  labels array[label_info];
};

func mk(es *exprscope, return_type *cu_typeexpr) bodystate {
  ret bodystate;
  ret.es = es;
  ret.cs = es->cs;
  ret.im = es->im;
  ret.clq = es->clq;
  ret.return_type = return_type;
  return ret;
}

func check_body(bs *bodystate, a *ast_bracebody) bool {
  nstatements size = count(&a->statements);
  vp varpopper;
  for i size = 0; i < nstatements; i = i + 1 {
    s *ast_statement = ref(&a->statements, i);
    if !check_statement(bs, &vp, s) {
      return false;
    }
  }
  return true;
}

func check_statement(bs *bodystate, vp *varpopper, s *ast_statement) bool {
  switch s {
    case &Expr(b ast_expr): {
      pt te_typeexpr = TeUnknown(void);
      if !check_expr_ai(bs->es, AllowIncompleteNo(void), &b, &pt) {
        return false;
      }
    }
    case &Return(b ast_return_statement): {
      if case &Has(c box[ast_expr]) = &b.expr {
        if !check_expr_ai(bs->es, AllowIncompleteNo(void), oo(&c), &bs->return_type->~) {
          return false;
        }
      } else {
        void_type te_typeexpr = primitive_void_type(bs->cs);
        unified te_typeexpr;
        if !unify_types(&void_type, &bs->return_type->~, &unified) {
          ERR(_u8("Empty return statement with non-void return value."));
          return false;
        }
      }
    }
    case &Var(b ast_var_statement): {
      // TODO: Cache converted... or something.
      converted te_typeexpr;
      if !convert_typeexpr(bs->cs, &b.decl.type, &converted) {
        return false;
      }

      computed cac_typeexpr;
      if !check_and_compute_typeexpr(bs->cs, bs->clq, bs->es->generics, bs->es->parms, &converted, &computed) {
        return false;
      }
      cu_computed cu_typeexpr;
      complete_type *cu_typeexpr;
      if case &Has(x box[ast_expr]) = &b.rhs {
        if !check_expr_ai(bs->es, AllowIncompleteNo(void), oo(&x), &computed.te) {
          return false;
        }
        complete_type = expr_complete_type(oo(&x));
      } else {
        if !computed.complete {
          ERR(_u8("Variable declaration with no rhs, incomplete type"));
          return false;
        }
        // NOTE: The object must be default-constructible.
        cu_computed = ~computed.te;
        complete_type = &cu_computed;
      }

      if !es_push_var(bs->es, vp, &b.decl.name, complete_type, AutoInitYes(void)) {
        return false;
      }
    }
    case &IfThen(b ast_ifthen_statement): {
      cond_vp varpopper;
      init_vp(&cond_vp, bs->es);
      if !check_condition(bs->es, &cond_vp, &b.condition) {
        return false;
      }
      if !check_body(bs, &b.body) {
        return false;
      }
    }
    case &IfThenElse(b ast_ifthenelse_statement): {
      cond_vp varpopper;
      init_vp(&cond_vp, bs->es);
      if !check_condition(bs->es, &cond_vp, &b.condition) {
        return false;
      }
      if !check_body(bs, &b.thenbody) {
        return false;
      }
      descope_vars(&cond_vp);
      if !check_body(bs, &b.elsebody) {
        return false;
      }
    }
    case &While(b ast_while_statement): {
      cond_vp varpopper;
      init_vp(&cond_vp, bs->es);
      if !check_condition(bs->es, &cond_vp, &b.condition) {
        return false;
      }
      if !check_body(bs, &b.body) {
        return false;
      }
    }
    case &For(b ast_for_statement): {
      initter_vp varpopper;
      init_vp(&initter_vp, bs->es);
      if case &Has(initter box[ast_statement]) = &b.initializer {
        if !check_statement(bs, &initter_vp, oo(&initter)) {
          return false;
        }
      }
      if case &Has(cond box[ast_expr]) = &b.condition {
        boolean te_typeexpr = primitive_bool_type(bs->cs);
        if !check_expr_ai(bs->es, AllowIncompleteNo(void), oo(&cond), &boolean) {
          return false;
        }
      }
      if case &Has(incr box[ast_expr]) = &b.increment {
        unknown te_typeexpr = TeUnknown(void);
        if !check_expr_ai(bs->es, AllowIncompleteNo(void), oo(&incr), &unknown) {
          return false;
        }
      }
      if !check_body(bs, &b.body) {
        return false;
      }
    }
    case &Switch(b ast_switch_statement): {
      unknown te_typeexpr = TeUnknown(void);
      if !check_expr_ai(bs->es, AllowIncompleteNo(void), oo(&b.swartch), &unknown) {
        return false;
      }

      swartch_type *cu_typeexpr = expr_complete_type(oo(&b.swartch));

      switchable_type *te_typeexpr;
      is_ptr bool = decompose_typeapp(&swartch_type->~, primitive_pointer_puretype(bs->cs), &switchable_type);
      if !is_ptr {
        switchable_type = &swartch_type->~;
      }

      // switchable_type is complete, because swartch_type was.

      enum_type *te_typeexpr;
      if !complete_structural_rhs(bs->es, switchable_type, &enum_type) {
        return false;
      }
      // enum_type is complete, because complete_structural_rhs does that.

      if case &TeEnum(et te_enum) = enum_type {
        ncases size = count(&b.cases);
        for i size = 0; i < ncases; i = i + 1 {
          cas *ast_switch_case = ref(&b.cases, i);
          for j size = 0; j < i; j = j + 1 {
            if duped_patterns(&cas->pattern, &ref(&b.cases, j)->pattern) {
              ERR(_u8("duplicate patterns"));
              return false;
            }
          }

          switch &cas->pattern {
            case &Case(patt ast_constructor_pattern): {
              if isHas(&patt.addressof_constructor) != is_ptr {
                ERR(_u8("swartch/pattern pointeriness mismatch"));
                return false;
              }

              expected_type *te_typeexpr;
              if !find_vardecl(&et.constructors, patt.constructor_name.value, &expected_type) {
                ERR(_u8("constructor not found"));
                return false;
              }
              // expected_type is complete, because enum_type was.

              // TODO: Cache converted?
              converted te_typeexpr;
              if !convert_typeexpr(bs->cs, &patt.decl.type, &converted) {
                return false;
              }

              unified te_typeexpr;
              if !unify_types(&converted, expected_type, &unified) {
                ERR(_u8("constructor variable type mismatch"));
                return false;
              }

              case_vp varpopper;
              init_vp(&case_vp, bs->es);
              cu_expected_type cu_typeexpr = ~ *expected_type;
              // Can't auto-initialize bound case variables, be the switch be over a pointer or not.
              if !es_push_var(bs->es, &case_vp, &patt.decl.name, &cu_expected_type, AutoInitNo(void)) {
                return false;
              }

              if !check_body(bs, &cas->body) {
                return false;
              }
            }
            case &Default(v void): {
              if !check_body(bs, &cas->body) {
                return false;
              }
            }
          }
        }
        if ncases > count(&et.constructors) {
          check(ncases == 1 + count(&et.constructors));
          ERR(_u8("Unnecessary default case."));
          return false;
        }
      } else {
        ERR(_u8("Switching over non-switchable type."));
      }
    }
    case &Label(b ast_label_statement): {
      if case Has(ix size) = lookup_label(bs, b.name.value) {
        ERR(_u8("Duplicate label name."));
        return false;
      }

      push(&bs->labels, {b.name.value, vars_in_scope(bs->es), false});
    }
    case &Goto(b ast_goto_statement): {
      push(&bs->gotos, {b.target.value, vars_in_scope(bs->es)});
    }
  }
  return true;
}

func lookup_label(bs *bodystate, label_name sym) opt[size] {
  nlabels size = count(&bs->labels);
  for i size = 0; i < nlabels; i = i + 1 {
    if ref(&bs->labels, i)->label_name == label_name {
      return Has(i);
    }
  }
  return None();
}

func duped_patterns(a *ast_case_pattern, b *ast_case_pattern) bool {
  switch a {
    case &Case(ac ast_constructor_pattern): {
      if case &Case(bc ast_constructor_pattern) = b {
        return ac.constructor_name.value == bc.constructor_name.value;
      }
    }
    case &Default(v void): {
      if case &Default(u void) = b {
        return true;
      }
    }
  }
  return false;
}

func check_condition(es *exprscope, cond_vp *varpopper, a *ast_condition) bool {
  switch a {
    case &ExprCondition(b box[ast_expr]): {
      booltype te_typeexpr = primitive_bool_type(es->cs);
      if !check_expr_ai(es, AllowIncompleteNo(void), oo(&b), &booltype) {
        return false;
      }
      return true;
    }
    case &PatternCondition(b ast_pattern_assign): {
      unknown te_typeexpr = TeUnknown(void);
      if !check_expr_ai(es, AllowIncompleteNo(void), oo(&b.rhs), &unknown) {
        return false;
      }

      // TODO: vv Some of this code is redundant with switch statement code.
      swartch_type *cu_typeexpr = expr_complete_type(oo(&b.rhs));
      switchable_type *te_typeexpr;
      is_ptr bool = decompose_typeapp(&swartch_type->~, primitive_pointer_puretype(es->cs), &switchable_type);
      if !is_ptr {
        switchable_type = &swartch_type->~;
      }
      // switchable_type is complete, because swartch_type is.

      enum_type *te_typeexpr;
      if !complete_structural_rhs(es, switchable_type, &enum_type) {
        return false;
      }
      // enum_type is complete, because complete_structural_rhs.

      if case &TeEnum(et te_enum) = enum_type {
        if isHas(&b.pattern.addressof_constructor) != is_ptr {
          ERR(_u8("condition pattern pointeriness mismatch"));
          return false;
        }

        expected_type *te_typeexpr;
        if !find_vardecl(&et.constructors, b.pattern.constructor_name.value, &expected_type) {
          ERR(_u8("constructor not found in condition pattern"));
          return false;
        }
        // expected_type is complete because enum_type is.

        // TODO: Cache converted?
        converted te_typeexpr;
        if !convert_typeexpr(es->cs, &b.pattern.decl.type, &converted) {
          return false;
        }

        unified te_typeexpr;
        if !unify_types(&converted, expected_type, &unified) {
          ERR(_u8("constructor variable type mismatch"));
          return false;
        }

        cu_expected_type cu_typeexpr = ~ *expected_type;
        if !es_push_var(es, cond_vp, &b.pattern.decl.name, &cu_expected_type, AutoInitNo(void)) {
          return false;
        }

        return true;
      } else {
        ERR(_u8("Condition pattern over non-switchable type."));
        return false;
      }
    }
  }
}

func finish_lambda_body(bs *bodystate) bool {
  ngotos size = count(&bs->gotos);
  for i size = 0; i < ngotos; i = i + 1 {
    g *goto_info = ref(&bs->gotos, i);
    if case Has(j size) = lookup_label(bs, g->label_name) {
      ref(&bs->labels, j)->hit = true;
    } else {
      ERR(_u8("no label named '"), lookup(bs->im, g->label_name), _u8("'"));
      return false;
    }
  }

  nlabels size = count(&bs->labels);
  for i size = 0; i < nlabels; i = i + 1 {
    l *label_info = ref(&bs->labels, i);
    if !l->hit {
      ERR(_u8("no gotos for label named '"), lookup(bs->im, l->label_name), _u8("'"));
      return false;
    }
  }

  return true;
}
