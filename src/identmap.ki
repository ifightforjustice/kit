import hash;
import string;
import stdlib;

deftype sym size;

func build_u8str(r *array[u8], v *sym) void {
  append(r, as_hex(v->~));
}

def `~` fn[size, sym] = wrapconvert;

func `==`(x sym, y sym) bool {
  return x.~ == y.~;
}
func `!=`(x sym, y sym) bool {
  return x.~ != y.~;
}

func hash_compute_hash(x *sym) osize {
  return ~x->~;
}

func hash_equal(x *sym, y *sym) bool {
  return *x == *y;
}

defclass[T] copy symmap struct {
  // A map from T's to ident values.
  table hash[T, sym];
  // A map from ident values to T's.
  backmap array[T];
};

access symmap[_] {
  func[T] do_init(im *symmap[T]) void {
    init(&im->table);
    init(&im->backmap);
  }

  func[T] intern(im *symmap[T], s T) sym {
    val size = count(&im->backmap);
    if try_insert(&im->table, s, ~val) {
      push(&im->backmap, s);
      return ~val;
    } else {
      switch lookup(&im->table, s) {
        case Has(value): {
          return value;
        }
      }
    }
  }

  func[T] is_interned(im *symmap[T], s T) opt[sym] {
    return lookup(&im->table, s);
  }

  func[T] lookup(im *symmap[T], ident sym) T {
    return get(&im->backmap, ident.~);
  }
}

deftype common_syms struct {
  fnsym sym;
  boolsym sym;
  voidsym sym;
  i8sym sym;
  u8sym sym;
  i16sym sym;
  u16sym sym;
  i32sym sym;
  u32sym sym;
  sizesym sym;
  osizesym sym;
  primitive_module_sym sym;
  ptrtype_sym sym;
  lengthsym sym;
  tee_sym sym;
  uee_sym sym;
  derefsym sym;
  addressofsym sym;
  assignmentsym sym;
  convertsym sym;
  magic_init sym;
  magic_copy sym;
  magic_move sym;
  magic_destroy sym;
};

deftype identmap struct {
  sm symmap[string];
  cym common_syms;
};

func make_common_syms(im *symmap[string]) common_syms {
  ret common_syms;
  ret.fnsym = intern(im, from_u8(_u8("fn")));
  ret.boolsym = intern(im, from_u8(_u8("bool")));
  ret.voidsym = intern(im, from_u8(_u8("void")));
  ret.i8sym = intern(im, from_u8(_u8("i8")));
  ret.u8sym = intern(im, from_u8(_u8("u8")));
  ret.i16sym = intern(im, from_u8(_u8("i16")));
  ret.u16sym = intern(im, from_u8(_u8("u16")));
  ret.i32sym = intern(im, from_u8(_u8("i32")));
  ret.u32sym = intern(im, from_u8(_u8("u32")));
  ret.sizesym = intern(im, from_u8(_u8("size")));
  ret.osizesym = intern(im, from_u8(_u8("osize")));
  ret.primitive_module_sym = intern(im, from_u8(_u8("<primitive>")));
  ret.ptrtype_sym = intern(im, from_u8(_u8("*")));
  ret.lengthsym = intern(im, from_u8(_u8("length")));
  ret.tee_sym = intern(im, from_u8(_u8("T")));
  ret.uee_sym = intern(im, from_u8(_u8("U")));
  ret.derefsym = intern(im, from_u8(_u8("*")));
  ret.addressofsym = intern(im, from_u8(_u8("&")));
  ret.assignmentsym = intern(im, from_u8(_u8("=")));
  ret.convertsym = intern(im, from_u8(_u8("~")));
  ret.magic_init = intern(im, from_u8(_u8("magic_init")));
  ret.magic_copy = intern(im, from_u8(_u8("magic_copy")));
  ret.magic_move = intern(im, from_u8(_u8("magic_move")));
  ret.magic_destroy = intern(im, from_u8(_u8("magic_destroy")));
  return ret;
}

func make_im() identmap {
  ret identmap;
  ret.cym = make_common_syms(&ret.sm);
  return ret;
}

func intern(im *identmap, s string) sym {
  return intern(&im->sm, s);
}

func is_interned(im *identmap, s string) opt[sym] {
  return is_interned(&im->sm, s);
}

func lookup(im *identmap, ident sym) string {
  return lookup(&im->sm, ident);
}
