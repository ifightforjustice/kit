import ast;
import identmap;
import pos;

deftype ps struct {
  data *u8;
  length size;
  pos size;

  im *identmap;

  stack array[ptree];
};

func make_ps(im *identmap, data *u8, length size) ps {
  p ps;
  p.data = data;
  p.length = length;
  p.pos = 0;
  p.im = im;
  return p;
}

func ps_pos(p *ps) pos {
  ret pos;
  ret.~ = p->pos;
  return ret;
}

func ps_restore_pos(p *ps, pos pos) void {
  p->pos = pos.~;
}

func ps_peek(p *ps) i32 {
  check(p->pos <= p->length);
  if p->pos == p->length {
    return -1;
  }
  return ~p->data[p->pos];
}

func ps_step(p *ps) void {
  check(p->pos < p->length);
  p->pos = p->pos + 1;
}



defenum keyw {
  Case void;
  Def void;
  Defclass void;
  Defenum void;
  Deftype void;
  Else void;
  False void;
  For void;
  Func void;
  If void;
  Null void;
  Return void;
  Struct void;
  Switch void;
  True void;
  Underscore void;
  Union void;
  Var void;
  While void;
};

defenum numlit {
  DecNum array[i8];
  HexNum array[i8];
};

defenum grouper {
  LParen void;
  RParen void;
  LBracket void;
  RBracket void;
  LBrace void;
  RBrace void;
};

defenum tokval {
  Keyw keyw;
  Num numlit;
  Oper array[i32];
  Ident array[i32];
  Grouper grouper;
};

deftype tok struct {
  interval interval;
  val tokval;
};

func mk_tok(left pos, right pos, val tokval) tok {
  ret tok;
  ret.val = val;
  ret.interval = mk_interval(left, right);
  return ret;
}

defenum treesym {
  Token tok;
};

deftype ptree struct {
  sym treesym;
  childs array[uniq[ptree]];
};

defenum grab_tok_res {
  BadToken interval;
  EofToken void;
  TokToken tok;
};

func is_lower(x i32) bool {
  // TODO: Statically assert 'z' - 'a' == 25.
  return x >= ~'a' && x <= ~'z';
}

func is_upper(x i32) bool {
  // TODO: Statically assert 'Z' - 'A' == 25.
  return x >= ~'A' && x <= ~'Z';
}

func is_alpha(x i32) bool {
  return is_lower(x) || is_upper(x);
}

func is_digit(x i32) bool {
  // TODO: Statically assert '9' - '0' == 9.
  return x >= ~'0' && x <= ~'9';
}

func is_alnum(x i32) bool {
  return is_alpha(x) || is_digit(x);
}

func is_hexdigit(x i32, val_out *i8) bool {
  // TODO: Statically assert 'f' - 'a', 'F' - 'A', '9' - '0'.
  if is_digit(x) {
    *val_out = ~(x - ~'0');
    return true;
  }
  if ~'A' <= x && x <= ~'F' {
    *val_out = ~(x - ~'A');
    return true;
  }
  if ~'a' <= x && x <= ~'f' {
    *val_out = ~(x - ~'a');
    return true;
  }
  return false;
}

func is_numeric_postchar(x i32) bool {
  // TODO: Implement for real.
  return !is_alnum(x);
}

func is_ident_firstchar(x i32) bool {
  return is_alpha(x) || x == ~'_';
}

func is_ident_midchar(x i32) bool {
  return is_ident_firstchar(x) || is_digit(x);
}

func is_ident_postchar(x i32) bool {
  // TODO: Implement for real.
  return !is_ident_midchar(x);
}

func grab_tok(p *ps) grab_tok_res {
  left pos = ps_pos(p);
  ch i32 = ps_peek(p);
  if ch == @[i32]-1 {
    return EofToken(void);
  }
  if ch == ~'0' {
    ps_step(p);
    ch = ps_peek(p);
    if ch == ~'x' {
      ps_step(p);
      ch = ps_peek(p);
      digits array[i8];
      val i8;
      while is_hexdigit(ch, &val) {
        append(&digits, val);
        ps_step(p);
        ch = ps_peek(p);
      }

      if is_numeric_postchar(ch) {
        return TokToken(mk_tok(left, ps_pos(p), Num(HexNum(digits))));
      } else {
        return BadToken(mk_interval(left, ps_pos(p)));
      }
    } else {
      if is_numeric_postchar(ch) {
        digits array[i8];
        append(&digits, 0);
        return TokToken(mk_tok(left, ps_pos(p), Num(DecNum(digits))));
      } else {
        return BadToken(mk_interval(left, ps_pos(p)));
      }
    }
  } else if is_digit(ch) {
    digits array[i8];
    append(&digits, @[i8]~(ch - ~'0'));
    ps_step(p);
    ch = ps_peek(p);
    while is_digit(ch) {
      append(&digits, @[i8]~(ch - ~'0'));
      ps_step(p);
      ch = ps_peek(p);
    }
    if is_numeric_postchar(ch) {
      return TokToken(mk_tok(left, ps_pos(p), Num(DecNum(digits))));
    } else {
      return BadToken(mk_interval(left, ps_pos(p)));
    }
  } else if is_ident_firstchar(ch) {
    ret tok;
    if (grab_keyword(p, "case", Case(void), &ret)
        || grab_keyword(p, "def", Def(void), &ret)
        || grab_keyword(p, "defclass", Defclass(void), &ret)
        || grab_keyword(p, "defenum", Defenum(void), &ret)
        || grab_keyword(p, "deftype", Deftype(void), &ret)
        || grab_keyword(p, "else", Else(void), &ret)
        || grab_keyword(p, "false", False(void), &ret)
        || grab_keyword(p, "for", For(void), &ret)
        || grab_keyword(p, "func", Func(void), &ret)
        || grab_keyword(p, "if", If(void), &ret)
        || grab_keyword(p, "null", Null(void), &ret)
        || grab_keyword(p, "return", Return(void), &ret)
        || grab_keyword(p, "struct", Struct(void), &ret)
        || grab_keyword(p, "switch", Switch(void), &ret)
        || grab_keyword(p, "true", True(void), &ret)
        || grab_keyword(p, "_", Underscore(void), &ret)
        || grab_keyword(p, "union", Union(void), &ret)
        || grab_keyword(p, "var", Var(void), &ret)
        || grab_keyword(p, "while", While(void), &ret)) {
      return TokToken(ret);
    }

    arr array[i32];
    append(&arr, ch);
    ps_step(p);
    ch = ps_peek(p);
    while is_ident_midchar(ch) {
      append(&arr, ch);
      ps_step(p);
      ch = ps_peek(p);
    }
    if !is_ident_postchar(ch) {
      return BadToken(mk_interval(left, ps_pos(p)));
    }
    return TokToken(mk_tok(left, ps_pos(p), Ident(arr)));
  } else if ch == ~'(' {
    ps_step(p);
    return TokToken(mk_tok(left, ps_pos(p), Grouper(LParen(void))));
  } else if ch == ~')' {
    ps_step(p);
    return TokToken(mk_tok(left, ps_pos(p), Grouper(RParen(void))));
  } else if ch == ~'[' {
    ps_step(p);
    return TokToken(mk_tok(left, ps_pos(p), Grouper(LBracket(void))));
  } else if ch == ~']' {
    ps_step(p);
    return TokToken(mk_tok(left, ps_pos(p), Grouper(RBracket(void))));
  } else if ch == ~'{' {
    ps_step(p);
    return TokToken(mk_tok(left, ps_pos(p), Grouper(LBrace(void))));
  } else if ch == ~'}' {
    ps_step(p);
    return TokToken(mk_tok(left, ps_pos(p), Grouper(RBrace(void))));
  } else if ch == ~'!' {
    arr array[i32];
    append(&arr, ch);
    ps_step(p);
    ch = ps_peek(p);
    if ch == ~'=' {
      append(&arr, ch);
      ps_step(p);
    }
    return TokToken(mk_tok(left, ps_pos(p), Oper(arr)));
  } else {
    // TODO: Implement.
    return BadToken(mk_interval(left, ps_pos(p)));
  }
}

func[String] grab_keyword(p *ps, s String, k keyw, out *tok) bool {
  left pos = ps_pos(p);
  for i size = 0; i < s.length; i = i + 1 {
    si u8 = s[i];
    if ps_peek(p) != ~si {
      ps_restore_pos(p, left);
      return false;
    }
    ps_step(p);
  }

  if !is_ident_postchar(ps_peek(p)) {
    return false;
  }

  *out = mk_tok(left, ps_pos(p), Keyw(k));
  return true;
}
