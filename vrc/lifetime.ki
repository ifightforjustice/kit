import state;

// This file's a grab-bag for lifetime type related stuff.  Probably most of it should be moved to other files and this should go away.

// I suspect instpacks might require lifetime type name mapping information, so this is a placeholder.
func canonicalized_pack(pack *opt[te_instpack]) opt[te_instpack] {
  return *pack;
}

func canonicalize_arraytype_count(a *opt[u32]) opt[u32] {
  return *a;
}

func make_canonicalized_lifetime_name(im *identmap, ix size) sym {
  b array[u8];
  push(&b, '$');
  build_u8str(void, &b, &ix);
  return intern(im, from_u8(&b));
}

func canonicalize_idy_lifetimes(im *identmap, lifetime_names *array[sym], t *te_typeexpr, out *te_typeexpr) void {
  switch t {
  case &TeName(a te_name):
    *out = *t;
  case &TeApp(a te_typeapp):
    newparams array[te_typeexpr];
    nparams size = count(&a.params);
    for i size = 0; i < nparams; i = i + 1 {
      tmp te_typeexpr;
      canonicalize_idy_lifetimes(im, lifetime_names, ref(&a.params, i), &tmp);
      push(&newparams, tmp);
    }
    *out = TeApp({a.typefunc, freeze(&newparams), canonicalized_pack(&a.pack)});
  case &TeUnion(a te_union):
    // Honestly, a union having lifetimes would be pretty weird.
    *out = TeUnion({canonicalize_idy_vardecls(im, lifetime_names, &a.fields)});
  case &TeArraytype(a te_arraytype):
    count opt[u32] = canonicalize_arraytype_count(&a.count);
    param shp[te_typeexpr];
    canonicalize_idy_lifetimes(im, lifetime_names, oo(&a.param), oo(&param));
    *out = TeArraytype({count, param});
  case &TeLifetime(a te_lifetime):
    lifetime te_lifetime;
    canonicalize_idy_lifetime(im, lifetime_names, &a, &lifetime);
    *out = TeLifetime(lifetime);
  case &TeTrans(a te_trans):
    before shray[te_statedesc];
    canonicalize_idy_statedesc_lists(im, lifetime_names, &a.before, &before);
    after shray[te_statedesc];
    canonicalize_idy_statedesc_lists(im, lifetime_names, &a.after, &after);
    *out = TeTrans({before, after});
  case &TeUnknown:
    ice(_u8("canonicalize_idy_lifetimes sees TeUnknown."));
  }
}

func canonicalize_idy_lifetime(im *identmap, lifetime_names *array[sym], a *te_lifetime, out *te_lifetime) void {
  if case Has(ix size) = find(lifetime_names, a->name) {
    *out = {make_canonicalized_lifetime_name(im, ix)};
  } else {
    n size = count(lifetime_names);
    push(lifetime_names, a->name);
    *out = {make_canonicalized_lifetime_name(im, n)};
  }
}

func canonicalize_idy_statedesc_lists(im *identmap, lifetime_names *array[sym], a *shray[te_statedesc], out *shray[te_statedesc]) void {
  build array[te_statedesc];
  n size = count(a);
  for i size = 0; i < n; i = i + 1 {
    desc *te_statedesc = ref(a, i);
    lifetime te_lifetime;
    canonicalize_idy_lifetime(im, lifetime_names, &desc->lifetime, &lifetime);
    push(&build, {lifetime, desc->active});
  }
  *out = freeze(&build);
}

func canonicalize_idy_vardecls(im *identmap, lifetime_names *array[sym], a *shray[te_vardecl]) shray[te_vardecl] {
  build array[te_vardecl];
  n size = count(a);
  for i size = 0; i < n; i = i + 1 {
    decl *te_vardecl = ref(a, i);
    tmp te_typeexpr;
    canonicalize_idy_lifetimes(im, lifetime_names, &decl->type, &tmp);
    push(&build, {decl->name, tmp});
  }
  return freeze(&build);
}
