import dumbgen;
import state;

/* We need to figure out what cell is what.

In a function body, cells fit in exactly ONE leaf node of this tree of categories:

 - subcells of some other cell
   - constant offset subcells
   - computed offset subcells -- location depends on another cell
 - not a subcell
   - static cells -- these can be statically located, have a static lifetime
     - outer cells -- pre-existing, locations taken as given
    //  - globals (these do not exist yet)
        - outer func paramlist & return cell
     - paramlist cells -- part of a func paramlist in GrApply
     - free cells -- temporaries, variables, we can locate them anywhere in the stack frame.
   - deref cells -- formed by dereferencing a pointer

Some more definitions:
 - A cell is "statically locatable" if it is a static cell or a constant offset subcells of a statically locatable cell.
 - "Statlocat" is an abbrevation for "statically locatable."
 - A cell is "derefalike" if it is a deref cell or a subcell of a derefalike cell.

We should find that some restrictions are upheld:

 - subcells are always subcells of exactly one cell, declared in exactly one node.  hell, every cell is sort of defined by exactly one node.
 - computed offset subcells' location cells must be statlocat.
 - GrApply return cells must be statlocat (for now).
 - paramlist cells can only be part of one func paramlist.
*/

/* What we want to do:

  At a minimum, we want to know whether a cell is a paramlist cell, and what paramlist it's part of.
*/

struct subcell_disp {
  subcell_opnum gr_num;
  partof cell_num;
  offset gr_offset;
};

enum cell_const_disp {
  NoConstDisp void;
  HasConstValue gr_const;
  NotConst void;
};

struct cell_disp {
  // If the cell's part of a function param list, tells what paramlist it's part of.
  paramlist opt[gr_num];
  // If the cell's part of a primop param list, tells what paramlist it's part of.
  prim_paramlist opt[gr_num];
  // If the cell's a funcell of a GrApply, tells what paramlist it's applying.  Or tells what paramlist it used to apply, if the function got inlined.
  funcell opt[gr_num];
  // If the cell's value is used, outside of a funcell.
  value_used bool;
  // If the cell's a subcell of another, tells what it's a subcell of.
  subcell opt[subcell_disp];
  // If the cell has a constant value.  (Must be a static cell.)
  const_value cell_const_disp;

  // Which cells are alive at the same time as this one (except this one).
  // This can have duplicates, but it won't have many.
  conflicting array[cell_num];

  // Which cells are subcells of this one.
  subcelled array[cell_num];
};

struct basic_analyze_state {
  // This means we've analyzed gns [0, gns_analyzed).  But we haven't analyzed further gns.
  gns_analyzed size;
  paramlists array[gr_num];
  celldisp array[cell_disp];
};

func basic_analyze_fn_body(cs *checkstate, g *graphed_fn_body, bas_out *basic_analyze_state) void {
  bas basic_analyze_state = {0, mk_array@[gr_num](), mk_array@[cell_disp]()};

  help_basic_analyze(cs, &bas, &g->graph.gr);

  // TODO: Check mutual exclusivity of celldisps -- cells can't be certain combinations of things.

  *bas_out = bas;
}

func help_basic_analyze(cs *checkstate, bas *basic_analyze_state, gr *frame_graph) void {
  n_ops size = count(&gr->ops);
  cellcount size = count(&gr->cells);
  grow(&bas->celldisp, cellcount - count(&bas->celldisp), {None, None, None, false, None, NoConstDisp, mk_array@[cell_num](), mk_array@[cell_num]()});

  for i size = bas->gns_analyzed; i < n_ops; i = i + 1 {
    gn gr_num = ~i;
    node *gr_node = ref(&gr->ops, i);
    switch node {
    case &XOp(xn gr_xnode):
      switch &xn.op {
      case &GrApply(a gr_apply):
        push(&bas->paramlists, ~i);
        funcell_cd *cell_disp = ref(&bas->celldisp, a.funcell.x);
        if case &Has(other_gn gr_num) = &funcell_cd->funcell {
          ice(_u8("two-timing funcell "), a.funcell.x, _u8(" for "), other_gn.x, _u8(" and "), i);
        } else {
          funcell_cd->funcell = Has(gn);
        }
        nparams size = count(&a.params);
        for j size = 0; j < nparams; j = j + 1 {
          mark_cell_paramlist(bas, get(&a.params, j), gn);
        }
        mark_cell_not_const(bas, a.retcell);
      case &GrPrimApply(a gr_prim_apply):
        nparams size = count(&a.params);
        for j size = 0; j < nparams; j = j + 1 {
          mark_cell_prim_paramlist(bas, get(&a.params, j), gn);
        }
        mark_cell_not_const(bas, a.retcell);
      case &GrMemCopy(a gr_memcopy):
        mark_cell_value_used(bas, a.src);
        mark_cell_not_const(bas, a.dest);
      case &GrWriteConst(a gr_writeconst):
        if case LocationStatic = ref(&gr->cells, a.dest.x)->location {
          disp *cell_const_disp = &ref(&bas->celldisp, a.dest.x)->const_value;
          switch disp {
          case &NoConstDisp:
            *disp = HasConstValue(a.value);
          case &HasConstValue(gc gr_const):
            *disp = NotConst;
          case &NotConst: { }
          }
        }
      case &GrAddressof(a gr_addressof):
        mark_cell_value_used(bas, a.addressee);
        // If this is the address of a static cell, the value is actually const.  But we ignore that possibility.
        mark_cell_not_const(bas, a.dest);
        mark_cell_not_const(bas, a.addressee);
      case &GrSubcell(a gr_subcell):
        set(&ref(&bas->celldisp, a.name.x)->subcell, {gn, a.partof, a.offset});
        push(&ref(&bas->celldisp, a.partof.x)->subcelled, a.name);
        check(ref(&gr->cells, a.name.x)->location == LocationVirtual);
        mark_cell_not_const(bas, a.partof);
        mark_cell_value_used(bas, a.name);
        mark_cell_value_used(bas, a.partof);
       default: { }
      }
    case &QOp(qn gr_qnode):
      switch &qn.op {
      case &GrBranch(a gr_branch):
        mark_cell_value_used(bas, a.src);
      default: { }
      }
    }
  }
  bas->gns_analyzed = n_ops;
}

func mark_cell_value_used(bas *basic_analyze_state, c cell_num) void {
  p *cell_disp = ref(&bas->celldisp, c.x);
  p->value_used = true;
}

// Also marks value_used.
func mark_cell_paramlist(bas *basic_analyze_state, c cell_num, apply_opnum gr_num) void {
  p *cell_disp = ref(&bas->celldisp, c.x);
  set(&p->paramlist, apply_opnum);
  p->value_used = true;
}

// Also marks value_used.
func mark_cell_prim_paramlist(bas *basic_analyze_state, c cell_num, apply_opnum gr_num) void {
  p *cell_disp = ref(&bas->celldisp, c.x);
  set(&p->prim_paramlist, apply_opnum);
  p->value_used = true;
}

func mark_cell_not_const(bas *basic_analyze_state, c cell_num) void {
  ref(&bas->celldisp, c.x)->const_value = NotConst;
}

func basic_and_inline(cs *checkstate, g *graphed_fn_body) np {
  switch &g->inline_state {
  case &NotComputed:
    g->inline_state = BeganComputing;
    bas basic_analyze_state;
    basic_analyze_fn_body(cs, g, &bas);

    if case Printed(pm) = help_basic_inline_inlinables(cs, &bas, g) {
      g->inline_state = FailedComputation;
      return Printed(pm);
    }
    g->inline_state = Computed(bas);
    return NoFail;
  case &BeganComputing:
    g->inline_state = FailedComputation;
    return ERR(_u8("Recursively inlining function "), lookup(cs->im, g->graph.gr.informal_name));
  case &FailedComputation:
    return ERR(_u8("basic_inline_inlinables already failed for "), lookup(cs->im, g->graph.gr.informal_name));
  case &Computed(x basic_analyze_state):
    return NoFail;
  }
}

func help_basic_inline_inlinables(cs *checkstate, bas *basic_analyze_state, g *graphed_fn_body) np {
  gr *frame_graph = &g->graph.gr;
  // nparamlists is _not_ constant.
  nparamlists size = count(&bas->paramlists);
  new_paramlists array[gr_num];
  for i size = 0; i < nparamlists; i = i + 1 {
    gn gr_num = get(&bas->paramlists, i);
    // (We avoid retaining references into arrays that we'll modify -- so we copy out the node.)
    if case XOp(xn gr_xnode) = *ref_node(gr, gn) {
      if case &GrApply(a gr_apply) = &xn.op {
        // TODO: Remove vestigial funcell (if nothing ever reads it) after inlining.  (Somehow.)
        if case Has(fnid fn_body_id) = is_const_funcell(cs, bas, a.funcell) {
          ent *fn_body_entry = ref_fn_body(cs, fnid);
          switch &ent->u {
          case &GraphedFnBody(eg graphed_fn_body):
            switch eg.inline {
            case InlineMust:
              if case Printed(pm) = basic_and_inline(cs, &eg) {
                return Printed(pm);
              }
              nparams size = count(&a.params);
              check(count(&eg.argcells) == nparams);
              // Okay, we're inlining.
              nec size = count(&eg.graph.gr.cells);
              cell_mapping array[cell_num];
              reserve(&cell_mapping, nec);
              for j size = 0; j < nec; j = j + 1 {
                mapped cell_num;
                if case Has(k size) = find(&eg.argcells, ~j) {
                  // TODO: Assert that the cell types in g and eg are equal?  The sizes?
                  mapped = get(&a.params, k);
                } else if eg.graph.cell == ~j {
                  // TODO: Assert that the cell types in g and eg are equal?  The sizes?
                  mapped = a.retcell;
                } else {
                  egi *cell_info = ref(&eg.graph.gr.cells, j);
                  mapped = add_cell(gr, {egi->location, egi->type, egi->props});
                }
                push(&cell_mapping, mapped);
              }

              op_addend size = count(&gr->ops);

              neo size = count(&eg.graph.gr.ops);
              for j size = 0; j < neo; j = j + 1 {
                push(&gr->ops, adjust_op_for_inline(op_addend, &cell_mapping, get(&eg.graph.gr.ops, j)));
              }

              base_op_adjusted gr_num = ~(eg.graph.gn.x + op_addend);

              // Now we overwrite the apply op.
              // A GrApply always needs the return cell to be live before it's called.  So we add GrAssertLive to verify that's the case.
              precs_op gr_num = help_add_node(gr, @[gr_node]XOp({xn.precs, @[gr_xop]GrDead({a.funcell})}));
              seqer sq_num = seqq(gr, {precs_op,
                                       seqq(gr, {addx(gr, @[gr_xop]GrAssertLive({a.retcell})),
                                                 seqq(gr, {base_op_adjusted,
                                                           nopq(gr)})})});


              // It's important to note that GrXNop would be ignored by help_basic_analyze.
              // TODO: It'd be nice if we could undo the mark_cell_not_const of a.retcell (that happened when we processed GrApply in help_basic_analyze before).

              *ref(&gr->ops, gn.x) = XOp({mk_shray(seqer.x), GrXNop});

              // And since there's no apply op, we update the arg/funcell cell_disps.
              // Actually, we don't update the funcell disp, so that we don't allocate/write its cell needlessly.
              // unSet(&ref(&bas->celldisp, a.funcell.x)->funcell);
              for j size = 0; j < nparams; j = j + 1 {
                unSet(&ref(&bas->celldisp, get(&a.params, j).x)->paramlist);
              }

              help_basic_analyze(cs, bas, gr);
              nparamlists = count(&bas->paramlists);
            case InlineYawn:
              push(&new_paramlists, gn);
            }
          default:
            push(&new_paramlists, gn);
          }
        } else {
          push(&new_paramlists, gn);
        }
      } else {
        ice(_u8("basic_inline_inlinables impossible xnode type"));
      }
    } else {
      ice(_u8("basic_inline_inlinables impossible node type"));
    }
  }
  swap(&bas->paramlists, &new_paramlists);
  return NoFail;
}

func adjust_op_for_inline(op_addend size, cm *array[cell_num], node gr_node) gr_node {
  switch node {
  case XOp(xn gr_xnode):
    build array[gr_num];
    nprecs size = count(&xn.precs);
    for i size = 0; i < nprecs; i = i + 1 {
      push(&build, ~(get(&xn.precs, i).x + op_addend));
    }
    newprecs shray[gr_num] = freeze(&build);
    switch &xn.op {
    case &GrApply(a gr_apply):
      return XOp({newprecs, GrApply({get(cm, a.funcell.x), help_adjust_params(cm, &a.params), get(cm, a.retcell.x)})});
    case &GrPrimApply(a gr_prim_apply):
      return XOp({newprecs, GrPrimApply({a.primop, help_adjust_params(cm, &a.params), get(cm, a.retcell.x)})});
    case &GrMemCopy(a gr_memcopy):
      return XOp({newprecs, GrMemCopy({get(cm, a.dest.x), get(cm, a.src.x)})});
    case &GrWriteConst(a gr_writeconst):
      return XOp({newprecs, GrWriteConst({get(cm, a.dest.x), a.value})});
    case &GrAddressof(a gr_addressof):
      return XOp({newprecs, GrAddressof({get(cm, a.dest.x), get(cm, a.addressee.x)})});
    case &GrDeref(a gr_deref):
      return XOp({newprecs, GrDeref({get(cm, a.name.x), get(cm, a.pointer.x), help_adjust_offset(cm, &a.offset)})});
    case &GrSubcell(a gr_subcell):
      return XOp({newprecs, GrSubcell({get(cm, a.name.x), get(cm, a.partof.x), help_adjust_offset(cm, &a.offset)})});
    case &GrLive(a gr_live):
      return XOp({newprecs, GrLive({get(cm, a.cell.x)})});
    case &GrAssertLive(a gr_assert_live):
      return XOp({newprecs, GrAssertLive({get(cm, a.cell.x)})});
    case &GrDead(a gr_dead):
      return XOp({newprecs, GrDead({get(cm, a.cell.x)})});
    case &GrVirtualDead(a gr_virtual_dead):
      return XOp({newprecs, GrVirtualDead({get(cm, a.cell.x)})});
    case &GrXNop:
      return XOp({newprecs, GrXNop});
    }
  case QOp(qn gr_qnode):
    switch &qn.op {
    case &GrBranch(a gr_branch):
      newcases array[tup[gr_const, sq_num]];
      ncases size = count(&a.cases);
      for i size = 0; i < ncases; i = i + 1 {
        cas *tup[gr_const, sq_num] = ref(&a.cases, i);
        push(&newcases, {cas->car, ~ ~(cas->cdr.x.x + op_addend)});
      }
      defaultcase opt[sq_num];
      if case Has(sn sq_num) = a.default_case {
        defaultcase = Has(~ @[gr_num]~(sn.x.x + op_addend));
      } else {
        defaultcase = None;
      }
      return QOp({GrBranch({get(cm, a.src.x), freeze(&newcases), defaultcase})});
    case &GrSequence(a gr_sequence):
      return QOp({GrSequence({~(a.first.x + op_addend), ~ ~(a.second.x.x + op_addend)})});
    case &GrJmp(a gr_jmp):
      return QOp({GrJmp({~ ~(a.next.x.x + op_addend)})});
    case &GrQNop:
      return QOp({GrQNop});
    }
  }
}

func help_adjust_params(cm *array[cell_num], params *shray[cell_num]) shray[cell_num] {
  ret array[cell_num];
  n size = count(params);
  for i size = 0; i < n; i = i + 1 {
    push(&ret, get(cm, get(params, i).x));
  }
  return freeze(&ret);
}

func help_adjust_offset(cm *array[cell_num], off *gr_offset) gr_offset {
  switch off {
  case &OffsetConst(x u32):
    return OffsetConst(x);
  case &OffsetComputed(p tup[u32, cell_num]):
    return OffsetComputed({p.car, get(cm, p.cdr.x)});
  }
}
