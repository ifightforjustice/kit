import ast;
import deferred;
import expr;
import kitutil;
import parse;
import tok;
import typeexpr;
import shp;
import state;
import u8ast;

// This code does some typechecking.  See state.ki for types that maintain typechecking state.

/*
func[T] dbgcheck(x T) void { DBG(x); }
func[T, U] dbgcheck(x T, y U) void { DBG(x, y); }
func[T, U, V] dbgcheck(x T, y U, z V) void { DBG(x, y, z); }
*/
func[T] dbgcheck(x T) void { }
func[T, U] dbgcheck(x T, y U) void { }
func[T, U, V] dbgcheck(x T, y U, z V) void { }

func finish_checking(cs *checkstate, clq *clqueue) bool {
  while case Has(entry clqueue_entry) = popval(&clq->entries) {
    switch &entry {
      case &ClqDeftypeEntry(e clqueue_deftype_entry): {
        if !ensure_deftype_inst_checked(cs, clq, ref_deftype_entry(cs, e.ent_id), e.inst_id) {
          return false;
        }
      }
    }
  }
  return true;
}

func check_module(cs *checkstate, mod_name sym) bool {
  dbgcheck(_u8("check_module"));
  switch process_module(cs, mod_name) {
    case None(v): {
      dbgcheck(_u8("process_module None"));
      return false;
    }
    case Has(id module_id): {
      dbgcheck(_u8("process_module Has"));
      mod *module = ref_module(cs, id);

      naccess_blocks size = count(&mod->access_blocks);
      for i size = 0; i < naccess_blocks; i = i + 1 {
        dti deftype_entry_id;
        if !get_accessible_deftype(cs, get(&mod->access_blocks, i), &dti) {
          return false;
        }
      }

      ndefs size = count(&mod->defs);
      for i size = 0; i < ndefs; i = i + 1 {
        if !ensure_def_checked(cs, get(&mod->defs, i)) {
          dbgcheck(_u8("ensure_def_checked failed"));
          return false;
        }
      }

      ndeftypes size = count(&mod->deftypes);
      for i size = 0; i < ndeftypes; i = i + 1 {
        if !ensure_deftype_checked(cs, get(&mod->deftypes, i)) {
          dbgcheck(_u8("ensure_deftype_checked failed"));
          return false;
        }
      }

      // I guess that's everything.
      return true;
    }
  }
}

func find_matching_inst(cs *checkstate, insts *array[def_inst_id], parms *genparms) opt[def_inst_id] {
  n size = count(insts);
  for i size = 0; i < n; i = i + 1 {
    id def_inst_id = get(insts, i);
    inst *def_inst = ref_inst(cs, id);
    if parms_equal(cs, parms, &inst->parms) {
      return Has(id);
    }
  }
  return None();
}

func parms_equal(cs *checkstate, a *genparms, b *genparms) bool {
  if enumnum(a) != enumnum(b) {
    return false;
  }
  switch a {
    case &NoParms(v void): { return true; }
    case &HasParms(ah array[te_typeexpr]): {
      switch b {
        case &HasParms(bh array[te_typeexpr]): {
          return typeexpr_list_equal(cs, &ah, &bh);
        }
      }
    }
  }
}

func arity(parms *genparms) generics_arity {
  switch parms {
    case &NoParms(v void): { return NoParamsArity(void); }
    case &HasParms(arr array[te_typeexpr]): { return FiniteArity(~count(&arr)); }
  }
}

func convert_typefunc(cs *checkstate, a *ast_typeexpr, out *te_puretype) bool {
  switch a {
    case &Name(b ast_ident): {
      *out = TePureName(b.value);
      return true;
    }
    case &Unknown(b ast_unknown): {
      *out = TePureUnknown(void);
      return true;
    }
    default: {
      ERR(_u8("Fancy type expression '"), to_u8str(a), _u8("' in typefunc"));
      return false;
    }
  }
}

func convert_typeexpr_list(cs *checkstate, arr *array[ast_typeexpr], out *array[te_typeexpr]) bool {
  build array[te_typeexpr];
  n size = count(arr);
  for i size = 0; i < n; i = i + 1 {
    t te_typeexpr;
    if !convert_typeexpr(cs, ref(arr, i), &t) {
      return false;
    }
    push(&build, t);
  }
  *out = build;
  return true;
}

func convert_vardecl_list(cs *checkstate, arr *array[ast_vardecl], out *array[te_vardecl]) bool {
  build array[te_vardecl];
  n size = count(arr);
  for i size = 0; i < n; i = i + 1 {
    vd te_vardecl;
    if !convert_vardecl(cs, ref(arr, i), &vd) {
      return false;
    }
    push(&build, vd);
  }
  *out = build;
  return true;
}

func convert_vardecl(cs *checkstate, a *ast_vardecl, out *te_vardecl) bool {
  type te_typeexpr;
  if !convert_typeexpr(cs, &a->type, &type) {
    return false;
  }
  *out = {a->name.value, type};
  return true;
}

// TODO: Callers of this might expect this function to also lookup names, check arity, etc.  Or they need to do such things themselves.
func convert_typeexpr(cs *checkstate, a *ast_typeexpr, out *te_typeexpr) bool {
  switch a {
    case &Name(b ast_ident): {
      *out = TeName({b.value, None()});
      return true;
    }
    case &App(b ast_typeapp): {
      typefunc te_puretype;
      params array[te_typeexpr];
      if !(convert_typefunc(cs, oo(&b.typefunc), &typefunc)
           && convert_typeexpr_list(cs, &b.params, &params)) {
        return false;
      }
      *out = TeApp({embox(typefunc), params, None()});
      return true;
    }
    case &Struct(b ast_struct): {
      fields array[te_vardecl];
      if !convert_vardecl_list(cs, &b.fields, &fields) {
        return false;
      }
      *out = TeStruct({fields});
      return true;
    }
    case &Enum(b ast_enum): {
      constructors array[te_vardecl];
      if !convert_vardecl_list(cs, &b.constructors, &constructors) {
        return false;
      }
      *out = TeEnum({constructors});
      return true;
    }
    case &Union(b ast_union): {
      fields array[te_vardecl];
      if !convert_vardecl_list(cs, &b.fields, &fields) {
        return false;
      }
      *out = TeUnion({fields});
      return true;
    }
    case &Arraytype(b ast_arraytype): {
      count opt[u32];
      if case &Has(bo box[ast_expr]) = &b.count {
        num u32;
        if !fake_eval_arraytype_count(oo(&bo), &num) {
          return false;
        }
        count = Has(num);
      } else {
        count = None();
      }
      param box[te_typeexpr];
      if !convert_typeexpr(cs, oo(&b.param), oo(&param)) {
        return false;
      }
      *out = TeArraytype({count, param});
      return true;
    }
    case &Unknown(b ast_unknown): {
      *out = TeUnknown(void);
      return true;
    }
  }
}

func def_converted_typeexpr(cs *checkstate, ent *def_entry, out **te_typeexpr) bool {
  switch &ent->converted_typeexpr {
    case &NotComputed(v void): {
      ent->converted_typeexpr = BeganComputing();
      converted te_typeexpr;
      if !convert_typeexpr(cs, &ent->quick_typeexpr, &converted) {
        ent->converted_typeexpr = FailedComputation();
        return false;
      }
      ent->converted_typeexpr = Computed(converted);
      if case &Computed(te te_typeexpr) = &ent->converted_typeexpr {
        *out = &te;
      } else {
        crash(_u8("impossible converted_typeexpr"));
      }
      return true;
    }
    case &BeganComputing(v void): {
      ERR(_u8("recursively computing def's typeexpr"));
      return false;
    }
    case &FailedComputation(v void): {
      ERR(_u8("repeat of error in def_converted_typeexpr"));
      return false;
    }
    case &Computed(x te_typeexpr): {
      *out = &x;
      return true;
    }
  }
}

func deftype_converted_rhs(cs *checkstate, ent *deftype_entry, out **te_typeexpr) bool {
  if case &Has(np) = &ent->nonprim {
    switch &np.rhs {
      case &NotComputed(v void): {
        np.rhs = BeganComputing();
        a *ast_typeexpr = deftype_rhs_type(&np.tl->rhs);
        converted te_typeexpr;
        if !convert_typeexpr(cs, a, &converted) {
          np.rhs = FailedComputation();
          return false;
        }
        np.rhs = Computed(converted);
        if case &Computed(te te_typeexpr) = &np.rhs {
          *out = &te;
        } else {
          crash(_u8("impossible rhs"));
        }
        return true;
      }
      case &BeganComputing(v void): {
        ERR(_u8("recursively computing deftype's rhs"));
        return false;
      }
      case &FailedComputation(v void): {
        ERR(_u8("repeat of error in deftype_converted_rhs"));
        return false;
      }
      case &Computed(x te_typeexpr): {
        *out = &x;
        return true;
      }
    }
  } else {
    // TODO: Probably this function should take a non-prim deftype.
    ice(_u8("Calling deftype_converted_rhs on non-prim deftype."));
    return fake();
  }
}

func enqueue_def_inst_compute_type(cs *checkstate, clq *clqueue, id def_entry_id, parms *genparms, computed_type_out **te_typeexpr, computed_type_properties_out **type_properties, inst_id_out *def_inst_id) bool {
  inst_id def_inst_id = enqueue_def_inst(cs, clq, id, parms);
  if !ensure_def_inst_type_computed(cs, clq, ref_def_entry(cs, id), inst_id) {
    return false;
  }
  inst *def_inst = ref_inst(cs, inst_id);
  *computed_type_out = &inst->computed_type;
  *computed_type_properties_out = &inst->computed_type_properties;
  *inst_id_out = inst_id;
  return true;
}

func enqueue_def_inst(cs *checkstate, clq *clqueue, id def_entry_id, parms *genparms) def_inst_id {
  var res = ensure_def_inst(cs, ref_def_entry(cs, id), parms);
  if res.created {
    push(&clq->entries, ClqDefEntry({id, res.id}));
  }
  return res.id;
}

// rhs is "None()" for extern defs.
func ensure_def_inst(cs *checkstate, ent *def_entry, parms *genparms) struct { id def_inst_id; created bool; } {
  check(arity(&ent->generics) == arity(parms));
  if case Has(id) = find_matching_inst(cs, &ent->insts, parms) {
    return {id, false};
  }
  rhs opt[ast_expr];
  switch ent->tl {
    case &Def(a ast_def): { rhs = Has(a.rhs); }
    case &ExternDef(a ast_extern_def): { rhs = None(); }
    default: {
      ice(_u8("def_entry has invalid toplevel\n"));
    }
  }
  var id = add_inst(cs, mk(*parms, rhs));
  push(&ent->insts, id);
  return {id, true};
}

func ensure_def_checked_with_parms(cs *checkstate, clq *clqueue, ent *def_entry, parms *genparms) bool {
  dbgcheck(_u8("ensure_def_checked_with_parms"));
  var res = ensure_def_inst(cs, ent, parms);
  return ensure_def_inst_checked(cs, clq, ent, res.id);
}

func ensure_def_inst_type_computed(cs *checkstate, clq *clqueue, ent *def_entry, inst_id def_inst_id) bool {
  dbgcheck(_u8("ensure_def_inst_type_computed"));
  inst *def_inst = ref_inst(cs, inst_id);
  switch inst->status {
    case DidNotStartComputingType(v): {
      dbgcheck(_u8("ensure_def_inst_type_computed DidNotStartComputingType"));
      inst->status = BeganComputingType(void);

      ent_typeexpr *te_typeexpr;
      if !def_converted_typeexpr(cs, ent, &ent_typeexpr) {
        dbgcheck(_u8("def_converted_typeexpr failed"));
        return false;
      }
      // TODO: We need to check exact name shadowing(?), typeexpr, and rhs.

      // Important:  We check the typeexpr first.  If that typeexpr cyclically refers to this def, we fail.  If there is no typeexpr, we need to compute it from the rhs (and that also needs to not depend cyclically on this def's own typeexpr).
      computed_complete bool;
      computed te_typeexpr;
      if !check_and_compute_typeexpr(cs, clq, &ent->generics, &inst->parms, ent_typeexpr, &computed, &computed_complete) {
        dbgcheck(_u8("check_and_compute_typeexpr failed"));
        return false;
      }
      check(computed_complete);
      props type_properties;
      if !compute_type_properties(cs, clq, &computed, &props) {
        dbgcheck(_u8("compute_type_properties failed"));
        return false;
      }
      inst->status = FinishedComputingType(void);
      inst->computed_type = computed;
      inst->computed_type_properties = props;
      return true;
    }
    case BeganComputingType(v): {
      ERR(_u8("computing def's type arouses cyclic dependency"), lookup(cs->im, ent->def_name));
      return false;
    }
    case FinishedComputingType(v): {
      return true;
    }
    case BeganCheckingRhs(v): {
      return true;
    }
    case FinishedCheckingRhs(v): {
      return true;
    }
  }
}

func ensure_def_inst_checked(cs *checkstate, clq *clqueue, ent *def_entry, inst_id def_inst_id) bool {
  dbgcheck(_u8("ensure_def_inst_checked"));
  if !ensure_def_inst_type_computed(cs, clq, ent, inst_id) {
    dbgcheck(_u8("ensure_def_inst_type_computed failed"));
    return false;
  }
  inst *def_inst = ref_inst(cs, inst_id);
  switch inst->status {
    case DidNotStartComputingType(v): {
      ice(_u8("unexpected DidNotStartComputingType status"));
      return fake();
    }
    case BeganComputingType(v): {
      ice(_u8("unexpected BeganComputingType status"));
      return fake();
    }
    case FinishedComputingType(v): {
      inst->status = BeganCheckingRhs(void);
      if case &Has(rhs ast_expr) = &inst->rhs {
        // TODO: How do we know that ent->generics doesn't shadow, doesn't self-shadow?
        if !check_expr(cs, clq, ent->accessible, &ent->generics, &inst->parms, &rhs, &inst->computed_type) {
          return false;
        }
      }
      inst->status = FinishedCheckingRhs(void);
      return true;
    }
    case BeganCheckingRhs(v): {
      return true;
    }
    case FinishedCheckingRhs(v): {
      return true;
    }
  }
}

func check_and_compute_typeexpr(cs *checkstate, clq *clqueue, g *ast_generics, parms *genparms, t *te_typeexpr, computed_out *te_typeexpr, computed_complete_out *bool) bool {
  dbgcheck(_u8("check_and_compute_typeexpr"));
  switch t {
    case &TeName(a te_name): {
      if !check_and_compute_name_type(cs, clq, g, parms, &a, computed_out) {
        dbgcheck(_u8("check_and_compute_name_type failed"));
        return false;
      }
      *computed_complete_out = true;
      return true;
    }
    case &TeApp(a te_typeapp): {
      return check_and_compute_app_type(cs, clq, g, parms, &a, computed_out, computed_complete_out);
    }
    case &TeStruct(a te_struct): {
      computed_fields_complete bool;
      computed_fields array[te_vardecl];
      if !help_check_fields(cs, clq, g, parms, &a.fields, &computed_fields, &computed_fields_complete) {
        return false;
      }
      *computed_out = TeStruct({computed_fields});
      *computed_complete_out = computed_fields_complete;
      return true;
    }
    case &TeEnum(a te_enum): {
      // TODO: For enums, field names are constructors.  Check shadowing?
      computed_constructors_complete bool;
      computed_constructors array[te_vardecl];
      if !help_check_fields(cs, clq, g, parms, &a.constructors, &computed_constructors, &computed_constructors_complete) {
        return false;
      }
      *computed_out = TeEnum({computed_constructors});
      *computed_complete_out = computed_constructors_complete;
      return true;
    }
    case &TeUnion(a te_union): {
      computed_fields_complete bool;
      computed_fields array[te_vardecl];
      if !help_check_fields(cs, clq, g, parms, &a.fields, &computed_fields, &computed_fields_complete) {
        return false;
      }
      *computed_out = TeUnion({computed_fields});
      *computed_complete_out = computed_fields_complete;
      return true;
    }
    case &TeArraytype(a te_arraytype): {
      param box[te_typeexpr];
      param_complete bool;
      if !check_and_compute_typeexpr(cs, clq, g, parms, oo(&a.param), oo(&param), &param_complete) {
        return false;
      }
      if case &Has(count u32) = &a.count {
        *computed_out = TeArraytype({Has(count), param});
        *computed_complete_out = param_complete;
        return true;
      } else {
        *computed_out = TeArraytype({None(), param});
        *computed_complete_out = false;
        return true;
      }
    }
    case &TeUnknown(v void): {
      *computed_out = TeUnknown(void);
      *computed_complete_out = false;
      return true;
    }
  }
}

func numeric_literal_to_u32(x *ast_numeric_literal, out *u32) bool {
  switch x {
    case &HexLiteral(a ast_hex_literal): {
      return convert_to_u32(16, &a.digits, out);
    }
    case &DecLiteral(a ast_dec_literal): {
      return convert_to_u32(10, &a.digits, out);
    }
  }
}

func convert_to_u32(base i8, digits *array[i8], out *u32) bool {
  check(base > 0);
  acc u32 = 0;
  n size = count(digits);
  for i size = 0; i < n; i = i + 1 {
    if !try_mul(acc, @[u32]~base, &acc) {
      return false;
    }
    if !try_add(acc, @[u32]~get(digits, i), &acc) {
      return false;
    }
  }
  *out = acc;
  return true;
}

func fake_eval_arraytype_count(x *ast_expr, count_out *u32) bool {
  // TODO: Remove this function and really evaluate an array's count expression.
  switch &x->u {
    case &NumericLiteral(a ast_numeric_literal): {
      return numeric_literal_to_u32(&a, count_out);
    }
    default: {
      ERR(_u8("Array types (for now) must have a numeric literal for length (or _)."));
      return false;
    }
  }
}

func help_check_fields(cs *checkstate, clq *clqueue, g *ast_generics, parms *genparms, a *array[te_vardecl], computed_fields_out *array[te_vardecl], computed_fields_complete_out *bool) bool {
  n size = count(a);
  all_complete bool = true;
  all_computed array[te_vardecl];
  for i size = 0; i < n; i = i + 1 {
    decl *te_vardecl = ref(a, i);
    for j size = 0; j < i; j = j + 1 {
      if ref(a, j)->name == decl->name {
        ERR(_u8("Duplicate field name "), lookup(cs->im, decl->name));
        return false;
      }
    }
    complete bool;
    computed te_typeexpr;
    if !check_and_compute_typeexpr(cs, clq, g, parms, &decl->type, &computed, &complete) {
      return false;
    }
    all_complete = all_complete & complete;
    push(&all_computed, {decl->name, computed});
  }
  *computed_fields_out = all_computed;
  *computed_fields_complete_out = all_complete;
  return true;
}

func check_and_compute_name_type(cs *checkstate, clq *clqueue, g *ast_generics, parms *genparms, a *te_name, computed_out *te_typeexpr) bool {
  dbgcheck(_u8("check_and_compute_name_type"));
  // Generic parameters have already been checked.  (I hope so.)
  if lookup_generic(g, parms, a->value, computed_out) {
    return true;
  }

  matching_deftype opt[deftype_entry_id];
  if !match_deftype(cs, a->value, None(), &matching_deftype) {
    dbgcheck(_u8("match_deftype failed"));
    // An error happened when looking up a deftype (multiple matches?).
    return false;
  }

  if case Has(id) = matching_deftype {
    np genparms = NoParms(void);
    inst_id deftype_inst_id = enqueue_deftype_inst(cs, clq, id, &np);
    *computed_out = TeName({a->value, Has({id, inst_id})});
    return true;
  } else {
    ERR(_u8("type name has no match "), lookup(cs->im, a->value));
    return false;
  }
}

func check_and_compute_typeexpr_array(cs *checkstate, clq *clqueue, g *ast_generics, parms *genparms, t *array[te_typeexpr], computed_out *array[te_typeexpr], computed_complete_out *bool) bool {
  complete bool = true;
  computed array[te_typeexpr];
  n size = count(t);
  for i size = 0; i < n; i = i + 1 {
    c te_typeexpr;
    c_complete bool;
    if !check_and_compute_typeexpr(cs, clq, g, parms, ref(t, i), &c, &c_complete) {
      return false;
    }
    push(&computed, c);
    complete = complete & c_complete;
  }
  *computed_out = computed;
  *computed_complete_out = complete;
  return true;
}

func check_and_compute_app_type(cs *checkstate, clq *clqueue, g *ast_generics, parms *genparms, a *te_typeapp, computed_out *te_typeexpr, computed_complete_out *bool) bool {
  params_complete bool;
  params array[te_typeexpr];
  if !check_and_compute_typeexpr_array(cs, clq, g, parms, &a->params, &params, &params_complete) {
    return false;
  }

  switch oo(&a->typefunc) {
    case &TePureName(value sym): {
      matching_deftype opt[deftype_entry_id];
      if !match_deftype(cs, value, Has(&params), &matching_deftype) {
        return false;
      }

      if case Has(id) = matching_deftype {
        if params_complete {
          hp genparms = HasParms(params);
          inst_id deftype_inst_id = enqueue_deftype_inst(cs, clq, id, &hp);
          *computed_out = TeApp({embox(TePureName(value)), params, Has({id, inst_id})});
        } else {
          *computed_out = TeApp({embox(TePureName(value)), params, None()});
        }
        *computed_complete_out = params_complete;
        return true;
      } else {
        ERR(_u8("type name/params has no match "), lookup(cs->im, value));
        return false;
      }
    }
    case &TePureUnknown(v void): {
      *computed_out = TeApp({embox(TePureUnknown(void)), params, None()});
      *computed_complete_out = false;
      return true;
    }
  }
}

func arity_matches(a *ast_generics, params opt[*array[te_typeexpr]]) bool {
  ar generics_arity;
  if case Has(p) = params {
    ar = FiniteArity(~count(p));
  } else {
    ar = NoParamsArity(void);
  }
  lhs_arity generics_arity = arity(a);
  return lhs_arity == ar;
}

func ERR_no_match(im *identmap, name sym, params opt[*array[te_typeexpr]]) void {
  ERR(_u8("No match for type with name '"), lookup(im, name), _u8("' and maybe some params"));
}

// TODO: Why does out point to an opt?
func match_deftype(cs *checkstate, name sym, params opt[*array[te_typeexpr]], out *opt[deftype_entry_id]) bool {
  if case Has(arr *array[deftype_entry_id]) = lookup_ref(&cs->deftypes_by_name, name) {
    n size = count(arr);
    match opt[deftype_entry_id];
    for i size = 0; i < n; i = i + 1 {
      id deftype_entry_id = get(arr, i);
      ent *_ = ref_deftype_entry(cs, id);
      if arity_matches(&ent->generics, params) {
        if case Has(alt_id) = match {
          ERR(_u8("Multiple deftypes named '"), lookup(cs->im, name), _u8("' match arity"));
          return false;
        }
        match = Has(id);
      }
    }
    if case Has(id) = match {
      *out = match;
      return true;
    } else {
      ERR_no_match(cs->im, name, params);
      return false;
    }
  } else {
    ERR_no_match(cs->im, name, params);
    return false;
  }
}

func find_generic(g *ast_generics, name sym) opt[size] {
  switch g {
    case &NoGenerics(v void): { return None(); }
    case &HasGenerics(a array[ast_ident]): {
      n size = count(&a);
      for i size = 0; i < n; i = i + 1 {
        if ref(&a, i)->value == name {
          return Has(i);
        }
      }
      return None();
    }
  }
}

// TODO: Does anybody use this?
func lookup_generic(g *ast_generics, parms *genparms, name sym, out *te_typeexpr) bool {
  switch g {
    case &NoGenerics(v): { return false; }
    case &HasGenerics(a array[ast_ident]): {
      n size = count(&a);
      for i size = 0; i < n; i = i + 1 {
        if ref(&a, i)->value == name {
          if case &HasParms(ps) = parms {
            *out = *ref(&ps, i);
            return true;
          } else {
            crash(_u8("non-matching parms"));
          }
        }
      }
      return false;
    }
  }
}

func ensure_def_checked(cs *checkstate, id def_entry_id) bool {
  ent *def_entry = ref_def_entry(cs, id);
  switch &ent->generics {
    case &NoGenerics(v): {
      parms genparms = NoParms(void);
      clq clqueue;
      if !ensure_def_checked_with_parms(cs, &clq, ent, &parms) {
        return false;
      }
      return finish_checking(cs, &clq);
    }
    case &HasGenerics(ig): {
      discard *te_typeexpr;
      if !def_converted_typeexpr(cs, ent, &discard) {
        return false;
      }
      // We declare success -- we check non-generic defs.
      // TODO: Somewhere we have to check def generics shadowing.
      return true;
    }
  }
}

func find_matching_deftype_inst(cs *checkstate, insts *array[deftype_inst_id], parms *genparms) opt[deftype_inst_id] {
  n size = count(insts);
  for i size = 0; i < n; i = i + 1 {
    id deftype_inst_id = get(insts, i);
    inst *deftype_inst = ref_deftype_inst(cs, id);
    if parms_equal(cs, parms, &inst->parms) {
      return Has(id);
    }
  }
  return None();
}

func deftype_rhs_type(rhs *ast_type_def_rhs) *ast_typeexpr {
  switch rhs {
    case &TypeexprRhs(a): { return &a; }
    case &ClassexprRhs(a): { return &a.rhs_type; }
  }
}

func enqueue_deftype_inst(cs *checkstate, clq *clqueue, id deftype_entry_id, parms *genparms) deftype_inst_id {
  dbgcheck(_u8("enqueue_deftype_inst"));
  var res = ensure_deftype_inst(cs, ref_deftype_entry(cs, id), parms);
  if res.created {
    push(&clq->entries, ClqDeftypeEntry({id, res.id}));
  }
  return res.id;
}

func ensure_deftype_inst(cs *checkstate, ent *deftype_entry, parms *genparms) struct { id deftype_inst_id; created bool; } {
  check(arity(&ent->generics) == arity(parms));
  if case Has(id) = find_matching_deftype_inst(cs, &ent->insts, parms) {
    return {id, false};
  }
  inst deftype_inst;
  if case &Has(info deftype_inst_info) = &ent->default_info {
    inst = {*parms, FinishedChecking(void), Has(info)};
  } else {
    inst = {*parms, DidNotStartChecking(void), None()};
  }
  var id = add_deftype_inst(cs, inst);
  push(&ent->insts, id);
  return {id, true};
}

func compute_pack_properties(cs *checkstate, clq *clqueue, pack *te_instpack, out *type_properties) bool {
  if !ensure_deftype_inst_checked(cs, clq, ref_deftype_entry(cs, pack->ent_id), pack->inst_id) {
    return false;
  }
  inst *deftype_inst = ref_deftype_inst(cs, pack->inst_id);
  if case &Has(info deftype_inst_info) = &inst->info {
    *out = info.props;
    return true;
  } else {
    ice(_u8("ensure_deftype_inst_checked did not compute properties."));
    return fake();
  }
}

// t had better be complete.
func compute_type_properties(cs *checkstate, clq *clqueue, t *te_typeexpr, out *type_properties) bool {
  switch t {
    case &TeName(a te_name): {
      if case &Has(p te_instpack) = &a.pack {
        return compute_pack_properties(cs, clq, &p, out);
      } else {
        crash(_u8("compute_type_properties called on packless name type."));
        return fake();
      }
    }
    case &TeApp(a te_typeapp): {
      if case &Has(pack te_instpack) = &a.pack {
        return compute_pack_properties(cs, clq, &pack, out);
      } else {
        ice(_u8("compute_type_properties called on packless app type."));
        return fake();
      }
    }
    case &TeStruct(a te_struct): {
      offset u32 = 0;
      max_alignment u32 = 1;
      init_trivial bool = true;
      move_trivial bool = true;
      copy_trivial bool = true;
      destroy_trivial bool = true;
      n size = count(&a.fields);
      for i size = 0; i < n; i = i + 1 {
        props type_properties;
        if !compute_type_properties(cs, clq, &ref(&a.fields, i)->type, &props) {
          return false;
        }
        offset = ceil_aligned(offset, props.flat_alignment);
        offset = offset + props.flat_size;
        max_alignment = max(max_alignment, props.flat_alignment);
        init_trivial = init_trivial & isTrivial(props.init_behavior);
        move_trivial = move_trivial & isTrivial(props.move_behavior);
        copy_trivial = copy_trivial & isTrivial(props.copy_behavior);
        destroy_trivial = destroy_trivial & isTrivial(props.destroy_behavior);
      }
      check(offset % max_alignment == 0);
      *out = {offset, max_alignment, trivialOrNot(init_trivial),
              trivialOrNot(move_trivial), trivialOrNot(copy_trivial),
              trivialOrNot(destroy_trivial)};
      return true;
    }
    case &TeEnum(a te_enum): {
      // TODO: This is deeply married to implementation-specific behavior.
      tag_size u32 = 4;
      max_size u32 = tag_size;
      max_alignment u32 = tag_size;
      init_trivial bool = true;
      move_trivial bool = true;
      copy_trivial bool = true;
      destroy_trivial bool = true;
      n size = count(&a.constructors);
      for i size = 0; i < n; i = i + 1 {
        props type_properties;
        if !compute_type_properties(cs, clq, &ref(&a.constructors, i)->type, &props) {
          return false;
        }
        tagged_size u32 = ceil_aligned(tag_size, props.flat_alignment) + props.flat_size;
        max_size = max(max_size, tagged_size);
        max_alignment = max(max_alignment, props.flat_alignment);
        init_trivial = init_trivial & isTrivial(props.init_behavior);
        move_trivial = move_trivial & isTrivial(props.move_behavior);
        copy_trivial = copy_trivial & isTrivial(props.copy_behavior);
        destroy_trivial = destroy_trivial & isTrivial(props.destroy_behavior);
      }
      // See TeUnion for explanation of final_size.
      final_size u32 = ceil_aligned(max_size, max_alignment);
      *out = {final_size, max_alignment, trivialOrNot(init_trivial),
              trivialOrNot(move_trivial), trivialOrNot(copy_trivial),
              trivialOrNot(destroy_trivial)};
      return true;
    }
    case &TeUnion(a te_union): {
      // This is very similar to TeEnum, but TeEnum will change and this will not.
      max_size u32 = 0;
      max_alignment u32 = 1;
      n size = count(&a.fields);
      for i size = 0; i < n; i = i + 1 {
        props type_properties;
        if !compute_type_properties(cs, clq, &ref(&a.fields, i)->type, &props) {
          return false;
        }
        max_size = max(max_size, props.flat_size);
        max_alignment = max(max_alignment, props.flat_alignment);
        if !(isTrivial(props.init_behavior) && isTrivial(props.move_behavior) && isTrivial(props.copy_behavior) && isTrivial(props.destroy_behavior)) {
          ERR(_u8("union type has non-trivial field"));
          return false;
        }
      }
      // Consider the case where you have a union of {uint32_t, uint32_t, uint32_t} and {uint64_t}.  We have alignment 8, thus we need size 16.
      final_size u32 = ceil_aligned(max_size, max_alignment);
      *out = {final_size, max_alignment, DerivedMethodTrivial(void),
              DerivedMethodTrivial(void), DerivedMethodTrivial(void),
              DerivedMethodTrivial(void)};
      return true;
    }
    case &TeArraytype(a te_arraytype): {
      if case Has(c u32) = a.count {
        props type_properties;
        if !compute_type_properties(cs, clq, oo(&a.param), &props) {
          return false;
        }

        // We _should_ maintain alignment for a zero-element array because the pointer to such an array might hack in tag-bit logic.
        *out = {props.flat_size * c, props.flat_alignment,
                trivialOrNot(isTrivial(props.init_behavior)),
                trivialOrNot(isTrivial(props.move_behavior)),
                trivialOrNot(isTrivial(props.copy_behavior)),
                trivialOrNot(isTrivial(props.destroy_behavior))};
        return true;
      } else {
        ice(_u8("compute_type_properties called on incomplete arraytype."));
        return fake();
      }
    }
    case &TeUnknown(a void): {
      ice(_u8("compute_type_properties called on incomplete type."));
      return fake();
    }
  }
}

func lambda_declared_type(cym *common_syms, a *ast_lambda) ast_typeexpr {
  type_params array[ast_typeexpr];
  n size = count(&a->args);
  for i size = 0; i < n; i = i + 1 {
    push(&type_params, ref(&a->args, i)->type);
  }
  push(&type_params, a->return_type);
  // TODO: Something about the meta value and zero literal.
  return App({embox(Name({@[ast_meta]~0, cym->fnsym})), type_params});
}

func quick_typeexpr(cym *common_syms, a *ast_def, out *ast_typeexpr) bool {
  if case &Has(s ast_typeexpr) = &a->syntactic_typeexpr {
    *out = s;
    return true;
  } else {
    switch &a->rhs.u {
      case &Lambda(b ast_lambda): {
        *out = lambda_declared_type(cym, &b);
        return true;
      }
      default: {
        ERR(_u8("Def does not have immediately conceivable typeexpr."));
        return false;
      }
    }
  }
}

// TODO: Make this take a deftype_entry_id, it'd be cleaner.
func ensure_deftype_inst_checked(cs *checkstate, clq *clqueue, ent *deftype_entry, id deftype_inst_id) bool {
  dbgcheck(_u8("ensure_deftype_inst_checked for inst '"), id.~, _u8("'"));
  inst *deftype_inst = ref_deftype_inst(cs, id);

  switch inst->status {
    case DidNotStartChecking(v): {
      inst->status = StartedChecking(void);

      ent_rhs *te_typeexpr;
      if !deftype_converted_rhs(cs, ent, &ent_rhs) {
        return false;
      }

      rhs_computed te_typeexpr;
      rhs_complete bool;
      if !check_and_compute_typeexpr(cs, clq, &ent->generics, &inst->parms, ent_rhs, &rhs_computed, &rhs_complete) {
        inst->status = FailedChecking(void);
        return false;
      }
      check(rhs_complete);

      check(isNone(&inst->info));
      properties type_properties;
      if !compute_type_properties(cs, clq, &rhs_computed, &properties) {
        inst->status = FailedChecking(void);
        return false;
      }
      check(isNone(&inst->info));
      if case &Has(np deftype_nonprim) = &ent->nonprim {
        switch &np.tl->rhs {
          case &TypeexprRhs(a): {
            inst->info = Has({Has(rhs_computed), properties});
          }
          case &ClassexprRhs(a): {
            inst->info = Has({Has(rhs_computed), to_defclass_properties(properties)});
          }
        }
      } else {
        // TODO: Figure this shiz out.
        ice(_u8("Assigning inst properties on non-primitive deftype."));
      }
      inst->status = FinishedChecking(void);
      return true;
    }
    case StartedChecking(v): {
      ERR(_u8("deftype for '"), lookup(cs->im, ent->name), _u8("' recursively checking"));
      return false;
    }
    case FinishedChecking(v): {
      check(isHas(&inst->info));
      return true;
    }
    case FailedChecking(v): {
      ERR(_u8("deftype for '"), lookup(cs->im, ent->name), _u8("' already failed checking"));
      return false;
    }
  }
}

func ensure_deftype_checked(cs *checkstate, id deftype_entry_id) bool {
  ent *deftype_entry = ref_deftype_entry(cs, id);
  discard *te_typeexpr;
  if !deftype_converted_rhs(cs, ent, &discard) {
    return false;
  }
  if case &Has(np deftype_nonprim) = &ent->nonprim {
    switch &np.tl->generics {
      case &NoGenerics(v): {
        parms genparms = NoParms(void);
        clq clqueue;
        discard_id deftype_inst_id = enqueue_deftype_inst(cs, &clq, id, &parms);
        return finish_checking(cs, &clq);
      }
      case &HasGenerics(ig): {
        // We declare success -- we check non-generic defs.
        // TODO: Somewhere we have to check deftype generics shadowing.
        return true;
      }
    }
  } else {
    // Primitive types are pre-checked.
    return true;
  }
}

func load_module(cs *checkstate, mod_name sym) opt[module_id] {
  dbgcheck(_u8("load_module"));
  switch lookup(&cs->modules_by_name, mod_name) {
    case Has(id module_id): {
      dbgcheck(_u8("load_module lookup Has"));
      return Has(id);
    }
    case None(v): {
      dbgcheck(_u8("load_module lookup None"));
      switch (cs->loader)(cs, mod_name) {
        case None(v2): {
          dbgcheck(_u8("load_module loader None"));
          ERR(_u8("Could not open file for module "), lookup(cs->im, mod_name));
          return None();
        }
        case Has(arr array[u8]): {
          dbgcheck(_u8("load_module loader Has"));
          mod shp[module];
          oo(&mod)->process_state = Unprocessed(void);
          oo(&mod)->module_name = mod_name;
          oo(&mod)->buf = arr;
          p ps = make_ps(cs->im, data(&oo(&mod)->buf), count(&oo(&mod)->buf));
          if !parse_file(&p, &oo(&mod)->file) {
            ERR(_u8("Trouble parsing module "), lookup(cs->im, mod_name));
            return None();
          }
          mod_id module_id = ~count(&cs->modules);
          push(&cs->modules, mod);
          if !try_insert(&cs->modules_by_name, mod_name, mod_id) {
            ERR(_u8("ICE: modules_by_name already has name "), lookup(cs->im, mod_name));
            return None();
          }
          return Has(mod_id);
        }
      }
    }
  }
}

func process_module(cs *checkstate, mod_name sym) opt[module_id] {
  dbgcheck(_u8("process_module"));
  switch load_module(cs, mod_name) {
    case None(v): {
      dbgcheck(_u8("load_module None"));
      return None();
    }
    case Has(id module_id): {
      dbgcheck(_u8("load_module Has"));
      mod *module = ref_module(cs, id);
      if mod->process_state == Unprocessed(void) {
         if !process_module_toplevels(cs, mod) {
           return None();
         }
      }
      return Has(id);
    }
  }
}

func process_module_toplevels(cs *checkstate, mod *module) bool {
  check_mutate(&mod->process_state, Unprocessed(void), Processing(void));
  // We start the module outside of any access blocks, so the scope is empty, of course.
  access_scope array[access_entry_id];
  if !process_toplevels(cs, access_scope, mod, &mod->file.toplevels) {
    return false;
  }
  check_mutate(&mod->process_state, Processing(void), DoneProcessing(void));
  return true;
}

func add_def_entry(cs *checkstate,
                   module_name sym,
                   module_defs *array[def_entry_id],
                   ent shp[def_entry]) void {
  id def_entry_id = ~count(&cs->defs);
  push(&cs->defs, ent);
  arr *array[def_entry_id] = try_insert_lookup(
    &cs->defs_by_name, oo(ent)->def_name, default());
  push(arr, id);
  push(module_defs, id);
}

func process_toplevels(cs *checkstate,
                       access_scope array[access_entry_id],
                       mod *module,
                       toplevels *array[ast_toplevel]) bool {
  for i size = 0; i < count(toplevels); i = i + 1 {
    toplevel *ast_toplevel = ref(toplevels, i);
    switch toplevel {
      case &Import(a ast_import): {
        switch process_module(cs, a.name.value) {
          case None(v): {
            return false;
          }
          case Has(id module_id): {
            // Do nothing!  We've processed the module successfully.
          }
        }
      }
      case &Def(a ast_def): {
        quick_te ast_typeexpr;
        if !quick_typeexpr(&cs->cym, &a, &quick_te) {
          return false;
        }
        ent shp[def_entry] = emshp(mk(mod->module_name, a.name.value, access_scope, a.generics, quick_te, toplevel));
        add_def_entry(cs, mod->module_name, &mod->defs, ent);
      }
      case &ExternDef(a ast_extern_def): {
        ent shp[def_entry] = emshp(mk(mod->module_name, a.name.value, access_scope, NoGenerics(void), a.type, toplevel));
        add_def_entry(cs, mod->module_name, &mod->defs, ent);
      }
      case &TypeDef(a ast_type_def): {
        id deftype_entry_id = add_deftype_entry(cs, mk(mod->module_name, a.name.value, access_scope, is_public(&a.rhs), a.generics, &a));
        push(&mod->deftypes, id);
      }
      case &Access(a ast_access): {
        access_id access_entry_id = add_access_entry(cs, mk(a.name.value, a.arity));
        push(&mod->access_blocks, access_id);
        push(&access_scope, access_id);
        if !process_toplevels(cs, access_scope, mod, &a.toplevels) {
          return false;
        }
        pop(&access_scope);
      }
    }
  }
  return true;
}

func is_public(a *ast_type_def_rhs) rhs_accessibility {
  switch a {
    case &TypeexprRhs(b ast_typeexpr): { return RhsPublic(void); }
    case &ClassexprRhs(b): { return RhsPrivate(void); }
  }
}

func get_accessible_deftype(cs *checkstate, aid access_entry_id, out *deftype_entry_id) bool {
  ent *access_entry = ref_access_entry(cs, aid);
  switch ent->ent_id {
    case NotComputed(v void): {
      ent->ent_id = BeganComputing();
      switch ent->arity {
        case NoParamsArity(u void): {
          match opt[deftype_entry_id];
          if !match_deftype(cs, ent->name, None(), &match) {
            ent->ent_id = FailedComputation();
            return false;
          }
          if case Has(id) = match {
            *out = id;
            ent->ent_id = Computed(id);
            return true;
          } else {
            ERR(_u8("Access block matches nothing"));
            ent->ent_id = FailedComputation();
            return false;
          }
        }
        case FiniteArity(n u32): {
          params array[te_typeexpr] = repeat(TeUnknown(void), ~n);
          match opt[deftype_entry_id];
          if !match_deftype(cs, ent->name, Has(&params), &match) {
            ent->ent_id = FailedComputation();
            return false;
          }
          if case Has(id) = match {
            *out = id;
            ent->ent_id = Computed(id);
            return true;
          } else {
            ERR(_u8("Access block matches nothing"));
            ent->ent_id = FailedComputation();
            return false;
          }
        }
      }
    }
    case BeganComputing(v void): {
      ERR(_u8("Recursively computing access block reference"));
      return false;
    }
    case FailedComputation(v void): {
      ERR(_u8("Repeated get_accessible_deftype error"));
      return false;
    }
    case Computed(x deftype_entry_id): {
      *out = x;
      return true;
    }
  }
}

defenum match_def_res {
  NoMatch void;
  MultiMatch void;
  // TODO: We'll want to include any simplification of the instantiated parms, or other type information, that we can get.
  OneMatch struct { ent def_entry_id; parms genparms; };
};

// Note that gp could be incomplete.
func match_def(cs *checkstate, name sym, gp *genparms, pt *te_typeexpr,
               res_out *match_def_res) bool {
  // TODO: What about defenum constructors?
  if case Has(arr *array[def_entry_id]) = lookup_ref(&cs->defs_by_name, name) {
    n size = count(arr);
    matches array[struct { ent def_entry_id; parms genparms; }];
    for i size = 0; i < n; i = i + 1 {
      id def_entry_id = get(arr, i);
      ent *def_entry = ref_def_entry(cs, id);
      ent_typeexpr *te_typeexpr;
      if !def_converted_typeexpr(cs, ent, &ent_typeexpr) {
        return false;
      }
      match_result entry_matches_res;
      if !entry_matches(cs, pt, &ent->generics, gp, ent_typeexpr, &match_result) {
        return false;
      }
      switch match_result {
        case EntryDoesNotMatch(v void): {
          // Do nothing.
        }
        case EntryMatchesAmbigously(v void): {
          // TODO: We could see if we have _one_ ambiguously matching entry, and extract any type information that we learned, to help the next match attempt (see check_expr and its allow_ambiguous parameter).  (Maybe we should, but maybe we shouldn't to keep the type checking algorithm simple and describable.)
          // Certainly the error message (somewhere) could be improved.
          *res_out = MultiMatch(void);
          return true;
        }
        case EntryMatchesPrecisely(complete_parms genparms): {
          push(&matches, {id, complete_parms});
        }
      }
    }
    num_matches size = count(&matches);
    if num_matches == 0 {
      *res_out = NoMatch(void);
      return true;
    } else if num_matches == 1 {
      *res_out = OneMatch(get(&matches, 0));
      return true;
    } else {
      *res_out = MultiMatch(void);
      return true;
    }
  } else {
    *res_out = NoMatch(void);
    return true;
  }
}

defenum entry_matches_res {
  EntryDoesNotMatch void;
  EntryMatchesAmbigously void;
  EntryMatchesPrecisely genparms;
};

func from_type_matches_res(hasparms bool, x type_matches_res) entry_matches_res {
  switch x {
    case TypeDoesNotMatch(v void): {
      return EntryDoesNotMatch(void);
    }
    case TypeMatchesAmbiguously(a): {
      return EntryMatchesAmbigously(void);
    }
    case TypeMatchesPrecisely(a array[te_typeexpr]): {
      if hasparms {
        return EntryMatchesPrecisely(HasParms(a));
      } else {
        check(count(&a) == 0);
        return EntryMatchesPrecisely(NoParms(void));
      }
    }
  }
}

// TODO: This function always returns true.
func entry_matches(cs *checkstate, pt *te_typeexpr, generics *ast_generics, gp *genparms, typeexpr *te_typeexpr, matches_out *entry_matches_res) bool {
  switch generics {
    case &NoGenerics(v void): {
      switch gp {
        case &HasParms(parms array[te_typeexpr]): {
          *matches_out = EntryDoesNotMatch(void);
          return true;
        }
        case &NoParms(u void): {
          names array[ast_ident];
          parms array[te_typeexpr];
          *matches_out = from_type_matches_res(false, type_matches(pt, &names, &parms, typeexpr));
          return true;
        }
      }
    }
    case &HasGenerics(names array[ast_ident]): {
      switch gp {
        case &HasParms(parms array[te_typeexpr]): {
          if count(&parms) != count(&names) {
            *matches_out = EntryDoesNotMatch(void);
            return true;
          }
          *matches_out = from_type_matches_res(true, type_matches(pt, &names, &parms, typeexpr));
          return true;
        }
        case &NoParms(u void): {
          parms array[te_typeexpr] = repeat(count(&names), TeUnknown(void));
          *matches_out = from_type_matches_res(false, type_matches(pt, &names, &parms, typeexpr));
          return true;
        }
      }
    }
  }
}

defenum type_matches_res {
  TypeDoesNotMatch void;
  // Provides partial types of some generic names.
  TypeMatchesAmbiguously array[te_typeexpr];
  // Provides complete types of all generic names.
  TypeMatchesPrecisely array[te_typeexpr];
};

// t is complete, but it references the generic names in "names", whose corresponding values in "parms" could be incomplete.  pt is the partial type of an expression we're matching against this generic definition.  count(parms) == count(names).
func type_matches(pt *te_typeexpr, names *array[ast_ident], parms *array[te_typeexpr],
                  t *te_typeexpr) type_matches_res {
  check(count(names) == count(parms));
  // We need to retain all new information we gain about the value of the generic param typeexprs as we compare the whole type, in order to make sure we don't match conflicting information about a generic parameter.
  unif_parms array[te_typeexpr] = *parms;
  // Since t is complete, discard_unified is irrelevant and must be identical to t.
  unified te_typeexpr;
  if !unify_under_generics(pt, names, &unif_parms, t, &unified) {
    return TypeDoesNotMatch(void);
  }
  if all_complete(&unif_parms) {
    return TypeMatchesPrecisely(unif_parms);
  } else {
    return TypeMatchesAmbiguously(unif_parms);
  }
}

func all_complete(types *array[te_typeexpr]) bool {
  n size = count(types);
  for i size = 0; i < n; i = i + 1 {
    if !is_complete(ref(types, i)) {
      return false;
    }
  }
  return true;
}

func all_complete(decls *array[te_vardecl]) bool {
  n size = count(decls);
  for i size = 0; i < n; i = i + 1 {
    if !is_complete(&ref(decls, i)->type) {
      return false;
    }
  }
  return true;
}

func is_complete(t *te_typeexpr) bool {
  switch t {
    case &TeName(a te_name): { return true; }
    case &TeApp(a te_typeapp): {
      if case &TePureUnknown(v void) = oo(&a.typefunc) {
        return false;
      }
      return all_complete(&a.params);
    }
    case &TeStruct(a te_struct): { return all_complete(&a.fields); }
    case &TeEnum(a te_enum): { return all_complete(&a.constructors);    }
    case &TeUnion(a te_union): { return all_complete(&a.fields); }
    case &TeArraytype(a te_arraytype): {
      return isHas(&a.count) && is_complete(oo(&a.param));
    }
    case &TeUnknown(v void): {
      return false;
    }
  }
}

// t references the generic names in "names", whose corresponding values in "unif_parms" might be incomplete.  We update the values in unif_parms when necessary.  t does not need to be complete -- this code is also used by unify_types.
// "*unified_out" is initialized with the unified type, _except_ when t references a generic name, in which case it's initialized with the value of "*t", the generic name.  (The reason is, we might not have gathered complete information about the generic parameter when we've halfway-processed the type -- the caller can and should reconstruct the correct values later.)
func unify_under_generics(pt *te_typeexpr,
                          names *array[ast_ident], unif_parms *array[te_typeexpr],
                          t *te_typeexpr, unified_out *te_typeexpr) bool {
  if case &TeUnknown(v void) = pt {
    // It's worth pointing out:  This _is_ correct behavior if t is a generic parameter.
    *unified_out = *t;
    return true;
  }
  switch t {
    case &TeName(a te_name): {
      if case Has(ix size) = lookup_name(names, a.value) {
        unified te_typeexpr;
        if !unify_types(ref(unif_parms, ix), pt, &unified) {
          return false;
        }
        set(unif_parms, ix, unified);
        // TODO: None()?  So we discard that info?
        *unified_out = TeName({a.value, None()});
        return true;
      } else {
        if case &TeName(pa te_name) = pt {
          // TODO: Naturally, at some point scopage might be a factor.
          if a.value != pa.value {
            return false;
          }
          // TODO: None()?  So we discard that info?
          *unified_out = TeName({a.value, None()});
          return true;
        } else {
          return false;
        }
      }
    }

    case &TeApp(a te_typeapp): {
      // Generics can't be type constructors (yet).
      if case &TeApp(pa te_typeapp) = pt {
        unified_typefunc te_puretype;
        if !unify_puretypes(oo(&a.typefunc), oo(&pa.typefunc), &unified_typefunc) {
          return false;
        }
        n size = count(&a.params);
        if n != count(&pa.params) {
          return false;
        }
        unified_params array[te_typeexpr];
        for i size = 0; i < n; i = i + 1 {
          unified te_typeexpr;
          if !unify_under_generics(ref(&pa.params, i), names, unif_parms, ref(&a.params, i), &unified) {
            return false;
          }
          push(&unified_params, unified);
        }
        // TODO: None()?  So we discard that info?
        *unified_out = TeApp({embox(unified_typefunc), unified_params, None()});
        return true;
      } else {
        return false;
      }
    }

    case &TeStruct(a te_struct): {
      if case &TeStruct(pa te_struct) = pt {
        n size = count(&a.fields);
        if n != count(&pa.fields) {
          return false;
        }
        unified_fields array[te_vardecl];
        for i size = 0; i < n; i = i + 1 {
          pd *te_vardecl = ref(&pa.fields, i);
          d *te_vardecl = ref(&a.fields, i);
          if pd->name != d->name {
            return false;
          }
          unified te_typeexpr;
          if !unify_under_generics(&pd->type, names, unif_parms, &d->type, &unified) {
            return false;
          }
          push(&unified_fields, {d->name, unified});
        }
        *unified_out = TeStruct({unified_fields});
        return true;
      } else {
        return false;
      }
    }

    case &TeEnum(a te_enum): {
      if case &TeEnum(pa te_enum) = pt {
        n size = count(&a.constructors);
        if n != count(&pa.constructors) {
          return false;
        }
        unified_constructors array[te_vardecl];
        for i size = 0; i < n; i = i + 1 {
          pd *te_vardecl = ref(&pa.constructors, i);
          d *te_vardecl = ref(&a.constructors, i);
          if pd->name != d->name {
            return false;
          }
          unified te_typeexpr;
          if !unify_under_generics(&pd->type, names, unif_parms, &d->type, &unified) {
            return false;
          }
          push(&unified_constructors, {d->name, unified});
        }
        *unified_out = TeEnum({unified_constructors});
        return true;
      } else {
        return false;
      }
    }

    case &TeUnion(a te_union): {
      if case &TeUnion(pa te_union) = pt {
        n size = count(&a.fields);
        if n != count(&pa.fields) {
          return false;
        }
        unified_fields array[te_vardecl];
        for i size = 0; i < n; i = i + 1 {
          pd *te_vardecl = ref(&pa.fields, i);
          d *te_vardecl = ref(&a.fields, i);
          if pd->name != d->name {
            return false;
          }
          unified te_typeexpr;
          if !unify_under_generics(&pd->type, names, unif_parms, &d->type, &unified) {
            return false;
          }
          push(&unified_fields, {d->name, unified});
        }
        *unified_out = TeUnion({unified_fields});
        return true;
      } else {
        return false;
      }
    }

    case &TeArraytype(a te_arraytype): {
      if case &TeArraytype(pa te_arraytype) = pt {
        unified_count opt[u32];
        if case Has(ac u32) = a.count {
          if case Has(pac u32) = pa.count {
            if ac != pac {
              return false;
            } else {
              unified_count = Has(ac);
            }
          } else {
            unified_count = Has(ac);
          }
        } else {
          unified_count = pa.count;
        }
        unified_type te_typeexpr;
        if !unify_under_generics(oo(&pa.param), names, unif_parms, oo(&a.param), &unified_type) {
          return false;
        }
        *unified_out = TeArraytype({unified_count, embox(unified_type)});
        return true;
      } else {
        return false;
      }
    }

    case &TeUnknown(v void): {
      // Right now, the only callers are type_matches and unify_types.  From type_matches, t is complete, and from unify_types, there are no generic names.
      check(count(names) == 0);
      *unified_out = *pt;
      return true;
    }
  }
}

func lookup_name(arr *array[ast_ident], x sym) opt[size] {
  n size = count(arr);
  for i size = 0; i < n; i = i + 1 {
    if ref(arr, i)->value == x {
      return Has(i);
    }
  }
  return None();
}

func unify_puretypes(ppta *te_puretype, pptb *te_puretype, out *te_puretype) bool {
  switch ppta {
    case &TePureName(as sym): {
      switch pptb {
        case &TePureName(bs sym): {
          if as == bs {
            *out = TePureName(as);
            return true;
          } else {
            return false;
          }
        }
        case &TePureUnknown(v void): {
          *out = *ppta;
          return true;
        }
      }
    }
    case &TePureUnknown(v void): {
      *out = *pptb;
      return true;
    }
  }
}

func unify_types(pta *te_typeexpr, ptb *te_typeexpr, out *te_typeexpr) bool {
  names array[ast_ident];
  unif_parms array[te_typeexpr];
  return unify_under_generics(pta, &names, &unif_parms, ptb, out);
}

func testmodule_name() string {
  return from_u8(_u8("testmodule"));
}

func test_loader(cs *checkstate, name sym) opt[array[u8]] {
  if name == intern(cs->im, testmodule_name()) {
    return Has(* @[*array[u8]]cast(cs->loader_ctx));
  } else {
    return None();
  }
}

func test_platform() platform_info {
  ret platform_info = {
    {1, 1},
    {{1, 1}, {-big("128"), big("127")}},
    {{1, 1}, {big("0"), big("255")}},
    {{2, 2}, {-big("32768"), big("32767")}},
    {{2, 2}, {big("0"), big("65536")}},
    {{4, 4}, {-big("2147483648"), big("2147483647")}},
    {{4, 4}, {big("0"), big("4294967296")}},
    {4, 4}
  };
  return ret;
}

func[T] run_check_test(name T, file array[u8]) bool {
  print(Stdout(), _u8("test "), _u8(name), _u8("..."));
  fflush(Stdout());
  im identmap;
  cs checkstate = make_checkstate(&im, test_platform(), @[*void]cast(&file), test_loader);
  add_primitives(&cs);
  if !check_module(&cs, intern(&im, testmodule_name())) {
    print(Stdout(), _u8("FAIL\n"));
    fflush(Stdout());
    return false;
  } else {
    print(Stdout(), _u8("PASS\n"));
    fflush(Stdout());
    return true;
  }
}

func[T] run_check_negtest(name T, file array[u8]) bool {
  print(Stdout(), _u8("test !"), _u8(name), _u8("..."));
  fflush(Stdout());
  im identmap;
  cs checkstate = make_checkstate(&im, test_platform(), @[*void]cast(&file), test_loader);
  add_primitives(&cs);
  if check_module(&cs, intern(&im, testmodule_name())) {
    print(Stdout(), _u8("FAIL\n"));
    fflush(Stdout());
    return false;
  } else {
    print(Stdout(), _u8("PASS\n"));
    fflush(Stdout());
    return true;
  }
}

// TODO: Make test output not go directly to stdout/stderr.

func test_check_basic_cases() bool {
  pass bool = true;
  pass = pass & run_check_test("c001",
    _u8("def x bool = true;"));
  pass = pass & run_check_test("c002",
    _u8("def x i32 = 3;\n"
        "deftype dword u32;\n"
        "deftype blah dword;\n"
        "deftype feh *blah;\n"
        "deftype quux *quux;\n"));
  // Fails because foo holds itself flatly.
  pass = pass & run_check_negtest("c003",
    _u8("deftype foo bar;\n"
        "deftype bar foo;\n"));
  pass = pass & run_check_test("c004",
    _u8("def x i32 = 3;\n"
        "deftype foo struct { x u32; y i32; z *foo; };\n"));
  pass = pass & run_check_test("c005",
    _u8("def x i32 = 3;"
        "deftype foo struct { x u32; y i32; z *foo; };\n"));
  // TODO: This should fail, because "whatever[_]" is not in scope.
  pass = pass & run_check_test("c006-a",
    _u8("def x i32 = 3;"
        "deftype[T] foo struct { count u32; p whatever[T]; };\n"));
  pass = pass & run_check_test("c006-b",
    _u8("def x i32 = 3;"
        "deftype[T] foo struct { count u32; p *T; };\n"));
  // Fails because bar recursively holds itself through a template parameter.
  pass = pass & run_check_negtest("c007",
    _u8("deftype[T, U] foo struct { x *T; y U; };\n"
        "deftype bar struct { z foo[u32, bar]; };\n"));
  pass = pass & run_check_test("c008",
    _u8("deftype[T, U] foo struct { x *T; y U; };\n"
        "deftype bar struct { z foo[bar, u32]; };\n"));
  return pass;
}

func test_check() bool {
  pass bool = true;
  pass = pass & test_check_basic_cases();
  return pass;
}
