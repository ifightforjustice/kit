import anal;
import check;
import dumbgen;
import linux_objfile;
import win_objfile;
import objfile;

func build_nowrite_module(cs *checkstate, modulename sym, flattened_out *array[u8]) bool {
  if !check_module(cs, modulename) {
    return false;
  }

  f objfile = mk_objfile();

  if !add_fn_body_symbols(cs, &f) {
    return false;
  }

  if !build_fn_bodies(cs, &f) {
    return false;
  }

  switch cs->plat.opsys {
  case Linux32(v void):
    *flattened_out = linux32_flatten(cs->im, &f);
  case Win32(v void):
    *flattened_out = win_flatten(cs->im, &f);
  }

  return true;
}

func build_module(cs *checkstate, modulename sym) bool {
  flattened array[u8];
  if !build_nowrite_module(cs, modulename, &flattened) {
    return false;
  }

  path array[u8] = to_u8str(lookup(cs->im, modulename));
  switch cs->plat.opsys {
  case Linux32(v void):
    append(&path, _u8(".o"));
  case Win32(v void):
    append(&path, _u8(".obj"));
  }

  if !write_file(path, &flattened) {
    ERR(_u8("Could not write object file"));
    return false;
  }

  return true;
}

func build_fn_bodies(cs *checkstate, f *objfile) bool {
  nbodies size = count(&cs->fn_bodies);
  for i size = 0; i < nbodies; i = i + 1 {
    ent *fn_body_entry = oo(ref(&cs->fn_bodies, i));
    if !build_fn_body(cs, f, ent) {
      return false;
    }
  }
  return true;
}

func build_fn_body(cs *checkstate, f *objfile, ent *fn_body_entry) bool {
  switch &ent->u {
  case &GraphedFnBody(g graphed_fn_body):
    fillercode_align_double_quadword(f);
    set_symbol_value(f, *unHas(&ent->symbol_table_index), secsize(&f->text));
    bas basic_analyze_state;
    if !basic_analyze_fn_body(cs, f, &g, &bas) {
      return false;
    }
    return dumbly_gen_graphed_fn_body(cs, f, &bas, &g);
  case &ExternFnBody(e extern_fn_body):
    // We have nothing to do, of course.
    return true;
  }
}

func add_fn_body_symbols(cs *checkstate, f *objfile) bool {
  nbodies size = count(&cs->fn_bodies);
  for i size = 0; i < nbodies; i = i + 1 {
    ent *fn_body_entry = oo(ref(&cs->fn_bodies, i));
    if !add_fn_body_symbol(cs, f, ent) {
      return false;
    }
  }
  return true;
}

func add_fn_body_symbol(cs *checkstate, f *objfile, ent *fn_body_entry) bool {
  switch &ent->u {
  case &GraphedFnBody(g graphed_fn_body): { }
  case &ExternFnBody(e extern_fn_body):
    c_name sym = c_symbol_name(cs, e.name);
    symbol_table_index sti = add_remote_symbol(f, c_name, IsFunctionYes(void));
    annotate(&ent->symbol_table_index, symbol_table_index);
    return true;
  }
  // We do make symbol names for prim fn bodies, but maybe we won't actually generate them.
  name sym = generate_kit_name(cs);
  symbol_table_index sti = add_local_symbol(f, name, 0 /* We'll overwrite the value later. */, SectionText(void), IsStaticNo(void));
  annotate(&ent->symbol_table_index, symbol_table_index);
  return true;
}

func generate_kit_name(cs *checkstate) sym {
  build array[u8] = _u8("_kit_");
  num u32 = cs->kit_name_counter + 1;
  cs->kit_name_counter = num;
  build_u8str(void, &build, &num);
  return intern(cs->im, from_u8(&build));
}

func c_symbol_name(cs *checkstate, name sym) sym {
  switch cs->plat.opsys {
  case Linux32(v void):
    return name;
  case Win32(v void):
    namestr string = lookup(cs->im, name);
    return intern(cs->im, _s("_") + namestr);
  }
}
