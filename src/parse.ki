import ast;
import identmap;
import pos;

deftype ps struct {
  data *u8;
  length size;
  pos size;

  line size;
  column size;

  im *identmap;

  stack array[ptree];
};

func make_ps(im *identmap, data *u8, length size) ps {
  p ps;
  p.data = data;
  p.length = length;
  p.pos = 0;
  p.line = 1;
  p.column = 0;
  p.im = im;
  return p;
}

func ps_pos(p *ps) pos {
  ret pos;
  ret.~ = p->pos;
  return ret;
}

func ps_peek(p *ps) i32 {
  check(p->pos <= p->length);
  if p->pos == p->length {
    return -1;
  }
  return ~p->data[p->pos];
}

func ps_step(p *ps) void {
  check(p->pos < p->length);
  ch u8 = p->data[p->pos];
  if ch == '\n' {
    p->line = p->line + 1;
    p->column = 0;
  } else if ch == '\t' {
    p->column = (p->column | 7) + 1;
  } else {
    p->column = p->column + 1;
  }

  p->pos = p->pos + 1;
}

defenum keyw {
  Return void;
  While void;
  For void;
  If void;
  Else void;
  Switch void;
  Case void;
  Def void;
  Func void;
  Deftype void;
  Defenum void;
  Defclass void;
  Struct void;
  Var void;
  Union void;
  Underscore void;
};

defenum numlit {
  DecNum array[i8];
  HexNum array[i8];
};

defenum grouper {
  LParen void;
  RParen void;
  LBracket void;
  RBracket void;
  LBrace void;
  RBrace void;
};

defenum tokval {
  Keyw keyw;
  Num numlit;
  Oper string;
  Ident string;
  Grouper grouper;
};

deftype tok struct {
  interval interval;
  val tokval;
};

func mk_tok(left pos, right pos, val tokval) tok {
  ret tok;
  ret.val = val;
  ret.interval = mk_interval(left, right);
  return ret;
}

defenum treesym {
  Token tok;
};

deftype ptree struct {
  sym treesym;
  childs array[uniq[ptree]];
};

defenum grab_tok_res {
  BadToken interval;
  EofToken void;
  TokToken tok;
};

func is_lower(x i32) bool {
  // TODO: Statically assert 'z' - 'a' == 25.
  return x >= ~'a' && x <= ~'z';
}

func is_upper(x i32) bool {
  // TODO: Statically assert 'Z' - 'A' == 25.
  return x >= ~'A' && x <= ~'Z';
}

func is_alpha(x i32) bool {
  return is_lower(x) || is_upper(x);
}

func is_digit(x i32) bool {
  // TODO: Statically assert '9' - '0' == 9.
  return x >= ~'0' && x <= ~'9';
}

func is_alnum(x i32) bool {
  return is_alpha(x) || is_digit(x);
}

func is_hexdigit(x i32, val_out *i8) bool {
  // TODO: Statically assert 'f' - 'a', 'F' - 'A', '9' - '0'.
  if is_digit(x) {
    *val_out = ~(x - ~'0');
    return true;
  }
  if ~'A' <= x && x <= ~'F' {
    *val_out = ~(x - ~'A');
    return true;
  }
  if ~'a' <= x && x <= ~'f' {
    *val_out = ~(x - ~'a');
    return true;
  }
  return false;
}

func is_numeric_postchar(x i32) bool {
  // TODO: Implement for real.
  return !is_alnum(x);
}

func grab_tok(p *ps) grab_tok_res {
  left pos = ps_pos(p);
  ch i32 = ps_peek(p);
  if ch == @[i32]-1 {
    return EofToken(void);
  }
  if ch == ~'0' {
    ps_step(p);
    ch = ps_peek(p);
    if ch == ~'x' {
      ps_step(p);
      ch = ps_peek(p);
      digits array[i8];
      val i8;
      while is_hexdigit(ch, &val) {
        append(&digits, val);
        ps_step(p);
        ch = ps_peek(p);
      }

      if is_numeric_postchar(ch) {
        return TokToken(mk_tok(left, ps_pos(p), Num(HexNum(digits))));
      } else {
        return BadToken(mk_interval(left, ps_pos(p)));
      }
    } else {
      if is_numeric_postchar(ch) {
        digits array[i8];
        append(&digits, 0);
        return TokToken(mk_tok(left, ps_pos(p), Num(DecNum(digits))));
      } else {
        return BadToken(mk_interval(left, ps_pos(p)));
      }
    }
  } else {
    // TODO: Implement.
    check(false);
    return EofToken(void);  // TODO: No.
  }
}
