import anal;
import check;
import dumbgen;
import linux_objfile;
import win_objfile;
import objfile;

func build_nowrite_module(cs *checkstate, modulename sym, flattened_out *array[u8]) bool {
  if !check_module(cs, modulename) {
    return false;
  }

  f objfile = mk_objfile();

  if !add_fn_body_symbols(cs, &f) {
    return false;
  }

  if !build_fn_bodies(cs, &f) {
    return false;
  }

  if !add_export_symbols(cs, &f, modulename) {
    return false;
  }

  switch cs->plat.opsys {
  case Linux32(v void):
    *flattened_out = linux32_flatten(cs->im, &f);
  case Win32(v void):
    *flattened_out = win_flatten(cs->im, &f);
  }

  return true;
}

func build_module(cs *checkstate, modulename sym) bool {
  flattened array[u8];
  if !build_nowrite_module(cs, modulename, &flattened) {
    return false;
  }

  path array[u8] = to_u8str(lookup(cs->im, modulename));
  switch cs->plat.opsys {
  case Linux32(v void):
    append(&path, _u8(".o"));
  case Win32(v void):
    append(&path, _u8(".obj"));
  }

  if !write_file(path, &flattened) {
    ERR(_u8("Could not write object file"));
    return false;
  }

  return true;
}

func build_fn_bodies(cs *checkstate, f *objfile) bool {
  nbodies size = count(&cs->fn_bodies);
  for i size = 0; i < nbodies; i = i + 1 {
    ent *fn_body_entry = oo(ref(&cs->fn_bodies, i));
    if !build_fn_body(cs, f, ent) {
      return false;
    }
  }
  return true;
}

func build_fn_body(cs *checkstate, f *objfile, ent *fn_body_entry) bool {
  switch &ent->u {
  case &GraphedFnBody(g graphed_fn_body):
    fillercode_align_double_quadword(f);
    // DBG(_u8("gen graphed fn body for "), lookup(cs->im, g.graph.gr.informal_name));
    text_offset u32 = secsize(&f->text);
    set_symbol_value(f, *unHas(&ent->symbol_table_index), text_offset);
    annotate(&ent->body_text_offset, text_offset);
    bas basic_analyze_state;
    if !basic_analyze_fn_body(cs, f, &g, &bas) {
      return false;
    }
    return dumbly_gen_graphed_fn_body(cs, f, &bas, &g);
  case &ExternFnBody(e extern_fn_body):
    // We have nothing to do, of course.
    return true;
  }
}

func add_export_symbols(cs *checkstate, f *objfile, modulename sym) bool {
  mod_id module_id = unHas(lookup(&cs->modules_by_name, &modulename));
  mod *module = ref_module(cs, mod_id);
  ndefs size = count(&mod->defs);
  for i size = 0; i < ndefs; i = i + 1 {
    ent_id def_entry_id = get(&mod->defs, i);
    ent *def_entry = ref_def_entry(cs, ent_id);
    if def_is_export(ent) {
      check(count(&ent->insts) == 1);
      noparms cu_genparms = NoParms(void);
      if case Has(inst_id def_inst_id) = lookup(&ent->insts, &noparms) {
        inst *def_inst = ref_inst(cs, inst_id);
        if !is_fn_type(cs, &inst->computed_type.~) {
          ERR(_u8("Cannot codegen export symbols for non-fn def (can only export functions)"));
          return false;
        }
        if case &Computed(val st_value) = &inst->evaled_value {
          fnid fn_body_id;
          if !x86_simple_symbolref(cs, &val, &fnid) {
            ERR(_u8("Export fn-symbol has invalid value (zero-initialized fn[...] value, I bet)"));
            return false;
          }
          body_text_offset u32 = *unHas(&ref_fn_body(cs, fnid)->body_text_offset);
          name string = lookup(cs->im, ent->def_name);
          switch cs->plat.opsys {
          case Linux32(v void): { }
          case Win32(v void):
            name = _s("_") + name;
          }
          discard sti = add_local_symbol(f, intern(cs->im, name), body_text_offset, SectionText(void), IsStaticNo(void));
        } else {
          ice(_u8("add_export_symbols sees unevaled inst"));
        }
      } else {
        ice(_u8("add_export_symbols cannot find inst (export-with-generics?)"));
      }
    }
  }

  return true;
}

func def_is_export(ent *def_entry) bool {
  if case &DefnHasRhs(np def_nonprim) = &ent->definition {
    if case &Def(d ast_def) = np.tl {
      if case IsExport(v void) = d.is_export {
        return true;
      }
    }
  }
  return false;
}

func add_fn_body_symbols(cs *checkstate, f *objfile) bool {
  nbodies size = count(&cs->fn_bodies);
  for i size = 0; i < nbodies; i = i + 1 {
    ent *fn_body_entry = oo(ref(&cs->fn_bodies, i));
    if !add_fn_body_symbol(cs, f, ent) {
      return false;
    }
  }
  return true;
}

func argcell_types(cs *checkstate, g *graphed_fn_body) shray[cu_typeexpr] {
  bu array[cu_typeexpr];
  nargcells size = count(&g->argcells);
  for i size = 0; i < nargcells; i = i + 1 {
    push(&bu, ref_cell(&g->graph.gr, get(&g->argcells, i))->type);
  }
  return freeze(&bu);
}

func add_fn_body_symbol(cs *checkstate, f *objfile, ent *fn_body_entry) bool {
  switch &ent->u {
  case &GraphedFnBody(g graphed_fn_body):
    arg_types shray[cu_typeexpr] = argcell_types(cs, &g);
    // We do make symbol names for prim fn bodies, but maybe we won't actually generate them.
    name sym = generate_kit_name(cs, ent->informal_name, arg_types);
    symbol_table_index sti = add_local_symbol(f, name, 0 /* We'll overwrite the value later. */, SectionText(void), IsStaticNo(void));
    annotate(&ent->symbol_table_index, symbol_table_index);
    return true;
  case &ExternFnBody(e extern_fn_body):
    c_name sym = c_symbol_name(cs, e.name);
    symbol_table_index sti = add_remote_symbol(f, c_name, IsFunctionYes(void));
    annotate(&ent->symbol_table_index, symbol_table_index);
    return true;
  }
}

func generate_kit_name(cs *checkstate, informal_name sym, arg_types shray[cu_typeexpr]) sym {
  build array[u8] = _u8("_kit_");
  num u32 = cs->kit_name_counter + 1;
  cs->kit_name_counter = num;
  build_u8str(void, &build, &num);
  push(&build, '_');
  // TODO: Actually, build should be a string, not an array[u8].
  append(&build, to_u8str(lookup(cs->im, informal_name)));
  push(&build, '[');
  nargtypes size = count(&arg_types);
  for i size = 0; i < nargtypes; i = i + 1 {
    if i != 0 {
      push(&build, ',');
    }
    build_u8str(cs->im, &build, ref(&arg_types, i));
  }
  push(&build, ']');
  return intern(cs->im, from_u8(&build));
}

func c_symbol_name(cs *checkstate, name sym) sym {
  switch cs->plat.opsys {
  case Linux32(v void):
    return name;
  case Win32(v void):
    namestr string = lookup(cs->im, name);
    return intern(cs->im, _s("_") + namestr);
  }
}
