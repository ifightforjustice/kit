import ast;
import parse;
import tok;
import shp;
import u8ast;

deftype checkstate struct {
  im *identmap;
  loader fn[sym, opt[array[u8]]];

  modules array[shp[module]];
  modules_by_name hash[sym, module_id];

  instantiations array[shp[def_inst]];
  type_instantiations array[shp[deftype_inst]];

  deftypes array[shp[deftype_entry]];
  deftypes_by_name hash[sym, array[deftype_entry_id]];

  aliases array[shp[alias_entry]];
  aliases_by_name hash[sym, array[alias_entry_id]];

  defs array[shp[def_entry]];
  defs_by_name hash[sym, array[def_entry_id]];
};

// An index into checkstate's modules array.
deftype module_id size;
def `~` fn[size, module_id] = wrapconvert;

// An index into checkstate's instantiations array.
deftype def_inst_id size;

// An index into checkstate's type_instantiations array.
deftype deftype_inst_id size;
def `~` fn[size, deftype_inst_id] = wrapconvert;

// An index into checkstate's defs array.
deftype def_entry_id size;
def `~` fn[size, def_entry_id] = wrapconvert;

// An index into checkstate's deftypes array.
deftype deftype_entry_id size;
def `~` fn[size, deftype_entry_id] = wrapconvert;

// An index into checkstate's aliases array.
deftype alias_entry_id size;
def `~` fn[size, alias_entry_id] = wrapconvert;

defenum module_process_state {
  Unprocessed void;
  Processing void;
  DoneProcessing void;
};

func `==`(a module_process_state, b module_process_state) bool {
  return enumnum(&a) == enumnum(&b);
}

deftype module struct {
  module_name sym;
  file ast_file;
  buf array[u8];
  process_state module_process_state;
  // vvv  Valid when process_state == DoneProcessing.  vvv
  defs array[def_entry_id];
  deftypes array[deftype_entry_id];
  aliases array[alias_entry_id];
};

deftype deftype_inst struct {
  parms genparms;
  concrete_rhs ast_type_def_rhs;
  // Did we start checking the type?  Whether we find this recursively or not, we don't need to re-enter the type, or recheck the type.
  started_checking bool;
  // If we're recursively checking this type, we increment a number every time there's a pointer indirection, so we can recognize if the type recursively holds itself.
  flatness_depth i32;
};

deftype deftype_entry struct {
  module_name sym;
  name sym;
  tl *ast_type_def;

  insts array[deftype_inst_id];
};

func mk(module_name sym, name sym, tl *ast_type_def) deftype_entry {
  return {module_name, name, tl, default()};
}

deftype alias_entry struct {
  module_name sym;
  alias_name sym;
  tl *ast_toplevel;
};

deftype def_inst struct {
};

deftype def_entry struct {
  module_name sym;
  def_name sym;
  tl *ast_toplevel;
};

func check_module(cs *checkstate, mod_name sym) bool {
  switch process_module(cs, mod_name) {
    case None(v): {
      return false;
    }
    case Has(id module_id): {
      mod *module = oo(ref(&cs->modules, id.~));
      for i size = 0; i < count(&mod->deftypes); i = i + 1 {
        ent *deftype_entry = oo(ref(&cs->deftypes, get(&mod->deftypes, i).~));
        if !check_deftype(cs, ent) {
          return false;
        }
      }
      for i size = 0; i < count(&mod->aliases); i = i + 1 {
        ent *alias_entry = oo(ref(&cs->aliases, get(&mod->aliases, i).~));
        if !check_alias(cs, ent) {
          return false;
        }
      }
      for i size = 0; i < count(&mod->defs); i = i + 1 {
        ent *def_entry = oo(ref(&cs->defs, get(&mod->defs, i).~));
        if !check_def(cs, ent) {
          return false;
        }
      }
      return true;
    }
  }
}

func load_module(cs *checkstate, mod_name sym) opt[module_id] {
  switch lookup(&cs->modules_by_name, mod_name) {
    case Has(id module_id): {
      return Has(id);
    }
    case None(v): {
      switch (cs->loader)(mod_name) {
        case None(v2): {
          ERR(_u8("Could not open file for module "), lookup(cs->im, mod_name));
          return None();
        }
        case Has(arr array[u8]): {
          mod shp[module];
          oo(&mod)->process_state = Unprocessed(void);
          oo(&mod)->module_name = mod_name;
          oo(&mod)->buf = arr;
          p ps = make_ps(cs->im, data(&oo(&mod)->buf), count(&oo(&mod)->buf));
          if !parse_file(&p, &oo(&mod)->file) {
            ERR(_u8("Trouble parsing module "), lookup(cs->im, mod_name));
            return None();
          }
          mod_id module_id = ~count(&cs->modules);
          push(&cs->modules, mod);
          if !try_insert(&cs->modules_by_name, mod_name, mod_id) {
            ERR(_u8("ICE: modules_by_name already has name "), lookup(cs->im, mod_name));
            return None();
          }
          return Has(mod_id);
        }
      }
    }
  }
}

func process_module(cs *checkstate, mod_name sym) opt[module_id] {
  switch load_module(cs, mod_name) {
    case None(v): {
      return None();
    }
    case Has(id module_id): {
      mod *module = oo(get(&cs->modules, id.~));
      if mod->process_state == Unprocessed(void) {
         if !process_defs(cs, mod) {
           return None();
         }
      }
      return Has(id);
    }
  }
}

func process_defs(cs *checkstate, mod *module) bool {
  check_mutate(&mod->process_state, Unprocessed(void), Processing(void));
  if !process_toplevels(cs, mod, &mod->file.toplevels) {
    return false;
  }
  check_mutate(&mod->process_state, Processing(void), DoneProcessing(void));
  return true;
}

func add_def_entry(cs *checkstate,
                   module_name sym,
                   module_defs *array[def_entry_id],
                   ent shp[def_entry]) void {
  id def_entry_id = ~count(&cs->defs);
  push(&cs->defs, ent);
  arr *array[def_entry_id] = try_insert_lookup(
    &cs->defs_by_name, oo(ent)->def_name, default());
  push(arr, id);
  push(module_defs, id);
}

func process_toplevels(cs *checkstate,
                       mod *module,
                       toplevels *array[ast_toplevel]) bool {
  for i size = 0; i < count(toplevels); i = i + 1 {
    toplevel *ast_toplevel = ref(toplevels, i);
    switch toplevel {
      case &Import(a ast_import): {
        switch process_module(cs, a.name.value) {
          case None(v): {
            return false;
          }
          case Has(id module_id): {
            // Do nothing!  We've processed the module successfully.
          }
        }
      }
      case &Def(a ast_def): {
        ent shp[def_entry] = emshp({mod->module_name, a.name.value, toplevel});
        add_def_entry(cs, mod->module_name, &mod->defs, ent);
      }
      case &ExternDef(a ast_extern_def): {
        ent shp[def_entry] = emshp({mod->module_name, a.name.value, toplevel});
        add_def_entry(cs, mod->module_name, &mod->defs, ent);
      }
      case &TypeDef(a ast_type_def): {
        ent shp[deftype_entry] = emshp(mk(mod->module_name, a.name.value, &a));
        id deftype_entry_id = ~count(&cs->deftypes);
        push(&cs->deftypes, ent);
        arr *array[deftype_entry_id] = try_insert_lookup(
          &cs->deftypes_by_name, oo(ent)->name, default());
        push(arr, id);
        push(&mod->deftypes, id);
      }
      case &TypeAlias(a ast_type_alias): {
        ent shp[alias_entry] = emshp({mod->module_name, a.name.value, toplevel});
        id alias_entry_id = ~count(&cs->aliases);
        push(&cs->aliases, ent);
        arr *array[alias_entry_id] = try_insert_lookup(
          &cs->aliases_by_name, oo(ent)->alias_name, default());
        push(arr, id);
        push(&mod->aliases, id);
      }
      case &Access(a ast_access): {
        if !process_toplevels(cs, mod, &a.toplevels) {
          return false;
        }
      }
    }
  }
  return true;
}

func check_deftype(cs *checkstate, ent *deftype_entry) bool {
  a *ast_type_def = ent->tl;
  if !check_generics_shadowing(cs, &a->generics) {
    return false;
  }

  switch &a->generics {
    case &NoGenerics(v): {
      return check_deftype_with_genparms(cs, ent, NoParms(void), 1);
    }
    case &HasGenerics(args array[ast_ident]): {
      // TODO: Are there any aspects of a generic type decl that we should check up-front?  Such as uniqueness of field names?
    }
  }
  // TODO: Everything, flatness.
  return faketrue;
}

defenum genparms {
  NoParms void;
  HasParms array[ast_typeexpr];
};

func to_u8str(g genparms) array[u8] {
  switch g {
    case NoParms(v): {
      return _u8("NoParms()");
    }
    case HasParms(a array[ast_typeexpr]): {
      var ret = _u8("HasParms([");
      e size = count(&a);
      for i size = 0; i < e; i = i + 1 {
        if i != 0 {
          append(&ret, _u8(", "));
        }
        var tmp = to_u8str(get(&a, i));
        append(&ret, &tmp);
      }
      append(&ret, _u8("])"));
      return ret;
    }
  }
}

func genparms_eq(cs *checkstate, x *genparms, y *genparms) bool {
  if enumnum(x) != enumnum(y) {
    return false;
  }
  switch x {
    case &NoParms(v): { return true; }
    case &HasParms(xa array[ast_typeexpr]): {
      switch y {
        case &HasParms(ya array[ast_typeexpr]): {
          return typelists_eq(cs, &xa, &ya);
        }
      }
    }
  }
}

func typelists_eq(cs *checkstate, x *array[ast_typeexpr], y *array[ast_typeexpr]) bool {
  n size = count(x);
  if n != count(y) {
    return false;
  }
  for i size = 0; i < n; i = i + 1 {
    if !types_eq(cs, ref(x, i), ref(y, i)) {
      return false;
    }
  }
  return true;
}

// This is somewhat "interesting" because it has to expand aliases.
func types_eq(cs *checkstate, x *ast_typeexpr, y *ast_typeexpr) bool {
  // TODO: Implement.
  return false;
}

func find_inst(cs *checkstate, ent *deftype_entry, parms *genparms)
    opt[deftype_inst_id] {
  e size = count(&ent->insts);
  for i size = 0; i < e; i = i + 1 {
    id deftype_inst_id = get(&ent->insts, i);
    inst *deftype_inst = oo(ref(&cs->type_instantiations, id.~));
    if genparms_eq(cs, parms, &inst->parms) {
      return Has(id);
    }
  }
  return None();
}

func check_deftype_with_genparms(cs *checkstate, ent *deftype_entry,
                                 parms genparms, flatness_depth i32) bool {
  if case Has(id deftype_inst_id) = find_inst(cs, ent, &parms) {
    inst *deftype_inst = oo(ref(&cs->type_instantiations, id.~));
    if inst->started_checking {
      if inst->flatness_depth == flatness_depth {
        ERR(_u8("type recursively contains itself (has infinite size): "),
            lookup(cs->im, ent->name), _u8(" "), parms);
        return false;
      }
      return true;
    } else {
      ERR(_u8("ICE: a deftype_inst we didn't immediately start typechecking: "),
          lookup(cs->im, ent->name), _u8(" "), parms);
      return false;
    }
  } else {
    a *ast_type_def = ent->tl;
    conc_rhs ast_type_def_rhs = replace_generics(&a->generics, &parms, &a->rhs);
    inst shp[deftype_inst] = emshp({parms, conc_rhs, true, flatness_depth});
    id deftype_inst_id = ~count(&cs->type_instantiations);
    push(&cs->type_instantiations, inst);
    push(&ent->insts, id);

    // TODO: Recursively check the type rhs -- and compute how to init/copy/move/destroy?
    return false;
  }
}

func replace_generics(g *ast_generics, parms *genparms, rhs *ast_type_def_rhs) ast_type_def_rhs {
  // TODO: Everything.
  return default();
}

func check_alias(cs *checkstate, ent *alias_entry) bool {
  // TODO: Everything.
  return faketrue;
}

func check_def(cs *checkstate, ent *def_entry) bool {
  // TODO: Finish implementing:
  //   - check def for name conflicts (if that's not handled elsehow)
  //   - check uniqueness of generic variable names
  //   - check that name/arity combination is unique

  switch ent->tl {
    case &Def(a ast_def): {
      if !check_generics_shadowing(cs, &a.generics) {
        return false;
      }

      /* TODO: Check for perfect def shadowing... _after_ we typecheck
      the rhs, because the type signature of the def is optional. */

      // TODO: Implement.
      //   - check sanity of typeexpr.
      //   - check rhs expr.
      //   - check that rhs expr can be statically evaled?
      //   - compute static eval dependency relationships?
      return faketrue;
    }
    case &ExternDef(a ast_extern_def): {
      // TODO: Implement.
      //   - Check sanity of typeexpr.
      //   - Check for shadowing.
      return faketrue;
    }
    default: {
      crash(_u8("check_def sees unexpected toplevel in def_entry."));
      return fake();
    }
  }
}

func check_generics_shadowing(cs *checkstate, g *ast_generics) bool {
  switch g {
    case &NoGenerics(v): { return true; }
    case &HasGenerics(a array[ast_ident]): {
      for i size = 0; i < count(&a); i = i + 1 {
        ival sym = ref(&a, i)->value;
        for j size = 0; j < i; j = j + 1 {
          if ival == ref(&a, j)->value {
            ERR(_u8("Generic params have duplicate name "), ival);
            return false;
          }
        }
        if scope_shadows(cs, ival) {
          ERR(_u8("Generic param externally shadows "), ival);
        }
      }
      return true;
    }
  }
}

func scope_shadows(cs *checkstate, name sym) bool {
  return has_key(&cs->defs_by_name, name) || has_key(&cs->deftypes_by_name, name);
}

// TODO: Remove faketrue.
def faketrue bool = true;

func[T, U, V, W] ERR(x T, y U, z V, p W) void {
  ERR(cons(cons(x, y), cons(z, p)));
}

func[T, U, V] ERR(x T, y U, z V) void {
  ERR(cons(cons(x, y), z));
}

func[T, U] ERR(x T, y U) void {
  ERR(cons(x, y));
}

func[T] ERR(x T) void {
  print(Stderr(), to_u8str(x));
  print(Stderr(), _u8("\n"));
  fflush(Stderr());
}
