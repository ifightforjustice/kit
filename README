        Kit v0.00.2A.x

Current status:  "proto-Kit"

Definitions:
   s1: A compiler, written in C.  It can compile s2.  Located in trc/.
   s2: A compiler, written in proto-Kit-v0.00.1.x.  It can
       compile itself and s3.  Located in urc/.
   s3: A compiler, written in proto-Kit-v0.00.2.x.  It can
       compile itself.  Located in src/.
   s2-by-s1: s2, as compiled by s1.
   s2-self: s2, as compiled by s2.
   s3-by-s2: s3, as compiled by s2.
   s3-self: s3, as compiled by s3.
   s4-by-s3: s4, asd compiled by s3.
   s4-self: s4, as compiled by s4.

  BUILD INSTRUCTIONS

# Prerequisites: An x86 CPU.  Windows or Linux.  On Windows, MSVC
# 2013 or 2015 (something with basic C99 support) -- for example,
# run these commands from a "Developer Command Prompt for VS2015".
# On Linux, gcc with 32-bit support, which usually means some
# gcc-multilib package.  Maybe clang works too.

# Step 1. Build s1 -- creates executable "out.exe" (or "out")
   windows_build.bat  (or ./linux_build.sh)
# Step 2. Build s2 -- creates executable "s2.exe" (or "s2")
   windows_build_s2.bat  (or ./linux_build_s2.sh)
# Step 3. Build s3
   windows_build_s3.bat
# Step 4. Build s4
   windows_build_s4.bat
# Step 5. Run parsing/typechecking+codegen tests.
   s4 --build  (or ./s4 --build)
# Step 6. If you wish, run s4-self on itself
   cd src
   move main.obj old_main.obj
   ..\s4 main
   sha1sum old_main.obj main.obj
# The sha1sums should match.

  DIRECTORY STRUCTURE

The current directory structure is:

   trc - s1, implemented in C.  Compiles s2.
   urc - s2, implemented in proto-Kit, v0.00.1.x.  Compiles s2 and s3.
   src - s3, implemented in proto-Kit, v0.00.2.x.  Compiles s3 and s4.
   vrc - s4, implemented in proto-Kit, v0.00.2A.x.  Compiles s4.
   examples - examples to run, disorganized junk

  COMMAND USAGE

"out" is the name of the s1 executable, "s2" is the name of the s2 executable, and "s3" is the name of the s3 executable.

   out --test    # runs tests.
   out <modulename>    # builds <modulename>.ki and its imports.
   s2    # runs parsing/typechecking tests without codegen.
   s2 --build    # runs parsing/typechecking tests with codegen.
   s2 <modulename>  # builds <modulename>.ki and its imports.
   s3 ...    # same as s2.
   s4 ...    # same as s3 and s2.

  PROJECT TIMELINE

Here's the project timeline:

   1. Parsing.  (DONE)
   2. Typechecking/name-resolving.  (DONE)
   3. Generate code, i.e. have a working compiler.  (DONE)
   4. Cleanup error messages to have useful source information. (BETTER)
   5. Cleanup the language to make it more usable. (GOOD ENOUGH)
      Wishlist (waiting for these features specifically needed):
       A. Structure / array initialization syntax. (DONE)
       B. Packed struct types.  (DON'T CARE for now -- use le_u32)
       C. Destructuring assignment.
       D. Incr/decr and "+="-type operators. (DONE in s2 but user-defined)
   6. Linux support. (DONE)
   7. Make a self-hosted implementation (adding improvements and
      fixes to the C implementation when useful). (DONE)
   8. Give the self-hosted implementation "respectable" codegen.
   9. Basic cleanup of the language.
      Wishlist:
       A. defstruct, no more naked structs.
       B. type aliases.
       C. a non-truncative conversion operator (prefix +).  (DONE)
       D. negative integer literals.
       E. var keyword after variable.  (DONE)
       F. o8, o16, o32.  (DONE in s2)
       G. u64, i64, o64.
       H. a signed size type ("diff").  (DONE in s2)
       I. negation for o-verflow types.  (DONE in s2)
       J. smart move/allocate-in-the-spot semantics.
       K. scoped types or scoped vars.
       L. better syntax for defining copy/init/move/destroy.
       M. defer statements (or scoped statements).
       N. handlers for overflow errors.
       O. enum types with "default" values instead of zero-tag.
       P. cute enum syntax for voids.  (DONE)
       Q. better type-checking, see-through-negation.
       R. explicit overloading/specialization.
       S. support for multiple calling conventions.
       T. cross-function goto statements of the IInd kind.
       U. capturing closures.
       V. actual modules/namespaces.
       W. pretentious quotes in the binaries.
       X. removal of pretentious quotes in the binaries.
       Y. field names in struct literals.
       Z. array literals (struct literals in an array place).  (DONE)

  ABOUT THE VERSIONS

s1's language, v0.00.1.x, is merely "C, with templates,
constructors and destructors, elementary encapsulation, tagged enum
types, no implicit conversions."  s2's, v0.00.2.x, is the same as
s1's, but with some basic convenience enhancements that should be
easy to backport to s1 -- the differences are described in
FEATURES.  s3's, v0.00.2A.x, is very similar to s2's, I think there
might not be any differences.  s4's should become quite different
from s3's.

Right now, s1 is very close to being able to compile s3.  s2 will
disappear pretty soon -- its new language features are gradually
getting implemented in s1.  Actually, s1 can compile both s3 and s4
at the time of writing this.  s3 or s4 wouldn't disappear until
there's an s5, though -- we don't want the actively developed
compiler version to have to maintain compatibility with s1's warts.
