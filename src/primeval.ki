import eval;

func st_eval_prim_fn_body(clq *clqueue, env *st_env, paramorefs *array[st_obj_ref], retvalref st_obj_ref, prent *prim_fn_body) bool {
  switch &prent->op {
  case &PrimNum(a primitive_numeric_op):
    return st_eval_prim_num(clq, env, paramorefs, retvalref, &a);
  case &PrimNumCompare(a primitive_numeric_comparison_op):
    return st_eval_prim_num_compare(clq, env, paramorefs, retvalref, &a);
  case &PrimLogical(a primitive_logical_op):
    return TODO();
  case &PrimPtrCompare(a primitive_ptr_comparison_op):
    return TODO();
  case &PrimConversion(a primitive_conversion_op):
    return TODO();
  }
}

func st_eval_prim_num_compare(clq *clqueue, env *st_env, paramorefs *array[st_obj_ref], retvalref st_obj_ref, op *primitive_numeric_comparison_op) bool {
  ps array[bigint];
  // Comparison ops all take 2 arguments.
  if !st_nums(env, paramorefs, 2, op->op_size, &op->op_numtraits, &ps) {
    return false;
  }
  if retvalref.count != env->plat.booltraits.size {
    ice(_u8("st_eval_prim_num_compare bad retvalref size"));
  }

  a bigint = get(&ps, 0);
  b bigint = get(&ps, 1);
  result bool;
  switch op->op_action {
  case CmpEq(v void): result = a == b;
  case CmpNe(v void): result = a != b;
  case CmpLt(v void): result = a < b;
  case CmpGt(v void): result = a > b;
  case CmpLe(v void): result = a <= b;
  case CmpGe(v void): result = a >= b;
  }
  resultint bigint;
  if result {
    resultint = ~ @[u32] 1;
  } else {
    resultint = ~ @[u32] 0;
  }
  val st_value = st_bigint_to_value_unsigned(&env->plat, retvalref.count, resultint);
  if !obj_write(env, retvalref, &val) {
    ice(_u8("st_eval_prim_num_compare cannot write into retvalref"));
  }
  return true;
}

func st_eval_prim_num(clq *clqueue, env *st_env, paramorefs *array[st_obj_ref], retvalref st_obj_ref, op *primitive_numeric_op) bool {
  ps array[bigint];
  if !st_nums(env, paramorefs, op_arity(op->op_action), op->op_size, &op->op_numtraits, &ps) {
    return false;
  }
  if retvalref.count != op->op_size {
    ice(_u8("st_eval_prim_arith bad retvalref size"));
  }

  switch op->op_action {
  case NumAdd(v void):
    return st_num_rangechecked_output(clq, env, retvalref, get(&ps, 0) + get(&ps, 1), op);
  case NumSub(v void):
    return st_num_rangechecked_output(clq, env, retvalref, get(&ps, 0) - get(&ps, 1), op);
  case NumMul(v void):
    return st_num_rangechecked_output(clq, env, retvalref, get(&ps, 0) * get(&ps, 1), op);
  case NumDiv(v void):
    // TODO: This does not have x86-compatible (or platform-compatible) behavior for signed division.
    div_result bigint;
    mod_discard bigint;
    if !st_divmod(get(&ps, 0), get(&ps, 1), op, &div_result, &mod_discard) {
      return false;
    }
    return st_num_rangechecked_output(clq, env, retvalref, div_result, op);
  case NumMod(v void):
    // TODO: This does not have x86-compatible (or platform-compatible) behavior for signed division.
    div_discard bigint;
    mod_result bigint;
    if !st_divmod(get(&ps, 0), get(&ps, 1), op, &div_discard, &mod_result) {
      return false;
    }
    return st_num_rangechecked_output(clq, env, retvalref, mod_result, op);
  case NumNegate(v void):
    return st_num_rangechecked_output(clq, env, retvalref, - get(&ps, 0), op);
  default:
    return TODO();
  }
}

func st_divmod(x bigint, y bigint, op *primitive_numeric_op, div_out *bigint, mod_out *bigint) bool {
  if y == ~ @[u32] 0 {
    ERR(_u8("Static eval: divide by zero"));
    return false;
  }
  switch op->op_numtraits.repr {
  case Unsigned(v void): { }
  case SignedTwos(v void):
    if y == - (@[bigint] ~ @[u32] 1) && x == op->op_numtraits.minval {
      ERR(_u8("Static eval: divide minval by -1"));
      return false;
    }
  }
  dm tup[bigint, bigint] = divmod(x, y);
  *div_out = dm.car;
  *mod_out = dm.cdr;
  return true;
}

func st_num_rangechecked_output(clq *clqueue, env *st_env, retvalref st_obj_ref, num bigint, op *primitive_numeric_op) bool {
  if num < op->op_numtraits.minval || num > op->op_numtraits.maxval {
    if op->op_numtraits.trap_overflow {
      ERR(_u8("Result out of range."));
      return false;
    }
    // Make sure we know to handle some weird reprs later when we have them.
    switch op->op_numtraits.repr {
    case Unsigned(void):
      // do nothing
    case SignedTwos(void):
      // do nothing
    }
    addand bigint = incr(op->op_numtraits.maxval - op->op_numtraits.minval);
    num = ((num - op->op_numtraits.minval) % addand) + op->op_numtraits.minval;
  }

  val st_value;
  if !st_bigint_to_value_twos(&env->plat, op->op_size, num, &val) {
    ice(_u8("st_num_rangechecked_input just rangechecked bigint, could not convert to st_value."));
  }
  obj_write(env, retvalref, &val);
  return true;
}

func st_nums(env *st_env, paramorefs *array[st_obj_ref], op_arity u32, op_size u32, op_numtraits *numeric_traits, out *array[bigint]) bool {
  nparams size = count(paramorefs);
  if op_arity != ~nparams {
    ice(_u8("st_nums numeric op bad arity"));
  }
  ret array[bigint];
  for i size = 0; i < nparams; i = i + 1 {
    oref st_obj_ref = get(paramorefs, i);
    if oref.count != op_size {
      ice(_u8("st_nums bad operand size"));
    }
    val st_value;
    if !obj_read(env, oref, &val) {
      return false;
    }

    num bigint;
    switch op_numtraits->repr {
    case Unsigned(void):
      if !st_value_unsigned_as_bigint(&env->plat, &val, &num) {
        return false;
      }
    case SignedTwos(void):
      if !st_value_signed_twos_as_bigint(&env->plat, &val, &num) {
        return false;
      }
    }
    push(&ret, num);
  }
  *out = ret;
  return true;
}
