import check;
import primitives;

deftype exprscope struct {
  cs *checkstate;
  // Same as cs->im.
  im *identmap;
  clq *clqueue;
  // Generics and their _complete_ replacements.
  generics *ast_generics;
  parms *genparms;

  local_vars array[var_info];
};

deftype var_info struct {
  name sym;
  // A complete, checked, type, with generics replaced.
  type te_typeexpr;
};

defenum allow_incomplete {
  AllowIncompleteNo void;
  AllowIncompleteYes void;
};

func `==`(x allow_incomplete, y allow_incomplete) bool {
  return enumnum(&x) == enumnum(&y);
}

func check_expr(cs *checkstate, clq *clqueue, g *ast_generics, parms *genparms, x *ast_expr, pt *te_typeexpr) bool {
  es exprscope = {cs, cs->im, clq, g, parms, default@[array[var_info]]()};
  return check_expr_ai(&es, AllowIncompleteNo(void), x, pt);
}

func replaced_name_parms(es *exprscope, a *ast_name_expr, out *genparms) bool {
  if case &Has(arr array[ast_typeexpr]) = &a->generic_params {
    replaced array[te_typeexpr];
    n size = count(&arr);
    for i size = 0; i < n; i = i + 1 {
      converted te_typeexpr;
      if !convert_typeexpr(es->cs, ref(&arr, i), &converted) {
        return false;
      }
      computed te_typeexpr;
      computed_complete bool;
      if !check_and_compute_typeexpr(es->cs, es->clq, es->generics, es->parms, &converted, &computed, &computed_complete) {
        return false;
      }
      push(&replaced, computed);
    }
    *out = HasParms(replaced);
    return true;
  } else {
    *out = NoParms(void);
    return true;
  }
}

deftype global_info struct {
  ent def_entry_id;
  inst def_inst_id;
};

deftype local_info struct {
  varinfo_ix size;
};

defenum name_info {
  Local void;
  Global global_info;
};

defenum es_match_res {
  NoMatch void;
  AmbigGlobalMatch void;
  OneGlobalMatch global_info;
  OneLocalMatch local_info;
};

func es_lookup_name(es *exprscope, name sym, gp *genparms, pt *te_typeexpr, res_out *es_match_res) bool {
  if case &NoParms(v void) = gp {
    n size = count(&es->local_vars);
    for i size = 0; i < n; i = i + 1 {
      inf *var_info = ref(&es->local_vars, i);
      if inf->name == name {
        type te_typeexpr;
        if !unify_types(pt, &inf->type, &type) {
          ERR(_u8("local '"), lookup(es->im, name), _u8("' has wrong type"));
          return false;
        }
        *res_out = OneLocalMatch({i});
        return true;
      }
    }
  }

  res match_def_res;
  if !match_def(es->cs, name, gp, pt, &res) {
    return false;
  }

  switch res {
    case NoMatch(v void): {
      // TODO: Is in not weird that we return NoMatch + true, instead of false, in this failure case?
      *res_out = NoMatch(void);
      return true;
    }
    case MultiMatch(void): {
      *res_out = AmbigGlobalMatch(void);
      return true;
    }
    case OneMatch(m struct { ent def_entry_id; parms genparms; }): {
      inst_id def_inst_id = enqueue_def_inst(es->cs, es->clq, m.ent, &m.parms);
      *res_out = OneGlobalMatch({m.ent, inst_id});
      return true;
    }
  }
}

func help_check_simple_literal(pt *te_typeexpr, type te_typeexpr, errmsg_name array[u8], x *ast_expr) bool {
  unified te_typeexpr;
  if !unify_types(pt, &type, &unified) {
    ERR(errmsg_name, _u8(" literal in bad place"));
    return false;
  }
  if is_complete(&unified) {
    annotate_info(x, CompleteCheck(type));
  } else {
    annotate_info(x, IncompleteCheck(type));
  }
  return true;
}

func check_expr_ai(es *exprscope, ai allow_incomplete, x *ast_expr, pt *te_typeexpr) bool {
  switch &x->u {
    case &NameExpr(a ast_name_expr): {
      parms genparms;
      if !replaced_name_parms(es, &a, &parms) {
        return false;
      }
      match_res es_match_res;
      if !es_lookup_name(es, a.ident.value, &parms, pt, &match_res) {
        return false;
      }
      switch &match_res {
        case &NoMatch(v void): {
          ERR(_u8("Name lookup for '"), lookup(es->im, a.ident.value), _u8("', maybe with parms, not found."));
          return false;
        }
        case &AmbigGlobalMatch(v void): {
          if ai == AllowIncompleteYes(void) {
            // TODO: We could annotate this more precisely in ambiguous-single-match cases.
            annotate_info(x, IncompleteCheck(TeUnknown(void)));
            return true;
          } else {
            ERR(_u8("Name lookup for '"), lookup(es->im, a.ident.value), _u8("', maybe with parms, matches ambiguously."));
            return false;
          }
        }
        case &OneGlobalMatch(gi global_info): {
          if !ensure_def_inst_type_computed(es->cs, es->clq, ref_def_entry(es->cs, gi.ent), gi.inst) {
            return false;
          }
          inst *def_inst = ref_inst(es->cs, gi.inst);
          annotate_info(x, CompleteCheck(inst->computed_type));
          return true;
        }
        case &OneLocalMatch(v local_info): {
          vi *var_info = ref(&es->local_vars, v.varinfo_ix);
          annotate_info(x, CompleteCheck(vi->type));
          return true;
        }
      }
    }

    case &ParenExpr(a ast_paren_expr): {
      if !check_expr_ai(es, ai, oo(&a.expr), pt) {
        return false;
      }
      annotate_info(x, oo(&a.expr)->info);
      return true;
    }

    case &NumericLiteral(a ast_numeric_literal): {
      // TODO: Make this actually be an abstract numeric type.  (This is a temporary implementation so I can write some type-checking tests conveniently.)
      // TODO: The numeric value will need to be shown to be in range, too.
      return help_check_simple_literal(pt, primitive_i32_type(es->cs), _u8("numeric"), x);
    }

    case &BoolLiteral(a ast_bool_literal): {
      return help_check_simple_literal(pt, primitive_bool_type(es->cs), _u8("bool"), x);
    }

    case &VoidLiteral(a ast_void_literal): {
      return help_check_simple_literal(pt, primitive_void_type(es->cs), _u8("void"), x);
    }

    case &NullLiteral(a ast_null_literal): {
      return help_check_simple_literal(pt, pointer_to(es->cs, TeUnknown(void)), _u8("null"), x);
    }

    case &CharLiteral(a ast_char_literal): {
      // See NumericLiteral case.
      return TODO();
    }

    case &StringLiteral(a ast_string_literal): {
      // TODO: At some point we'll want string literals to be more compile-time-magical.  Right now they're of type [N]u8.  And we really want [N]<numeric>?
      type te_typeexpr = primitive_string_literal_type(es->cs, count(&a.charspecs));
      unified te_typeexpr;
      if !unify_types(pt, &type, &unified) {
        ERR(_u8("string literal in bad place"));
        return false;
      }
      annotate_info(x, CompleteCheck(type));
      return true;
    }
    case &Funcall(a ast_funcall): {
      return check_expr_funcall(es, ai, x, &a, pt);
    }
    case &IndexExpr(a ast_index_expr): {
      return check_expr_index(es, x, &a, pt);
    }
    case &Lambda(a ast_lambda): {
      // TODO: Cache type.
      type ast_typeexpr = lambda_declared_type(&es->cs->cym, &a);
      // TODO: Cache converted.
      converted te_typeexpr;
      if !convert_typeexpr(es->cs, &type, &converted) {
        return false;
      }
      // TODO: I see some duplicated logic with the TypedExpr case.
      computed_complete bool;
      computed te_typeexpr;
      if !check_and_compute_typeexpr(es->cs, es->clq, es->generics, es->parms, &converted, &computed, &computed_complete) {
        return false;
      }
      // Lambda exprs can't have partial types (yet!).
      check(computed_complete);
      unified te_typeexpr;
      if !unify_types(pt, &computed, &unified) {
        ERR(_u8("Lambda is incompatible with contextual type."));
        return false;
      }
      // TODO: We need to check that the parameter names are unique, and check the body.
      return TODO();
    }
    case &LocalField(a ast_local_field): {
      unknown te_typeexpr = TeUnknown(void);
      if !check_expr_ai(es, AllowIncompleteNo(void), oo(&a.lhs), &unknown) {
        return false;
      }
      type *te_typeexpr = expr_complete_type(oo(&a.lhs));
      fieldtype te_typeexpr;
      if !check_field(es->cs, type, &a.fieldname, pt, &fieldtype) {
        return false;
      }
      annotate_info(x, CompleteCheck(fieldtype));
      return true;
    }
    case &DerefField(a ast_deref_field): {
      // The fact that our partial type isn't a pointer type is deliberate.
      unknown te_typeexpr = TeUnknown(void);
      if !check_expr_ai(es, AllowIncompleteNo(void), oo(&a.lhs), &unknown) {
        return false;
      }
      type *te_typeexpr = expr_complete_type(oo(&a.lhs));
      param *te_typeexpr;
      if !decompose_typeapp(type, primitive_pointer_puretype(es->cs), &param) {
        ERR(_u8("Expected pointer for lhs of deref field"));
        return false;
      }
      fieldtype te_typeexpr;
      if !check_field(es->cs, param, &a.fieldname, pt, &fieldtype) {
        return false;
      }
      annotate_info(x, CompleteCheck(fieldtype));
      return true;
    }
    case &TypedExpr(a ast_typed_expr): {
      // TODO: Cache converted.
      converted te_typeexpr;
      if !convert_typeexpr(es->cs, &a.type, &converted) {
        return false;
      }
      computed_complete bool;
      computed te_typeexpr;
      if !check_and_compute_typeexpr(es->cs, es->clq, es->generics, es->parms, &converted, &computed, &computed_complete) {
        return false;
      }
      unified te_typeexpr;
      if !unify_types(pt, &computed, &unified) {
        ERR(_u8("TypedExpr is incompatible with contextual type."));
        return false;
      }
      if !check_expr_ai(es, ai, oo(&a.expr), &unified) {
        return false;
      }
      annotate_info(x, oo(&a.expr)->info);
      return true;
    }
    case &Strinit(a ast_strinit): {
      return TODO();
    }
  }
}

func decompose_typeapp(t *te_typeexpr, expected_puretype te_puretype, oneparam_out **te_typeexpr) bool {
  // This could be implemented in terms of unify_under_generics, you know.
  if case &TeApp(app te_typeapp) = t {
    unified te_puretype;
    if !unify_puretypes(oo(&app.typefunc), &expected_puretype, &unified) {
      return false;
    }
    if count(&app.params) != 1 {
      return false;
    }
    *oneparam_out = ref(&app.params, 0);
    return true;
  } else {
    return false;
  }
}

func check_field(cs *checkstate, t *te_typeexpr, a *ast_fieldname, pt *te_typeexpr, fieldtype_out *te_typeexpr) bool {
  return TODO();
}

func check_expr_funcall(es *exprscope, ai allow_incomplete, x *ast_expr, a *ast_funcall, pt *te_typeexpr) bool {
  a_param_incomplete bool;
  if !check_funcall_params_firsttime(es, &a->params, &a_param_incomplete) {
    return false;
  }

  funcexpr_ai allow_incomplete;
  if a_param_incomplete {
    funcexpr_ai = AllowIncompleteNo(void);
  } else {
    funcexpr_ai = AllowIncompleteYes(void);
  }

  func_pt te_typeexpr = make_fn_partial_type(es->cs, pt, &a->params);
  if !check_expr_ai(es, funcexpr_ai, oo(&a->fun), &func_pt) {
    return false;
  }

  if expr_type_incomplete(oo(&a->fun)) {
    check(ai == AllowIncompleteYes(void));
    annotate_info(x, IncompleteCheck(TeUnknown(void)));
    return true;
  }

  if a_param_incomplete {
    if !check_funcall_params_secondtime(es, expr_complete_type(oo(&a->fun)), &a->params) {
      return false;
    }
  }

  return_type *te_typeexpr = fn_return_type(expr_complete_type(oo(&a->fun)));
  annotate_info(x, CompleteCheck(*return_type));
  return true;
}

func check_funcall_params_firsttime(es *exprscope, params *array[ast_expr], a_param_incomplete_out *bool) bool {
  n size = count(params);
  unknown te_typeexpr = TeUnknown(void);
  all_params_complete bool = true;
  for i size = 0; i < n; i = i + 1 {
    expr *ast_expr = ref(params, i);
    if !check_expr_ai(es, AllowIncompleteYes(void), expr, &unknown) {
      return false;
    }
    all_params_complete = all_params_complete & expr_type_complete(expr);
  }
  *a_param_incomplete_out = !all_params_complete;
  return true;
}

func check_funcall_params_secondtime(es *exprscope, functype *te_typeexpr, params *array[ast_expr]) bool {
  n size = count(params);

  type_params *array[te_typeexpr];
  if case &TeApp(app te_typeapp) = functype {
    // TODO: Assert fn-type.
    type_params = &app.params;
    check(count(type_params) == n + 1);
  } else {
    ice(_u8("Expecting a TeApp for fn-type."));
  }

  for i size = 0; i < n; i = i + 1 {
    expr *ast_expr = ref(params, i);
    if !check_expr_ai(es, AllowIncompleteNo(void), expr, ref(type_params, i)) {
      return false;
    }
  }
  return true;
}

func check_expr_index(es *exprscope, x *ast_expr, a *ast_index_expr, pt *te_typeexpr) bool {
  unknown te_typeexpr = TeUnknown(void);
  if !check_expr_ai(es, AllowIncompleteNo(void), oo(&a->lhs), &unknown) {
    return false;
  }
  sizetype te_typeexpr = primitive_size_type(es->cs);
  if !check_expr_ai(es, AllowIncompleteNo(void), oo(&a->rhs), &sizetype) {
    return false;
  }

  ixtype *te_typeexpr;
  if !decompose_indexable(es->cs, expr_complete_type(oo(&a->lhs)), &ixtype) {
    ERR(_u8("indexing on non-indexable type"));
    return false;
  }
  // We passed AllowIncompleteNo for the lhs.
  check(is_complete(ixtype));

  unified te_typeexpr;
  if !unify_types(pt, ixtype, &unified) {
    ERR(_u8("index expr returns wrong type"));
  }

  annotate_info(x, CompleteCheck(unified));
  return true;
}

func decompose_indexable(cs *checkstate, t *te_typeexpr, out **te_typeexpr) bool {
  if decompose_typeapp(t, primitive_pointer_puretype(cs), out) {
    return true;
  }
  if decompose_arraytype(t, out) {
    return true;
  }
  return false;
}

func decompose_arraytype(t *te_typeexpr, out **te_typeexpr) bool {
  if case &TeArraytype(a te_arraytype) = t {
    *out = oo(&a.param);
    return true;
  } else {
    return false;
  }
}

func expr_type(a *ast_expr) te_typeexpr {
  switch &a->info {
    case &NoInfo(v void): {
      ice(_u8("expr_type sees NoInfo"));
      return fake();
    }
    case &IncompleteCheck(t te_typeexpr): {
      return t;
    }
    case &CompleteCheck(t te_typeexpr): {
      return t;
    }
  }
}

func expr_complete_type(a *ast_expr) *te_typeexpr {
  if case &CompleteCheck(t te_typeexpr) = &a->info {
    return &t;
  } else {
    ice(_u8("expr_complete_type sees... not a complete type"));
    return fake();
  }
}

func expr_type_complete(a *ast_expr) bool {
  switch &a->info {
    case &NoInfo(v void): {
      ice(_u8("expr_type_complete sees NoInfo"));
      return fake();
    }
    case &IncompleteCheck(t te_typeexpr): { return false; }
    case &CompleteCheck(t te_typeexpr): { return true; }
  }
}


func expr_type_incomplete(a *ast_expr) bool {
  return !expr_type_complete(a);
}

func make_fn_partial_type(cs *checkstate, return_type *te_typeexpr, params *array[ast_expr]) te_typeexpr {
  type_params array[te_typeexpr];
  n size = count(params);
  for i size = 0; i < n; i = i + 1 {
    push(&type_params, expr_type(ref(params, i)));
  }
  push(&type_params, *return_type);
  return TeApp({embox(primitive_function_puretype(cs)), type_params, None()});
}

func fn_return_type(func_type *te_typeexpr) *te_typeexpr {
  if case &TeApp(app te_typeapp) = func_type {
    // TODO: Assert fn-type.
    n size = count(&app.params);
    check(n > 0);
    return ref(&app.params, n - 1);
  } else {
    ice(_u8("Expected TeApp for fn-type in fn_return_type."));
    return fake();
  }
}
