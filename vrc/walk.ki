import ast;
import expr;

// We have a set of lifetimes that pop in and out of existence over time.  They all have interesting state that needs to be tracked.  We want to chase state through everything.

// How should we represent state?  We've got facts.  A big bag of facts.  Okay then.  I hope they aren't self-contradictory!

struct walkdesc {
  facts array[te_statedesc];
};

// There's just one of these (for any given walk).
struct walkstate {
  bs *bodystate;
  es *framescope;
  ds *defscope;
  clq *clqueue;
  cs *checkstate;
  im *identmap;

  current_desc walkdesc;
};

func mk(bs *bodystate) walkstate {
  ret walkstate = {bs, &bs->es, bs->ds, bs->clq, bs->cs, bs->im, {mk_array()}};
  return ret;
}

// computed_params is the fn[...] params (including return type and transdesc)
func walk_lambda_state(bs *bodystate, computed_params *shray[te_typeexpr], a *ast_lambda) np {
  ws walkstate = mk(bs);

  nargs size = count(&a->args);
  for i size = 0; i < nargs; i++ {
    vn var_number = *un(&ref(&a->args, i)->vn);
    vi *var_info = ref_var(&bs->es, vn);
    // Okay, and?
  }

  if case Printed(pm) = walk_body(&ws, &a->body.bb) {
    return Printed(pm);
  }

  // TODO(): Something must be done.
  return NoFail;
}

func walk_body(ws *walkstate, a *ast_bracebody) np {
  nstatements size = count(&a->statements);
  for i size = 0; i < nstatements; i++ {
    s *ast_statement = ref(&a->statements, i);
    if case Printed(pm) = walk_statement(ws, s) {
      return Printed(pm);
    }
  }
  if case Printed(pm) = walk_var_destructions(ws, &un(&a->info)->destructions) {
    return Printed(pm);
  }
  // TODO(): Cycle back?
  return NoFail;
}

func walk_statement(ws *walkstate, a *ast_statement) np {
  switch &a->u {
  case &Expr(b ast_expr_discard):
    if case Printed(pm) = walk_discard_expr(ws, &b) {
      return Printed(pm);
    }

  case &Return(b ast_return_statement):
    // TODO(): We should only keep going _past_ the return statement in order to look for dirty markings.
    if case Printed(pm) = walk_return_statement(ws, &b) {
      return Printed(pm);
    }

  case &Var(b ast_var_statement):
    if case Printed(pm) = walk_var_statement(ws, &b) {
      return Printed(pm);
    }

  case &IfThen(b ast_ifthen_statement):
    if case Printed(pm) = walk_ifthen_statement(ws, &b) {
      return Printed(pm);
    }

  case &IfThenElse(b ast_ifthenelse_statement):
    if case Printed(pm) = walk_ifthenelse_statement(ws, &b) {
      return Printed(pm);
    }

  case &While(b ast_while_statement):
    if case Printed(pm) = walk_while_statement(ws, &b) {
      return Printed(pm);
    }

  case &For(b ast_for_statement):
    if case Printed(pm) = walk_for_statement(ws, &b) {
      return Printed(pm);
    }

  case &Switch(b ast_switch_statement):
    if case Printed(pm) = walk_switch_statement(ws, &b) {
      return Printed(pm);
    }

  case &Break(b ast_break_statement):
    if case Printed(pm) = walk_break_statement(ws, &b) {
      return Printed(pm);
    }

  case &Continue(b ast_continue_statement):
    if case Printed(pm) = walk_continue_statement(ws, &b) {
      return Printed(pm);
    }

  case &Label(b ast_label_statement):
    if case Printed(pm) = walk_label_statement(ws, &b) {
      return Printed(pm);
    }

  case &Goto(b ast_goto_statement):
    if case Printed(pm) = walk_goto_statement(ws, &b) {
      return Printed(pm);
    }
  }

  return NoFail;
}

func walk_goto_statement(ws *walkstate, a *ast_goto_statement) np {
  // NOTE: We should think about how we do our variable unwindings (and in particular, windings).  We could overlap with other variable unwindings/windings, heading towards the same label.  Should we overlap the typestate, too?  For now, the answer is, nah.

  return TODO();
}

func walk_pattern_assign(ws *walkstate, a *ast_pattern_assign) np {
  if case Printed(pm) = walk_expr_consume(ws, oo(&a->rhs)) {
    return Printed(pm);
  }
  // TODO(): That's it?  Do some tag cell / enum cell / deref cell logic?
  return NoFail;
}

func walk_condition(ws *walkstate, a *ast_condition) np {
  switch a {
  case &ExprCondition(b box[ast_expr_consume]):
    return walk_expr_consume(ws, oo(&b));
  case &PatternCondition(b ast_pattern_assign):
    return walk_pattern_assign(ws, &b);
  }
}

func walk_condition_discard(ws *walkstate, a *ast_condition_discard_info) np {
  if case &Has(c cell_num) = un(&a->virtual_cell_dead) {
    // TODO(): What is this, and how the heck do we handle this?
  }
  if case Printed(pm) = walk_later_discard_info(ws, &a->later) {
    return Printed(pm);
  }
  return NoFail;
}

func walk_ifthen_statement(ws *walkstate, a *ast_ifthen_statement) np {
  // TODO(): Connect condition discard, and body, correctly.
  // TODO(): Cycle correctly.
  if case Printed(pm) = walk_condition(ws, &a->condition) {
    return Printed(pm);
  }
  if case Printed(pm) = walk_body(ws, &a->body) {
    return Printed(pm);
  }
  if case Printed(pm) = walk_condition_discard(ws, &a->condition_discard) {
    return Printed(pm);
  }
  return NoFail;
}

func walk_ifthenelse_statement(ws *walkstate, a *ast_ifthenelse_statement) np {
  // TODO(): Connect condition discard, and body, correctly.  (Discard before/after elsebody correctly.)
  // TODO(): Cycle correctly.
  // TODO(): Walk condition correctly.
  if case Printed(pm) = walk_condition(ws, &a->condition) {
    return Printed(pm);
  }
  if case Printed(pm) = walk_body(ws, &a->thenbody) {
    return Printed(pm);
  }
  if case Printed(pm) = walk_body(ws, &a->elsebody) {
    return Printed(pm);
  }
  if case Printed(pm) = walk_condition_discard(ws, &a->condition_discard) {
    return Printed(pm);
  }
  return NoFail;
}

func walk_while_statement(ws *walkstate, a *ast_while_statement) np {
  // TODO(): Connect the condition discards, and body, correctly.
  // TODO(): Cycle correctly.
  if case Printed(pm) = walk_condition(ws, &a->condition) {
    return Printed(pm);
  }
  if case Printed(pm) = walk_body(ws, &a->body) {
    return Printed(pm);
  }
  if case Printed(pm) = walk_condition_discard(ws, &a->condition_discard_continue) {
    return Printed(pm);
  }
  if case Printed(pm) = walk_condition_discard(ws, &a->condition_discard_exit) {
    return Printed(pm);
  }
  return NoFail;
}

func walk_for_statement(ws *walkstate, a *ast_for_statement) np {
  // TODO(): Connect the condition discard, body, etc, correctly.
  // TODO(): Cycle correctly.
  if case &Has(b box[ast_statement]) = &a->initializer {
    if case Printed(pm) = walk_statement(ws, oo(&b)) {
      return Printed(pm);
    }
  }
  if case &Has(b ast_expr_condition) = &a->condition {
    // TODO(): Uh.. walk b.discard more properly.
    if case Printed(pm) = walk_expr_consume(ws, oo(&b.expr)) {
      return Printed(pm);
    }
    if case Printed(pm) = walk_later_discard_info(ws, &b.discard) {
      return Printed(pm);
    }
  }
  if case &Has(b box[ast_expr_discard]) = &a->increment {
    if case Printed(pm) = walk_discard_expr(ws, oo(&b)) {
      return Printed(pm);
    }
  }

  if case Printed(pm) = walk_body(ws, &a->body) {
    return Printed(pm);
  }
  return NoFail;
}

func walk_switch_statement(ws *walkstate, a *ast_switch_statement) np {
  // TODO(): Cycle properly.
  // TODO(): Connect switch cases properly, swartch discard.
  // TODO(): Handle default case/swartch discard properly.
  if case Printed(pm) = walk_expr_consume(ws, oo(&a->swartch)) {
    return Printed(pm);
  }
  // TODO(): Process swartch deconstruction info / tag cell properly?
  ncases size = count(&a->cases);
  for i size = 0; i < ncases; i++ {
    cas *ast_switch_case = ref(&a->cases, i);
    // TODO(): Process case pattern... somehow.
    if case Printed(pm) = walk_body(ws, &cas->body) {
      return Printed(pm);
    }
  }

  if case Printed(pm) = walk_later_discard_info(ws, &a->swartch_discard) {
    return Printed(pm);
  }

  return NoFail;
}

func walk_break_statement(ws *walkstate, a *ast_break_statement) np {
  return TODO();
}

func walk_continue_statement(ws *walkstate, a *ast_continue_statement) np {
  return TODO();
}

func walk_label_statement(ws *walkstate, a *ast_label_statement) np {
  return TODO();
}

func walk_discard_expr(ws *walkstate, a *ast_expr_discard) np {
  if case Printed(pm) = walk_expr(ws, &a->expr) {
    return Printed(pm);
  }
  if case Printed(pm) = walk_expr_after_discard(ws, un(&a->after)) {
    return Printed(pm);
  }
  // TODO(): Something must be done?
  return NoFail;
}

func walk_expr(ws *walkstate, a *ast_expr) np {
  switch &a->u {
  case &NameExpr(b ast_name_expr):
    return TODO();
  case &ParenExpr(b ast_paren_expr):
    return walk_expr(ws, oo(&b.expr));
  case &NumericLiteral(b ast_numeric_literal):
    return TODO();
  case &BoolLiteral(b ast_bool_literal):
    return TODO();
  case &VoidLiteral(b ast_void_literal):
    return TODO();
  case &NullLiteral(b ast_null_literal):
    return TODO();
  case &CharLiteral(b ast_char_literal):
    return TODO();
  case &StringLiteral(b ast_string_literal):
    return TODO();
  case &Funcall(b ast_funcall):
    nparams size = count(&b.params);
    for i size = 0; i < nparams; i++ {
      if case Printed(pm) = walk_expr_consume(ws, ref(&b.params, i)) {
        return Printed(pm);
      }
    }
    // TODO: Handle funcall state.
    return TODO();
  case &LogicalConjunction(b ast_logical_conjunction):
    // TODO(): Connect premature return/postmature return.  (And isn't there a lhs discard / move op?)
    if case Printed(pm) = walk_expr_consume(ws, oo(&b.lhs)) {
      return Printed(pm);
    }
    if case Printed(pm) = walk_expr_consume(ws, oo(&b.rhs)) {
      return Printed(pm);
    }
    return TODO();
  case &Assignment(b ast_assignment):
    return walk_assignment(ws, &b);
  case &RefOf(b ast_refof):
    if case Printed(pm) = walk_expr(ws, oo(&b.rhs)) {
      return Printed(pm);
    }
    // TODO: idk.
    return TODO();
  case &AddressOf(b ast_addressof):
    if case Printed(pm) = walk_expr(ws, oo(&b.rhs)) {
      return Printed(pm);
    }
    // TODO: idk.
    return TODO();
  case &Deref(b ast_deref):
    if case Printed(pm) = walk_expr_consume(ws, oo(&b.rhs)) {
      return Printed(pm);
    }
    // TODO(): Handle pointer discard.
    return TODO();
  case &IndexExpr(b ast_index_expr):
    if case Printed(pm) = walk_expr(ws, oo(&b.lhs)) {
      return Printed(pm);
    }
    if case Printed(pm) = walk_expr_consume(ws, oo(&b.rhs)) {
      return Printed(pm);
    }
    // TODO(): idk.
    return TODO();
  case &Lambda(b ast_lambda):
    return TODO();
  case &LocalField(b ast_local_field):
    if case Printed(pm) = walk_expr(ws, oo(&b.lhs)) {
      return Printed(pm);
    }
    // TODO: idk.
    return TODO();
  case &DerefField(b ast_deref_field):
    if case Printed(pm) = walk_expr_consume(ws, oo(&b.lhs)) {
      return Printed(pm);
    }
    // TODO(): Handle pointer discard.
    return TODO();
  case &TypedExpr(b ast_typed_expr):
    return walk_expr(ws, oo(&b.expr));
  case &Strinit(b ast_strinit):
    nexprs size = count(&b.exprs);
    for i size = 0; i < nexprs; i++ {
      if case Printed(pm) = walk_strinit_param(ws, ref(&b.exprs, i)) {
        return Printed(pm);
      }
    }
    // TODO: idk.  Activate something?
    return TODO();
  case &Ternary(b ast_ternary):
    // TODO(): Connect entry and exit of cases properly.
    if case Printed(pm) = walk_expr_consume(ws, oo(&oo(&b.condition)->expr)) {
      return Printed(pm);
    }
    if case Printed(pm) = walk_expr_consume(ws, oo(&b.then_clause)) {
      return Printed(pm);
    }
    if case Printed(pm) = walk_expr_consume(ws, oo(&b.else_clause)) {
      return Printed(pm);
    }
    // TODO(): Make sure condition discard happens before/after then/else clauses, correctly.
    if case Printed(pm) = walk_later_discard_info(ws, &oo(&b.condition)->discard) {
      return Printed(pm);
    }
    return TODO();
  }
}

func walk_assignment_info(ws *walkstate, a *ast_assignment_info) np {
  // NOTE(): This all makes sense, right?
  switch a {
  case &StaticSelfAssignment:
    return NoFail;
  case &SimpleMoveAssignment(b ast_simple_move_assignment_info):
    if case Printed(pm) = walk_destroy_action(ws, &b.target_destroy) {
      return Printed(pm);
    }
    if case Printed(pm) = walk_move_action(ws, &b.rhs_move) {
      return Printed(pm);
    }
    return NoFail;
  case &SimpleCopyDestroyAssignment(b ast_simple_copydestroy_assignment_info):
    if case Printed(pm) = walk_destroy_action(ws, &b.target_destroy) {
      return Printed(pm);
    }
    if case Printed(pm) = walk_copy_action(ws, &b.rhs_copy) {
      return Printed(pm);
    }
    if case Printed(pm) = walk_destroy_action(ws, &b.rhs_cleanup) {
      return Printed(pm);
    }
    return NoFail;
  case &SimpleCopyAssignment(b ast_simple_copy_assignment_info):
    if case Printed(pm) = walk_destroy_action(ws, &b.target_destroy) {
      return Printed(pm);
    }
    if case Printed(pm) = walk_copy_action(ws, &b.rhs_copy) {
      return Printed(pm);
    }
    // TODO(): Do we do anything with rhs_deadme?  No?
    return NoFail;
  case &ConditionalAssignment(b ast_conditional_assignment_info):
    // TODO(): We're missing the conditional operation entirely.  This needs to get celled and lifetimed out like anything else (the way it used to be, instead of just being an instpair).

    if case Printed(pm) = walk_destroy_action(ws, &b.conditional_destroy) {
      return Printed(pm);
    }
    if case Printed(pm) = walk_copy_action(ws, &b.conditional_copy) {
      return Printed(pm);
    }
    // TODO(): Do we do anything with rhs_deadme?  No?
    return TODO();
  }
}

func walk_assignment(ws *walkstate, a *ast_assignment) np {
  if case Printed(pm) = walk_expr(ws, oo(&a->lhs)) {
    return Printed(pm);
  }
  if case Printed(pm) = walk_expr(ws, oo(&a->rhs)) {
    return Printed(pm);
  }
  if case Printed(pm) = walk_assignment_info(ws, un(&a->info)) {
    return Printed(pm);
  }
  return NoFail;
}

func walk_later_discard_info(ws *walkstate, a *ast_later_discard_info) np {
  return walk_destroy_action(ws, un(&a->action));
}

func walk_strinit_param(ws *walkstate, a *ast_strinit_param) np {
  return walk_expr_consume(ws, &a->ec);
}

func walk_expr_consume(ws *walkstate, a *ast_expr_consume) np {
  if case Printed(pm) = walk_expr(ws, &a->expr) {
    return Printed(pm);
  }
  if case Printed(pm) = walk_expr_after_consume(ws, un(&a->after)) {
    return Printed(pm);
  }
  // TODO: idk.
  return TODO();
}

func walk_expr_after_discard(ws *walkstate, a *ast_expr_after_discard) np {
  switch a {
  case &DiscardTemporary(act destroy_action):
    return walk_destroy_action(ws, &act);
  case &DiscardVirtualDead(c cell_num):
    // TODO: idk.
    return TODO();
  case &DiscardNothing:
    // TODO(): How does this case exist?
    return NoFail;
  }
}

func walk_expr_after_consume(ws *walkstate, a *ast_expr_after_consume) np {
  switch &a->actions {
  case &ConsumeByInPlace:
    return NoFail;
  case &ConsumeByCopyDestroy(act copy_destroy_action):
    if case Printed(pm) = walk_copy_action(ws, &act.copy) {
      return Printed(pm);
    }
    if case Printed(pm) = walk_destroy_action(ws, &act.destroy) {
      return Printed(pm);
    }
    return NoFail;
  case &ConsumeByCopy(act tup[copy_action, lval_deadme]):
    if case Printed(pm) = walk_copy_action(ws, &act.car) {
      return Printed(pm);
    }
    // TODO(): Handle lval_deadme.
    return TODO();
  }
}

func walk_return_statement(ws *walkstate, a *ast_return_statement) np {
  if case &Has(b box[ast_expr_consume]) = &a->expr {
    if case Printed(pm) = walk_expr_consume(ws, oo(&b)) {
      return Printed(pm);
    }
  } else {
    // TODO(): Model assignment of void to return cell.
  }

  // TODO(): We exit the function, also we have a->destructions.
  return TODO();
}

func walk_var_statement(ws *walkstate, a *ast_var_statement) np {
  switch &a->rhs {
  case &HasExpr(b box[ast_expr_consume]):
    if case Printed(pm) = walk_expr_consume(ws, oo(&b)) {
      return Printed(pm);
    }
  case &AutoInit(act opt[init_action]):
    // TODO(): Why is act optional?  Should it be nc?
    return TODO();
  }

  // TODO: idk.
  return TODO();
}

func walk_copy_action(ws *walkstate, a *copy_action) np {
  return TODO();
}

func walk_move_action(ws *walkstate, a *move_action) np {
  return TODO();
}

func walk_destroy_action(ws *walkstate, a *destroy_action) np {
  return TODO();
}

// "a" is in variable declaration order -- the _opposite_ of destruction order.
func walk_var_destructions(ws *walkstate, a *array[var_destruction]) np {
  n size = count(a);
  for i size = count(a); i > 0; {
    i--;
    if case Printed(pm) = walk_var_destruction(ws, ref(a, i)) {
      return Printed(pm);
    }
  }
  return NoFail;
}

func walk_var_destruction(ws *walkstate, a *var_destruction) np {
  switch a {
  case &VarSelfContainedDestruction(da destroy_action):
    return walk_destroy_action(ws, &da);
  case &VarVirtualCellDead(c cell_num):
    // TODO(): Mark cell/lifetime deceased?
    return TODO();
  }
}
