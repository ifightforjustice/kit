import state;

/* We need to figure out what cell is what.

In a function body, cells fit in exactly ONE leaf node of this tree of categories:

 - subcells of some other cell
   - constant offset subcells
   - computed offset subcells -- location depends on another cell
 - not a subcell
   - static cells -- these can be statically located, have a static lifetime
     - outer cells -- pre-existing, locations taken as given
    //  - globals (these do not exist yet)
        - outer func paramlist & return cell
     - paramlist cells -- part of a func paramlist in GrApply
     - free cells -- temporaries, variables, we can locate them anywhere in the stack frame.
   - deref cells -- formed by dereferencing a pointer

Some more definitions:
 - A cell is "statically locatable" if it is a static cell or a constant offset subcells of a statically locatable cell.
 - "Statlocat" is an abbrevation for "statically locatable."
 - A cell is "derefalike" if it is a deref cell or a subcell of a derefalike cell.

We should find that some restrictions are upheld:

 - subcells are always subcells of exactly one cell, declared in exactly one node.  hell, every cell is sort of defined by exactly one node.
 - computed offset subcells' location cells must be statlocat.
 - GrApply return cells must be statlocat (for now).
 - paramlist cells can only be part of one func paramlist.
*/

/* What we want to do:

  At a minimum, we want to know whether a cell is a paramlist cell, and what paramlist it's part of.
*/

deftype subcell_disp struct {
  subcell_opnum gr_num;
  partof cell_num;
  offset gr_offset;
};

defenum cell_const_disp {
  NoConstDisp void;
  HasConstValue gr_const;
  NotConst void;
};

deftype cell_disp struct {
  // If the cell's part of a function param list, tells what paramlist it's part of.
  paramlist opt[gr_num];
  // If the cell's a funcell of a GrApply, tells what paramlist it's applying.
  funcell opt[gr_num];
  // If the cell's a subcell of another, tells what it's a subcell of.
  subcell opt[subcell_disp];
  // If the cell has a constant value.  (Must be a static cell.)
  const_value cell_const_disp;

  // Which cells are subcells of this one.
  subcelled array[cell_num];
};

deftype basic_analyze_state struct {
  paramlists array[gr_num];
  celldisp array[cell_disp];
};

func basic_analyze_fn_body(cs *checkstate, g *graphed_fn_body, bas_out *basic_analyze_state) bool {
  bas basic_analyze_state = {
    mk_array@[gr_num](),
    repeat(count(&g->graph.gr.cells), {None(), None(), None(), NoConstDisp(void), mk_array@[cell_num]()})
  };

  if !help_basic_analyze(cs, &bas, &g->graph.gr) {
    return false;
  }

  // TODO: Check mutual exclusivity of celldisps -- cells can't be certain combinations of things.

  *bas_out = bas;
  return true;
}

func help_basic_analyze(cs *checkstate, bas *basic_analyze_state, gr *frame_graph) bool {
  n_ops size = count(&gr->ops);
  for i size = 0; i < n_ops; i = i + 1 {
    gn gr_num = ~i;
    node *gr_node = ref(&gr->ops, i);
    switch &node->op {
    case &GrApply(a gr_apply):
      push(&bas->paramlists, ~i);
      funcell_cd *cell_disp = ref(&bas->celldisp, a.funcell.~);
      if case &Has(other_gn gr_num) = &funcell_cd->funcell {
        ice(_u8("two-timing funcell "), a.funcell.~, _u8(" for "), other_gn.~, _u8(" and "), i);
      } else {
        funcell_cd->funcell = Has(gn);
      }
      nparams size = count(&a.params);
      for j size = 0; j < nparams; j = j + 1 {
        mark_cell_paramlist(bas, get(&a.params, j), gn);
      }
      mark_cell_not_const(bas, a.retcell);
    case &GrPrimApply(a gr_prim_apply):
      // TODO: Dedup.
      push(&bas->paramlists, ~i);
      nparams size = count(&a.params);
      for j size = 0; j < nparams; j = j + 1 {
        mark_cell_paramlist(bas, get(&a.params, j), gn);
      }
      mark_cell_not_const(bas, a.retcell);
    case &GrMemCopy(a gr_memcopy):
      mark_cell_not_const(bas, a.dest);
    case &GrWriteConst(a gr_writeconst):
      if case LocationStatic(v void) = ref(&gr->cells, a.dest.~)->location {
        disp *cell_const_disp = &ref(&bas->celldisp, a.dest.~)->const_value;
        switch disp {
        case &NoConstDisp(v2 void):
          *disp = HasConstValue(a.value);
        case &HasConstValue(gc gr_const):
          *disp = NotConst(void);
        case &NotConst(v2 void): { }
        }
      }
    case &GrAddressof(a gr_addressof):
      // If this is the address of a static cell, the value is actually const.  But we ignore that possibility.
      mark_cell_not_const(bas, a.dest);
    case &GrSubcell(a gr_subcell):
      set(&ref(&bas->celldisp, a.name.~)->subcell, {gn, a.partof, a.offset});
      push(&ref(&bas->celldisp, a.partof.~)->subcelled, a.name);
      check(ref(&gr->cells, a.name.~)->location == LocationVirtual(void));
    default: { }
    }
  }
  return true;
}

func mark_cell_paramlist(bas *basic_analyze_state, c cell_num, apply_opnum gr_num) void {
  p *cell_disp = ref(&bas->celldisp, c.~);
  set(&p->paramlist, apply_opnum);
}

func mark_cell_not_const(bas *basic_analyze_state, c cell_num) void {
  ref(&bas->celldisp, c.~)->const_value = NotConst(void);
}