import bar;
import string;

export def foo i32 = ~(1u);

func fac(x i32) i32 {
  var acc i32 = 1;
  for var i i32 = x; i > 0; i = i - 1 {
    acc = acc * i;
  }
  return acc;
}

deftype ty struct {
  x i32;
  y i32;
};

func[T] getsize() u32 {
  return sizeof@[T];
}

defclass kla struct {
  x u32;
  y u32;
};

access kla {
  func do_destroy(p *kla) void {
    p->x = 0u;
    p->y = 0u;
  }
  func do_init(p *kla) void {
    p->x = 37u;
    p->y = 47u;
  }

  func do_copy(a *kla, c *kla) void {
    a->x = c->x;
    a->y = c->y;
  }

  func expose(p *kla) struct { x u32; y u32; } {
    return p->~;
  }
}

func call_kla(x kla) void {
  print(expose(&x).x);
  putchar(32);
  print(expose(&x).y);
  putchar(10);
}

func try_kla() void {
  var k kla;
  var l struct { x u32; y u32; } = expose(&k);
  print(l.x);
  putchar(32);
  print(l.y);
  putchar(10);
  call_kla(k);
}

defenum enty {
  c1 void;
  c2 struct { p i32; q i32; };
  c3 string;
};

def blah_enty = func(x enty) enty {
  var v void;
  var y enty = c1(v);
  var u struct { p i32; q i32; };
  y = c2(u);
  switch x {
    case c1(a void): {
      var s string = lits("c1 (void)\n");
      print(&s);
    }
    case c2(a): {
      var s string = lits("c2 ... ");
      print(&s);
      print(@[u32]~a.p);
      putchar(32);
      print(@[u32]~a.q);
      putchar(10);
    }
    case c3(a string): {
      print(&a);
    }
  }
  return y;
};

// This could be func au8(p *string, x u8) void but
// we demo statically evaluated lambdas.
def au8 fn[*string, u8, void] = func(p *string, x u8) void {
  return append(p, x);
};

def try_string = func() void {
  var x = lits("Hello, world!\n");
  print(&x);
};

export func showfacs(p *ty, num *u16) ty {
  try_kla();
  try_string();

  var v void;
  var k enty = blah_enty(c1(v));
  var vz struct { p i32; q i32; };
  vz.p = 125;
  vz.q = 343;
  blah_enty(c2(vz));
  blah_enty(c3(lits("just another string\n")));

  var ret ty;
  p->x = -5;
  p->y = fac(7);
  p->x = -p->x;

  var tmp u32 = ~fac(p->x);
  var y u32 = ~(*p).y;
  print(tmp);
  putchar(10);
  print(y);
  putchar(10);

  var yptr *i32 = &p->y;
  *yptr = 77;
  var xptr *i32 = &p->x;
  xptr[0] = 99;

  p[1].x = 33;
  *num = ~29;
  p[1].y = ~(@[u16]~22 + @[u16]~44);

  var heh [2]ty;
  heh[0] = p[1];
  heh[0].x = ^34;
  p[1] = heh[0];

  var void_value void;

  var naked struct { x i32; y i32; };
  naked.x = p->x;
  naked.y = ~getsize@[ty]();

  ret.~ = naked;
  return ret;
}

def u8_value u8 = ~3;
