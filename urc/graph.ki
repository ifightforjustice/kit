import check;

struct frame_graph {
  informal_name sym;
  cells array[cell_info];
  ops array[gr_node];
};

struct cell_num { x size; };

def `~` fn[size, cell_num] = wrapconvert;
def `==` fn[cell_num, cell_num, bool] = wrapequate;
func `!=`(x cell_num, y cell_num) bool { return x.x != y.x; }
func `<`(x cell_num, y cell_num) bool { return x.x < y.x; }
func[H] build_u8str(help H, r *array[u8], c *cell_num) void {
  build_u8str(help, r, &c->x);
}
inline func hash_compute_hash(x *cell_num) osize {
  return hash_compute_hash(&x->x);
}
inline func hash_equal(x *cell_num, y *cell_num) bool {
  return x->x == y->x;
}

/* A cell location is tricky: the location of an expr's return value
is defined both by the expr itself and the context it's found
in. Location should be specified when:

   - for lvalues, whenever we create the cell (by calling add_cell) for the lvalue.
   - for rvalues, when we annotate the disposal for the rvalue.
*/

enum cell_location {
  // The "cell" is actually caused by dereferencing something, or maybe accessing something's field?
  LocationVirtual void;
  LocationStatic void;
};

func `==`(x cell_location, y cell_location) bool {
  return enumnum(&x) == enumnum(&y);
}

func `!=`(x cell_location, y cell_location) bool {
  return enumnum(&x) != enumnum(&y);
}

func isLocationStatic(location cell_location) bool {
  switch location {
  case LocationVirtual: return false;
  case LocationStatic: return true;
  }
}

struct cell_info {
  // Location must be specified by type-checking, but it spends time in an unspecified state.
  location cell_location;
  type cu_typeexpr;
  props type_properties;
};

func location(info *cell_info) cell_location {
  return info->location;
}

// To "evaluate" an op, first we evaluate its precs (in unspecified order), then we ealuate the op.
enum gr_node {
  XOp gr_xnode;
  QOp gr_qnode;
};

struct gr_xnode {
  precs shray[gr_num];
  op gr_xop;
};

struct gr_qnode {
  op gr_qop;
};

struct gr_num { x size; };
def `~` fn[size, gr_num] = wrapconvert;
func `==`(x gr_num, y gr_num) bool { return x.x == y.x; }
func `!=`(x gr_num, y gr_num) bool { return x.x != y.x; }
func `<`(x gr_num, y gr_num) bool { return x.x < y.x; }
inline func hash_compute_hash(n *gr_num) osize {
  return hash_compute_hash(&n->x);
}
inline func hash_equal(x *gr_num, y *gr_num) bool {
  return x->x == y->x;
}

struct sq_num { x gr_num; };
def `~` fn[gr_num, sq_num] = wrapconvert;

enum gr_xop {
  GrApply gr_apply;
  GrPrimApply gr_prim_apply;
  GrMemCopy gr_memcopy;
  GrWriteConst gr_writeconst;
  GrAddressof gr_addressof;
  GrDeref gr_deref;
  GrSubcell gr_subcell;
  GrLive gr_live;
  GrAssertLive gr_assert_live;
  GrDead gr_dead;
  GrVirtualDead gr_virtual_dead;
  GrXNop void;
  // A debugging xop for compiler devs.
};

enum gr_qop {
  GrBranch gr_branch;
  GrSequence gr_sequence;
  GrJmp gr_jmp;
  GrQNop void;
};

// TODO: What's the deal with informal_name and the incomplete_graph's informal name?
func init_frame_graph_from_incomplete(incomplete_graph *opt[frame_graph]) frame_graph {
  incomplete *frame_graph = unHas(incomplete_graph);
  ret frame_graph = move(incomplete);
  *incomplete_graph = None;
  return ret;
}

func init_frame_graph_empty(informal_name sym) frame_graph {
  return {informal_name, mk_array@[cell_info](), mk_array@[gr_node]()};
}

func add_cellp(gr *frame_graph, info *cell_info) cell_num {
  num cell_num = ~count(&gr->cells);
  pushref(&gr->cells, info);
  return num;
}

inline func add_cell(gr *frame_graph, info cell_info) cell_num {
  return add_cellp(gr, &info);
}

func help_add_node(gr *frame_graph, node gr_node) gr_num {
  ret gr_num = ~count(&gr->ops);
  pushref(&gr->ops, &node);
  return ret;
}

func addx(gr *frame_graph, precs shray[gr_num], op gr_xop) gr_num {
  return help_add_node(gr, @[gr_node]XOp({precs, op}));
}

func addx(gr *frame_graph, op gr_xop) gr_num {
  return help_add_node(gr, @[gr_node]XOp({mk_shray(), op}));
}

func addx(gr *frame_graph, prec gr_num, op gr_xop) gr_num {
  return seq2(gr, prec, addx(gr, op)).x;
}

func addq(gr *frame_graph, op gr_qop) sq_num {
  return ~help_add_node(gr, @[gr_node]QOp({op}));
}

func mut_qnop_node(gr *frame_graph, ix sq_num, newnode gr_qnode) void {
  node *gr_node = ref_node(gr, ix.x);
  switch node {
  case &XOp(xn gr_xnode):
    ice(_u8("mut_qnop_node sees XOp"));
  case &QOp(qn gr_qnode):
    if case &GrQNop = &qn.op {
      *node = QOp(newnode);
    } else {
      ice(_u8("mut_qnop_node sees non-nop node"));
    }
  }
}

inline func ref_cell(gr *frame_graph, c cell_num) *cell_info {
  return ref(&gr->cells, c.x);
}

inline func ref_node(gr *frame_graph, gn gr_num) *gr_node {
  return ref(&gr->ops, gn.x);
}

struct gr_apply {
  funcell cell_num;
  params shray[cell_num];
  retcell cell_num;
};

struct gr_prim_apply {
  primop primitive_op;
  params shray[cell_num];
  retcell cell_num;
};

struct gr_memcopy {
  dest cell_num;
  src cell_num;
};

struct gr_writeconst {
  dest cell_num;
  value gr_const;
};

struct gr_addressof {
  dest cell_num;
  addressee cell_num;
};

struct gr_deref {
  name cell_num;
  pointer cell_num;
  offset gr_offset;
};

struct gr_subcell {
  name cell_num;
  partof cell_num;
  offset gr_offset;
};

enum gr_offset {
  OffsetConst u32;
  OffsetComputed tup[u32, cell_num];
};

struct gr_branch {
  src cell_num;
  cases shray[tup[gr_const, sq_num]];
  default_case opt[sq_num];
};

struct gr_sequence {
  first gr_num;
  second sq_num;
};

struct gr_jmp {
  next sq_num;
};

// Declares a cell to be live.  The cell may not have previously been live.  The cell location must be static -- otherwise, gr_deref or gr_subcell will make the cell live.
struct gr_live {
  cell cell_num;
};

struct gr_assert_live {
  cell cell_num;
};

struct gr_dead {
  cell cell_num;
};

struct gr_virtual_dead {
  cell cell_num;
};

enum gr_const {
  ConstInt bigint;
  ConstDef instpair;
  ConstFnBody fn_body_id;
  ConstBytes shray[u8];
};

struct fullbody_state {
  // all_vars and labels is from the ast_fullbody_info.
  // We use the cell field, to know the name of the var's cell.
  all_vars array[var_info];

  final_node sq_num;
  // count(&label_gn) == count(&info->labels), they start off as nop nodes until we see the label.
  label_gn array[sq_num];
  // Cells that are used as return cells.
  return_cells array[cell_num];
};

func nopq(gr *frame_graph) sq_num {
  return addq(gr, GrQNop);
}

func seqq(gr *frame_graph, gsq gr_sequence) sq_num {
  return addq(gr, GrSequence(gsq));
}

func seq1(gr *frame_graph, gn gr_num) sq_num {
  return seqq(gr, {gn, nopq(gr)});
}

func seq2(gr *frame_graph, gn1 gr_num, gn2 gr_num) sq_num {
  return seqq(gr, {gn1, seq1(gr, gn2)});
}

func seq3(gr *frame_graph, gn1 gr_num, gn2 gr_num, gn3 gr_num) sq_num {
  return seqq(gr, {gn1, seq2(gr, gn2, gn3)});
}

func seq4(gr *frame_graph, gn1 gr_num, gn2 gr_num, gn3 gr_num, gn4 gr_num) sq_num {
  return seqq(gr, {gn1, seq3(gr, gn2, gn3, gn4)});
}

func gr_fullbody(clq *clqueue, gr *frame_graph, x *ast_fullbody, out *gr_num, return_cell_out *cell_num) np {
  final_node sq_num = nopq(gr);

  info *ast_fullbody_info = un(&x->info);
  exit_node sq_num;
  if case Printed(pm) = gr_unwind_vars(clq, gr, &info->parameter_destructions, final_node, &exit_node) {
    return Printed(pm);
  }

  label_gn array[sq_num];
  n size = count(&info->labels);
  for i size = 0; i < n; i = i + 1 {
    ngn sq_num = nopq(gr);
    push(&label_gn, ngn);
  }

  fb fullbody_state = {info->all_vars, final_node, label_gn, mk_array@[cell_num]()};

  body_gn sq_num;
  if case Printed(pm) = gr_bracebody(clq, gr, &fb, None, &x->bb, exit_node, &body_gn) {
    return Printed(pm);
  }

  // This assumes it's okay to have a subcell op produce the identical type -- it's the only place we do that.
  return_subcells_op sq_num = nopq(gr);
  return_subcells_dead sq_num = nopq(gr);
  nreturn_cells size = count(&fb.return_cells);
  for i size = 0; i < nreturn_cells; i = i + 1 {
    // We pop the subcells in the opposite order that we push them... which might improve compile-times somehow.
    j size = nreturn_cells - 1 - i;
    subn var = addx(gr, @[gr_xop]GrSubcell({get(&fb.return_cells, j), info->return_cell, OffsetConst(0)}));
    return_subcells_op = seqq(gr, {subn, return_subcells_op});
    deadn var = addx(gr, @[gr_xop]GrVirtualDead({get(&fb.return_cells, i)}));
    return_subcells_dead = seqq(gr, {deadn, return_subcells_dead});
  }

  seqop sq_num = seqq(gr, {return_subcells_op.x, body_gn});

  mut_qnop_node(gr, fb.final_node,
                {@[gr_qop]GrSequence({
                   return_subcells_dead.x,
                   nopq(gr)})});

  *out = seqop.x;
  *return_cell_out = info->return_cell;
  return NoFail;
}

// TODO: Stop needing this -- make label_info and goto_info more general and use that, or make some other sort of annotation.  The use of breakgrack duplicates the usage of breakpack in body.ki.  It's not _particularly_ unsafe though.
struct breakgrack {
  break_target sq_num;
  continue_target sq_num;
};

func gr_bracebody(clq *clqueue, gr *frame_graph, fb *fullbody_state, obg opt[breakgrack], x *ast_bracebody, outflow sq_num, out *sq_num) np {
  bn sq_num;
  if case Printed(pm) = gr_unwind_vars(clq, gr, &un(&x->info)->destructions, outflow, &bn) {
    return Printed(pm);
  }
  n size = count(&x->statements);
  for i size = n; i > 0; {
    i = i - 1;
    gn sq_num;
    if case Printed(pm) = gr_statement(clq, gr, fb, obg, ref(&x->statements, i), bn, &gn) {
      return Printed(pm);
    }
    bn = gn;
  }
  *out = bn;
  return NoFail;
}

func gr_statement(clq *clqueue, gr *frame_graph, fb *fullbody_state, obg opt[breakgrack], x *ast_statement, outflow sq_num, out *sq_num) np {
  switch &x->u {
    case &Expr(a ast_expr_discard): {
      gn gr_num;
      if case Printed(pm) = gr_expr_discard(clq, gr, &a, &gn) {
        return Printed(pm);
      }
      *out = seqq(gr, {gn, outflow});
      return NoFail;
    }
    case &Return(a ast_return_statement): {
      if case Printed(pm) = gr_return_statement(clq, gr, fb, &a, out) {
        return Printed(pm);
      }
      return NoFail;
    }
    case &Var(a ast_var_statement): {
      gn gr_num;
      if case Printed(pm) = gr_var_statement(clq, gr, fb, &a, &gn) {
        return Printed(pm);
      }
      *out = seqq(gr, {gn, outflow});
      return NoFail;
    }

    case &IfThen(a ast_ifthen_statement): {
      if case Printed(pm) = gr_ifthen_statement(clq, gr, fb, obg, &a, outflow, out) {
        return Printed(pm);
      }
      return NoFail;
    }
    case &IfThenElse(a ast_ifthenelse_statement): {
      if case Printed(pm) = gr_ifthenelse_statement(clq, gr, fb, obg, &a, outflow, out) {
        return Printed(pm);
      }
      return NoFail;
    }
    case &While(a ast_while_statement): {
      if case Printed(pm) = gr_while_statement(clq, gr, fb, &a, outflow, out) {
        return Printed(pm);
      }
      return NoFail;
    }

    case &For(a ast_for_statement): {
      if case Printed(pm) = gr_for_statement(clq, gr, fb, &a, outflow, out) {
        return Printed(pm);
      }
      return NoFail;
    }
    case &Switch(a ast_switch_statement): {
      if case Printed(pm) = gr_switch_statement(clq, gr, fb, obg, &a, outflow, out) {
        return Printed(pm);
      }
      return NoFail;
    }

    case &Break(a ast_break_statement):
      if case Printed(pm) = gr_break_statement(clq, gr, fb, obg, &a, outflow, out) {
        return Printed(pm);
      }
      return NoFail;

    case &Continue(a ast_continue_statement):
      if case Printed(pm) = gr_continue_statement(clq, gr, fb, obg, &a, outflow, out) {
        return Printed(pm);
      }
      return NoFail;

    case &Label(a ast_label_statement): {
      if case Printed(pm) = gr_label_statement(clq, gr, fb, &a, outflow, out) {
        return Printed(pm);
      }
      return NoFail;
    }
    case &Goto(a ast_goto_statement): {
      if case Printed(pm) = gr_goto_statement(clq, gr, fb, &a, outflow, out) {
        return Printed(pm);
      }
      return NoFail;
    }
  }
}

func gr_break_statement(clq *clqueue, gr *frame_graph, fb *fullbody_state, obg opt[breakgrack], a *ast_break_statement, outflow sq_num, out *sq_num) np {
  info *ast_break_statement_info = un(&a->info);
  un sq_num;
  if case Printed(pm) = gr_unwind_vars(clq, gr, &info->destructions, unHas(&obg)->break_target, &un) {
    return Printed(pm);
  }
  *out = un;
  return NoFail;
}

func gr_continue_statement(clq *clqueue, gr *frame_graph, fb *fullbody_state, obg opt[breakgrack], a *ast_continue_statement, outflow sq_num, out *sq_num) np {
  info *ast_continue_statement_info = un(&a->info);
  un sq_num;
  if case Printed(pm) = gr_unwind_vars(clq, gr, &info->destructions, unHas(&obg)->continue_target, &un) {
    return Printed(pm);
  }
  *out = un;
  return NoFail;
}

func gr_goto_statement(clq *clqueue, gr *frame_graph, fb *fullbody_state, a *ast_goto_statement, outflow sq_num, out *sq_num) np {
  info *ast_goto_statement_info = un(&a->info);
  jmp sq_num = get(&fb->label_gn, info->label_number.x);
  wn sq_num;
  if case Printed(pm) = gr_wind_vars(clq, gr, &info->initializations, jmp, &wn) {
    return Printed(pm);
  }
  un sq_num;
  if case Printed(pm) = gr_unwind_vars(clq, gr, &info->destructions, wn, &un) {
    return Printed(pm);
  }
  *out = un;
  return NoFail;
}

func gr_label_statement(clq *clqueue, gr *frame_graph, fb *fullbody_state, a *ast_label_statement, outflow sq_num, out *sq_num) np {
  gn sq_num = get(&fb->label_gn, un(&a->info)->label_number.x);
  mut_qnop_node(gr, gn, {@[gr_qop]GrJmp({outflow})});
  // Should we set *out to gn or outflow?  When labels get fancier, the answer will matter.
  *out = gn;
  return NoFail;
}

func gr_switch_statement(clq *clqueue, gr *frame_graph, fb *fullbody_state, obg opt[breakgrack], a *ast_switch_statement, outflow sq_num, out *sq_num) np {
  swartch_discard_gn gr_num;
  if case Printed(pm) = gr_later_discard(clq, gr, &a->swartch_discard, &swartch_discard_gn) {
    return Printed(pm);
  }

  param_discard *te_typeexpr;
  is_ptr bool = decompose_typeapp(&expr_complete_type(&oo(&a->swartch)->expr)->x, primitive_pointer_puretype(clq->cs), &param_discard);

  exitseq var = seqq(gr, {swartch_discard_gn, outflow});

  info *ast_enum_deconstruction_info = un(&a->info);
  // TODO: Rename field
  cases array[opt[sq_num]] = repeat(info->num_enum_constructors, None);
  default_case opt[sq_num] = None;
  ncases size = count(&a->cases);
  reserve(&cases, ncases);
  for i size = 0; i < ncases; i = i + 1 {
    sc *ast_switch_case = ref(&a->cases, i);

    switch &sc->pattern {
      case &Case(cp ast_constructor_pattern): {
        cp_info *ast_cp_info = un(&cp.cp_info);
        if case Has(vn var_number) = cp_info->ovn {
          vi *var_info = ref(&fb->all_vars, vn.x);

          kill_var gr_num = addx(gr, @[gr_xop]GrVirtualDead({vi->cell}));
          bodyexit sq_num = seqq(gr, {kill_var, exitseq});

          body_gn sq_num;
          if case Printed(pm) = gr_bracebody(clq, gr, fb, obg, &sc->body, bodyexit, &body_gn) {
            return Printed(pm);
          }

          vcgn gr_num;
          if is_ptr {
            vcgn = addx(gr, @[gr_xop]GrDeref({vi->cell, result_cell(oo(&a->swartch)), OffsetConst(cp_info->field_offset)}));
          } else {
            vcgn = addx(gr, @[gr_xop]GrSubcell({vi->cell, result_cell(oo(&a->swartch)), OffsetConst(cp_info->field_offset)}));
          }
          gn1 var = seqq(gr, {vcgn, body_gn});
          kill_tag gr_num = addx(gr, @[gr_xop]GrVirtualDead({info->tag_cell}));
          gn var = seqq(gr, {kill_tag, gn1});
          set(ref(&cases, unmk_enum_tag_value(cp_info->tag_value)), gn);
        } else {
          body_gn sq_num;
          if case Printed(pm) = gr_bracebody(clq, gr, fb, obg, &sc->body, exitseq, &body_gn) {
            return Printed(pm);
          }
          kill_tag gr_num = addx(gr, @[gr_xop]GrVirtualDead({info->tag_cell}));
          gn var = seqq(gr, {kill_tag, body_gn});
          set(ref(&cases, unmk_enum_tag_value(cp_info->tag_value)), gn);
        }
      }
      case &Default: {
        body_gn sq_num;
        if case Printed(pm) = gr_bracebody(clq, gr, fb, obg, &sc->body, exitseq, &body_gn) {
          return Printed(pm);
        }

        kill_tag gr_num = addx(gr, @[gr_xop]GrVirtualDead({info->tag_cell}));
        gn var = seqq(gr, {kill_tag, body_gn});
        set(&default_case, gn);
      }
    }
  }

  branch_cases array[tup[gr_const, sq_num]];
  nconstructors size = count(&cases);
  for i size = 0; i < nconstructors; i = i + 1 {
    if case Has(sq sq_num) = get(&cases, i) {
      push(&branch_cases, {ConstInt(bigu(mk_enum_tag_value(i).x)), sq});
    } else {
      if case Has(dq sq_num) = default_case {
        push(&branch_cases, {ConstInt(bigu(mk_enum_tag_value(i).x)), dq});
      }
    }
  }

  swartch_gn gr_num;
  if case Printed(pm) = gr_live_and_expr_consume(clq, gr, oo(&a->swartch), &swartch_gn) {
    return Printed(pm);
  }

  taggn gr_num;
  if is_ptr {
    taggn = addx(gr, swartch_gn, @[gr_xop]GrDeref({info->tag_cell, result_cell(oo(&a->swartch)), OffsetConst(enum_tag_offset)}));
  } else {
    taggn = addx(gr, swartch_gn, @[gr_xop]GrSubcell({info->tag_cell, result_cell(oo(&a->swartch)), OffsetConst(enum_tag_offset)}));
  }

  br var = seqq(gr, {taggn,
    addq(gr, @[gr_qop]GrBranch({info->tag_cell, freeze(&branch_cases), None}))});

  *out = br;
  return NoFail;
}

func gr_for_statement(clq *clqueue, gr *frame_graph, fb *fullbody_state, a *ast_for_statement, outflow sq_num, out *sq_num) np {
  topgn var = nopq(gr);

  loopcleanupgn gr_num;
  if case &Has(cond ast_expr_condition) = &a->condition {
    if case Printed(pm) = gr_later_discard(clq, gr, &cond.discard, &loopcleanupgn) {
      return Printed(pm);
    }
  } else {
    loopcleanupgn = addx(gr, @[gr_xop]GrXNop);
  }

  continue_target sq_num;

  continuegn sq_num;
  if case &Has(increment box[ast_expr_discard]) = &a->increment {
    incrgn gr_num;
    if case Printed(pm) = gr_expr_discard(clq, gr, oo(&increment), &incrgn) {
      return Printed(pm);
    }
    totopgn var = seqq(gr, {incrgn, topgn});
    continue_target = totopgn;
    continuegn = seqq(gr, {loopcleanupgn, totopgn});
  } else {
    continuegn = seqq(gr, {loopcleanupgn, topgn});
    continue_target = continuegn;
  }

  bp breakgrack = {outflow, continue_target};

  thengn sq_num;
  if case Printed(pm) = gr_bracebody(clq, gr, fb, Has(bp), &a->body, continuegn, &thengn) {
    return Printed(pm);
  }

  gn sq_num;
  if case &Has(cond ast_expr_condition) = &a->condition {
    // TODO: This would be using the same cells in different nodes.
    loopexitgn gr_num;
    if case Printed(pm) = gr_later_discard(clq, gr, &cond.discard, &loopexitgn) {
      return Printed(pm);
    }

    initseq sq_num;
    if case Printed(pm) = gr_unwind_vars(clq, gr, &un(&a->info)->initter_destructions, outflow, &initseq) {
      return Printed(pm);
    }

    exitseq var = seqq(gr, {loopexitgn, initseq});

    if case Printed(pm) = gr_expr_condition(clq, gr, oo(&cond.expr), thengn, exitseq, &gn) {
      return Printed(pm);
    }
  } else {
    gn = thengn;
  }

  mut_qnop_node(gr, topgn, {@[gr_qop]GrJmp({gn})});

  fingn sq_num;
  if case &Has(bi box[ast_statement]) = &a->initializer {
    if case Printed(pm) = gr_statement(clq, gr, fb, None, oo(&bi), topgn, &fingn) {
      return Printed(pm);
    }
  } else {
    fingn = topgn;
  }
  *out = fingn;
  return NoFail;
}

func gr_condition_discard(clq *clqueue, gr *frame_graph, a *ast_condition_discard_info, out *gr_num) np {
  disc gr_num;
  if case Printed(pm) = gr_later_discard(clq, gr, &a->later, &disc) {
    return Printed(pm);
  }
  *out = disc;
  return NoFail;
}

func gr_while_statement(clq *clqueue, gr *frame_graph, fb *fullbody_state, a *ast_while_statement, outflow sq_num, out *sq_num) np {
  topgn var = nopq(gr);

  loopcleanupgn gr_num;
  if case Printed(pm) = gr_condition_discard(clq, gr, &a->condition_discard_continue, &loopcleanupgn) {
    return Printed(pm);
  }

  loopexitgn gr_num;
  if case Printed(pm) = gr_condition_discard(clq, gr, &a->condition_discard_exit, &loopexitgn) {
    return Printed(pm);
  }

  bp breakgrack = {outflow, topgn};

  exitseq var = seqq(gr, {loopexitgn, outflow});

  continuegn var = seqq(gr, {loopcleanupgn, topgn});
  thengn sq_num;
  if case Printed(pm) = gr_condition_body(clq, gr, fb, Has(bp), &a->condition_discard_continue, &a->body, continuegn, &thengn) {
    return Printed(pm);
  }
  gn sq_num;
  if case Printed(pm) = gr_condition(clq, gr, fb, &a->condition, thengn, exitseq, &gn) {
    return Printed(pm);
  }

  mut_qnop_node(gr, topgn, {@[gr_qop]GrJmp({gn})});
  *out = topgn;
  return NoFail;
}

func gr_ifthenelse_statement(clq *clqueue, gr *frame_graph, fb *fullbody_state, obg opt[breakgrack], a *ast_ifthenelse_statement, outflow sq_num, out *sq_num) np {
  latergn gr_num;
  if case Printed(pm) = gr_condition_discard(clq, gr, &a->condition_discard, &latergn) {
    return Printed(pm);
  }

  latseq var = seqq(gr, {latergn, outflow});

  thengn sq_num;
  if case Printed(pm) = gr_condition_body(clq, gr, fb, obg, &a->condition_discard, &a->thenbody, latseq, &thengn) {
    return Printed(pm);
  }
  elsegn sq_num;
  if case Printed(pm) = gr_bracebody(clq, gr, fb, obg, &a->elsebody, latseq, &elsegn) {
    return Printed(pm);
  }
  gn sq_num;
  if case Printed(pm) = gr_condition(clq, gr, fb, &a->condition, thengn, elsegn, &gn) {
    return Printed(pm);
  }
  *out = gn;
  return NoFail;
}

func gr_condition_body(clq *clqueue, gr *frame_graph, fb *fullbody_state, obg opt[breakgrack], cd *ast_condition_discard_info, body *ast_bracebody, outflow sq_num, out *sq_num) np {
  if case &Has(c cell_num) = un(&cd->virtual_cell_dead) {
    vd gr_num = addx(gr, @[gr_xop]GrVirtualDead({c}));
    outflow = seqq(gr, {vd, outflow});
  }
  return gr_bracebody(clq, gr, fb, obg, body, outflow, out);
}

func gr_ifthen_statement(clq *clqueue, gr *frame_graph, fb *fullbody_state, obg opt[breakgrack], a *ast_ifthen_statement, outflow sq_num, out *sq_num) np {
  latergn gr_num;
  if case Printed(pm) = gr_condition_discard(clq, gr, &a->condition_discard, &latergn) {
    return Printed(pm);
  }

  latseq var = seqq(gr, {latergn, outflow});

  bodygn sq_num;
  if case Printed(pm) = gr_condition_body(clq, gr, fb, obg, &a->condition_discard, &a->body, latseq, &bodygn) {
    return Printed(pm);
  }
  gn sq_num;
  if case Printed(pm) = gr_condition(clq, gr, fb, &a->condition, bodygn, latseq, &gn) {
    return Printed(pm);
  }
  *out = gn;
  return NoFail;
}

func gr_expr_condition(clq *clqueue, gr *frame_graph, a *ast_expr_consume, thengn sq_num, elsegn sq_num, out *sq_num) np {
  congn gr_num;
  if case Printed(pm) = gr_live_and_expr_consume(clq, gr, a, &congn) {
    return Printed(pm);
  }
  cases shray[tup[gr_const, sq_num]] = mk_shray({@[gr_const]ConstInt(~ @[u32] 0), elsegn});
  br var = seqq(gr, {congn,
    addq(gr, @[gr_qop]GrBranch({result_cell(a), cases, Has(thengn)}))});

  *out = br;
  return NoFail;
}

func gr_condition(clq *clqueue, gr *frame_graph, fb *fullbody_state, a *ast_condition, thengn sq_num, elsegn sq_num, out *sq_num) np {
  switch a {
    case &ExprCondition(bec box[ast_expr_consume]): {
      return gr_expr_condition(clq, gr, oo(&bec), thengn, elsegn, out);
    }

    case &PatternCondition(pa ast_pattern_assign): {
      rhs gr_num;
      if case Printed(pm) = gr_live_and_expr_consume(clq, gr, oo(&pa.rhs), &rhs) {
        return Printed(pm);
      }

      info *ast_pattern_assign_info = un(&pa.info);
      // TODO: Avoid the duplicate checks for addressof_constructor, only do one GrDeref.
      taggn gr_num;
      if isHas(&pa.pattern.addressof_constructor) {
        taggn = addx(gr, rhs, @[gr_xop]GrDeref({info->deconstruct.tag_cell, result_cell(oo(&pa.rhs)), OffsetConst(enum_tag_offset)}));
      } else {
        taggn = addx(gr, rhs, @[gr_xop]GrSubcell({info->deconstruct.tag_cell, result_cell(oo(&pa.rhs)), OffsetConst(enum_tag_offset)}));
      }
      cases array[tup[gr_const, sq_num]];
      n size = info->deconstruct.num_enum_constructors;
      reserve(&cases, n);
      for i size = 0; i < n; i = i + 1 {
        tag enum_tag_value = mk_enum_tag_value(i);
        if info->matching_tag_value.x == tag.x {
          cp_info *ast_cp_info = un(&pa.pattern.cp_info);
          if case Has(vn var_number) = cp_info->ovn {
            vi *var_info = ref(&fb->all_vars, vn.x);
            vcgn gr_num;
            if isHas(&pa.pattern.addressof_constructor) {
              vcgn = addx(gr, @[gr_xop]GrDeref({vi->cell, result_cell(oo(&pa.rhs)), OffsetConst(cp_info->field_offset)}));
            } else {
              vcgn = addx(gr, @[gr_xop]GrSubcell({vi->cell, result_cell(oo(&pa.rhs)), OffsetConst(cp_info->field_offset)}));
            }
            gn var = seqq(gr, {vcgn, thengn});
            tagdead gr_num = addx(gr, @[gr_xop]GrVirtualDead({info->deconstruct.tag_cell}));
            thenseq sq_num = seqq(gr, {tagdead, gn});
            push(&cases, {@[gr_const]ConstInt(~tag.x), thenseq});
          } else {
            tagdead gr_num = addx(gr, @[gr_xop]GrVirtualDead({info->deconstruct.tag_cell}));
            thenseq sq_num = seqq(gr, {tagdead, thengn});
            push(&cases, {@[gr_const]ConstInt(~tag.x), thenseq});
          }
        } else {
          tagdead gr_num = addx(gr, @[gr_xop]GrVirtualDead({info->deconstruct.tag_cell}));
          elseseq sq_num = seqq(gr, {tagdead, elsegn});
          push(&cases, {@[gr_const]ConstInt(~tag.x), elseseq});
        }
      }
      br var = seqq(gr, {taggn,
        addq(gr, @[gr_qop]GrBranch({info->deconstruct.tag_cell, freeze(&cases), None}))});

      *out = br;
      return NoFail;
    }
  }
}

func gr_var_statement(clq *clqueue, gr *frame_graph, fb *fullbody_state, a *ast_var_statement, out *gr_num) np {
  switch &a->rhs {
    case &HasExpr(be box[ast_expr_consume]): {
      return gr_live_and_expr_consume(clq, gr, oo(&be), out);
    }
    case &AutoInit(x opt[init_action]): {
      if case &Has(ia init_action) = &x {
        return gr_init_action(clq, gr, &ia, out);
      } else {
        ice(_u8("AutoInit action not annotated"));
        return fake();
      }
    }
  }
}

func gr_return_statement(clq *clqueue, gr *frame_graph, fb *fullbody_state, a *ast_return_statement, out *sq_num) np {
  gn gr_num;
  if case &Has(b box[ast_expr_consume]) = &a->expr {
    if case Printed(pm) = gr_expr_consume(clq, gr, oo(&b), &gn) {
      return Printed(pm);
    }
    push(&fb->return_cells, result_cell(oo(&b)));
  } else {
    gn = addx(gr, @[gr_xop]GrXNop);
  }
  info *ast_return_statement_info = un(&a->info);
  uw sq_num;
  if case Printed(pm) = gr_unwind_vars(clq, gr, &info->destructions, fb->final_node, &uw) {
    return Printed(pm);
  }
  sn var = seqq(gr, {gn, uw});
  *out = sn;
  return NoFail;
}

// "initializations" is in variable declaration order -- the _same_ order as evaluation.
func gr_wind_vars(clq *clqueue, gr *frame_graph, initializations *array[init_action], outflow sq_num, out *sq_num) np {
  bn sq_num = outflow;
  n size = count(initializations);
  for i size = n; i > 0; {
    i = i - 1;
    gn gr_num;
    if case Printed(pm) = gr_init_action(clq, gr, ref(initializations, i), &gn) {
      return Printed(pm);
    }
    bn = seqq(gr, {gn, bn});
  }
  *out = bn;
  return NoFail;
}

// "destructions" is in variable declaration order -- the _opposite_ order of evaluation.
func gr_unwind_vars(clq *clqueue, gr *frame_graph, destructions *array[var_destruction], outflow sq_num, out *sq_num) np {
  bn sq_num = outflow;
  n size = count(destructions);
  for i size = 0; i < n; i = i + 1 {
    gn gr_num;
    switch get(destructions, i) {
    case VarSelfContainedDestruction(da destroy_action):
      if case Printed(pm) = gr_destroy_action(clq, gr, &da, DeadAfterDestroyYes, &gn) {
        return Printed(pm);
      }
    case VarVirtualCellDead(c cell_num):
      gn = addx(gr, @[gr_xop]GrVirtualDead({c}));
    }
    bn = seqq(gr, {gn, bn});
  }
  *out = bn;
  return NoFail;
}

func gr_expr_discard(clq *clqueue, gr *frame_graph, x *ast_expr_discard, out *gr_num) np {
  dp gr_num;
  if case Printed(pm) = gr_expr(clq, gr, &x->expr, &dp) {
    return Printed(pm);
  }
  after_gn gr_num;
  if case Printed(pm) = gr_expr_after_discard(clq, gr, &x->expr, un(&x->after), dp, &after_gn) {
    return Printed(pm);
  }
  *out = after_gn;
  return NoFail;
}

func gr_expr_after_discard(clq *clqueue, gr *frame_graph, x *ast_expr, aft *ast_expr_after_discard, xp gr_num, out *gr_num) np {
  after_gn gr_num;
  switch aft {
  case &DiscardTemporary(da destroy_action):
    if case Printed(pm) = gr_destroy_action(clq, gr, &da, DeadAfterDestroyYes, &after_gn) {
      return Printed(pm);
    }
    if whole_cell(x) != partial_cell(x) {
      after_gn = seqq(gr, {addx(gr, @[gr_xop]GrVirtualDead({partial_cell(x)})), seq1(gr, after_gn)}).x;
    }
    xp = gr_live_before(gr, whole_cell(x), xp);
  case &DiscardVirtualDead(c cell_num):
    after_gn = addx(gr, @[gr_xop]GrVirtualDead({c}));
  case &DiscardNothing:
    after_gn = addx(gr, @[gr_xop]GrXNop);
  }
  *out = seq2(gr, xp, after_gn).x;
  return NoFail;
}

func gr_live_and_expr_consume(clq *clqueue, gr *frame_graph, x *ast_expr_consume, out *gr_num) np {
  ec gr_num;
  if case Printed(pm) = gr_expr_consume(clq, gr, x, &ec) {
    return Printed(pm);
  }
  *out = gr_live_before(gr, result_cell(x), ec);
  return NoFail;
}

func gr_xop_before(gr *frame_graph, op gr_xop, after gr_num) gr_num {
  assert_gn sq_num = seq2(gr, addx(gr, op), after);
  return assert_gn.x;
}

func gr_live_before(gr *frame_graph, cell cell_num, after gr_num) gr_num {
  return gr_xop_before(gr, @[gr_xop]GrLive({cell}), after);
}

func gr_assert_live_before(gr *frame_graph, cell cell_num, after gr_num) gr_num {
  return gr_xop_before(gr, @[gr_xop]GrAssertLive({cell}), after);
}

func gr_expr_consume(clq *clqueue, gr *frame_graph, x *ast_expr_consume, out *gr_num) np {
  return gr_expr_and_consume(clq, gr, &x->expr, un(&x->after), out);
}

func gr_expr_and_consume(clq *clqueue, gr *frame_graph, x *ast_expr, aft *ast_expr_after_consume, out *gr_num) np {
  expr_gn gr_num;
  if case Printed(pm) = gr_expr(clq, gr, x, &expr_gn) {
    return Printed(pm);
  }
  after_gn gr_num;
  if case Printed(pm) = gr_consume_actions(clq, gr, expr_gn, x, aft, &after_gn) {
    return Printed(pm);
  }

  *out = after_gn;
  return NoFail;
}

func gr_expr(clq *clqueue, gr *frame_graph, x *ast_expr, out *gr_num) np {
  cs *checkstate = clq->cs;
  switch &x->u {
    case &NameExpr(a ast_name_expr): {
      return gr_name_expr(clq, gr, x, &a, out);
    }
    case &ParenExpr(a ast_paren_expr): {
      return gr_expr(clq, gr, oo(&a.expr), out);
    }
    case &NumericLiteral(a ast_numeric_literal): {
      return gr_literal(clq, gr, x, numeric_literal_value(&a), out);
    }
    case &BoolLiteral(a ast_bool_literal): {
      value bigint;
      if a.value {
        value = ~ @[u32] 1;
      } else {
        value = ~ @[u32] 0;
      }
      return gr_literal(clq, gr, x, value, out);
    }
    case &VoidLiteral(a ast_void_literal): {
      value bigint = ~ @[u32] 0;
      return gr_literal(clq, gr, x, value, out);
    }
    case &NullLiteral(a ast_null_literal): {
      value bigint = ~ @[u32] 0;
      return gr_literal(clq, gr, x, value, out);
    }
    case &CharLiteral(a ast_char_literal): {
      value bigint = ~ a.charspec.value;
      return gr_literal(clq, gr, x, value, out);
    }

    case &StringLiteral(a ast_string_literal): {
      return gr_string_literal(clq, gr, x, &a, out);
    }
    case &Funcall(a ast_funcall): {
      return gr_funcall(clq, gr, x, &a, out);
    }
    case &LogicalConjunction(a ast_logical_conjunction): {
      return gr_logical_conjunction(clq, gr, x, &a, out);
    }
    case &Assignment(a ast_assignment): {
      return gr_assignment(clq, gr, x, &a, out);
    }
    case &RefOf(a ast_refof):
      return gr_mk_refof(clq, gr, x, &a, out);
    case &AddressOf(a ast_addressof): {
      return gr_mk_addressof(clq, gr, x, &a, out);
    }
    case &Deref(a ast_deref): {
      return gr_mk_deref(clq, gr, x, &a, out);
    }
    case &IndexExpr(a ast_index_expr): {
      return gr_index_expr(clq, gr, x, &a, out);
    }
    case &Lambda(a ast_lambda): {
      return gr_lambda_expr(clq, gr, x, &a, out);
    }
    case &LocalField(a ast_local_field): {
      return gr_local_field(clq, gr, x, &a, out);
    }
    case &DerefField(a ast_deref_field): {
      return gr_deref_field(clq, gr, x, &a, out);
    }
    case &TypedExpr(a ast_typed_expr): {
      return gr_expr(clq, gr, oo(&a.expr), out);
    }
    case &Strinit(a ast_strinit):
      return gr_mk_strinit(clq, gr, x, &a, out);
    case &Ternary(a ast_ternary):
      return gr_mk_ternary(clq, gr, x, &a, out);
  }
}

func gr_mk_ternary(clq *clqueue, gr *frame_graph, x *ast_expr, a *ast_ternary, out *gr_num) np {
  // TODO: We do the condcleanup at the end instead of repeating it twice right after the branch... do it right after the branch.
  condcleanupgn gr_num;
  if case Printed(pm) = gr_later_discard(clq, gr, &oo(&a->condition)->discard, &condcleanupgn) {
    return Printed(pm);
  }

  cleanup_tail sq_num = seq1(gr, condcleanupgn);

  then_gn gr_num;
  if case Printed(pm) = gr_expr_consume(clq, gr, oo(&a->then_clause), &then_gn) {
    return Printed(pm);
  }
  else_gn gr_num;
  if case Printed(pm) = gr_expr_consume(clq, gr, oo(&a->else_clause), &else_gn) {
    return Printed(pm);
  }

  conjoined cell_num = rval_cell(x);

  then_sn sq_num = seqq(gr, {
    addx(gr, @[gr_xop]GrSubcell({result_cell(oo(&a->then_clause)), conjoined, OffsetConst(0)})),
    seqq(gr, {
      then_gn,
      seqq(gr, {
        addx(gr, @[gr_xop]GrVirtualDead({result_cell(oo(&a->then_clause))})),
        cleanup_tail})})});
  else_sn sq_num = seqq(gr, {
    addx(gr, @[gr_xop]GrSubcell({result_cell(oo(&a->else_clause)), conjoined, OffsetConst(0)})),
    seqq(gr, {
      else_gn,
      seqq(gr, {
        addx(gr, @[gr_xop]GrVirtualDead({result_cell(oo(&a->else_clause))})),
        cleanup_tail})})});

  cond_sn sq_num;
  if case Printed(pm) = gr_expr_condition(clq, gr, oo(&oo(&a->condition)->expr), then_sn, else_sn, &cond_sn) {
    return Printed(pm);
  }

  *out = cond_sn.x;
  return NoFail;
}

func gr_mk_strinit(clq *clqueue, gr *frame_graph, x *ast_expr, a *ast_strinit, out *gr_num) np {
  build gr_num = addx(gr, @[gr_xop]GrXNop);
  nparams size = count(&a->exprs);
  for i size = nparams; i > 0; {
    // We declare virtual cells left-to-right and keep them around until every subexpr is evaluated.  (Unwinding will need such.)
    i = i - 1;
    param *ast_strinit_param = ref(&a->exprs, i);
    befdep gr_num = addx(gr, @[gr_xop]GrSubcell({result_cell(&param->ec), rval_cell(x), OffsetConst(un(&param->info)->offset)}));
    dep gr_num;
    if case Printed(pm) = gr_expr_consume(clq, gr, &param->ec, &dep) {
      return Printed(pm);
    }
    aftdep gr_num = addx(gr, @[gr_xop]GrVirtualDead({result_cell(&param->ec)}));

    build = seq4(gr, befdep, dep, build, aftdep).x;
  }
  *out = build;
  return NoFail;
}

func gr_deref_field(clq *clqueue, gr *frame_graph, x *ast_expr, a *ast_deref_field, out *gr_num) np {
  rp gr_num;
  if case Printed(pm) = gr_live_and_expr_consume(clq, gr, oo(&a->lhs), &rp) {
    return Printed(pm);
  }
  info *ast_deref_field_info = un(&a->info);
  ap gr_num;
  if case Printed(pm) = gr_later_discard(clq, gr, &a->ptr_discard, &ap) {
    return Printed(pm);
  }
  switch info {
    case &DerefArrayLength(count u32): {
      cp gr_num = addx(gr, @[gr_xop]GrWriteConst({rval_cell(x), ConstInt(~count)}));
      gn gr_num = seq3(gr, rp, ap, cp).x;
      *out = gn;
      return NoFail;
    }
    case &DerefFieldName(offset u32): {
      name cell_num = ellval_cell(x);
      dp gr_num = addx(gr, @[gr_xop]GrDeref({name, result_cell(oo(&a->lhs)), OffsetConst(offset)}));
      gn gr_num = seq3(gr, rp, dp, ap).x;
      *out = gn;
      return NoFail;
    }
  }
}

func gr_local_field(clq *clqueue, gr *frame_graph, x *ast_expr, a *ast_local_field, out *gr_num) np {
  info *ast_local_field_info = un(&a->info);
  lp gr_num;
  if case Printed(pm) = gr_expr(clq, gr, oo(&a->lhs), &lp) {
    return Printed(pm);
  }
  switch info {
    case &ArrayLength(alinfo ast_arraylength_info): {
      dp gr_num;
      if case Printed(pm) = gr_expr_after_discard(clq, gr, oo(&a->lhs), &alinfo.after, lp, &dp) {
        return Printed(pm);
      }
      cp gr_num = addx(gr, @[gr_xop]GrWriteConst({rval_cell(x), ConstInt(~alinfo.count)}));
      gn gr_num = seq2(gr, dp, cp).x;
      *out = gn;
      return NoFail;
    }
    case &FieldName(offset u32): {
      gn1 var = addx(gr, lp, @[gr_xop]GrSubcell({value_cell(x), value_cell(oo(&a->lhs)), OffsetConst(offset)}));
      gn gr_num;
      switch &expr_complete_info(oo(&a->lhs))->lval {
      case &IsLvalYes(desc lval_description):
        if case DeadMe = desc.deadme {
          gn = addx(gr, gn1, @[gr_xop]GrVirtualDead({desc.num}));
        } else {
          gn = gn1;
        }
      case &IsLvalNo(desc rval_description):
        if case Printed(pm) = gr_chain_virtualdead(clq, gr, gn1, desc.partial_num, &gn) {
          return Printed(pm);
        }
      }
      *out = gn;
      return NoFail;
    }
  }
}

func gr_lambda_expr(clq *clqueue, gr *frame_graph, x *ast_expr, a *ast_lambda, out *gr_num) np {
  info *ast_fullbody_info = un(&a->body.info);
  lambda_gr frame_graph = init_frame_graph_from_incomplete(&info->incomplete_graph);
  fullbody_gn gr_num;
  return_cell cell_num;
  if case Printed(pm) = gr_fullbody(clq, &lambda_gr, &a->body, &fullbody_gn, &return_cell) {
    return Printed(pm);
  }

  id fn_body_id = add_fn_body(clq->cs, {gr->informal_name, NotComputed, NotComputed, @[fn_body_entry_enum]GraphedFnBody({FnBodyLambda(a), {lambda_gr, fullbody_gn, return_cell}, info->arg_cells, parsed_inline_to_state_inline(a->is_inline), NotComputed})});
  gn var = addx(gr, @[gr_xop]GrWriteConst({rval_cell(x), ConstFnBody(id)}));
  *out = gn;
  return NoFail;
}

func parsed_inline_to_state_inline(a ast_isinline) should_inline {
  switch a {
  case IsInline: return InlineMust;
  case IsNotInline: return InlineYawn;
  }
}

func gr_index_expr(clq *clqueue, gr *frame_graph, x *ast_expr, a *ast_index_expr, out *gr_num) np {
  info *ast_index_expr_info = un(&a->info);
  rp gr_num;
  if case Printed(pm) = gr_live_and_expr_consume(clq, gr, oo(&a->rhs), &rp) {
    return Printed(pm);
  }
  lp gr_num;
  if case Printed(pm) = gr_expr(clq, gr, oo(&a->lhs), &lp) {
    return Printed(pm);
  }
  rhs_later gr_num;
  if case Printed(pm) = gr_later_discard(clq, gr, &info->rhs_later, &rhs_later) {
    return Printed(pm);
  }
  if case &Has(aft tup[ast_expr_after_consume, ast_later_discard_info]) = &info->lhs_after {
    // It's a pointer.
    name cell_num = ellval_cell(x);
    flat_size u32 = ref_cell(gr, name)->props.flat_size;
    lgn gr_num;
    if case Printed(pm) = gr_consume_actions(clq, gr, lp, oo(&a->lhs), &aft.car, &lgn) {
      return Printed(pm);
    }
    live_before_lgn var = gr_live_before(gr, result_cell(&aft.car), lgn);
    // Important: lhs is evaluated before rhs here.
    before_deref var = seq2(gr, live_before_lgn, rp).x;
    gp var = addx(gr, before_deref, @[gr_xop]GrDeref({name, result_cell(&aft.car), OffsetComputed({flat_size, result_cell(oo(&a->rhs))})}));
    lhs_later gr_num;
    if case Printed(pm) = gr_later_discard(clq, gr, &aft.cdr, &lhs_later) {
      return Printed(pm);
    }
    laters var = seq2(gr, rhs_later, lhs_later).x;
    gp_laters var = seq2(gr, gp, laters);
    *out = gp_laters.x;
    return NoFail;
  } else {
    name cell_num = value_cell(x);
    flat_size u32 = ref_cell(gr, name)->props.flat_size;
    // Important: lhs is evaluated before rhs here.
    before_subcell var = seq2(gr, lp, rp).x;
    gp1 var = addx(gr, before_subcell, @[gr_xop]GrSubcell({name, value_cell(oo(&a->lhs)), OffsetComputed({flat_size, result_cell(oo(&a->rhs))})}));
    gp gr_num;
    // TODO: Dedup with local_field code?
    switch &expr_complete_info(oo(&a->lhs))->lval {
    case &IsLvalYes(desc lval_description):
      if case DeadMe = desc.deadme {
        gp = addx(gr, gp1, @[gr_xop]GrVirtualDead({desc.num}));
      } else {
        gp = gp1;
      }
    case &IsLvalNo(desc rval_description):
      if case Printed(pm) = gr_chain_virtualdead(clq, gr, gp1, desc.partial_num, &gp) {
        return Printed(pm);
      }
    }
    gp_later sq_num = seq2(gr, gp, rhs_later);
    *out = gp_later.x;
    return NoFail;
  }
}

func gr_later_discard(clq *clqueue, gr *frame_graph, a *ast_later_discard_info, out *gr_num) np {
  da *destroy_action = un(&a->action);
  return gr_destroy_action(clq, gr, da, DeadAfterDestroyYes, out);
}

func gr_mk_deref(clq *clqueue, gr *frame_graph, x *ast_expr, a *ast_deref, out *gr_num) np {
  rp gr_num;
  if case Printed(pm) = gr_live_and_expr_consume(clq, gr, oo(&a->rhs), &rp) {
    return Printed(pm);
  }
  dp var = addx(gr, rp, @[gr_xop]GrDeref({ellval_cell(x), result_cell(oo(&a->rhs)), OffsetConst(0)}));
  ap gr_num;
  if case Printed(pm) = gr_later_discard(clq, gr, &a->ptr_discard, &ap) {
    return Printed(pm);
  }
  gn sq_num = seq2(gr, dp, ap);
  *out = gn.x;
  return NoFail;
}

func gr_mk_addressof(clq *clqueue, gr *frame_graph, x *ast_expr, a *ast_addressof, out *gr_num) np {
  // This is a total copy/paste of gr_mk_refof.
  rp gr_num;
  if case Printed(pm) = gr_expr(clq, gr, oo(&a->rhs), &rp) {
    return Printed(pm);
  }
  desc *lval_description = ellval_desc(oo(&a->rhs));
  ap1 gr_num = addx(gr, rp, @[gr_xop]GrAddressof({rval_cell(x), desc->num}));
  ap gr_num;
  if case DeadMe = desc->deadme {
    ap = addx(gr, ap1, @[gr_xop]GrVirtualDead({ellval_cell(oo(&a->rhs))}));
  } else {
    ap = ap1;
  }
  *out = ap;
  return NoFail;
}

func gr_mk_refof(clq *clqueue, gr *frame_graph, x *ast_expr, a *ast_refof, out *gr_num) np {
  // This is a total copy/paste of gr_mk_addressof.
  rp gr_num;
  if case Printed(pm) = gr_expr(clq, gr, oo(&a->rhs), &rp) {
    return Printed(pm);
  }
  desc *lval_description = ellval_desc(oo(&a->rhs));
  ap1 gr_num = addx(gr, rp, @[gr_xop]GrAddressof({rval_cell(x), desc->num}));
  ap gr_num;
  if case DeadMe = desc->deadme {
    ap = addx(gr, ap1, @[gr_xop]GrVirtualDead({ellval_cell(oo(&a->rhs))}));
  } else {
    ap = ap1;
  }
  *out = ap;
  return NoFail;
}

func gr_assignment(clq *clqueue, gr *frame_graph, x *ast_expr, a *ast_assignment, out *gr_num) np {
  // The lhs is an lvalue.  If the rhs is an rvalue, we need to make its cell live.
  // The lhs is evaluated before the rhs.  (TODO: Oh really, is it?  Oughtn't its destruction go before the rhs's, too?)

  lp gr_num;
  if case Printed(pm) = gr_expr(clq, gr, oo(&a->lhs), &lp) {
    return Printed(pm);
  }
  rp gr_num;
  if case Printed(pm) = gr_expr(clq, gr, oo(&a->rhs), &rp) {
    return Printed(pm);
  }
  switch un(&a->info) {
    case &StaticSelfAssignment: {
      // rhs is an lvalue.
      *out = seq2(gr, lp, rp).x;
      return NoFail;
    }
    case &SimpleMoveAssignment(smi ast_simple_move_assignment_info): {
      // rhs is an rvalue.
      dgn gr_num;
      if case Printed(pm) = gr_destroy_action(clq, gr, &smi.target_destroy, DeadAfterDestroyNo, &dgn) {
        return Printed(pm);
      }
      mgn gr_num;
      if case Printed(pm) = gr_move_action(clq, gr, &smi.rhs_move, &mgn) {
        return Printed(pm);
      }
      gn1 sq_num = seq2(gr, dgn, mgn);
      // rhs is an rvalue.
      lp_rp gr_num = seq2(gr, lp, gr_live_before(gr, whole_cell(oo(&a->rhs)), rp)).x;
      gn2 sq_num = seqq(gr, {lp_rp, gn1});
      *out = gn2.x;
      return NoFail;
    }
    case &SimpleCopyDestroyAssignment(scdi ast_simple_copydestroy_assignment_info): {
      dgn gr_num;
      if case Printed(pm) = gr_destroy_action(clq, gr, &scdi.target_destroy, DeadAfterDestroyNo, &dgn) {
        return Printed(pm);
      }
      mgn1 gr_num;
      if case Printed(pm) = gr_copy_action(clq, gr, &scdi.rhs_copy, &mgn1) {
        return Printed(pm);
      }
      mgn gr_num;
      if case Printed(pm) = gr_chain_virtualdead(clq, gr, mgn1, scdi.rhs_copy.x.src, &mgn) {
        return Printed(pm);
      }
      drgn gr_num;
      if case Printed(pm) = gr_destroy_action(clq, gr, &scdi.rhs_cleanup, DeadAfterDestroyYes, &drgn) {
        return Printed(pm);
      }
      gn1 sq_num = seq2(gr, mgn, drgn);
      gn2 sq_num = seqq(gr, {dgn, gn1});
      // rhs is an rvalue.
      lp_rp gr_num = seq2(gr, lp, gr_live_before(gr, whole_cell(oo(&a->rhs)), rp)).x;
      gn3 sq_num = seqq(gr, {lp_rp, gn2});
      *out = gn3.x;
      return NoFail;
    }
    case &SimpleCopyAssignment(sci ast_simple_copy_assignment_info): {
      // TODO: This is disgusting.  We have a trivial destructor, trivial copy assignment.  Why go through this rigamarole?
      dgn gr_num;
      if case Printed(pm) = gr_destroy_action(clq, gr, &sci.target_destroy, DeadAfterDestroyNo, &dgn) {
        return Printed(pm);
      }
      mgn gr_num;
      if case Printed(pm) = gr_copy_action(clq, gr, &sci.rhs_copy, &mgn) {
        return Printed(pm);
      }
      if case DeadMe = sci.rhs_deadme {
        if case Printed(pm) = gr_chain_virtualdead(clq, gr, mgn, sci.rhs_copy.x.src, &mgn) {
          return Printed(pm);
        }
      }
      gn1 sq_num = seq2(gr, dgn, mgn);
      // rhs is an lvalue.
      lp_rp_nop gr_num = seq2(gr, lp, rp).x;
      gn2 sq_num = seqq(gr, {lp_rp_nop, gn1});
      *out = gn2.x;
      return NoFail;
    }
    case &ConditionalAssignment(ci ast_conditional_assignment_info): {
      destcell cell_num = value_cell(oo(&a->lhs));
      valuetype *cu_typeexpr = &ref_cell(gr, destcell)->type;
      ptrtype cu_typrop = computed_ptr_type(clq, valuetype);
      booltype cu_typrop = compute_prim(clq, primitive_bool_type(clq->cs));
      fntype cu_typrop = compute_prim(clq, fn_type(clq->cs, ptrtype.cu.x, ptrtype.cu.x, booltype.cu.x));

      funcell cell_num = add_cell(gr, {LocationStatic, fntype.cu, fntype.props});
      destptr cell_num = add_cell(gr, {LocationStatic, ptrtype.cu, ptrtype.props});
      srcptr cell_num = add_cell(gr, {LocationStatic, ptrtype.cu, ptrtype.props});
      cmp_result cell_num = add_cell(gr, {LocationStatic, booltype.cu, booltype.props});

      funcell_live var = addx(gr, @[gr_xop]GrLive({funcell}));
      fc var = addx(gr, funcell_live, @[gr_xop]GrWriteConst({funcell, ConstDef(ci.comparecells)}));
      destptr_live var = addx(gr, @[gr_xop]GrLive({destptr}));
      dp var = addx(gr, destptr_live, @[gr_xop]GrAddressof({destptr, destcell}));
      srcptr_live var = addx(gr, @[gr_xop]GrLive({srcptr}));
      sp var = addx(gr, srcptr_live, @[gr_xop]GrAddressof({srcptr, value_cell(oo(&a->rhs))}));
      cmp_result_live var = addx(gr, @[gr_xop]GrLive({cmp_result}));
      before_apply var = seq4(gr, cmp_result_live, fc, dp, sp).x;
      ap var = addx(gr, before_apply, @[gr_xop]GrApply({funcell, mk_shray(destptr, srcptr), cmp_result}));

      just_dead var = addx(gr, @[gr_xop]GrDead({cmp_result}));
      if case DeadMe = ci.rhs_deadme {
        // TODO: It would be nice if we just had a closing node for virtualdead, maybe also for just_dead, instead of these duplicate tails.
        if case Printed(pm) = gr_chain_virtualdead(clq, gr, just_dead, ci.conditional_copy.x.src, &just_dead) {
          return Printed(pm);
        }
      }

      assign_destroy gr_num;
      if case Printed(pm) = gr_destroy_action(clq, gr, &ci.conditional_destroy, DeadAfterDestroyNo, &assign_destroy) {
        return Printed(pm);
      }
      assign_copy gr_num;
      if case Printed(pm) = gr_copy_action(clq, gr, &ci.conditional_copy, &assign_copy) {
        return Printed(pm);
      }
      assign sq_num = seq2(gr, assign_destroy, assign_copy);
      dead_before_assign gr_num = addx(gr, @[gr_xop]GrDead({cmp_result}));
      dead_then_assign gr_num = seqq(gr, {dead_before_assign, assign}).x;
      if case DeadMe = ci.rhs_deadme {
        if case Printed(pm) = gr_chain_virtualdead(clq, gr, dead_then_assign, ci.conditional_copy.x.src, &dead_then_assign) {
          return Printed(pm);
        }
      }
      cases shray[tup[gr_const, sq_num]] = mk_shray({@[gr_const]ConstInt(~ @[u32] 0), seq1(gr, dead_then_assign)}, {@[gr_const]ConstInt(~ @[u32] 1), seq1(gr, just_dead)});

      br var = seqq(gr, {ap,
        addq(gr, @[gr_qop]GrBranch({cmp_result, cases, None}))});
      lp_rp gr_num = seq2(gr, lp, rp).x;
      seq_lp_rp_nop var = seqq(gr, {lp_rp, br});
      *out = seq_lp_rp_nop.x;
      return NoFail;
    }
  }
}

func gr_logical_conjunction(clq *clqueue, gr *frame_graph, x *ast_expr, a *ast_logical_conjunction, out *gr_num) np {
  lhs_dep gr_num;
  if case Printed(pm) = gr_live_and_expr_consume(clq, gr, oo(&a->lhs), &lhs_dep) {
    return Printed(pm);
  }
  rhs_dep gr_num;
  if case Printed(pm) = gr_live_and_expr_consume(clq, gr, oo(&a->rhs), &rhs_dep) {
    return Printed(pm);
  }

  rhs_cp_gn gr_num = addx(gr, rhs_dep, @[gr_xop]GrMemCopy({rval_cell(x), result_cell(oo(&a->rhs))}));
  rhs_dead_gn gr_num = addx(gr, rhs_cp_gn, @[gr_xop]GrDead({result_cell(oo(&a->rhs))}));

  rhs_lhs_dead_gn gr_num = addx(gr, @[gr_xop]GrDead({result_cell(oo(&a->lhs))}));
  lhs_dead_then_rhs sq_num = seq2(gr, rhs_lhs_dead_gn, rhs_dead_gn);

  lhs_cp_gn gr_num = addx(gr, @[gr_xop]GrMemCopy({rval_cell(x), result_cell(oo(&a->lhs))}));
  lhs_dead_gn gr_num = addx(gr, lhs_cp_gn, @[gr_xop]GrDead({result_cell(oo(&a->lhs))}));

  cases array[tup[gr_const, gr_num]];
  short_circuit_case gr_const;
  eval_rhs_case gr_const;
  if a->is_logical_or {
    short_circuit_case = ConstInt(~ @[u32] 1);
    eval_rhs_case = ConstInt(~ @[u32] 0);
  } else {
    short_circuit_case = ConstInt(~ @[u32] 0);
    eval_rhs_case = ConstInt(~ @[u32] 1);
  }
  bn sq_num = seqq(gr, {lhs_dep,
    addq(gr, @[gr_qop]GrBranch({result_cell(oo(&a->lhs)), mk_shray({short_circuit_case, seq1(gr, lhs_dead_gn)}, {eval_rhs_case, lhs_dead_then_rhs}), None}))});
  *out = bn.x;
  return NoFail;
}

func gr_funcall(clq *clqueue, gr *frame_graph, x *ast_expr, a *ast_funcall, out *gr_num) np {
  nparams size = count(&a->params);
  dep gr_num;
  if case Printed(pm) = gr_live_and_expr_consume(clq, gr, oo(&a->fun), &dep) {
    return Printed(pm);
  }
  paramcells array[cell_num];
  reserve(&paramcells, nparams);
  for i size = 0; i < nparams; i = i + 1 {
    param *ast_expr_consume = ref(&a->params, i);
    gn gr_num;
    if case Printed(pm) = gr_live_and_expr_consume(clq, gr, param, &gn) {
      return Printed(pm);
    }
    dep = seq2(gr, dep, gn).x;
    push(&paramcells, result_cell(param));
  }
  ap var = addx(gr, dep, @[gr_xop]GrApply({result_cell(oo(&a->fun)), freeze(&paramcells), rval_cell(x)}));
  *out = ap;
  return NoFail;
}

func gr_string_literal(clq *clqueue, gr *frame_graph, x *ast_expr, a *ast_string_literal, out *gr_num) np {
  bytes array[u8];
  nchars size = count(&a->charspecs);
  reserve(&bytes, nchars);
  for i size = 0; i < nchars; i = i + 1 {
    ch i32 = get(&a->charspecs, i).value;
    if ch < 0 || ch > 255 {
      ice(_u8("gr_string_literal char values out of range"));
    }
    push(&bytes, ~ch);
  }
  gn var = addx(gr, @[gr_xop]GrWriteConst({rval_cell(x), ConstBytes(freeze(&bytes))}));
  *out = gn;
  return NoFail;
}

func gr_literal(clq *clqueue, gr *frame_graph, x *ast_expr, value bigint, out *gr_num) np {
  gn var = addx(gr, @[gr_xop]GrWriteConst({rval_cell(x), ConstInt(value)}));
  *out = gn;
  return NoFail;
}

func gr_name_expr(clq *clqueue, gr *frame_graph, x *ast_expr, a *ast_name_expr, out *gr_num) np {
  switch un(&a->name_info) {
    case &LocalResolve(li local_info): {
      *out = addx(gr, @[gr_xop]GrXNop);
      return NoFail;
    }
    case &GlobalResolve(gi global_info): {
      *out = addx(gr, @[gr_xop]GrWriteConst({rval_cell(x), ConstDef({gi.ent, gi.inst})}));
      return NoFail;
    }
    case &EnumConstructor(ei enum_constructor_info): {
      *out = addx(gr, @[gr_xop]GrWriteConst({rval_cell(x), ConstDef(ei.ip)}));
      return NoFail;
    }
    case &EnumVoidConstructed(vi enum_voidconstructed_info): {
      info var = expr_complete_info(x);
      x_cell cell_num = rval_cell(x);
      cu cu_typeexpr;
      props type_properties;
      compute_prim(clq, enum_tag_type(clq->cs, &vi.et), &cu, &props);
      tag_cell cell_num = add_cell(gr, {LocationVirtual, cu, props});
      field_offset u32 = enum_field_offset(clq->cs, &vi.et, vi.constructor_tag);
      a_gn var = addx(gr, @[gr_xop]GrSubcell({tag_cell, x_cell, OffsetConst(enum_tag_offset)}));
      b_gn var = addx(gr, a_gn, @[gr_xop]GrWriteConst({tag_cell, ConstInt(~vi.constructor_tag.x)}));
      tag_end u32 = enum_tag_offset + props.flat_size;
      postpadding_ogn opt[gr_num]
        = gr_bzero_subcell(clq, gr, x_cell, tag_end, info->cu_props.flat_size - tag_end);
      prec gr_num;
      if case Has(postpadding_gn) = postpadding_ogn {
        prec = seq2(gr, b_gn, postpadding_gn).x;
      } else {
        prec = b_gn;
      }
      c_gn var = addx(gr, prec, @[gr_xop]GrVirtualDead({tag_cell}));
      *out = c_gn;
      return NoFail;
    }
  }
}

func ellval_desc(x *is_lval) *lval_description {
  switch x {
    case &IsLvalYes(desc lval_description): { return &desc; }
    case &IsLvalNo(desc rval_description): {
      ice(_u8("lvalue_value_cell expects lvalue"));
      return fake();
    }
  }
}

func ellval_cell(x *is_lval) cell_num {
  return ellval_desc(x)->num;
}

func ellval_cell(a *ast_expr) cell_num {
  return ellval_desc(a)->num;
}

func ellval_desc(a *ast_expr) *lval_description {
  return ellval_desc(&expr_complete_info(a)->lval);
}

func rval_cell(x *ast_expr) cell_num {
  return rval_cell(&expr_complete_info(x)->lval);
}

func rval_cell(x *is_lval) cell_num {
  switch x {
    case &IsLvalNo(desc rval_description): {
      if desc.whole_num != desc.partial_num {
        ice(_u8("rval_cell on non-whole"));
      }
      return desc.whole_num;
    }
    case &IsLvalYes(desc lval_description): {
      ice(_u8("rval_cell sees lvalue"));
      return fake();
    }
  }
}

func whole_cell(x *ast_expr) cell_num {
  return whole_cell(&expr_complete_info(x)->lval);
}

func whole_cell(x *is_lval) cell_num {
  switch x {
  case &IsLvalNo(desc rval_description):
    return desc.whole_num;
  case &IsLvalYes(desc lval_description):
    ice(_u8("whole_cell sees lvalue"));
    return fake();
  }
}

func partial_cell(x *ast_expr) cell_num {
  return partial_cell(&expr_complete_info(x)->lval);
}

func partial_cell(x *is_lval) cell_num {
  switch x {
  case &IsLvalNo(desc rval_description):
    return desc.partial_num;
  case &IsLvalYes(desc lval_description):
    ice(_u8("partial_cell sees lvalue"));
    return fake();
  }
}

enum dead_after_destroy {
  DeadAfterDestroyYes void;
  DeadAfterDestroyNo void;
};

func gr_after_actions(clq *clqueue, gr *frame_graph, prec gr_num, x *opt[destroy_action], out *gr_num) np {
  if case &Has(da destroy_action) = x {
    dep gr_num;
    if case Printed(pm) = gr_destroy_action(clq, gr, &da, DeadAfterDestroyYes, &dep) {
      return Printed(pm);
    }
    prec = seq2(gr, prec, dep).x;
  }
  *out = prec;
  return NoFail;
}

func gr_chain_virtualdead(clq *clqueue, gr *frame_graph, prec gr_num, c cell_num, out *gr_num) np {
  switch location(ref_cell(gr, c)) {
  case LocationVirtual:
    *out = addx(gr, prec, @[gr_xop]GrVirtualDead({c}));
  case LocationStatic:
    *out = prec;
  }
  return NoFail;
}

func gr_consume_actions(clq *clqueue, gr *frame_graph, prec gr_num, expr *ast_expr, aft *ast_expr_after_consume, out *gr_num) np {
  switch &aft->actions {
  case &ConsumeByInPlace: { }
  case &ConsumeByCopyDestroy(cd copy_destroy_action):
    dep gr_num;
    if case Printed(pm) = gr_copy_action(clq, gr, &cd.copy, &dep) {
      return Printed(pm);
    }
    if case Printed(pm) = gr_chain_virtualdead(clq, gr, dep, cd.copy.x.src, &dep) {
      return Printed(pm);
    }
    prec = seq2(gr, prec, dep).x;
    if case Printed(pm) = gr_destroy_action(clq, gr, &cd.destroy, DeadAfterDestroyYes, &dep) {
      return Printed(pm);
    }
    prec = seq2(gr, prec, dep).x;
    // It's an rvalue, we make the whole cell live before evaling.
    prec = gr_live_before(gr, whole_cell(expr), prec);
  case &ConsumeByCopy(cc tup[copy_action, lval_deadme]):
    dep gr_num;
    if case Printed(pm) = gr_copy_action(clq, gr, &cc.car, &dep) {
      return Printed(pm);
    }
    if case DeadMe = cc.cdr {
      if case Printed(pm) = gr_chain_virtualdead(clq, gr, dep, cc.car.x.src, &dep) {
        return Printed(pm);
      }
    }
    prec = seq2(gr, prec, dep).x;
  case &ConsumeByMove(m move_action):
    dep gr_num;
    if case Printed(pm) = gr_move_action(clq, gr, &m, &dep) {
      return Printed(pm);
    }
    prec = seq2(gr, prec, dep).x;
  }
  live_before_prec gr_num = gr_assert_live_before(gr, result_cell(aft), prec);
  *out = prec;
  return NoFail;
}

func gr_copy_action(clq *clqueue, gr *frame_graph, x *copy_action, out *gr_num) np {
  return gr_bi_action(clq, gr, &x->x, out);
}

func gr_move_action(clq *clqueue, gr *frame_graph, x *move_action, out *gr_num) np {
  dep gr_num;
  if case Printed(pm) = gr_bi_action(clq, gr, &x->x, &dep) {
    return Printed(pm);
  }
  *out = addx(gr, dep, @[gr_xop]GrDead({x->x.src}));
  return NoFail;
}

func gr_uni_fun(clq *clqueue, gr *frame_graph, ip instpair, arg cell_num) gr_num {
  argptr cu_typrop = computed_ptr_type(clq, &ref_cell(gr, arg)->type);
  voidret cu_typrop = compute_prim(clq, primitive_void_type(clq->cs));
  fnptr cu_typrop = compute_prim(clq, fn_type(clq->cs, argptr.cu.x, voidret.cu.x));
  funcell cell_num = add_cell(gr, {LocationStatic, fnptr.cu, fnptr.props});
  argptrcell cell_num = add_cell(gr, {LocationStatic, argptr.cu, argptr.props});
  retvoid cell_num = add_cell(gr, {LocationStatic, voidret.cu, voidret.props});

  funcell_live gr_num = addx(gr, @[gr_xop]GrLive({funcell}));
  fc gr_num = addx(gr, funcell_live, @[gr_xop]GrWriteConst({funcell, ConstDef(ip)}));
  argptrcell_live gr_num = addx(gr, @[gr_xop]GrLive({argptrcell}));
  arp gr_num = addx(gr, argptrcell_live, @[gr_xop]GrAddressof({argptrcell, arg}));
  retinit gr_num = addx(gr, @[gr_xop]GrLive({retvoid}));
  ap gr_num = addx(gr, seq3(gr, retinit, fc, arp).x, @[gr_xop]GrApply({funcell, mk_shray(argptrcell), retvoid}));
  deadret gr_num = addx(gr, ap, @[gr_xop]GrDead({retvoid}));
  return deadret;
}

func gr_init_action(clq *clqueue, gr *frame_graph, x *init_action, out *gr_num) np {
  switch &x->x.ctor {
    case &TrivialCtor: {
      dp gr_num = addx(gr, @[gr_xop]GrWriteConst({x->x.arg, ConstInt(~ @[u32] 0)}));
      *out = gr_live_before(gr, x->x.arg, dp);
      return NoFail;
    }
    case &FunCtor(ip instpair): {
      dp gr_num = gr_uni_fun(clq, gr, ip, x->x.arg);
      *out = gr_live_before(gr, x->x.arg, dp);
      return NoFail;
    }
  }
}

// TODO: The dead_after_destroy parameter here is definitely unnecessary, but not too harmful now.
func gr_destroy_action(clq *clqueue, gr *frame_graph, x *destroy_action, dad dead_after_destroy, out *gr_num) np {
  switch &x->x.ctor {
    case &TrivialCtor: {
      dp gr_num;
      if case DeadAfterDestroyYes = dad {
        dp = addx(gr, @[gr_xop]GrDead({x->x.arg}));
      } else {
        dp = addx(gr, @[gr_xop]GrXNop);
      }
      *out = dp;
      return NoFail;
    }
    case &FunCtor(ip instpair): {
      gn gr_num = gr_uni_fun(clq, gr, ip, x->x.arg);
      dp gr_num;
      if case DeadAfterDestroyYes = dad {
        dp = addx(gr, gn, @[gr_xop]GrDead({x->x.arg}));
      } else {
        dp = gn;
      }
      *out = dp;
      return NoFail;
    }
  }
}

func gr_bi_fun(clq *clqueue, gr *frame_graph, ip instpair, dest cell_num, src cell_num) gr_num {
  // In our "bi_fun" uses the dest and src have the same type.  It seems wrong for this menial code to know that, though.
  destptr cu_typrop = computed_ptr_type(clq, &ref_cell(gr, dest)->type);
  srcptr cu_typrop = computed_ptr_type(clq, &ref_cell(gr, src)->type);
  voidret cu_typrop = compute_prim(clq, primitive_void_type(clq->cs));
  fnptr cu_typrop = compute_prim(clq, fn_type(clq->cs, destptr.cu.x, srcptr.cu.x, voidret.cu.x));
  funcell cell_num = add_cell(gr, {LocationStatic, fnptr.cu, fnptr.props});
  destptrcell cell_num = add_cell(gr, {LocationStatic, destptr.cu, destptr.props});
  srcptrcell cell_num = add_cell(gr, {LocationStatic, srcptr.cu, srcptr.props});
  retvoid cell_num = add_cell(gr, {LocationStatic, voidret.cu, voidret.props});

  funcell_live gr_num = addx(gr, @[gr_xop]GrLive({funcell}));
  fc gr_num = addx(gr, funcell_live, @[gr_xop]GrWriteConst({funcell, ConstDef(ip)}));
  destptrcell_live gr_num = addx(gr, @[gr_xop]GrLive({destptrcell}));
  dp gr_num = addx(gr, destptrcell_live, @[gr_xop]GrAddressof({destptrcell, dest}));
  srcptrcell_live gr_num = addx(gr, @[gr_xop]GrLive({srcptrcell}));
  sp gr_num = addx(gr, srcptrcell_live, @[gr_xop]GrAddressof({srcptrcell, src}));
  retinit gr_num = addx(gr, @[gr_xop]GrLive({retvoid}));
  ap gr_num = addx(gr, seq4(gr, retinit, fc, dp, sp).x, @[gr_xop]GrApply({funcell, mk_shray(destptrcell, srcptrcell), retvoid}));
  deadret var = addx(gr, ap, @[gr_xop]GrDead({retvoid}));
  return deadret;
}

func gr_bi_action(clq *clqueue, gr *frame_graph, x *bi_action, out *gr_num) np {
  switch &x->ctor {
    case &TrivialCtor: {
      cp var = addx(gr, @[gr_xop]GrMemCopy({x->dest, x->src}));
      *out = cp;
      return NoFail;
    }
    case &FunCtor(ip instpair): {
      *out = gr_bi_fun(clq, gr, ip, x->dest, x->src);
      return NoFail;
    }
  }
}

// TODO: There's a lot of duplicated code in the splay-out of this function.
func gr_magic(cs *checkstate, clq *clqueue, mag *def_magic, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num], inline_out *should_inline) np {
  switch mag {
  case &MagicBzero(mb magic_bzero):
    if case Printed(pm) = gr_magic_bzero(cs, clq, &mb, gr_out, gn_out, return_cell_out, arg_cells_out) {
      return Printed(pm);
    }
    *inline_out = InlineMust;
    return NoFail;
  case &MagicMemcopy(mm magic_memcopy):
    if case Printed(pm) = gr_magic_memcopy(cs, clq, &mm, gr_out, gn_out, return_cell_out, arg_cells_out) {
      return Printed(pm);
    }
    *inline_out = InlineMust;
    return NoFail;
  case &MagicNopdestroy:
    if case Printed(pm) = gr_magic_nopdestroy(cs, clq, gr_out, gn_out, return_cell_out, arg_cells_out) {
      return Printed(pm);
    }
    *inline_out = InlineMust;
    return NoFail;
  case &MagicCtor(wmc which_magic_ctor):
    if case Printed(pm) = gr_magic_ctor(cs, clq, wmc.wc, &wmc.mc, gr_out, gn_out, return_cell_out, arg_cells_out) {
      return Printed(pm);
    }
    *inline_out = InlineYawn;
    return NoFail;
  case &MagicEnumConstruct(mec magic_enum_construct):
    arg_cell cell_num;
    if case Printed(pm) = gr_magic_enum_construct(cs, clq, &mec, gr_out, gn_out, return_cell_out, &arg_cell) {
      return Printed(pm);
    }
    *arg_cells_out = mk_array(arg_cell);
    *inline_out = InlineMust;
    return NoFail;
  }
}

struct gr_minimal_basics {
  return_cell cell_num;
  argcells array[cell_num];
};

struct gr_basics {
  minimal gr_minimal_basics;
  pointeecells array[cell_num];
  deref_prec gr_num;
};

func add_minimal_basics(cs *checkstate, clq *clqueue, gr *frame_graph, size u32, arity size, out *gr_minimal_basics) void {
  pointee_tp cu_typrop = compute_prim(clq, primitive_padding_type(cs, size));
  argtp cu_typrop = compute_prim(clq, ptr_type(cs, pointee_tp.cu.x));
  voidtp cu_typrop = compute_prim(clq, primitive_void_type(cs));
  ret gr_minimal_basics;
  ret.return_cell = add_cell(gr, {LocationStatic, voidtp.cu, voidtp.props});
  for i size = 0; i < arity; i = i + 1 {
    ac cell_num = add_cell(gr, {LocationStatic, argtp.cu, argtp.props});
    push(&ret.argcells, ac);
  }
  *out = ret;
}

func add_basics(cs *checkstate, clq *clqueue, gr *frame_graph, size u32, arity size, out *gr_basics) void {
  ret gr_basics;
  add_minimal_basics(cs, clq, gr, size, arity, &ret.minimal);

  pointee_tp cu_typrop = compute_prim(clq, primitive_padding_type(cs, size));
  deref_prec gr_num = nopq(gr).x;
  for i size = 0; i < arity; i = i + 1 {
    pc cell_num = add_cell(gr, {LocationVirtual, pointee_tp.cu, pointee_tp.props});
    push(&ret.pointeecells, pc);
    dn gr_num = addx(gr, @[gr_xop]GrDeref({pc, get(&ret.minimal.argcells, i), OffsetConst(0)}));
    deref_prec = seq2(gr, deref_prec, dn).x;
  }
  ret.deref_prec = deref_prec;
  *out = ret;
}

func minimal_basics_cleanup_prec(gr *frame_graph, bas *gr_minimal_basics, out *gr_num) void {
  prec gr_num = nopq(gr).x;
  ncells size = count(&bas->argcells);
  for i size = 0; i < ncells; i = i + 1 {
    gd gr_num = addx(gr, @[gr_xop]GrDead({get(&bas->argcells, i)}));
    // This causes us to deaden argcells in reverse order, yes.
    prec = seq2(gr, gd, prec).x;
  }
  retset var = addx(gr, @[gr_xop]GrWriteConst({bas->return_cell, ConstInt(bigu(0))}));
  // A wild guess that it's better to set the return cell _after_.
  prec = seq2(gr, prec, retset).x;
  *out = prec;
}

func minimal_basics_cleanup(cs *checkstate, clq *clqueue, gr *frame_graph, bas *gr_minimal_basics, gn gr_num, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num]) void {
  prec gr_num;
  minimal_basics_cleanup_prec(gr, bas, &prec);
  nopgn var = addx(gr, prec, @[gr_xop]GrXNop);
  fingn var = seq2(gr, gn, nopgn);
  *gr_out = *gr;
  *gn_out = fingn.x;
  *return_cell_out = bas->return_cell;
  *arg_cells_out = bas->argcells;
}

func basics_cleanup(cs *checkstate, clq *clqueue, gr *frame_graph, bas *gr_basics, gn gr_num, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num]) void {
  prec gr_num;
  minimal_basics_cleanup_prec(gr, &bas->minimal, &prec);
  ncells size = count(&bas->pointeecells);
  for i size = 0; i < ncells; i = i + 1 {
    pd gr_num = addx(gr, @[gr_xop]GrVirtualDead({get(&bas->pointeecells, i)}));
    // TODO: Think about this order a bit more?  Idk.
    prec = seq2(gr, prec, pd).x;
  }
  fingn var = seq2(gr, gn, prec);
  *gr_out = *gr;
  *gn_out = fingn.x;
  *return_cell_out = bas->minimal.return_cell;
  *arg_cells_out = bas->minimal.argcells;
}

func gr_magic_nopdestroy(cs *checkstate, clq *clqueue, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num]) np {
  gr frame_graph = init_frame_graph_empty(intern(cs->im, _s("magic_nopdestroy")));
  bas gr_minimal_basics;
  // TODO: How about make the size parameter opt[u32], don't deref if no size.
  add_minimal_basics(cs, clq, &gr, 0 /* Pass a made-up size. */, 1, &bas);
  gn gr_num = addx(&gr, @[gr_xop]GrXNop);
  minimal_basics_cleanup(cs, clq, &gr, &bas, gn, gr_out, gn_out, return_cell_out, arg_cells_out);
  return NoFail;
}

func gr_magic_memcopy(cs *checkstate, clq *clqueue, mm *magic_memcopy, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num]) np {
  gr frame_graph = init_frame_graph_empty(intern(cs->im, _s("magic_memcopy")));
  bas gr_basics;
  add_basics(cs, clq, &gr, *un(&mm->size), 2, &bas);
  gn gr_num = addx(&gr, bas.deref_prec, @[gr_xop]GrMemCopy({get(&bas.pointeecells, 0), get(&bas.pointeecells, 1)}));
  basics_cleanup(cs, clq, &gr, &bas, gn, gr_out, gn_out, return_cell_out, arg_cells_out);
  return NoFail;
}

func gr_magic_bzero(cs *checkstate, clq *clqueue, mb *magic_bzero, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num]) np {
  gr frame_graph = init_frame_graph_empty(intern(cs->im, _s("magic_bzero")));
  bas gr_basics;
  add_basics(cs, clq, &gr, *un(&mb->size), 1, &bas);
  gn gr_num = addx(&gr, bas.deref_prec, @[gr_xop]GrWriteConst({get(&bas.pointeecells, 0), ConstInt(bigu(0))}));
  basics_cleanup(cs, clq, &gr, &bas, gn, gr_out, gn_out, return_cell_out, arg_cells_out);
  return NoFail;
}

func gr_magic_ctor(cs *checkstate, clq *clqueue, wc which_ctor, mc *magic_ctor, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num]) np {
  info *magic_ctor_info = un(&mc->info);
  switch info {
  case &MagicStructInfo(msi magic_struct_info):
    return gr_magic_struct_info(cs, clq, wc, &msi, gr_out, gn_out, return_cell_out, arg_cells_out);
  case &MagicEnumInfo(mei magic_enum_info):
    return gr_magic_enum_info(cs, clq, wc, &mei, gr_out, gn_out, return_cell_out, arg_cells_out);
  case &MagicArraytypeInfo(mai magic_arraytype_info):
    return gr_magic_arraytype_info(cs, clq, wc, &mai, gr_out, gn_out, return_cell_out, arg_cells_out);
  }
}

func gr_magic_arraytype_info(cs *checkstate, clq *clqueue, wc which_ctor, mai *magic_arraytype_info, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num]) np {
  gr frame_graph = init_frame_graph_empty(intern(cs->im, _s("magic_arraytype")));
  argtp cu_typrop = compute_prim(clq, ptr_type(cs, mai->cu_type.x));

  voidtp cu_typrop = compute_prim(clq, primitive_void_type(cs));

  param *te_typeexpr;
  arraycount u32;
  if case &TeArraytype(at te_arraytype) = &mai->cu_type.x {
    param = oo(&at.param);
    if case Has(atcount u32) = at.count {
      arraycount = atcount;
    } else {
      ice(_u8("gr_magic_arraytype_info missing count"));
    }
  } else {
    ice(_u8("gr_magic_arraytype_info sees non-array type"));
  }

  param_props type_properties;
  if case Printed(pm) = compute_complete_type_properties(clq, param, &param_props) {
    return Printed(pm);
  }

  elemptrtype cu_typeexpr;
  elemptrtype_props type_properties;
  compute_prim(clq, ptr_type(cs, *param), &elemptrtype, &elemptrtype_props);

  nargs size = num_args(wc);

  fntype cu_typeexpr;
  fntype_props type_properties;
  compute_prim(clq, fn_type(cs, @[shray[_]]repeat(nargs, elemptrtype.x), voidtp.cu.x), &fntype, &fntype_props);

  size_type cu_typeexpr;
  size_type_props type_properties;
  compute_prim(clq, primitive_size_type(clq->cs), &size_type, &size_type_props);

  argcells array[cell_num];
  pointeecells array[cell_num];
  derefgn gr_num = nopq(&gr).x;
  for i size = 0; i < nargs; i = i + 1 {
    ac cell_num = add_cell(&gr, {LocationStatic, argtp.cu, argtp.props});
    push(&argcells, ac);
    pc cell_num = add_cell(&gr, {LocationVirtual, mai->cu_type, mai->cu_props});
    push(&pointeecells, pc);

    gn1 gr_num = addx(&gr, @[gr_xop]GrDeref({pc, ac, OffsetConst(0)}));
    gn gr_num = addx(&gr, gn1, @[gr_xop]GrDead({ac}));
    derefgn = seq2(&gr, derefgn, gn).x;
  }

  return_cell cell_num = add_cell(&gr, {LocationStatic, voidtp.cu, voidtp.props});

  indexcell cell_num = add_cell(&gr, {LocationStatic, size_type, size_type_props});

  deadprec gr_num;
  if true {
    setret gr_num = addx(&gr, @[gr_xop]GrWriteConst({return_cell, ConstInt(bigu(0))}));
    indexdead gr_num = addx(&gr, @[gr_xop]GrDead({indexcell}));
    deadprec = seq2(&gr, indexdead, setret).x;

    for i size = 0; i < nargs; i = i + 1 {
      pd gr_num = addx(&gr, @[gr_xop]GrVirtualDead({get(&pointeecells, i)}));
      // We end up doing GrVirtualDead in reverse order, yes.
      deadprec = seq2(&gr, pd, deadprec).x;
    }
  }

  deadseq sq_num = seq1(&gr, deadprec);

  topgn sq_num = nopq(&gr);

  elemptrcells array[cell_num];
  prec gr_num = nopq(&gr).x;
  for j size = 0; j < nargs; j = j + 1 {
    ec cell_num = add_cell(&gr, {LocationVirtual, ~ *param, param_props});
    indexcopycell cell_num = add_cell(&gr, {LocationStatic, size_type, size_type_props});
    copycell_live gr_num = addx(&gr, @[gr_xop]GrLive({indexcopycell}));
    copygn gr_num = addx(&gr, copycell_live, @[gr_xop]GrMemCopy({indexcopycell, indexcell}));
    gn gr_num = addx(&gr, copygn, @[gr_xop]GrSubcell({ec, get(&pointeecells, j), OffsetComputed({param_props.flat_size, indexcopycell})}));
    deadcopy gr_num = addx(&gr, gn, @[gr_xop]GrDead({indexcopycell}));
    epc cell_num = add_cell(&gr, {LocationStatic, elemptrtype, elemptrtype_props});
    push(&elemptrcells, epc);
    epc_live gr_num = addx(&gr, @[gr_xop]GrLive({epc}));
    ptrgn gr_num = addx(&gr, seq2(&gr, deadcopy, epc_live).x, @[gr_xop]GrAddressof({epc, ec}));
    ecdeadgn gr_num = addx(&gr, ptrgn, @[gr_xop]GrVirtualDead({ec}));
    prec = seq2(&gr, prec, ecdeadgn).x;
  }

  func_cell cell_num = add_cell(&gr, {LocationStatic, fntype, fntype_props});

  func_cell_live gr_num = addx(&gr, @[gr_xop]GrLive({func_cell}));
  func_gn gr_num = addx(&gr, func_cell_live, @[gr_xop]GrWriteConst({func_cell, ConstDef(mai->ip)}));
  // Order here doesn't matter, but we do func cell before arg cells.
  prec = seq2(&gr, func_gn, prec).x;

  elemretcell cell_num = add_cell(&gr, {LocationStatic, voidtp.cu, voidtp.props});
  // Order here doesn't matter, but we do ret cell before the others.
  prec = seq2(&gr, addx(&gr, @[gr_xop]GrLive({elemretcell})), prec).x;

  ap gr_num = addx(&gr, prec, @[gr_xop]GrApply({func_cell, freeze(&elemptrcells), elemretcell}));
  vd gr_num = addx(&gr, ap, @[gr_xop]GrDead({elemretcell}));

  ic2cell cell_num = add_cell(&gr, {LocationStatic, size_type, size_type_props});
  ic2cell_live gr_num = addx(&gr, @[gr_xop]GrLive({ic2cell}));
  ic2gn gr_num = addx(&gr, ic2cell_live, @[gr_xop]GrMemCopy({ic2cell, indexcell}));
  onecell cell_num = add_cell(&gr, {LocationStatic, size_type, size_type_props});
  onecell_live gr_num = addx(&gr, @[gr_xop]GrLive({onecell}));
  onegn gr_num = addx(&gr, onecell_live, @[gr_xop]GrWriteConst({onecell, ConstInt(bigu(1))}));
  op_action primitive_numeric_op_action;
  if case CtorDestroy = wc {
    op_action = NumSub;
  } else {
    op_action = NumAdd;
  }
  incrgn gr_num = addx(&gr, seq2(&gr, ic2gn, onegn).x, @[gr_xop]GrPrimApply({PrimNum({cs->plat.sizetraits.flat.size, cs->plat.sizetraits.numeric, op_action}), mk_shray(ic2cell, onecell), indexcell}));

  terminal_case u32;
  init_value u32;
  body_gn sq_num;
  if case CtorDestroy = wc {
    body_gn = seq2(&gr, incrgn, vd);
    init_value = arraycount;
    terminal_case = 0;
  } else {
    body_gn = seq2(&gr, vd, incrgn);
    init_value = 0;
    terminal_case = arraycount;
  }

  tie_gn sq_num = seqq(&gr, {body_gn.x, topgn});

  branch_gn sq_num = addq(&gr, @[gr_qop]GrBranch({indexcell, mk_shray({@[gr_const]ConstInt(bigu(terminal_case)), deadseq}), Has(tie_gn)}));

  mut_qnop_node(&gr, topgn, {@[gr_qop]GrJmp({branch_gn})});

  indexcell_live_gn gr_num = addx(&gr, @[gr_xop]GrLive({indexcell}));
  init_indexcell_gn gr_num = addx(&gr, indexcell_live_gn, @[gr_xop]GrWriteConst({indexcell, ConstInt(bigu(init_value))}));
  it_gn sq_num = seqq(&gr, {init_indexcell_gn, topgn});
  gn var = seqq(&gr, {derefgn, it_gn});
  *gr_out = gr;
  *gn_out = gn.x;
  *return_cell_out = return_cell;
  *arg_cells_out = argcells;
  return NoFail;
}

func gr_magic_enum_info(cs *checkstate, clq *clqueue, wc which_ctor, mei *magic_enum_info, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num]) np {
  init_padding bool = false;
  switch wc {
  case CtorInit:
    ice(_u8("Magic CtorInit on enum type"));
  case CtorCopy:
    init_padding = true;
  case CtorMove:
    init_padding = true;
  case CtorDestroy: { /* don't init padding. */ }
  }
  gr frame_graph = init_frame_graph_empty(intern(cs->im, _s("magic_enum_info")));
  argtp cu_typrop = compute_prim(clq, ptr_type(cs, mei->cu_type.x));

  voidtp cu_typrop = compute_prim(clq, primitive_void_type(clq->cs));

  et *te_enum = &mei->et;

  tagtype cu_typeexpr;
  tagtype_props type_properties;
  compute_prim(clq, enum_tag_type(cs, et), &tagtype, &tagtype_props);

  argcells array[cell_num];
  pointeecells array[cell_num];
  tagcells array[cell_num];
  deref_gns array[gr_num];
  tagcell_gns array[gr_num];
  nargs size = num_args(wc);
  for i size = 0; i < nargs; i = i + 1 {
    ac cell_num = add_cell(&gr, {LocationStatic, argtp.cu, argtp.props});
    push(&argcells, ac);
    pc cell_num = add_cell(&gr, {LocationVirtual, mei->cu_type, mei->cu_props});
    push(&pointeecells, pc);
    tc cell_num = add_cell(&gr, {LocationVirtual, tagtype, tagtype_props});
    push(&tagcells, tc);

    derefgn1 gr_num = addx(&gr, @[gr_xop]GrDeref({pc, ac, OffsetConst(0)}));
    derefgn gr_num = addx(&gr, derefgn1, @[gr_xop]GrDead({ac}));
    push(&deref_gns, derefgn);
    tcgn gr_num = addx(&gr, derefgn, @[gr_xop]GrSubcell({tc, pc, OffsetConst(enum_tag_offset)}));
    push(&tagcell_gns, tcgn);
  }

  deref_gn gr_num = addx(&gr, freeze(&tagcell_gns), @[gr_xop]GrXNop);

  return_cell cell_num = add_cell(&gr, {LocationStatic, voidtp.cu, voidtp.props});
  deadprecs array[gr_num];
  if true {
    setret gr_num = addx(&gr, @[gr_xop]GrWriteConst({return_cell, ConstInt(~ @[u32] 0)}));
    push(&deadprecs, setret);
    for i size = 0; i < nargs; i = i + 1 {
      pd gr_num = addx(&gr, @[gr_xop]GrVirtualDead({get(&pointeecells, i)}));
      push(&deadprecs, pd);
      td gr_num = addx(&gr, @[gr_xop]GrVirtualDead({get(&tagcells, i)}));
      push(&deadprecs, td);
    }
  }
  deadseq sq_num = seq1(&gr, addx(&gr, freeze(&deadprecs), @[gr_xop]GrXNop));

  cases_gn array[tup[gr_const, sq_num]];
  nconstructors size = count(&et->constructors);
  for i size = 0; i < nconstructors; i = i + 1 {
    tagval enum_tag_value = mk_enum_tag_value(i);

    fieldtype cu_typeexpr = ~ref(&et->constructors, i)->type;
    fieldtype_props type_properties;
    if case Printed(pm) = compute_type_properties(clq, &fieldtype, &fieldtype_props) {
      return Printed(pm);
    }

    field_offset u32 = enum_field_offset(cs, et, tagval);
    field_end u32 = field_offset + fieldtype_props.flat_size;
    tag_end u32 = enum_tag_offset + tagtype_props.flat_size;
    prepadding_ogn opt[gr_num]
      = gr_bzero_subcell(clq, &gr, get(&pointeecells, 0), tag_end, field_offset - tag_end);
    postpadding_ogn opt[gr_num]
      = gr_bzero_subcell(clq, &gr, get(&pointeecells, 0), field_end, mei->cu_props.flat_size - field_end);

    fieldcella array[cell_num];
    fieldcellgn array[gr_num];
    for j size = 0; j < nargs; j = j + 1 {
      fc cell_num = add_cell(&gr, {LocationVirtual, fieldtype, fieldtype_props});
      push(&fieldcella, fc);
      sn gr_num = addx(&gr, @[gr_xop]GrSubcell({get(&fieldcella, j), get(&pointeecells, j), OffsetConst(field_offset)}));
      push(&fieldcellgn, sn);
    }

    last_ogn gr_num;
    if case &Has(ip instpair) = ref(&mei->cips, i) {
      fieldptrtype cu_typeexpr;
      fieldptrtype_props type_properties;
      compute_prim(clq, ptr_type(cs, fieldtype.x), &fieldptrtype, &fieldptrtype_props);

      fieldptrcella array[cell_num];
      precs array[gr_num];
      for j size = 0; j < nargs; j = j + 1 {
        fpc cell_num = add_cell(&gr, {LocationStatic, fieldptrtype, fieldptrtype_props});
        push(&fieldptrcella, fpc);
        fpc_live gr_num = addx(&gr, @[gr_xop]GrLive({fpc}));
        an1 gr_num = addx(&gr, mk_shray(fpc_live, get(&fieldcellgn, j)), @[gr_xop]GrAddressof({fpc, get(&fieldcella, j)}));
        an gr_num = addx(&gr, an1, @[gr_xop]GrVirtualDead({get(&fieldcella, j)}));
        push(&precs, an);
      }

      fieldretcell cell_num = add_cell(&gr, {LocationStatic, voidtp.cu, voidtp.props});
      push(&precs, addx(&gr, @[gr_xop]GrLive({fieldretcell})));

      fntype cu_typeexpr;
      fntype_props type_properties;
      compute_prim(clq, fn_type(cs, @[shray[_]]repeat(nargs, fieldptrtype.x), voidtp.cu.x), &fntype, &fntype_props);

      func_cell cell_num = add_cell(&gr, {LocationStatic, fntype, fntype_props});
      func_cell_live gr_num = addx(&gr, @[gr_xop]GrLive({func_cell}));
      func_gn gr_num = addx(&gr, func_cell_live, @[gr_xop]GrWriteConst({func_cell, ConstDef(ip)}));
      push(&precs, func_gn);

      ap gr_num = addx(&gr, freeze(&precs), @[gr_xop]GrApply({func_cell, freeze(&fieldptrcella), fieldretcell}));
      vd gr_num = addx(&gr, ap, @[gr_xop]GrDead({fieldretcell}));
      last_ogn = vd;
    } else {
      ogn opt[gr_num];
      switch wc {
      case CtorInit:
        ice(_u8("CtorInit on enum type"));
      case CtorCopy:
        cgn var = addx(&gr, freeze(&fieldcellgn), @[gr_xop]GrMemCopy({get(&fieldcella, 0), get(&fieldcella, 1)}));
        ogn = Has(cgn);
      case CtorMove:
        cgn var = addx(&gr, freeze(&fieldcellgn), @[gr_xop]GrMemCopy({get(&fieldcella, 0), get(&fieldcella, 1)}));
        ogn = Has(cgn);
      case CtorDestroy:
        ogn = None;
        // do nothing.
      }
      if case Has(gn gr_num) = ogn {
        dfcprecs array[gr_num];
        for j size = 0; j < nargs; j = j + 1 {
          dfc var = addx(&gr, @[gr_xop]GrVirtualDead({get(&fieldcella, j)}));
          push(&dfcprecs, dfc);
        }
        dfcnop gr_num = addx(&gr, freeze(&dfcprecs), @[gr_xop]GrXNop);
        last_ogn = seq2(&gr, gn, dfcnop).x;
      } else {
        // The nodes that create fieldcella were never added to the graph, so we don't dead them.
        last_ogn = nopq(&gr).x;
      }
    }

    tagset_ogn opt[gr_num];
    switch wc {
    case CtorInit:
      ice(_u8("CtorInit on wc type"));
    case CtorCopy:
      tgn var = addx(&gr, @[gr_xop]GrWriteConst({get(&tagcells, 0), ConstInt(~ tagval.x)}));
      tagset_ogn = Has(tgn);
    case CtorMove:
      tgn var = addx(&gr, @[gr_xop]GrWriteConst({get(&tagcells, 0), ConstInt(~ tagval.x)}));
      tagset_ogn = Has(tgn);
    case CtorDestroy:
      tagset_ogn = None;
    }

    finalgn gr_num = addx(&gr, concat(tagset_ogn, prepadding_ogn, @[opt[gr_num]]Has(last_ogn), postpadding_ogn), @[gr_xop]GrXNop);

    finalseqgn sq_num = seqq(&gr, {finalgn, deadseq});
    push(&cases_gn, {@[gr_const]ConstInt(~ tagval.x), finalseqgn});
  }

  if true {
    if case CtorDestroy = wc {
      push(&cases_gn, {@[gr_const]ConstInt(bigu(0)), deadseq});
    } else {
      ztgn gr_num = addx(&gr, @[gr_xop]GrWriteConst({get(&pointeecells, 0), ConstInt(bigu(0))}));
      ztseq sq_num = seqq(&gr, {ztgn, deadseq});
      push(&cases_gn, {@[gr_const]ConstInt(bigu(0)), ztseq});
    }
  }

  br sq_num = addq(&gr, @[gr_qop]GrBranch({get(&tagcells, nargs - 1), freeze(&cases_gn), None}));
  sqr sq_num = seqq(&gr, {deref_gn, br});
  *gr_out = gr;
  *gn_out = sqr.x;
  *return_cell_out = return_cell;
  *arg_cells_out = argcells;
  return NoFail;
}

func gr_magic_struct_info(cs *checkstate, clq *clqueue, wc which_ctor, msi *magic_struct_info, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num]) np {
  // Destructors go in reverse order (which means we prepend them in the reverse of reverse order).
  reverse_order bool = false;
  // Init, copy, and move requires initializing intervening padding.
  init_padding bool = false;
  switch wc {
  case CtorInit:
    init_padding = true;
  case CtorCopy:
    init_padding = true;
  case CtorMove:
    init_padding = true;
  case CtorDestroy:
    reverse_order = true;
  }

  gr frame_graph = init_frame_graph_empty(intern(cs->im, _s("magic_struct_info")));
  argtp cu_typrop = compute_prim(clq, ptr_type(cs, msi->cu_type.x));

  voidtp cu_typrop = compute_prim(clq, primitive_void_type(clq->cs));

  st *te_struct = &msi->st;

  psd partial_struct_data;
  if case Printed(pm) = compute_partial_struct_data(clq, &st->fields, None, &psd) {
    return Printed(pm);
  }

  argcells array[cell_num];
  pointeecells array[cell_num];
  derefgns array[gr_num];
  nargs size = num_args(wc);
  for i size = 0; i < nargs; i = i + 1 {
    ac cell_num = add_cell(&gr, {LocationStatic, argtp.cu, argtp.props});
    push(&argcells, ac);
    pc cell_num = add_cell(&gr, {LocationVirtual, msi->cu_type, msi->cu_props});
    push(&pointeecells, pc);

    gn1 gr_num = addx(&gr, @[gr_xop]GrDeref({pc, ac, OffsetConst(0)}));
    gn gr_num = addx(&gr, gn1, @[gr_xop]GrDead({ac}));
    push(&derefgns, gn);
  }

  derefgn gr_num = addx(&gr, freeze(&derefgns), @[gr_xop]GrXNop);

  return_cell cell_num = add_cell(&gr, {LocationStatic, voidtp.cu, voidtp.props});

  deadprecs array[gr_num];
  if true {
    setret gr_num = addx(&gr, @[gr_xop]GrWriteConst({return_cell, ConstInt(~ @[u32] 0)}));
    push(&deadprecs, setret);

    for i size = 0; i < nargs; i = i + 1 {
      pd gr_num = addx(&gr, @[gr_xop]GrVirtualDead({get(&pointeecells, i)}));
      push(&deadprecs, pd);
    }
  }

  bn sq_num = seq1(&gr, addx(&gr, freeze(&deadprecs), @[gr_xop]GrXNop));

  nfields size = count(&msi->fips);
  check(nfields == count(&st->fields));
  for i2 size = 0; i2 < nfields; i2 = i2 + 1 {
    i size;
    if reverse_order {
      i = i2;
    } else {
      i = nfields - i2 - 1;
    }

    fieldcella array[cell_num];
    fieldcellgn array[gr_num];
    for j size = 0; j < nargs; j = j + 1 {
      fc cell_num = add_cell(&gr, {LocationVirtual, ~ ref(&st->fields, i)->type, ref(&psd.fields, i)->props});
      push(&fieldcella, fc);

      gn gr_num = addx(&gr, @[gr_xop]GrSubcell({fc, get(&pointeecells, j), OffsetConst(ref(&psd.fields, i)->offset)}));
      push(&fieldcellgn, gn);
    }

    field_gn gr_num;
    if case Has(ip instpair) = get(&msi->fips, i) {
      fieldptrtype cu_typeexpr;
      fieldptrtype_props type_properties;
      compute_prim(clq, ptr_type(cs, ref(&st->fields, i)->type), &fieldptrtype, &fieldptrtype_props);

      fieldptrcella array[cell_num];
      precs array[gr_num];
      for j size = 0; j < nargs; j = j + 1 {
        fpc cell_num = add_cell(&gr, {LocationStatic, fieldptrtype, fieldptrtype_props});
        push(&fieldptrcella, fpc);
        fpc_live gr_num = addx(&gr, @[gr_xop]GrLive({fpc}));
        gn1 gr_num = addx(&gr, mk_shray(fpc_live, get(&fieldcellgn, j)), @[gr_xop]GrAddressof({fpc, get(&fieldcella, j)}));
        gn gr_num = addx(&gr, gn1, @[gr_xop]GrVirtualDead({get(&fieldcella, j)}));
        push(&precs, gn);
      }

      fieldretcell cell_num = add_cell(&gr, {LocationStatic, voidtp.cu, voidtp.props});
      push(&precs, addx(&gr, @[gr_xop]GrLive({fieldretcell})));

      fntype cu_typeexpr;
      fntype_props type_properties;
      compute_prim(clq, fn_type(cs, @[shray[_]]repeat(nargs, fieldptrtype.x), voidtp.cu.x), &fntype, &fntype_props);

      func_cell cell_num = add_cell(&gr, {LocationStatic, fntype, fntype_props});
      func_cell_live gr_num = addx(&gr, @[gr_xop]GrLive({func_cell}));
      func_gn gr_num = addx(&gr, func_cell_live, @[gr_xop]GrWriteConst({func_cell, ConstDef(ip)}));
      push(&precs, func_gn);

      ap gr_num = addx(&gr, freeze(&precs), @[gr_xop]GrApply({func_cell, freeze(&fieldptrcella), fieldretcell}));

      vd gr_num = addx(&gr, ap, @[gr_xop]GrDead({fieldretcell}));

      field_gn = vd;
    } else {
      ogn opt[gr_num];
      switch wc {
      case CtorInit:
        // zero-initialize.
        gn1 var = addx(&gr, freeze(&fieldcellgn), @[gr_xop]GrWriteConst({get(&fieldcella, 0), ConstInt(~ @[u32] 0)}));
        ogn = Has(gn1);
      case CtorCopy:
        gn1 var = addx(&gr, freeze(&fieldcellgn), @[gr_xop]GrMemCopy({get(&fieldcella, 0), get(&fieldcella, 1)}));
        ogn = Has(gn1);
      case CtorMove:
        gn1 var = addx(&gr, freeze(&fieldcellgn), @[gr_xop]GrMemCopy({get(&fieldcella, 0), get(&fieldcella, 1)}));
        ogn = Has(gn1);
      case CtorDestroy:
        // do nothing.
        ogn = None;
      }

      if case Has(gn gr_num) = ogn {
        dfcprecs array[gr_num];
        for j size = 0; j < nargs; j = j + 1 {
          dfc var = addx(&gr, @[gr_xop]GrVirtualDead({get(&fieldcella, j)}));
          push(&dfcprecs, dfc);
        }
        dfcnop gr_num = addx(&gr, freeze(&dfcprecs), @[gr_xop]GrXNop);
        field_gn = seq2(&gr, gn, dfcnop).x;
      } else {
        field_gn = addx(&gr, @[gr_xop]GrXNop);
      }
    }

    field_and_padding_gn gr_num;
    if init_padding {
      padding_offset u32;
      padding_count u32;
      postpadding_offset_and_count(&psd, i, &padding_offset, &padding_count);
      if case Has(bzero_gn gr_num) = gr_bzero_subcell(clq, &gr, get(&pointeecells, 0), padding_offset, padding_count) {
        nop2_gn var = addx(&gr, mk_shray(bzero_gn, field_gn), @[gr_xop]GrXNop);
        field_and_padding_gn = nop2_gn;
      } else {
        field_and_padding_gn = field_gn;
      }
    } else {
      field_and_padding_gn = field_gn;
    }

    bn = seqq(&gr, {field_and_padding_gn, bn});
  }

  gn var = seqq(&gr, {derefgn, bn});

  *gr_out = gr;
  *gn_out = gn.x;
  *return_cell_out = return_cell;
  *arg_cells_out = argcells;
  return NoFail;
}

func gr_bzero_subcell(clq *clqueue, gr *frame_graph, c cell_num, offset u32, size u32) opt[gr_num] {
  if size == 0 {
    return None;
  }
  padtype cu_typrop = compute_prim(clq, primitive_padding_type(clq->cs, size));
  pad_cell cell_num = add_cell(gr, {LocationVirtual, padtype.cu, padtype.props});
  subcell_gn var = addx(gr, @[gr_xop]GrSubcell({pad_cell, c, OffsetConst(offset)}));
  bzero_gn var = addx(gr, subcell_gn, @[gr_xop]GrWriteConst({pad_cell, ConstInt(bigu(0))}));
  vd_gn var = addx(gr, bzero_gn, @[gr_xop]GrVirtualDead({pad_cell}));
  return Has(vd_gn);
}

func postpadding_offset_and_count(psd *partial_struct_data, i size, offset_out *u32, count_out *u32) void {
  check(i < psd_index(psd));
  begin u32 = ref(&psd->fields, i)->offset + ref(&psd->fields, i)->props.flat_size;
  end u32;
  if i + 1 < psd_index(psd) {
    end = ref(&psd->fields, i + 1)->offset;
  } else {
    end = psd->offset;
  }
  *offset_out = begin;
  *count_out = end - begin;
}

func gr_magic_enum_construct(cs *checkstate, clq *clqueue, mec *magic_enum_construct, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cell_out *cell_num) np {
  gr frame_graph = init_frame_graph_empty(intern(cs->im, _s("magic_enum_construct")));
  retnum cell_num = add_cell(&gr, {LocationStatic, mec->return_type, mec->return_type_props});

  tagval enum_tag_value = mk_enum_tag_value(mec->constructor_index);

  argtype *te_typeexpr = &ref(&mec->et.constructors, mec->constructor_index)->type;
  field_offset u32 = enum_field_offset(cs, &mec->et, tagval);
  tag_end u32;
  tag_cell cell_num;
  if true {
    cu cu_typeexpr;
    props type_properties;
    compute_prim(clq, enum_tag_type(cs, &mec->et), &cu, &props);
    tag_end = props.flat_size;
    tag_cell = add_cell(&gr, {LocationVirtual, cu, props});
  }

  prepadding_ogn opt[gr_num]
    = gr_bzero_subcell(clq, &gr, retnum, tag_end, field_offset - tag_end);
  field_end u32 = field_offset + mec->rhs_props.flat_size;
  postpadding_ogn opt[gr_num]
    = gr_bzero_subcell(clq, &gr, retnum, field_end, mec->return_type_props.flat_size - field_end);

  argnum cell_num = add_cell(&gr, {LocationStatic, ~ *argtype, mec->rhs_props});
  retpart cell_num = add_cell(&gr, {LocationVirtual, ~ *argtype, mec->rhs_props});

  retpart_gn var = addx(&gr, @[gr_xop]GrSubcell({retpart, retnum, OffsetConst(field_offset)}));

  ctor_gn gr_num;
  switch &mec->operational {
  case &EnumConstructMove(cd ctor_desc):
    bi_ctor_gn1 gr_num;
    if case Printed(pm) = gr_bi_ctor(cs, clq, &gr, argtype, retpart, argnum, &cd, &bi_ctor_gn1) {
      return Printed(pm);
    }
    bi_ctor_gn gr_num = addx(&gr, bi_ctor_gn1, @[gr_xop]GrVirtualDead({retpart}));
    ctor_gn = addx(&gr, bi_ctor_gn, @[gr_xop]GrDead({argnum}));

  case &EnumConstructCopyDestroy(cdd copy_destroy_desc):
    cpgn1 gr_num;
    if case Printed(pm) = gr_bi_ctor(cs, clq, &gr, argtype, retpart, argnum, &cdd.copy_desc, &cpgn1) {
      return Printed(pm);
    }
    cpgn gr_num = addx(&gr, cpgn1, @[gr_xop]GrVirtualDead({retpart}));
    destgn gr_num;
    if case Printed(pm) = gr_destroy_ctor(cs, clq, &gr, argtype, argnum, &cdd.destroy_desc, &destgn) {
      return Printed(pm);
    }
    ctor_gn = seq2(&gr, cpgn, destgn).x;
  }

  assign_gn var = seq2(&gr, retpart_gn, ctor_gn);

  tagcell_gn var = addx(&gr, @[gr_xop]GrSubcell({tag_cell, retnum, OffsetConst(enum_tag_offset)}));
  tag_gn1 var = addx(&gr, tagcell_gn, @[gr_xop]GrWriteConst({tag_cell, ConstInt(~tagval.x)}));
  tag_gn var = addx(&gr, tag_gn1, @[gr_xop]GrVirtualDead({tag_cell}));
  gn var = addx(&gr, concat(@[opt[gr_num]]Has(tag_gn), prepadding_ogn, @[opt[gr_num]]Has(assign_gn.x), postpadding_ogn), @[gr_xop]GrXNop);
  *gr_out = gr;
  *gn_out = gn;
  *return_cell_out = retnum;
  *arg_cell_out = argnum;
  return NoFail;
}

func gr_bi_ctor(cs *checkstate, clq *clqueue, gr *frame_graph, ty *te_typeexpr, destnum cell_num, srcnum cell_num, cd *ctor_desc, gn_out *gr_num) np {
  switch cd {
  case &TrivialCtor:
    *gn_out = addx(gr, @[gr_xop]GrMemCopy({destnum, srcnum}));
  case &FunCtor(ip instpair):
    *gn_out = gr_bi_fun(clq, gr, ip, destnum, srcnum);
  }
  return NoFail;
}

func gr_destroy_ctor(cs *checkstate, clq *clqueue, gr *frame_graph, ty *te_typeexpr, argnum cell_num, cd *ctor_desc, gn_out *gr_num) np {
  switch cd {
  case &TrivialCtor:
    dp var = addx(gr, @[gr_xop]GrDead({argnum}));
    *gn_out = dp;
  case &FunCtor(ip instpair):
    gn gr_num = gr_uni_fun(clq, gr, ip, argnum);
    dp var = addx(gr, gn, @[gr_xop]GrDead({argnum}));
    *gn_out = dp;
  }
  return NoFail;
}

func add_prim_fn_body(cs *checkstate, clq *clqueue, informal_name sym, type *cu_typeexpr, op primitive_op) fn_body_id {
  gr frame_graph = init_frame_graph_empty(informal_name);
  typarams *shray[te_typeexpr];
  if !decompose_typeapp(&type->x, primitive_function_puretype(cs), &typarams) {
    ice(_u8("add_prim_fn_body called with non-fn type"));
  }
  argcells array[cell_num];
  ntyparams size = count(typarams);
  nfn_params size = ntyparams - 1;
  for i size = 0; i < nfn_params; i = i + 1 {
    ty *te_typeexpr = ref(typarams, i);
    props type_properties;
    if case Printed(pm) = compute_complete_type_properties(clq, ty, &props) {
      ice(_u8("add_prim_fn_body typrops"));
    }
    c cell_num = add_cell(&gr, {LocationStatic, ~ *ty, props});
    push(&argcells, c);
  }
  retty *te_typeexpr = ref(typarams, ntyparams - 1);
  retprops type_properties;
  if case Printed(pm) = compute_complete_type_properties(clq, retty, &retprops) {
    ice(_u8("add_prim_fn_body retprops"));
  }
  retcell cell_num = add_cell(&gr, {LocationStatic, ~ *retty, retprops});

  argcells_copy array[cell_num] = argcells;
  argshray shray[cell_num] = freeze(&argcells_copy);
  gn gr_num = addx(&gr, @[gr_xop]GrPrimApply({op, argshray, retcell}));
  return add_fn_body(cs, {informal_name, NotComputed, NotComputed, @[fn_body_entry_enum]GraphedFnBody({FnBodyPrim(op), {gr, gn, retcell}, argcells, InlineMust, NotComputed})});
}

func ensure_def_inst_graphed(cs *checkstate, clq *clqueue, ent_id def_entry_id, inst_id def_inst_id) np {
  if case Printed(pm) = ensure_def_inst_checked(cs, clq, ent_id, inst_id) {
    return Printed(pm);
  }

  ent *def_entry = ref_def_entry(cs, ent_id);
  inst *def_inst = ref_inst(cs, inst_id);
  inst_typrop *cu_typrop = un(&inst->typrop);
  switch &inst->graph {
    case &NotComputed: {
      inst->graph = BeganComputing;
      switch &inst->rhs {
        case &InstRhsPrim(op primitive_op): {
          id fn_body_id = add_prim_fn_body(cs, clq, ent->def_name, &inst_typrop->cu, op);
          frg frame_regraphed = mk_const_frame_regraphed(ent->def_name, &inst_typrop->cu, &inst_typrop->props, ConstFnBody(id));
          inst->graph = Computed(Has(frg));
          return NoFail;
        }
        case &InstRhsExtern: {
          // TODO: What if an extern def isn't a function?
          id fn_body_id = add_fn_body(cs, {ent->def_name, NotComputed, NotComputed, @[fn_body_entry_enum]ExternFnBody({ent->def_name})});
          frg frame_regraphed = mk_const_frame_regraphed(ent->def_name, &inst_typrop->cu, &inst_typrop->props, ConstFnBody(id));
          inst->graph = Computed(Has(frg));
          return NoFail;
        }
        case &InstRhsExpr(dire def_inst_rhs_expr): {
          info *frame_info;
          if case &Computed(finfo) = &dire.frame_info {
            info = &finfo;
          } else {
            ice(_u8("ensure_def_inst_graphed missing 'dire' info"));
          }
          gr frame_graph = init_frame_graph_from_incomplete(&info->incomplete_graph);
          gn gr_num;
          if case Printed(pm) = gr_live_and_expr_consume(clq, &gr, &dire.ec, &gn) {
            inst->graph = FailedComputation;
            return Printed(pm);
          }
          inst->graph = Computed(Has(@[frame_regraphed]{gr, gn, result_cell(&dire.ec)}));
          return NoFail;
        }

        case &InstRhsNonMagic(nonmag def_non_magic): {
          switch &nonmag {
          case &NonMagicCtor(wnmc which_non_magic_ctor):
            info *non_magic_ctor_info = un(&wnmc.nmc.info);
            frg frame_regraphed = mk_const_frame_regraphed(ent->def_name, &inst_typrop->cu, &inst_typrop->props, ConstDef(info->ip));
            inst->graph = Computed(Has(frg));
            return NoFail;
          case &NonMagicProp(nmp non_magic_prop):
            info u32 = *un(&nmp.info);
            frg frame_regraphed = mk_const_frame_regraphed(ent->def_name, &inst_typrop->cu, &inst_typrop->props, @[gr_const]ConstInt(~info));
            inst->graph = Computed(Has(frg));
            return NoFail;
          }
        }

        case &InstRhsMagic(mag def_magic): {
          id fn_body_id;
          if true {
            body_gr frame_graph;
            body_gn gr_num;
            return_cell cell_num;
            arg_cells array[cell_num];
            inline should_inline;
            if case Printed(pm) = gr_magic(cs, clq, &mag, &body_gr, &body_gn, &return_cell, &arg_cells, &inline) {
              return Printed(pm);
            }
            id = add_fn_body(cs, {ent->def_name, NotComputed, NotComputed, @[fn_body_entry_enum]GraphedFnBody({FnBodyMagic(&mag), {body_gr, body_gn, return_cell}, arg_cells, inline, NotComputed})});
          }

          frg frame_regraphed = mk_const_frame_regraphed(ent->def_name, &inst_typrop->cu, &inst_typrop->props, ConstFnBody(id));
          inst->graph = Computed(Has(frg));
          return NoFail;
        }
      }
    }
    case &BeganComputing: {
      ice(_u8("ensure_def_inst_graphed recursively computing"));
      return fake();
    }
    case &FailedComputation: {
      return ERR(_u8("ensure_def_inst_graphed fails again on same def"));
    }
    case &Computed(odr opt[frame_regraphed]): {
      return NoFail;
    }
  }
}

func mk_const_frame_regraphed(informal_name sym, type *cu_typeexpr, props *type_properties, c gr_const) frame_regraphed {
  gr frame_graph = init_frame_graph_empty(informal_name);
  cell cell_num = add_cell(&gr, {LocationStatic, *type, *props});
  cell_live gr_num = addx(&gr, @[gr_xop]GrLive({cell}));
  gn gr_num = addx(&gr, cell_live, @[gr_xop]GrWriteConst({cell, c}));
  return {gr, gn, cell};
}
