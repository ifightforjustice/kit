import ast;
import expr;

// We have a set of lifetimes that pop in and out of existence over time.  They all have interesting state that needs to be tracked.  We want to chase state through everything.

// How should we represent state?  We've got facts.  A big bag of facts.  Okay then.  I hope they aren't self-contradictory!

struct walkdesc {
  facts array[te_statedesc];
};

// There's just one of these (for any given walk).
struct walkstate {
  bs *bodystate;
  es *framescope;
  ds *defscope;
  clq *clqueue;
  cs *checkstate;
  im *identmap;

  current_desc walkdesc;
};

func mk(bs *bodystate) walkstate {
  ret walkstate = {bs, &bs->es, bs->ds, bs->clq, bs->cs, bs->im, {mk_array()}};
  return ret;
}

// computed_params is the fn[...] params (including return type and transdesc)
func walk_lambda_state(bs *bodystate, computed_params *shray[te_typeexpr], a *ast_lambda) np {
  ws walkstate = mk(bs);

  nargs size = count(&a->args);
  for i size = 0; i < nargs; i++ {
    vn var_number = *un(&ref(&a->args, i)->vn);
    vi *var_info = ref_var(&bs->es, vn);
    // Okay, and?
  }

  if case Printed(pm) = walk_body(&ws, &a->body.bb) {
    return Printed(pm);
  }

  // TODO(): Something must be done.
  return NoFail;
}

func walk_body(ws *walkstate, a *ast_bracebody) np {
  nstatements size = count(&a->statements);
  for i size = 0; i < nstatements; i++ {
    s *ast_statement = ref(&a->statements, i);
    if case Printed(pm) = walk_statement(ws, s) {
      return Printed(pm);
    }
  }
  // TODO(): Now walk the destructions.
  return NoFail;
}

func walk_statement(ws *walkstate, a *ast_statement) np {
  switch &a->u {
  case &Expr(b ast_expr_discard):
    if case Printed(pm) = walk_discard_expr(ws, &b) {
      return Printed(pm);
    }

  case &Return(b ast_return_statement):
    if case Printed(pm) = walk_return_statement(ws, &b) {
      return Printed(pm);
    }

  case &Var(b ast_var_statement):
    if case Printed(pm) = walk_var_statement(ws, &b) {
      return Printed(pm);
    }

  case &IfThen(b ast_ifthen_statement):
    if case Printed(pm) = walk_ifthen_statement(ws, &b) {
      return Printed(pm);
    }

  case &IfThenElse(b ast_ifthenelse_statement):
    if case Printed(pm) = walk_ifthenelse_statement(ws, &b) {
      return Printed(pm);
    }

  case &While(b ast_while_statement):
    if case Printed(pm) = walk_while_statement(ws, &b) {
      return Printed(pm);
    }

  case &For(b ast_for_statement):
    if case Printed(pm) = walk_for_statement(ws, &b) {
      return Printed(pm);
    }

  case &Switch(b ast_switch_statement):
    if case Printed(pm) = walk_switch_statement(ws, &b) {
      return Printed(pm);
    }

  case &Break(b ast_break_statement):
    if case Printed(pm) = walk_break_statement(ws, &b) {
      return Printed(pm);
    }

  case &Continue(b ast_continue_statement):
    if case Printed(pm) = walk_continue_statement(ws, &b) {
      return Printed(pm);
    }

  case &Label(b ast_label_statement):
    if case Printed(pm) = walk_label_statement(ws, &b) {
      return Printed(pm);
    }

  case &Goto(b ast_goto_statement):
    if case Printed(pm) = walk_goto_statement(ws, &b) {
      return Printed(pm);
    }
  }

  return NoFail;
}

func walk_goto_statement(ws *walkstate, a *ast_goto_statement) np {
  return TODO();
}

func walk_ifthen_statement(ws *walkstate, a *ast_ifthen_statement) np {
  return TODO();
}

func walk_ifthenelse_statement(ws *walkstate, a *ast_ifthenelse_statement) np {
  return TODO();
}

func walk_while_statement(ws *walkstate, a *ast_while_statement) np {
  return TODO();
}

func walk_for_statement(ws *walkstate, a *ast_for_statement) np {
  return TODO();
}

func walk_switch_statement(ws *walkstate, a *ast_switch_statement) np {
  return TODO();
}

func walk_break_statement(ws *walkstate, a *ast_break_statement) np {
  return TODO();
}

func walk_continue_statement(ws *walkstate, a *ast_continue_statement) np {
  return TODO();
}

func walk_label_statement(ws *walkstate, a *ast_label_statement) np {
  return TODO();
}

func walk_discard_expr(ws *walkstate, a *ast_expr_discard) np {
  if case Printed(pm) = walk_expr(ws, &a->expr) {
    return Printed(pm);
  }
  if case Printed(pm) = walk_expr_after_discard(ws, un(&a->after)) {
    return Printed(pm);
  }
  // TODO(): Something must be done?
  return NoFail;
}

func walk_expr(ws *walkstate, a *ast_expr) np {
  switch &a->u {
  case &NameExpr(b ast_name_expr):
    return TODO();
  case &ParenExpr(b ast_paren_expr):
    return walk_expr(ws, oo(&b.expr));
  case &NumericLiteral(b ast_numeric_literal):
    return TODO();
  case &BoolLiteral(b ast_bool_literal):
    return TODO();
  case &VoidLiteral(b ast_void_literal):
    return TODO();
  case &NullLiteral(b ast_null_literal):
    return TODO();
  case &CharLiteral(b ast_char_literal):
    return TODO();
  case &StringLiteral(b ast_string_literal):
    return TODO();
  case &Funcall(b ast_funcall):
    nparams size = count(&b.params);
    for i size = 0; i < nparams; i++ {
      if case Printed(pm) = walk_expr_consume(ws, ref(&b.params, i)) {
        return Printed(pm);
      }
    }
    // TODO: Handle funcall state.
    return TODO();
  case &LogicalConjunction(b ast_logical_conjunction):
    return TODO();
  case &Assignment(b ast_assignment):
    if case Printed(pm) = walk_expr(ws, oo(&b.lhs)) {
      return Printed(pm);
    }
    if case Printed(pm) = walk_expr(ws, oo(&b.rhs)) {
      return Printed(pm);
    }
    // TODO: Uh... assignment_info, value effects.
    return TODO();
  case &RefOf(b ast_refof):
    if case Printed(pm) = walk_expr(ws, oo(&b.rhs)) {
      return Printed(pm);
    }
    // TODO: idk.
    return TODO();
  case &AddressOf(b ast_addressof):
    if case Printed(pm) = walk_expr(ws, oo(&b.rhs)) {
      return Printed(pm);
    }
    // TODO: idk.
    return TODO();
  case &Deref(b ast_deref):
    if case Printed(pm) = walk_expr_consume(ws, oo(&b.rhs)) {
      return Printed(pm);
    }
    // TODO(): Handle pointer discard.
    return TODO();
  case &IndexExpr(b ast_index_expr):
    if case Printed(pm) = walk_expr(ws, oo(&b.lhs)) {
      return Printed(pm);
    }
    if case Printed(pm) = walk_expr_consume(ws, oo(&b.rhs)) {
      return Printed(pm);
    }
    // TODO(): idk.
    return TODO();
  case &Lambda(b ast_lambda):
    return TODO();
  case &LocalField(b ast_local_field):
    if case Printed(pm) = walk_expr(ws, oo(&b.lhs)) {
      return Printed(pm);
    }
    // TODO: idk.
    return TODO();
  case &DerefField(b ast_deref_field):
    if case Printed(pm) = walk_expr_consume(ws, oo(&b.lhs)) {
      return Printed(pm);
    }
    // TODO(): Handle pointer discard.
    return TODO();
  case &TypedExpr(b ast_typed_expr):
    return walk_expr(ws, oo(&b.expr));
  case &Strinit(b ast_strinit):
    nexprs size = count(&b.exprs);
    for i size = 0; i < nexprs; i++ {
      if case Printed(pm) = walk_strinit_param(ws, ref(&b.exprs, i)) {
        return Printed(pm);
      }
    }
    // TODO: idk.  Activate something?
    return TODO();
  case &Ternary(b ast_ternary):
    return TODO();
  }
}

func walk_strinit_param(ws *walkstate, a *ast_strinit_param) np {
  return walk_expr_consume(ws, &a->ec);
}

func walk_expr_consume(ws *walkstate, a *ast_expr_consume) np {
  if case Printed(pm) = walk_expr(ws, &a->expr) {
    return Printed(pm);
  }
  if case Printed(pm) = walk_expr_after_consume(ws, un(&a->after)) {
    return Printed(pm);
  }
  // TODO: idk.
  return TODO();
}

func walk_expr_after_discard(ws *walkstate, a *ast_expr_after_discard) np {
  switch a {
  case &DiscardTemporary(act destroy_action):
    return walk_destroy_action(ws, &act);
  case &DiscardVirtualDead(c cell_num):
    // TODO: idk.
    return TODO();
  case &DiscardNothing:
    // TODO(): How does this case exist?
    return NoFail;
  }
}

func walk_expr_after_consume(ws *walkstate, a *ast_expr_after_consume) np {
  switch &a->actions {
  case &ConsumeByInPlace:
    return NoFail;
  case &ConsumeByCopyDestroy(act copy_destroy_action):
    if case Printed(pm) = walk_copy_action(ws, &act.copy) {
      return Printed(pm);
    }
    if case Printed(pm) = walk_destroy_action(ws, &act.destroy) {
      return Printed(pm);
    }
    return NoFail;
  case &ConsumeByCopy(act tup[copy_action, lval_deadme]):
    if case Printed(pm) = walk_copy_action(ws, &act.car) {
      return Printed(pm);
    }
    // TODO(): Handle lval_deadme.
    return TODO();
  }
}

func walk_return_statement(ws *walkstate, a *ast_return_statement) np {
  if case &Has(b box[ast_expr_consume]) = &a->expr {
    if case Printed(pm) = walk_expr_consume(ws, oo(&b)) {
      return Printed(pm);
    }
  } else {
    // TODO(): Model assignment of void to return cell.
  }

  // TODO(): We exit the function, also we have a->destructions.
  return TODO();
}

func walk_var_statement(ws *walkstate, a *ast_var_statement) np {
  switch &a->rhs {
  case &HasExpr(b box[ast_expr_consume]):
    if case Printed(pm) = walk_expr_consume(ws, oo(&b)) {
      return Printed(pm);
    }
  case &AutoInit(act opt[init_action]):
    // TODO(): Why is act optional?  Should it be nc?
    return TODO();
  }

  // TODO: idk.
  return TODO();
}

func walk_copy_action(ws *walkstate, a *copy_action) np {
  return TODO();
}

func walk_destroy_action(ws *walkstate, a *destroy_action) np {
  return TODO();
}
