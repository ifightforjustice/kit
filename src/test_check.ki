import check;


func testmodule_name() string {
  return from_u8(_u8("testmodule"));
}

func test_loader(cs *checkstate, name sym) opt[array[u8]] {
  if name == intern(cs->im, testmodule_name()) {
    return Has(* @[*array[u8]]cast(cs->loader_ctx));
  } else {
    return None();
  }
}

func test_platform() platform_info {
  ret platform_info = {
    4,
    {1, 1},
    {{1, 1}, {-big("128"), big("127")}},
    {{1, 1}, {big("0"), big("255")}},
    {{2, 2}, {-big("32768"), big("32767")}},
    {{2, 2}, {big("0"), big("65536")}},
    {{4, 4}, {-big("2147483648"), big("2147483647")}},
    {{4, 4}, {big("0"), big("4294967296")}},
    {4, 4},
    {4, 4}
  };
  return ret;
}

func[T] run_check_test(ctx *check_ctx, name T, file array[u8]) void {
  print(Stdout(), _u8("test "), _u8(name), _u8("..."));
  fflush(Stdout());
  im identmap;
  cs checkstate = make_checkstate(&im, test_platform(), @[*void]cast(&file), test_loader);
  add_primitives(&cs);
  if !check_module(&cs, intern(&im, testmodule_name())) {
    print(Stdout(), _u8("FAIL\n"));
    fflush(Stdout());
    ctx->fail = true;
  } else {
    print(Stdout(), _u8("PASS\n"));
    fflush(Stdout());
  }
}

func[T] run_check_negtest(ctx *check_ctx, name T, file array[u8]) void {
  print(Stdout(), _u8("test !"), _u8(name), _u8("..."));
  fflush(Stdout());
  im identmap;
  cs checkstate = make_checkstate(&im, test_platform(), @[*void]cast(&file), test_loader);
  add_primitives(&cs);
  if check_module(&cs, intern(&im, testmodule_name())) {
    print(Stdout(), _u8("FAIL\n"));
    fflush(Stdout());
    ctx->fail = true;
  } else {
    print(Stdout(), _u8("PASS\n"));
    fflush(Stdout());
  }
}

// TODO: Make test output not go directly to stdout/stderr.

deftype check_ctx struct {
  fail bool;
};


func test_check_basic_cases(ctx *check_ctx) void {
  run_check_test(ctx, "c001",
    _u8("def x bool = true;"));
  run_check_test(ctx, "c002",
    _u8("def x i32 = 3;\n"
        "deftype dword u32;\n"
        "deftype blah dword;\n"
        "deftype feh *blah;\n"
        "deftype quux *quux;\n"));
  // Fails because foo holds itself flatly.
  run_check_negtest(ctx, "c003",
    _u8("deftype foo bar;\n"
        "deftype bar foo;\n"));
  run_check_test(ctx, "c004",
    _u8("def x i32 = 3;\n"
        "deftype foo struct { x u32; y i32; z *foo; };\n"));
  run_check_test(ctx, "c005",
    _u8("def x i32 = 3;"
        "deftype foo struct { x u32; y i32; z *foo; };\n"));
  // TODO: This should fail, because "whatever[_]" is not in scope.
  run_check_test(ctx, "c006-a",
    _u8("def x i32 = 3;"
        "deftype[T] foo struct { count u32; p whatever[T]; };\n"));
  run_check_test(ctx, "c006-b",
    _u8("def x i32 = 3;"
        "deftype[T] foo struct { count u32; p *T; };\n"));
  // Fails because bar recursively holds itself through a template parameter.
  run_check_negtest(ctx, "c007",
    _u8("deftype[T, U] foo struct { x *T; y U; };\n"
        "deftype bar struct { z foo[u32, bar]; };\n"));
  run_check_test(ctx, "c008",
    _u8("deftype[T, U] foo struct { x *T; y U; };\n"
        "deftype bar struct { z foo[bar, u32]; };\n"));
  run_check_test(ctx, "c009",
    _u8("def x i32 = 3;\n"));
  run_check_test(ctx, "c010",
    _u8("def x u32 = 3;\n"));
  run_check_test(ctx, "c011-a",
    _u8("def[] x i32 = 3;\n"));
  run_check_test(ctx, "c011-b",
    _u8("def[] x i32 = 3;\n"
        "def y i32 = x;\n"));
}

func test_check_lambda_cases(ctx *check_ctx) void {
  run_check_test(ctx, "c012",
    _u8("def x i32 = 3;\n"
        "def y fn[i32, i32] = func(z i32)i32 {\n"
        "  return x;\n"
        "};\n"));
  // Fails because k is a u32.
  run_check_negtest(ctx, "c013",
    _u8("def x i32 = 3;\n"
        "def k u32 = k;\n"
        "def x i32 = 3;\n"
        "def y fn[i32, i32] = func(z i32)i32 {\n"
        "  return k;\n"
        "};\n"));
  // Passes despite x shadowing a global, because that's allowed.
  run_check_test(ctx, "c014",
    _u8("def x i32 = 3;\n"
        "def y fn[i32, i32] = func(z i32)i32 {\n"
        "  var x i32 = 4;\n"
        "  return z;\n"
        "};\n"));
  // Fails because z shadows a local.
  run_check_negtest(ctx, "c016",
    _u8("def x i32 = 3;\n"
        "def y fn[i32, i32] = func(z i32)i32 {\n"
        "  var z i32 = 4;\n"
        "  return x;\n"
        "};\n"));
  run_check_test(ctx, "c017",
    _u8("def x i32 = 3;\n"
        "def y fn[i32, i32] = func(z i32)i32 {\n"
        "  return x + z + 5;\n"
        "};\n"));
}

func test_check() bool {
  ctx check_ctx;
  test_check_basic_cases(&ctx);
  test_check_lambda_cases(&ctx);
  return !ctx.fail;
}
