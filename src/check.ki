import ast;
import parse;
import tok;
import typeexpr;
import shp;
import u8ast;

deftype checkstate struct {
  im *identmap;
  loader fn[sym, opt[array[u8]]];

  modules array[shp[module]];
  modules_by_name hash[sym, module_id];

  instantiations array[shp[def_inst]];
  type_instantiations array[shp[deftype_inst]];

  deftypes array[shp[deftype_entry]];
  deftypes_by_name hash[sym, array[deftype_entry_id]];

  aliases array[shp[alias_entry]];
  aliases_by_name hash[sym, array[alias_entry_id]];

  defs array[shp[def_entry]];
  defs_by_name hash[sym, array[def_entry_id]];
};

// An index into checkstate's modules array.
deftype module_id size;
def `~` fn[size, module_id] = wrapconvert;

// An index into checkstate's instantiations array.
deftype def_inst_id size;
def `~` fn[size, def_inst_id] = wrapconvert;

// An index into checkstate's type_instantiations array.
deftype deftype_inst_id size;
def `~` fn[size, deftype_inst_id] = wrapconvert;

// An index into checkstate's defs array.
deftype def_entry_id size;
def `~` fn[size, def_entry_id] = wrapconvert;

// An index into checkstate's deftypes array.
deftype deftype_entry_id size;
def `~` fn[size, deftype_entry_id] = wrapconvert;

// An index into checkstate's aliases array.
deftype alias_entry_id size;
def `~` fn[size, alias_entry_id] = wrapconvert;

func ref_module(cs *checkstate, id module_id) *module {
  return oo(ref(&cs->modules, id.~));
}

func ref_def_entry(cs *checkstate, id def_entry_id) *def_entry {
  return oo(ref(&cs->defs, id.~));
}

func ref_deftype_entry(cs *checkstate, id deftype_entry_id) *deftype_entry {
  return oo(ref(&cs->deftypes, id.~));
}

func ref_alias_entry(cs *checkstate, id alias_entry_id) *alias_entry {
  return oo(ref(&cs->aliases, id.~));
}

func ref_inst(cs *checkstate, id def_inst_id) *def_inst {
  return oo(ref(&cs->instantiations, id.~));
}

func add_inst(cs *checkstate, val def_inst) def_inst_id {
  id def_inst_id = ~count(&cs->instantiations);
  push(&cs->instantiations, emshp(val));
  return id;
}

defenum module_process_state {
  Unprocessed void;
  Processing void;
  DoneProcessing void;
};

func `==`(a module_process_state, b module_process_state) bool {
  return enumnum(&a) == enumnum(&b);
}

deftype module struct {
  module_name sym;
  file ast_file;
  buf array[u8];
  process_state module_process_state;
  // vvv  Valid when process_state == DoneProcessing.  vvv
  defs array[def_entry_id];
  deftypes array[deftype_entry_id];
  aliases array[alias_entry_id];
};

deftype deftype_inst struct {
  parms genparms;
};

deftype deftype_entry struct {
  module_name sym;
  name sym;
  tl *ast_type_def;

  insts array[deftype_inst_id];
};

func mk(module_name sym, name sym, tl *ast_type_def) deftype_entry {
  return {module_name, name, tl, default()};
}

deftype alias_entry struct {
  module_name sym;
  alias_name sym;
  tl *ast_toplevel;
};

defenum genparms {
  NoParms void;
  HasParms array[te_typeexpr];
};

deftype def_inst struct {
  parms genparms;
  // Our own copy of the def, which we can annotate.  It does not have its generics replaced.
  ast ast_def;
  computed_type_complete bool;
  // Becomes the concrete type (with generics replaced) once we've computed it and checked it.
  computed_type te_typeexpr;
};

func mk(parms genparms, a ast_def) def_inst {
  return {parms, a, false, default()};
}

deftype def_entry struct {
  module_name sym;
  def_name sym;
  tl *ast_toplevel;

  insts array[def_inst_id];
};

func mk(module_name sym, def_name sym, tl *ast_toplevel) def_entry {
  return {module_name, def_name, tl, default()};
}

func check_module(cs *checkstate, mod_name sym) bool {
  switch process_module(cs, mod_name) {
    case None(v): {
      return false;
    }
    case Has(id module_id): {
      mod *module = ref_module(cs, id);
      ndefs size = count(&mod->defs);
      for i size = 0; i < ndefs; i = i + 1 {
        if !ensure_def_checked(cs, get(&mod->defs, i)) {
          return false;
        }
      }

      ndeftypes size = count(&mod->deftypes);
      for i size = 0; i < ndeftypes; i = i + 1 {
        if !ensure_deftype_checked(cs, get(&mod->deftypes, i)) {
          return false;
        }
      }

      naliases size = count(&mod->aliases);
      for i size = 0; i < naliases; i = i + 1 {
        if !ensure_alias_checked(cs, get(&mod->aliases, i)) {
          return false;
        }
      }

      // I guess that's everything.
      // TODO: Check that access blocks point to an actual type?
      return true;
    }
  }
}

func find_matching_inst(cs *checkstate, insts *array[def_inst_id], parms *genparms) opt[def_inst_id] {
  n size = count(insts);
  for i size = 0; i < n; i = i + 1 {
    id def_inst_id = get(insts, i);
    inst *def_inst = ref_inst(cs, id);
    if parms_equal(cs, parms, &inst->parms) {
      return Has(id);
    }
  }
  return None();
}

func parms_equal(cs *checkstate, a *genparms, b *genparms) bool {
  if enumnum(a) != enumnum(b) {
    return false;
  }
  switch a {
    case &NoParms(v void): { return true; }
    case &HasParms(ah array[te_typeexpr]): {
      switch b {
        case &HasParms(bh array[te_typeexpr]): {
          return typeexpr_list_equal(cs, &ah, &bh);
        }
      }
    }
  }
}

func arity(parms *genparms) generics_arity {
  switch parms {
    case &NoParms(v void): { return NoParamsArity(void); }
    case &HasParms(arr array[te_typeexpr]): { return FiniteArity(~count(&arr)); }
  }
}

func ensure_def_checked_with_parms(cs *checkstate, ent *def_entry, a *ast_def, parms *genparms) bool {
  check(arity(&a->generics) == arity(parms));

  if case Has(id) = find_matching_inst(cs, &ent->insts, parms) {
    // If we already have an inst, that means we made an inst.

    inst *def_inst = ref_inst(cs, id);
    if !inst->computed_type_complete {
      ERR(_u8("computing def's type arouses cyclic dependency"));
      return false;
    }

    return true;
  }

  id def_inst_id = add_inst(cs, mk(*parms, *a));
  inst *def_inst = ref_inst(cs, id);
  // TODO: We ignore is_export entirely.  Is it relevant at all?
  a = &inst->ast;

  // TODO: We need to check exact name shadowing(?), typeexpr, and rhs.

  // Important:  We check the typeexpr first.  If that typeexpr cyclically refers to this def, we fail.  If there is no typeexpr, we need to compute it from the rhs (and that also needs to not depend cyclically on this def's own typeexpr).
  if case &Has(t ast_typeexpr) = &a->typeexpr {
    computed_complete bool;
    computed te_typeexpr;
    if !check_and_compute_typeexpr(cs, &a->generics, &inst->parms, &t, &computed, &computed_complete) {
      return false;
    }
    inst->computed_type_complete = computed_complete;
    inst->computed_type = computed;
  } else {
    inst->computed_type_complete = false;
    inst->computed_type = TeUnknown(void);
  }

  // TODO: How do we know that a->generics doesn't shadow, doesn't self-shadow?
  complete_type te_typeexpr;
  if !check_expr(cs, &a->generics, &inst->parms, &inst->computed_type, &a->rhs, &complete_type) {
    return false;
  }
  inst->computed_type_complete = true;
  inst->computed_type = complete_type;
  return true;
}

func check_and_compute_typeexpr(cs *checkstate, g *ast_generics, parms *genparms, t *ast_typeexpr, computed_out *te_typeexpr, computed_complete_out *bool) bool {
  // TODO: We need some kind of proper flatness checking.
  switch t {
    case &Name(a ast_ident): {
      if !check_and_compute_name_type(cs, g, parms, &a, computed_out) {
        return false;
      }
      *computed_complete_out = true;
      return true;
    }
    case &App(a ast_typeapp): {
      return check_and_compute_app_type(cs, g, parms, &a, computed_out, computed_complete_out);
    }
    case &Struct(a ast_struct): {
      computed_fields_complete bool;
      computed_fields array[te_vardecl];
      if !help_check_fields(cs, g, parms, &a.fields, &computed_fields, &computed_fields_complete) {
        return false;
      }
      *computed_out = TeStruct({computed_fields});
      *computed_complete_out = computed_fields_complete;
      return true;
    }
    case &Enum(a ast_enum): {
      // TODO: For enums, field names are constructors.  Check shadowing?
      computed_constructors_complete bool;
      computed_constructors array[te_vardecl];
      if !help_check_fields(cs, g, parms, &a.constructors, &computed_constructors, &computed_constructors_complete) {
        return false;
      }
      *computed_out = TeEnum({computed_constructors});
      *computed_complete_out = computed_constructors_complete;
      return true;
    }
    case &Union(a ast_union): {
      // TODO: Unions will need to enforce that they have "primitive" types, no classes.
      computed_fields_complete bool;
      computed_fields array[te_vardecl];
      if !help_check_fields(cs, g, parms, &a.fields, &computed_fields, &computed_fields_complete) {
        return false;
      }
      *computed_out = TeUnion({computed_fields});
      *computed_complete_out = computed_fields_complete;
      return true;
    }
    case &Arraytype(a ast_arraytype): {
      param box[te_typeexpr];
      param_complete bool;
      if !check_and_compute_typeexpr(cs, g, parms, oo(&a.param), oo(&param), &param_complete) {
        return false;
      }
      if case &Has(b box[ast_expr]) = &a.count {
        // TODO: _really_ typecheck and statically eval count.
        count u32;
        if !fake_eval_arraytype_count(oo(&b), &count) {
          return false;
        }
        *computed_out = TeArraytype({Has(count), param});
        *computed_complete_out = param_complete;
        return true;
      } else {
        *computed_out = TeArraytype({None(), param});
        *computed_complete_out = false;
        return true;
      }
    }
    case &Unknown(a ast_unknown): {
      *computed_out = TeUnknown(void);
      *computed_complete_out = false;
      return true;
    }
  }
}

func fake_eval_arraytype_count(x *ast_expr, count_out *u32) bool {
  // TODO: Remove this function and really evaluate an array's count expression.
  return TODO();
}

func help_check_fields(cs *checkstate, g *ast_generics, parms *genparms, a *array[ast_vardecl], computed_fields_out *array[te_vardecl], computed_fields_complete_out *bool) bool {
  return TODO();
}

func check_and_compute_name_type(cs *checkstate, g *ast_generics, parms *genparms, a *ast_ident, computed_out *te_typeexpr) bool {
  // Generic parameters have already been checked.  (I hope so.)
  if lookup_generic(g, parms, a->value, computed_out) {
    return true;
  }

  matching_alias opt[alias_entry_id];
  if !match_alias_by_name(cs, a->value, &matching_alias) {
    // An error happened when looking up an alias (multiple matches?).
    return false;
  }
  matching_deftype opt[deftype_entry_id];
  if !match_deftype_by_name(cs, a->value, &matching_deftype) {
    // An error happened when looking up a deftype (multiple matches?).
    return false;
  }

  if case Has(id) = matching_alias {
    if case Has(deftype_id) = matching_deftype {
      ERR(_u8("Both an alias and deftype match for name "), lookup(cs->im, a->value));
      return false;
    }
    return TODO();
  } else {
    if case Has(id) = matching_deftype {
      np genparms = NoParms(void);
      return ensure_deftype_checked_with_parms(cs, ref_deftype_entry(cs, id), &np);
    } else {
      ERR(_u8("type name has no match "), lookup(cs->im, a->value));
      return false;
    }
  }
}

func match_deftype_by_name(cs *checkstate, name sym, out *opt[deftype_entry_id]) bool {
  return TODO();
}

func match_alias_by_name(cs *checkstate, name sym, out *opt[alias_entry_id]) bool {
  return TODO();
}

func lookup_generic(g *ast_generics, parms *genparms, name sym, out *te_typeexpr) bool {
  return TODO();
}

func check_and_compute_app_type(cs *checkstate, g *ast_generics, parms *genparms, a *ast_typeapp, computed_out *te_typeexpr, computed_complete_out *bool) bool {
  return TODO();
}

func check_expr(cs *checkstate, g *ast_generics, parms *genparms, pt *te_typeexpr, x *ast_expr, computed_out *te_typeexpr) bool {
  return TODO();
}

func ensure_def_checked(cs *checkstate, id def_entry_id) bool {
  ent *def_entry = ref_def_entry(cs, id);
  switch ent->tl {
    case &Def(a ast_def): {
      switch &a.generics {
        case &NoGenerics(v): {
          parms genparms = NoParms(void);
          return ensure_def_checked_with_parms(cs, ent, &a, &parms);
        }
        case &HasGenerics(v): {
          // We declare success -- we check non-generic defs.
          return true;
        }
      }
    }
    case &ExternDef(a ast_extern_def): {
      return TODO();
    }
    default: {
      ice(_u8("def_entry has invalid toplevel\n"));
      return fake();
    }
  }
}

func ensure_deftype_checked_with_parms(cs *checkstate, ent *deftype_entry, parms *genparms) bool {
  return TODO();
}

func ensure_deftype_checked(cs *checkstate, id deftype_entry_id) bool {
  return TODO();
}

func ensure_alias_checked(cs *checkstate, id alias_entry_id) bool {
  return TODO();
}

func load_module(cs *checkstate, mod_name sym) opt[module_id] {
  switch lookup(&cs->modules_by_name, mod_name) {
    case Has(id module_id): {
      return Has(id);
    }
    case None(v): {
      switch (cs->loader)(mod_name) {
        case None(v2): {
          ERR(_u8("Could not open file for module "), lookup(cs->im, mod_name));
          return None();
        }
        case Has(arr array[u8]): {
          mod shp[module];
          oo(&mod)->process_state = Unprocessed(void);
          oo(&mod)->module_name = mod_name;
          oo(&mod)->buf = arr;
          p ps = make_ps(cs->im, data(&oo(&mod)->buf), count(&oo(&mod)->buf));
          if !parse_file(&p, &oo(&mod)->file) {
            ERR(_u8("Trouble parsing module "), lookup(cs->im, mod_name));
            return None();
          }
          mod_id module_id = ~count(&cs->modules);
          push(&cs->modules, mod);
          if !try_insert(&cs->modules_by_name, mod_name, mod_id) {
            ERR(_u8("ICE: modules_by_name already has name "), lookup(cs->im, mod_name));
            return None();
          }
          return Has(mod_id);
        }
      }
    }
  }
}

func process_module(cs *checkstate, mod_name sym) opt[module_id] {
  switch load_module(cs, mod_name) {
    case None(v): {
      return None();
    }
    case Has(id module_id): {
      mod *module = ref_module(cs, id);
      if mod->process_state == Unprocessed(void) {
         if !process_defs(cs, mod) {
           return None();
         }
      }
      return Has(id);
    }
  }
}

func process_defs(cs *checkstate, mod *module) bool {
  check_mutate(&mod->process_state, Unprocessed(void), Processing(void));
  if !process_toplevels(cs, mod, &mod->file.toplevels) {
    return false;
  }
  check_mutate(&mod->process_state, Processing(void), DoneProcessing(void));
  return true;
}

func add_def_entry(cs *checkstate,
                   module_name sym,
                   module_defs *array[def_entry_id],
                   ent shp[def_entry]) void {
  id def_entry_id = ~count(&cs->defs);
  push(&cs->defs, ent);
  arr *array[def_entry_id] = try_insert_lookup(
    &cs->defs_by_name, oo(ent)->def_name, default());
  push(arr, id);
  push(module_defs, id);
}

func process_toplevels(cs *checkstate,
                       mod *module,
                       toplevels *array[ast_toplevel]) bool {
  for i size = 0; i < count(toplevels); i = i + 1 {
    toplevel *ast_toplevel = ref(toplevels, i);
    switch toplevel {
      case &Import(a ast_import): {
        switch process_module(cs, a.name.value) {
          case None(v): {
            return false;
          }
          case Has(id module_id): {
            // Do nothing!  We've processed the module successfully.
          }
        }
      }
      case &Def(a ast_def): {
        ent shp[def_entry] = emshp(mk(mod->module_name, a.name.value, toplevel));
        add_def_entry(cs, mod->module_name, &mod->defs, ent);
      }
      case &ExternDef(a ast_extern_def): {
        ent shp[def_entry] = emshp(mk(mod->module_name, a.name.value, toplevel));
        add_def_entry(cs, mod->module_name, &mod->defs, ent);
      }
      case &TypeDef(a ast_type_def): {
        ent shp[deftype_entry] = emshp(mk(mod->module_name, a.name.value, &a));
        id deftype_entry_id = ~count(&cs->deftypes);
        push(&cs->deftypes, ent);
        arr *array[deftype_entry_id] = try_insert_lookup(
          &cs->deftypes_by_name, oo(ent)->name, default());
        push(arr, id);
        push(&mod->deftypes, id);
      }
      case &TypeAlias(a ast_type_alias): {
        ent shp[alias_entry] = emshp({mod->module_name, a.name.value, toplevel});
        id alias_entry_id = ~count(&cs->aliases);
        push(&cs->aliases, ent);
        arr *array[alias_entry_id] = try_insert_lookup(
          &cs->aliases_by_name, oo(ent)->alias_name, default());
        push(arr, id);
        push(&mod->aliases, id);
      }
      case &Access(a ast_access): {
        if !process_toplevels(cs, mod, &a.toplevels) {
          return false;
        }
      }
    }
  }
  return true;
}

func[T, U, V, W] ERR(x T, y U, z V, p W) void {
  ERR(cons(cons(x, y), cons(z, p)));
}

func[T, U, V] ERR(x T, y U, z V) void {
  ERR(cons(cons(x, y), z));
}

func[T, U] ERR(x T, y U) void {
  ERR(cons(x, y));
}

func[T] ERR(x T) void {
  print(Stderr(), to_u8str(x));
  print(Stderr(), _u8("\n"));
  fflush(Stderr());
}

func ice(msg array[u8]) void {
  x _ = _u8("ICE: ");
  append(&x, &msg);
  crash(x);
}
