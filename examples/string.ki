import bar;

extern malloc func[u32, *void];
extern free func[*void, void];

def[T] alloc_array func[u32, *T] = fn(n u32) *T {
  var u union { vp *void; tp *T; };
  u.vp = malloc(n * sizeof@[T]);
  for var i u32 = 0u; i < n; i = i + 1u {
    init(&u.tp[i]);
  }
  return u.tp;
};

def[T] delete_array func[u32, *T, void] = fn(n u32, p *T) void {
  for var i u32 = 0u; i < n; i = i + 1u {
    destroy(&p[i]);
  }
  var u union { vp *void; tp *T; };
  u.tp = p;
  free(u.vp);
  var ret void;
  return ret;
};

def alloc_u8_array func[u32, *u8] = fn(n u32) *u8 {
  var u union { vp *void; u8p *u8; };
  u.vp = malloc(n);
  return u.u8p;
};

def free_u8_array func[*u8, void] = fn(p *u8) void {
  var u union { vp *void; u8p *u8; };
  u.u8p = p;
  free(u.vp);
  var ret void;
  return ret;
};

defclass move string struct {
  size u32;
  cap u32;
  buf *u8;
};

access string {
  def do_init func[*string, void] = fn(p *string) void {
    p->size = 0u;
    p->cap = 0u;
    var buf *u8;
    p->buf = buf;
    var ret void;
    return ret;
  };

  def do_destroy func[*string, void] = fn(p *string) void {
    delete_array(p->cap, p->buf);
    var ret void;
    return ret;
  };

  def do_copy func[*string, *string, void] = fn(p *string, c *string) void {
    p->size = c->size;
    p->cap = c->cap;
    p->buf = alloc_array@[u8](p->size);
    var ret void;
    return ret;
  };

  def grow_cap func[*string, u32, void] = fn(p *string, newcap u32) void {
    var buf *u8 = alloc_array@[u8](newcap);
    var sz u32 = p->size;
    for var i u32 = 0u; i < sz; i = i + 1u {
      buf[i] = p->buf[i];
    }

    delete_array(p->cap, p->buf);
    p->buf = buf;
    p->cap = newcap;
    var ret void;
    return ret;
  };

  def append func[*string, u8, void] = fn(p *string, c u8) void {
    if p->size == p->cap {
      var new_cap u32;
      if (p->cap == 0u) {
        new_cap = 8u;
      } else {
        new_cap = p->cap + p->cap;
      }
      grow_cap(p, new_cap);
    }

    p->buf[p->size] = c;
    p->size = p->size + 1u;
    var ret void;
    return ret;
  };

  def get func[*string, u32, u8] = fn(p *string, i u32) u8 {
    return p->buf[i];
  };

  def size func[*string, u32] = fn(p *string) u32 {
    return p->size;
  };
}

def print func[*string, void] = fn(p *string) void {
  for var i u32 = 0u; i < size(p); i = i + 1u {
    var ch i32 = ~get(p, i);
    putchar(ch);
  }
  var ret void;
  return ret;
};
