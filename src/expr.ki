import check;

deftype exprscope struct {
  cs *checkstate;
  // Same as cs->im.
  im *identmap;
  clq *clqueue;
  // Generics and their _complete_ replacements.
  generics *ast_generics;
  parms *genparms;

  local_vars array[var_info];
};

deftype var_info struct {
  name sym;
  // A complete, checked, type, with generics replaced.
  type te_typeexpr;
};

defenum allow_incomplete {
  AllowIncompleteNo void;
  AllowIncompleteYes void;
};

func `==`(x allow_incomplete, y allow_incomplete) bool {
  return enumnum(&x) == enumnum(&y);
}

func check_expr(cs *checkstate, clq *clqueue, g *ast_generics, parms *genparms, x *ast_expr, pt *te_typeexpr) bool {
  es exprscope = {cs, cs->im, clq, g, parms, default@[array[var_info]]()};
  return check_expr_ai(&es, AllowIncompleteNo(void), x, pt);
}

deftype global_info struct {
  ent def_entry_id;
  inst def_inst_id;
};

deftype local_info struct {
  varinfo_ix size;
};

defenum name_info {
  Local void;
  Global global_info;
};

defenum es_match_res {
  NoMatch void;
  AmbigGlobalMatch void;
  OneGlobalMatch global_info;
  OneLocalMatch local_info;
};

func replaced_name_parms(es *exprscope, a *ast_name_expr, out *genparms) bool {
  if case &Has(arr array[ast_typeexpr]) = &a->generic_params {
    replaced array[te_typeexpr];
    n size = count(&arr);
    for i size = 0; i < n; i = i + 1 {
      converted te_typeexpr;
      if !convert_typeexpr(es->cs, ref(&arr, i), &converted) {
        return false;
      }
      computed te_typeexpr;
      computed_complete bool;
      if !check_and_compute_typeexpr(es->cs, es->clq, es->generics, es->parms, &converted, &computed, &computed_complete) {
        return false;
      }
      push(&replaced, computed);
    }
    *out = HasParms(replaced);
    return true;
  } else {
    *out = NoParms(void);
    return true;
  }
}

func es_lookup_name(es *exprscope, name sym, gp *genparms, pt *te_typeexpr, res_out *es_match_res) bool {
  if case &NoParms(v void) = gp {
    n size = count(&es->local_vars);
    for i size = 0; i < n; i = i + 1 {
      inf *var_info = ref(&es->local_vars, i);
      if inf->name == name {
        type te_typeexpr;
        if !unify_types(pt, &inf->type, &type) {
          return false;
        }
        *res_out = OneLocalMatch({i});
        return true;
      }
    }
  }

  res match_def_res;
  if !match_def(es->cs, name, gp, pt, &res) {
    return false;
  }

  switch res {
    case NoMatch(v void): {
      *res_out = NoMatch(void);
      return true;
    }
    case MultiMatch(void): {
      *res_out = AmbigGlobalMatch(void);
      return true;
    }
    case OneMatch(m struct { ent def_entry_id; }): {
      return TODO();
    }
  }
}


func check_expr_ai(es *exprscope, ai allow_incomplete, x *ast_expr, pt *te_typeexpr) bool {
  switch &x->u {
    case &NameExpr(a ast_name_expr): {
      parms genparms;
      if !replaced_name_parms(es, &a, &parms) {
        return false;
      }
      match_res es_match_res;
      if !es_lookup_name(es, a.ident.value, &parms, pt, &match_res) {
        return false;
      }
      switch &match_res {
        case &NoMatch(v void): {
          ERR(_u8("Name lookup for '"), lookup(es->im, a.ident.value), _u8("', maybe with parms, not found."));
          return false;
        }
        case &AmbigGlobalMatch(v void): {
          if ai == AllowIncompleteYes(void) {
            return TODO();
          } else {
            ERR(_u8("Name lookup for '"), lookup(es->im, a.ident.value), _u8("', maybe with parms, matches ambiguously."));
            return false;
          }
        }
        case &OneGlobalMatch(gi global_info): {
          return TODO();
        }
        case &OneLocalMatch(v local_info): {
          return TODO();
        }
      }
      return TODO();
    }
    case &ParenExpr(a ast_paren_expr): {
      return TODO();
    }
    case &NumericLiteral(a ast_numeric_literal): {
      return TODO();
    }
    case &BoolLiteral(a ast_bool_literal): {
      return TODO();
    }
    case &VoidLiteral(a ast_void_literal): {
      return TODO();
    }
    case &NullLiteral(a ast_null_literal): {
      return TODO();
    }
    case &CharLiteral(a ast_char_literal): {
      return TODO();
    }
    case &StringLiteral(a ast_string_literal): {
      return TODO();
    }
    case &Funcall(a ast_funcall): {
      return TODO();
    }
    case &IndexExpr(a ast_index_expr): {
      return TODO();
    }
    case &Lambda(a ast_lambda): {
      return TODO();
    }
    case &LocalField(a ast_local_field): {
      return TODO();
    }
    case &DerefField(a ast_deref_field): {
      return TODO();
    }
    case &TypedExpr(a ast_typed_expr): {
      return TODO();
    }
    case &Strinit(a ast_strinit): {
      return TODO();
    }
  }
}
