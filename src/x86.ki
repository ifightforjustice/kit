import array;

def x86_fillercode_byte u8 = 0xCC;

def X86_EAX u8 = 0;
def X86_ECX u8 = 1;
def X86_EDX u8 = 2;
def X86_EBX u8 = 3;
def X86_ESP u8 = 4;
def X86_EBP u8 = 5;
def X86_ESI u8 = 6;
def X86_EDI u8 = 7;

func mrr(mod u8, reg u8, rm u8) u8 {
  // TODO: s1 won't parse associative bitwise ops.
  return ((mod << 6) | (reg << 3)) | rm;
}

def MOD00 u8 = 0;
def MOD01 u8 = 1;
def MOD10 u8 = 2;
def MOD11 u8 = 3;

func appendtext(f *objfile, x u8) void {
  append_raw(&f->text, &x, 1);
}

func appendtext(f *objfile, x0 u8, x1 u8) void {
  b [2]u8;
  b[0] = x0;
  b[1] = x1;
  append_raw(&f->text, &b[0], 2);
}

func appendtext(f *objfile, x0 u8, x1 u8, x2 u8) void {
  b [3]u8;
  b[0] = x0;
  b[1] = x1;
  b[2] = x2;
  append_raw(&f->text, &b[0], 3);
}

func appendtext(f *objfile, x0 u8, x1 u8, x2 u8, x3 u8) void {
  b [3]u8;
  b[0] = x0;
  b[1] = x1;
  b[2] = x2;
  b[3] = x3;
  append_raw(&f->text, &b[0], 4);
}

func appendtext(f *objfile, x0 u8, x1 u8, x2 i32) void {
  b [6]u8;
  b[0] = x0;
  b[1] = x1;
  write_le_i32(&b[2], x2);
  append_raw(&f->text, &b[0], 6);
}

func appendtext(f *objfile, x0 u8, x1 u8, x2 u8, x3 i16) void {
  b [5]u8;
  b[0] = x0;
  b[1] = x1;
  b[2] = x2;
  write_le_i16(&b[3], x3);
  append_raw(&f->text, &b[0], 5);
}

func appendtext(f *objfile, x0 u8, x1 reg_rm_encoded) void {
  append_raw(&f->text, &x0, 1);
  append_raw(&f->text, &x1.buf[0], ~x1.length);
}

func appendtext(f *objfile, x0 u8, x1 u8, x2 reg_rm_encoded) void {
  b [2]u8;
  b[0] = x0;
  b[1] = x1;
  append_raw(&f->text, &b[0], 2);
  append_raw(&f->text, &x2.buf[0], ~x2.length);
}


func x86_push32(f *objfile, reg u8) void {
  appendtext(f, 0x50 + reg);
}

func x86_pop32(f *objfile, reg u8) void {
  appendtext(f, 0x58 + reg);
}

func x86_ret(f *objfile) void {
  appendtext(f, 0xC3);
}

func x86_retn(f *objfile, x u16) void {
  // I don't know if the immediate is treated signed or unsigned.
  check(x < ~ @[u32] 32768);
  b [3]u8;
  b[0] = 0xC2;
  write_le_u16(&b[1], x);
  append_raw(&f->text, &b[0], 3);
}

func x86_mov_reg32(f *objfile, dest u8, src u8) void {
  appendtext(f, 0x8B, mrr(MOD11, dest, src));
}

func x86_mov_reg8(f *objfile, dest u8, src u8) void {
  appendtext(f, 0x8A, mrr(MOD11, dest, src));
}

func x86_test_regs32(f *objfile, r1 u8, r2 u8) void {
  appendtext(f, 0x85, mrr(MOD11, r2, r1));
}

func x86_test_regs8(f *objfile, r1 u8, r2 u8) void {
  appendtext(f, 0x84, mrr(MOD11, r2, r1));
}

func x86_mov_imm32(f *objfile, dest u8, x i32) void {
  if x == 0 {
    x86_xor_w32(f, dest, dest);
  } else {
    b [5]u8;
    b[0] = 0xB8 + dest;
    write_le_i32(&b[1], x);
    append_raw(&f->text, &b[0], 5);
  }
}

func x8_mov_stiptr(f *objfile, dest u8, symbol_table_index sti) void {
  appendtext(f, 0xB8 + dest);
  append_dir32(&f->text, symbol_table_index);
}

func x86_int_3(f *objfile) void {
  appendtext(f, 0xCC);
}

func x86_shr_imm_w32(f *objfile, dest u8, imm u8) void {
  check(imm < 32);
  appendtext(f, 0xC1, mrr(MOD11, 5, dest), imm);
}

func x86_shl_cl_w32(f *objfile, dest u8) void {
  // SHL, SHR, SAR have different reg/opcode fields.
  appendtext(f, 0xD3, mrr(MOD11, 4, dest));
}

func x86_shl_cl_w16(f *objfile, dest u8) void {
  // SHL, SHR, SAR have different reg/opcode fields.
  appendtext(f, 0x66, 0xD3, mrr(MOD11, 4, dest));
}

func x86_shl_cl_w8(f *objfile, dest u8) void {
  // SHL, SHR, SAR have different reg/opcode fields.
  appendtext(f, 0xD2, mrr(MOD11, 4, dest));
}

func x86_shr_cl_w32(f *objfile, dest u8) void {
  // SHL, SHR, SAR have different reg/opcode fileds.
  appendtext(f, 0xD3, mrr(MOD11, 5, dest));
}

func x86_shr_cl_w16(f *objfile, dest u8) void {
  // SHL, SHR, SAR have different reg/opcode fileds.
  appendtext(f, 0x66, 0xD3, mrr(MOD11, 5, dest));
}

func x86_shr_cl_w8(f *objfile, dest u8) void {
  // SHL, SHR, SAR have different reg/opcode fileds.
  appendtext(f, 0xD2, mrr(MOD11, 5, dest));
}

func x86_sar_cl_w32(f *objfile, dest u8) void {
  // SHL, SHR, SAR have different reg/opcode fileds.
  appendtext(f, 0xD3, mrr(MOD11, 7, dest));
}

func x86_sar_cl_w16(f *objfile, dest u8) void {
  // SHL, SHR, SAR have different reg/opcode fileds.
  appendtext(f, 0x66, 0xD3, mrr(MOD11, 7, dest));
}

func x86_sar_cl_w8(f *objfile, dest u8) void {
  // SHL, SHR, SAR have different reg/opcode fileds.
  appendtext(f, 0xD2, mrr(MOD11, 7, dest));
}

func x86_add_esp_i32(f *objfile, x i32) void {
  appendtext(f, 0x81, mrr(MOD11, 0, X86_ESP), x);
}

func x86_add_w32(f *objfile, dest u8, src u8) void {
  appendtext(f, 0x01, mrr(MOD11, src, dest));
}

func x86_add_w16(f *objfile, dest u8, src u8) void {
  appendtext(f, 0x66, 0x01, mrr(MOD11, src, dest));
}

func x86_add_w8(f *objfile, dest u8, src u8) void {
  appendtext(f, 0x00, mrr(MOD11, src, dest));
}

func x86_eaxedx_mul_w32(f *objfile, src u8) void {
  // MUL, DIV, IDIV have different modr/m opcode.
  appendtext(f, 0xF7, mrr(MOD11, 4, src));
}

func x86_dxax_mul_w16(f *objfile, src u8) void {
  appendtext(f, 0x66, 0xF7, mrr(MOD11, 4, src));
}

func x86_alah_mul_w8(f *objfile, src u8) void {
  appendtext(f, 0xF6, mrr(MOD11, 4, src));
}

func x86_imul_w32(f *objfile, dest u8, src u8) void {
  appendtext(f, 0x0F, 0xAF, mrr(MOD11, dest, src));
}

func x86_imul_w16(f *objfile, dest u8, src u8) void {
  appendtext(f, 0x66, 0x0F, 0xAF, mrr(MOD11, dest, src));
}

func x86_alah_imul_w8(f *objfile, src u8) void {
  appendtext(f, 0xF6, mrr(MOD11, 5, src));
}

func x86_eaxedx_div_w32(f *objfile, denom u8) void {
  appendtext(f, 0xF7, mrr(MOD11, 6, denom));
}

func x86_axdx_div_w16(f *objfile, denom u8) void {
  appendtext(f, 0x66, 0xF7, mrr(MOD11, 6, denom));
}

func x86_alah_div_w8(f *objfile, denom u8) void {
  appendtext(f, 0xF6, mrr(MOD11, 6, denom));
}

func x86_eaxedx_idiv_w32(f *objfile, denom u8) void {
  appendtext(f, 0xF7, mrr(MOD11, 7, denom));
}

func x86_axdx_idiv_w16(f *objfile, denom u8) void {
  appendtext(f, 0x66, 0xF7, mrr(MOD11, 7, denom));
}

func x86_alah_idiv_w8(f *objfile, denom u8) void {
  appendtext(f, 0xF6, mrr(MOD11, 7, denom));
}

func x86_cdq_w32(f *objfile) void {
  appendtext(f, 0x99);
}

func x86_cmp_w32(f *objfile, lhs u8, rhs u8) void {
  appendtext(f, 0x39, mrr(MOD11, rhs, lhs));
}

func x86_cmp_w16(f *objfile, lhs u8, rhs u8) void {
  appendtext(f, 0x66, 0x39, mrr(MOD11, rhs, lhs));
}

func x86_cmp_imm32(f *objfile, lhs u8, x i32) void {
  appendtext(f, 0x81, mrr(MOD11, 7, lhs), x);
}

func x86_cmp_reg16_imm16(f *objfile, lhs u8, x i16) void {
  appendtext(f, 0x66, 0x81, mrr(MOD11, 7, lhs), x);
}

func x86_cmp_reg8_imm8(f *objfile, lhs u8, x i8) void {
  appendtext(f, 0x80, mrr(MOD11, 7, lhs), @[u8] ~ (0xFF & @[i32] ~x));
}

func x86_xor_w32(f *objfile, dest u8, src u8) void {
  appendtext(f, 0x31, mrr(MOD11, src, dest));
}

func x86_or_w32(f *objfile, dest u8, src u8) void {
  appendtext(f, 0x09, mrr(MOD11, src, dest));
}

func x86_and_w32(f *objfile, dest u8, src u8) void {
  appendtext(f, 0x21, mrr(MOD11, src, dest));
}

func x86_not_w8(f *objfile, dest u8) void {
  appendtext(f, 0xF6, mrr(MOD11, 2, dest));
}

func x86_not_w16(f *objfile, dest u8) void {
  appendtext(f, 0x66, 0xF7, mrr(MOD11, 2, dest));
}

func x86_not_w32(f *objfile, dest u8) void {
  appendtext(f, 0xF7, mrr(MOD11, 2, dest));
}

func x86_neg_w32(f *objfile, dest u8) void {
  appendtext(f, 0xF7, mrr(MOD11, 3, dest));
}

func x86_sub_w32(f *objfile, dest u8, src u8) void {
  appendtext(f, 0x29, mrr(MOD11, src, dest));
}

func x86_sub_w16(f *objfile, dest u8, src u8) void {
  appendtext(f, 0x66, 0x29, mrr(MOD11, src, dest));
}

func x86_sub_w8(f *objfile, dest u8, src u8) void {
  appendtext(f, 0x28, mrr(MOD11, src, dest));
}

func x86_setcc_b8(f *objfile, dest u8, setcc_code u8) void {
  appendtext(f, 0x0F, setcc_code, mrr(MOD11, 0, dest));
}

func x86_load32_zeroextend(f *objfile, ebp_disp i32, size u32) void {
  // EAX/EBP is hard-coded so that we "know" this is on the stack and it's okay to overread when size == 3.  Also since EAX == AX == AL
  dest u8 = X86_EAX;
  src_addr u8 = X86_EBP;
  if size == 0 {
    x86_xor_w32(f, dest, dest);
  } else if size == 4 {
    x86_load32(f, dest, src_addr, ebp_disp);
  } else if size == 1 {
    x86_movzx8(f, dest, src_addr, ebp_disp);
  } else if size == 2 {
    x86_movzx16(f, dest, src_addr, ebp_disp);
  } else if size == 3 {
    x86_load32(f, dest, src_addr, ebp_disp);
    x86_and_imm32(f, dest, 0x00FFFFFF);
  } else {
    ice(_u8("x86_load32_zeroextend with bad size"));
  }
}

func x86_store32_partial_destructively(f *objfile, ebp_disp i32, size u32) void {
  // EAX/EBP is hard-coded because... well, x86_load32_zeroextend has it hard-coded too.  Also because EAX == AX == AL.
  src u8 = X86_EAX;
  dest_addr u8 = X86_EBP;
  if size == 0 {
    // Do nothing.
  } else if size == 4 {
    x86_store32(f, dest_addr, ebp_disp, src);
  } else if size == 1 {
    x86_store8(f, dest_addr, ebp_disp, src);
  } else if size == 2 {
    x86_store16(f, dest_addr, ebp_disp, src);
  } else if size == 3 {
    // Heh!  In s1 we didn't implement this case.
    x86_store16(f, dest_addr, ebp_disp, src);
    x86_shr_imm_w32(f, src, 16);
    x86_store8(f, dest_addr, ebp_disp + 2, src);
  } else {
    ice(_u8("x86_store32_partial_destructively with bad size"));
  }
}

// NOTE: If this changes buflength, its consumers (like appendtext) will need to change theirs.
deftype reg_rm_encoded struct {
  length u8;
  buf [5]u8;
};

func encode_reg_rm(reg u8, rm_addr u8, rm_disp i32) reg_rm_encoded {
  ret reg_rm_encoded;
  if rm_disp == 0 && rm_addr != X86_ESP && rm_addr != X86_EBP {
    ret.buf[0] = mrr(MOD00, reg, rm_addr);
    ret.length = 1;
  } else if rm_addr == X86_ESP {
    ice(_u8("encode_reg_rm does not support ESP addrs (yet)"));
  } else if rm_disp >= @[i32] -128 && rm_disp <= 127 {
    ret.buf[0] = mrr(MOD01, reg, rm_addr);
    ret.buf[1] = ~ (rm_disp & 0xFF);
    ret.length = 2;
  } else {
    ret.buf[0] = mrr(MOD10, reg, rm_addr);
    write_le_i32(&ret.buf[1], rm_disp);
    ret.length = 5;
  }
  return ret;
}

func x86_load32(f *objfile, dest u8, src_addr u8, src_disp i32) void {
  appendtext(f, 0x8B, encode_reg_rm(dest, src_addr, src_disp));
}

func x86_movzx8(f *objfile, dest u8, src_addr u8, src_disp i32) void {
  appendtext(f, 0x0F, 0xB6, encode_reg_rm(dest, src_addr, src_disp));
}

func x86_movzx16(f *objfile, dest u8, src_addr u8, src_disp i32) void {
  appendtext(f, 0x0F, 0xB7, encode_reg_rm(dest, src_addr, src_disp));
}

func x86_and_imm32(f *objfile, dest u8, x i32) void {
  appendtext(f, 0x81, mrr(MOD11, 4, dest), x);
}

func x86_movsx8(f *objfile, dest u8, src_addr u8, src_disp i32) void {
  appendtext(f, 0x0F, 0xBE, encode_reg_rm(dest, src_addr, src_disp));
}

func x86_movsx16(f *objfile, dest u8, src_addr u8, src_disp i32) void {
  appendtext(f, 0x0F, 0xBF, encode_reg_rm(dest, src_addr, src_disp));
}

func x86_movzx8_reg8(f *objfile, dest u8, src u8) void {
  appendtext(f, 0x0F, 0xB6, mrr(MOD11, dest, src));
}

func x86_lea32(f *objfile, dest u8, src_addr u8, src_disp i32) void {
  appendtext(f, 0x8D, encode_reg_rm(dest, src_addr, src_disp));
}

func x86_load8(f *objfile, dest u8, src_addr u8, src_disp i32) void {
  appendtext(f, 0x8A, encode_reg_rm(dest, src_addr, src_disp));
}

func x86_store32(f *objfile, dest_addr u8, dest_disp i32, src u8) void {
  appendtext(f, 0x89, encode_reg_rm(src, dest_addr, dest_disp));
}

func x86_store16(f *objfile, dest_addr u8, dest_disp i32, src u8) void {
  appendtext(f, 0x66, 0x89, encode_reg_rm(src, dest_addr, dest_disp));
}

func x86_store8(f *objfile, dest_addr u8, dest_disp i32, src u8) void {
  appendtext(f, 0x88, encode_reg_rm(src, dest_addr, dest_disp));
}

func x86_indirect_call(f *objfile, reg u8) void {
  appendtext(f, 0xFF, mrr(MOD11, 2, reg));
}
