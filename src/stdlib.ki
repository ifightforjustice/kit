extern malloc fn[size, *void];
extern free fn[*void, void];
extern abort fn[void];

func check(x bool) void {
  if x { abort(); }
}

func[T] max(x T, y T) T {
  if (x < y) {
    return y;
  } else {
    return x;
  }
}

deftype size u32;

def `~` fn[u32, size] = to_size;

func to_size(x u32) size {
  var ret size;
  ret.~ = x;
  return ret;
}

func `+`(x size, y size) size { return ~(x.~ + y.~); }
func `+`(x size, y u32) size { return ~(x.~ + y); }
func `-`(x size, y size) size { return ~(x.~ - y.~); }
func `-`(x size, y u32) size { return ~(x.~ - y); }
func `*`(x size, y size) size { return ~(x.~ * y.~); }
func `*`(x size, y u32) size { return ~(x.~ * y); }
func `/`(x size, y size) size { return ~(x.~ / y.~); }
func `<`(x size, y size) bool { return x.~ < y.~; }
func `<=`(x size, y size) bool { return x.~ <= y.~; }
func `>`(x size, y size) bool { return x.~ > y.~; }
func `>=`(x size, y size) bool { return x.~ >= y.~; }
func `==`(x size, y size) bool { return x.~ == y.~; }
func `!=`(x size, y size) bool { return x.~ != y.~; }

func[S, T] cast(p *S) *T {
  var u union { p *S; q *T; };
  u.p = p;
  return u.q;
}

func[S, T] up(s S) T {
  var ret T;
  ret.~ = s;
  return ret;
}
