        Kit v0.0000...1B.x

Current status:  "proto-Kit"

Definitions:
   s1: A compiler, written in C.  It can compile s2.  Located in trc/.
   s2: A compiler, written in proto-Kit.  It can compile itself.  Located in src/.
   s2-by-s1: s2, as compiled by s1.
   s2-self: s2, as compiled by s2.

  BUILD INSTRUCTIONS

# Prerequisites: An x86 CPU.  Windows or Linux.  On Windows, MSVC
# 2013 or 2015 (something with basic C99 support) -- for example,
# run these commands from a "Developer Command Prompt for VS2015".
# On Linux, gcc with 32-bit support, which usually means some
# gcc-multilib package.  Maybe clang works too.

# Step 1. Build s1 -- creates executable "out.exe" (or "out")
   windows_build.bat  (or ./linux_build.sh)
# Run some useless tests
   out --test  (or ./out --test)
# Step 2. Build s2-by-s1
   cd src
   ..\out main  (or ../out --linux main)  # makes main.obj (or main.o)
   cl main.obj dummy.c  (or gcc -m32 main.o dummy.c -o main)
   ren main.exe s2b.exe  (or mv main s2b)
# Now "s2b.exe" (or "s2b") is s2-by-s1.
# Step 3. Build s2-self
   s2b main  (or ./s2b --linux main)  # makes main.obj (or main.o)
   cl main.obj dummy.c
   ren main.exe s2.exe
# Now "s2.exe" (or "s2") is s2-self.
# Run parsing/typechecking tests.
   s2b
   s2
# Run parsing/typechecking+codegen tests.
   s2b --build
   s2 --build
# Step 4. If you wish, run s2-self on itself
   ren main.obj old_main.obj
   s2 main
   sha1sum old_main.obj main.obj
# The sha1sums should match.

  DIRECTORY STRUCTURE

The current directory structure is:

   trc - s1, implemented in C.  Used to compile s2.
   src - s2, implemented in proto-Kit.  Used to compile itself.
   examples - examples to run, disorganized junk

Here's the project timeline:

   1. Parsing.  (DONE)
   2. Typechecking/name-resolving.  (DONE)
   3. Generate code, i.e. have a working compiler.  (DONE)
   4. Cleanup error messages to have useful source information. (BETTER)
   5. Cleanup the language to make it more usable. (GOOD ENOUGH)
      Wishlist (waiting for these features specifically needed):
       A. Structure / array initialization syntax. (DONE)
       B. Packed struct types.  (DON'T CARE for now -- use le_u32)
       C. Destructuring assignment.
       D. Incr/decr and "+="-type operators.
   6. Linux support. (DONE)
   7. Make a self-hosted implementation (adding improvements and
      fixes to the C implementation when useful). (DONE)
   8. Give the self-hosted implementation "respectable" codegen.
   9. Basic cleanup of the language.
      Wishlist:
       A. defstruct, no more naked structs.
       B. type aliases.
       C. a non-truncative conversion operator (prefix +).
       D. negative integer literals.
       E. var keyword after variable.
       F. o8, o16, o32.
       G. u64, i64, o64.
       H. a signed size type.  ("diff"?)
       I. negation for o-verflow types.
       J. smart move/allocate-in-the-spot semantics.
       K. scoped types or scoped vars.
       L. better syntax for defining copy/init/move/destroy.
       M. defer statements (or scoped statements).
       N. handlers for overflow errors.
       O. enum types with "default" values instead of zero-tag.
       P. cute enum syntax for voids.
       Q. better type-checking, see-through-negation.
       R. explicit overloading/specialization.
       S. support for multiple calling conventions.
       T. cross-function goto statements of the IInd kind.
       U. capturing closures.
       V. actual modules/namespaces.
       W. pretentious quotes in the binaries.
       X. removal of pretentious quotes in the binaries.
       Y. field names in struct literals.
       Z. array literals (struct literals in an array place).  (DONE)

s1's language is merely "C, with templates, constructors/destructors,
elementary encapsulation, tagged enum types, no implicit
conversions."  Future versions of the language will be more
advanced.  proto-Kit is a trade-off between the convenience of
implementing s1 and the convenience of implementing its successor.
