import state;

deftype gn_annot struct {
  // Which cells are guaranteed to be live when the gn starts.
  live hash[cell_num, void];
};

deftype frame struct {
  cs *checkstate;
  gr *frame_graph;
  bas *basic_analyze_state;
  // by_gn[i].fs shows what the state must is _before_ evaluating node i.  (All incoming nodes must agree!)
  by_gn array[opt[gn_annot]];
};

func dumbly_gen_graphed_fn_body(cs *checkstate, f *objfile, bas *basic_analyze_state, g *graphed_fn_body) bool {
  h frame = {cs, &g->graph.gr, bas, repeat(count(&g->graph.gr.ops), None())};

  prelive hash[cell_num, void];
  check_add_all(&prelive, &g->argcells);
  check_add(&prelive, g->graph.cell);

  mut exprmut;
  if !dumbly_gen_expression(cs, f, &h, &g->graph.gr, g->graph.gn, &prelive, &mut) {
    return false;
  }

  // TODO: Is there something I should assert about mut?

  return true;
}

deftype exprmut struct {
  // Cells that weren't live, that are used.
  made_live hash[cell_num, void];
  // Cells that were live, that are used (and not made dead).
  used hash[cell_num, void];
  // Cells that were not live, that are used.
  encapsulated hash[cell_num, void];
  // Cells that were live, that are made dead.
  made_dead hash[cell_num, void];
};

func dumbly_gen_expression(cs *checkstate, f *objfile, h *frame, gr *frame_graph, gn gr_num, prelive *hash[cell_num, void], mut_out *exprmut) bool {
  gnc *opt[gn_annot] = ref_annot(h, gn);
  if case &Has(annot gn_annot) = gnc {
    if !sets_equal(prelive, &annot.live) {
      ERR(_u8("Inconsistent liveness state when revisiting node."));
      return false;
    }
    return true;
  }

  set(ref_annot(h, gn), {*prelive});

  prec_muts exprmut;

  node *gr_node = ref_node(gr, gn);
  nprecs size = count(&node->precs);
  for i size = 0; i < nprecs; i = i + 1 {
    i_mut exprmut;
    if !dumbly_gen_expression(cs, f, h, gr, get(&node->precs, i), prelive, &i_mut) {
      return false;
    }
    if !add_parallel_mut(prelive, &prec_muts, &i_mut) {
      return false;
    }
  }

  switch &node->op {
  case &GrApply(a gr_apply):
    deaden(prelive, &prec_muts, a.funcell);
    nparams size = count(&a.params);
    for i size = 0; i < nparams; i = i + 1 {
      deaden(prelive, &prec_muts, get(&a.params, i));
    }
    output(prelive, &prec_muts, a.retcell);
  case &GrMemCopy(a gr_memcopy):
    output(prelive, &prec_muts, a.dest);
    input(prelive, &prec_muts, a.src);
  case &GrWriteConst(a gr_writeconst):
    output(prelive, &prec_muts, a.dest);
  case &GrAddressof(a gr_addressof):
    input(prelive, &prec_muts, a.addressee);
    output(prelive, &prec_muts, a.dest);
  case &GrDeref(a gr_deref):
    input(prelive, &prec_muts, a.pointer);
    // Location should always be virtual.
    virtual(prelive, &prec_muts, a.name);
  case &GrSubcell(a gr_subcell):
    input(prelive, &prec_muts, a.partof);
    deaden_offset(prelive, &prec_muts, &a.offset);
    virtual(prelive, &prec_muts, a.name);
  case &GrBranch(a gr_branch):
    return TODO();
  case &GrSequence(a gr_sequence):
    new_live hash[cell_num, void] = *prelive;
    compose_live(&new_live, &prec_muts);
    firstmut exprmut;
    if !dumbly_gen_expression(cs, f, h, gr, a.first, &new_live, &firstmut) {
      return false;
    }
    compose_muts(&prec_muts, &firstmut);
    compose_live(&new_live, &firstmut);
    secondmut exprmut;
    if !dumbly_gen_expression(cs, f, h, gr, a.second, &new_live, &secondmut) {
      return false;
    }

    compose_muts(&prec_muts, &secondmut);
  case &GrJmp(a gr_jmp):
    new_live hash[cell_num, void] = *prelive;
    compose_live(&new_live, &prec_muts);
    exitmut exprmut;
    if !dumbly_gen_expression(cs, f, h, gr, a.next, &new_live, &exitmut) {
      return false;
    }
    compose_muts(&prec_muts, &exitmut);
  case &GrWriteNothing(a gr_writenothing):
    output(prelive, &prec_muts, a.dest);
  case &GrDead(a gr_dead):
    deaden(prelive, &prec_muts, a.cell);
  case &GrNop(v void): { }
  }
  return true;
}

func deaden(prelive *hash[cell_num, void], prec_muts *exprmut, c cell_num) void {
  // TODO(): Implement
}

// input requires that the cell already be live.
func input(prelive *hash[cell_num, void], prec_muts *exprmut, c cell_num) void {
  // TODO(): Implement
}

// output either makes the cell live, if it wasn't already, or it means we use the cell.
func output(prelive *hash[cell_num, void], prec_muts *exprmut, c cell_num) void {
  // TODO(): Implement
}

// Says that we're naming a virtual cell.
func virtual(prelive *hash[cell_num, void], prec_muts *exprmut, c cell_num) void {
  // TODO(): Implement
}

func deaden_offset(prelive *hash[cell_num, void], prec_muts *exprmut, goff *gr_offset) void {
  switch goff {
  case &OffsetConst(n u32): { }
  case &OffsetComputed(p tup[u32, cell_num]):
    deaden(prelive, prec_muts, p.cdr);
  }
}

func compose_live(live *hash[cell_num, void], muts *exprmut) void {
  check_add_disjoint(live, &muts->made_live);
  remove_exactly(live, &muts->made_dead);
}

func compose_muts(onto *exprmut, after *exprmut) void {
  // Composes the mutation operations by running onto's muts, then after's muts.  For example, a cell in onto->made_live and after->made_dead becomes nothing.  (Maybe it should become "encapsulated," maybe that's an annotation we should use.  I guess it is -- if a cell has "encapsulated use" in one sub-expr, another sibling prec can't use it.  TODO: Add encapsulated cells to exprmut.)
  // TODO: Implement.
}

// This function should have a symmetry about it.
func add_parallel_mut(prelive *hash[cell_num, void], onto *exprmut, from *exprmut) bool {
  if intersects(&onto->made_dead, &from->used) || intersects(&onto->used, &from->made_dead) {
    ERR(_u8("ICE: One prec-expr marks cell dead that another uses"));
    return false;
  }
  if intersects(&onto->made_live, &from->encapsulated) || intersects(&onto->encapsulated, &from->made_live) {
    ERR(_u8("ICE: One prec-expr makes cell live that another encapsulates"));
    return false;
  }
  if !add_disjoint(&onto->made_live, &from->made_live) {
    ERR(_u8("ICE: multiple prec-exprs made the same cell live"));
    return false;
  }
  if !add_disjoint(&onto->made_dead, &from->made_dead) {
    ERR(_u8("ICE: multiple prec-exprs made the same cell dead"));
    return false;
  }
  if !add_disjoint(&onto->encapsulated, &from->encapsulated) {
    ERR(_u8("ICE: multiple prec-exprs use and discard the same cell"));
    return false;
  }

  add_union(&onto->used, &from->used);
  return true;
}

func ref_annot(h *frame, gn gr_num) *opt[gn_annot] {
  return ref(&h->by_gn, gn.~);
}
