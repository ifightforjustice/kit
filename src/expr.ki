import bigint;
import body;
import check;
import primitives;

deftype temporary_info struct {
  type cu_typeexpr;
};

deftype exprscope struct {
  ds *defscope;
  // Same as ds->cs.
  cs *checkstate;
  // Same as ds->im, same as cs->im.
  im *identmap;
  // Same as ds->clq.
  clq *clqueue;

  temporaries array[temporary_info];
};

func mk(ds *defscope) exprscope {
  return {ds, ds->cs, ds->im, ds->clq, mk_array@[temporary_info]()};
}

deftype temporary_number size;

def `~` fn[size, temporary_number] = wrapconvert;
def `==` fn[temporary_number, temporary_number, bool] = wrapequate;

func add_temporary(es *exprscope, type cu_typeexpr) temporary_number {
  ret size = count(&es->temporaries);
  push(&es->temporaries, {type});
  return ~ret;
}

func ref_temporary(es *exprscope, num temporary_number) *temporary_info {
  return ref(&es->temporaries, num.~);
}

deftype defscope struct {
  cs *checkstate;
  // Same as cs->im.
  im *identmap;
  clq *clqueue;
  accessible array[access_entry_id];
  // Generics and their _complete_ replacements.
  generics *ast_generics;
  parms *cu_genparms;

  all_vars array[var_info];

  // These var_numbers are always in increasing order.
  current_vars array[var_number];
};

deftype var_number size;

def `~` fn[size, var_number] = wrapconvert;
def `==` fn[var_number, var_number, bool] = wrapequate;
func `!=`(x var_number, y var_number) bool { return !(x == y); }
func `<`(x var_number, y var_number) bool {
  return x.~ < y.~;
}

defenum var_autoinit {
  AutoInitNo void;
  AutoInitYes void;
};

func `==`(x var_autoinit, y var_autoinit) bool {
  return enumnum(&x) == enumnum(&y);
}

deftype var_info struct {
  num var_number;
  // A complete, checked, type, with generics replaced.
  type cu_typeexpr;
  name sym;
  // Can a goto statement enter this var's scope and construct the var?  I.e. true if the variable is not bound by a case-pattern.  (Also true for lambda parameters, out of general principle.)
  autoinit var_autoinit;
};

func ref_var(ds *defscope, num var_number) *var_info {
  return ref(&ds->all_vars, num.~);
}

func vars_in_scope(ds *defscope) array[var_number] {
  return ds->current_vars;
}


defenum allow_incomplete {
  AllowIncompleteNo void;
  AllowIncompleteYes void;
};

func `==`(x allow_incomplete, y allow_incomplete) bool {
  return enumnum(&x) == enumnum(&y);
}

defclass move varpopper struct {
  ds *defscope;
  nums array[var_number];
};

access varpopper {

func do_init(vp *varpopper) void {
  init(&vp->ds);
  init(&vp->nums);
}

func init_vp(vp *varpopper, ds *defscope) void {
  check(vp->ds == null);
  vp->ds = ds;
}

func do_destroy(vp *varpopper) void {
  if vp->ds != null {
    descope_vars(vp);
  }
  destroy(&vp->nums);
  vp->ds = null;
}

func ds_push_var(ds *defscope, vp *varpopper, name *ast_ident, computed_type *cu_typeexpr, autoinit var_autoinit) bool {
  if case Has(num var_number) = ds_find_current_local(ds, name->value) {
    ERR(_u8("Local variable '"), lookup(ds->im, name->value), _u8("' shadows another"));
    return false;
  }
  num var_number = ~count(&ds->all_vars);
  push(&ds->all_vars, {num, *computed_type, name->value, autoinit});
  push(&ds->current_vars, num);
  push(&vp->nums, num);
  return true;
}

func descope_vars(vp *varpopper) void {
  ds *defscope = vp->ds;
  check(ds != null);
  while case Has(expected var_number) = popval(&vp->nums) {
    num var_number;
    if !popval(&ds->current_vars, &num) {
      ice(_u8("varpopper sees empty local_vars"));
    }
    if num != expected {
      ice(_u8("varpopper sees mismatch"));
    }
  }
}

}  // access varpopper

func check_expr(cs *checkstate, clq *clqueue, accessible array[access_entry_id], g *ast_generics, parms *cu_genparms, x *ast_expr, pt *te_typeexpr) bool {
  ds defscope = {cs, cs->im, clq, accessible, g, parms, default@[array[var_info]](), default@[array[var_number]]()};
  return check_consume_expr(&ds, x, pt);
}

func check_discard_expr(ds *defscope, x *ast_expr, pt *te_typeexpr) bool {
  es exprscope = mk(ds);
  if !check_expr_ai(&es, AllowIncompleteNo(void), x, pt) {
    return false;
  }
  if !annotate_disposal_for_discard(&es, x) {
    return false;
  }
  return true;
}

func check_consume_expr(ds *defscope, x *ast_expr, pt *te_typeexpr) bool {
  es exprscope = mk(ds);
  if !check_expr_ai(&es, AllowIncompleteNo(void), x, pt) {
    return false;
  }
  if !annotate_disposal_for_consume(&es, x) {
    return false;
  }
  return true;
}

// For exprs that we use, but then discard.  Conditionals... and switches?  Kinda.
func check_consume_then_discard_expr(ds *defscope, x *ast_expr, pt *te_typeexpr) bool {
  es exprscope = mk(ds);
  if !check_expr_ai(&es, AllowIncompleteNo(void), x, pt) {
    return false;
  }
  if !annotate_disposal_for_consume_then_discard(&es, x) {
    return false;
  }
  return true;
}

func replaced_name_parms(ds *defscope, a *ast_name_expr, out *genparms) bool {
  if case &Has(arr array[ast_typeexpr]) = &a->generic_params {
    replaced array[te_typeexpr];
    n size = count(&arr);
    for i size = 0; i < n; i = i + 1 {
      converted te_typeexpr;
      if !convert_typeexpr(ds->cs, ref(&arr, i), &converted) {
        return false;
      }
      computed cac_typeexpr;
      if !check_and_compute_typeexpr(ds->cs, ds->clq, ds->generics, ds->parms, &converted, &computed) {
        return false;
      }
      push(&replaced, computed.te);
    }
    *out = HasParms(replaced);
    return true;
  } else {
    *out = NoParms(void);
    return true;
  }
}

deftype constructor_info struct {
  type cu_typeexpr;
};

defenum ds_constructor_res {
  NoMatchConstructor void;
  AmbigMatchConstructor void;
  MatchedConstructor constructor_info;
};

func ds_lookup_constructor(ds *defscope, name sym, gp *genparms, pt *te_typeexpr, res_out *ds_constructor_res) bool {
  if case &HasParms(a) = gp {
    *res_out = NoMatchConstructor(void);
    return true;
  }
  arg_type *te_typeexpr;
  return_type *te_typeexpr;
  if !decompose_typeapp(pt, primitive_function_puretype(ds->cs), &arg_type, &return_type) {
    *res_out = NoMatchConstructor(void);
    return true;
  }
  if !is_complete(return_type) {
    *res_out = AmbigMatchConstructor(void);
    return true;
  }
  // enum_type is complete.
  enum_type *te_typeexpr;
  if !complete_structural_rhs(ds, return_type, &enum_type) {
    return false;
  }
  if case &TeEnum(et te_enum) = enum_type {
    rhs_type *te_typeexpr;
    if !find_vardecl(&et.constructors, name, &rhs_type) {
      *res_out = NoMatchConstructor(void);
      return true;
    }
    // rhs_type is complete.
    unified te_typeexpr;
    if !unify_types(arg_type, rhs_type, &unified) {
      *res_out = NoMatchConstructor(void);
      return true;
    }
    *res_out = MatchedConstructor({~fn_type(ds->cs, *rhs_type, *return_type)});
    return true;
  } else {
    *res_out = NoMatchConstructor(void);
    return true;
  }
}


deftype global_info struct {
  ent def_entry_id;
  inst def_inst_id;
};

deftype local_info struct {
  varnum var_number;
};

defenum name_info {
  Local void;
  Global global_info;
};

defenum es_match_res {
  NoMatch void;
  AmbigGlobalMatch void;
  OneGlobalMatch global_info;
  OneLocalMatch local_info;
  OneEnumConstructorMatch constructor_info;
};

func ds_lookup_name(ds *defscope, name sym, gp *genparms, pt *te_typeexpr, res_out *es_match_res) bool {
  if case &NoParms(v void) = gp {
    if case Has(num var_number) = ds_find_current_local(ds, name) {
      type te_typeexpr;
      vartype *cu_typeexpr = &ref_var(ds, num)->type;
      if !unify_types(pt, &vartype->~, &type) {
        ERR(_u8("local '"), lookup(ds->im, name), _u8("' has wrong type: '"), to_u8str(ds->im, *vartype), _u8("' where '"), to_u8str(ds->im, *pt), _u8("' expected"));
        return false;
      }
      *res_out = OneLocalMatch({num});
      return true;
    }
  }

  res match_def_res;
  if !match_def(ds->cs, name, gp, pt, &res) {
    return false;
  }

  switch res {
    case NoMatch(v void): {
      constructor_res ds_constructor_res;
      if !ds_lookup_constructor(ds, name, gp, pt, &constructor_res) {
        return false;
      }
      switch &constructor_res {
        case &NoMatchConstructor(u void): {
          *res_out = NoMatch(void);
        }
        case &AmbigMatchConstructor(u void): {
          *res_out = AmbigGlobalMatch(void);
        }
        case &MatchedConstructor(inf constructor_info): {
          *res_out = OneEnumConstructorMatch(inf);
        }
      }
      return true;
    }
    case MultiMatch(void): {
      *res_out = AmbigGlobalMatch(void);
      return true;
    }
    case OneMatch(m struct { ent def_entry_id; parms genparms; }): {
      cu_parms cu_genparms;
      if !check_and_compute_parms(ds->cs, ds->clq, &m.parms, &cu_parms) {
        return false;
      }
      inst_id def_inst_id = enqueue_def_inst(ds->cs, ds->clq, m.ent, &cu_parms);
      *res_out = OneGlobalMatch({m.ent, inst_id});
      return true;
    }
  }
}

func ds_find_current_local(ds *defscope, name sym) opt[var_number] {
  n size = count(&ds->current_vars);
  for i size = 0; i < n; i = i + 1 {
    num var_number = get(&ds->current_vars, i);
    inf *var_info = ref_var(ds, num);
    if inf->name == name {
      return Has(num);
    }
  }
  return None();
}

func help_check_simple_literal(es *exprscope, pt *te_typeexpr, type te_typeexpr, errmsg_name array[u8], x *ast_expr) bool {
  unified te_typeexpr;
  if !unify_types(pt, &type, &unified) {
    ERR(errmsg_name, _u8(" literal in bad place"));
    return false;
  }
  if is_complete(&unified) {
    c cac_typeexpr;
    if !noscoped_check_and_compute_typeexpr(es->cs, es->clq, &unified, &c) {
      ice(_u8("help_check_simple_literal passed bad type"));
    }
    check(c.complete);

    annotate_info(x, CompleteCheck(mk(wholeRval(add_temporary(es, ~c.te)), ~c.te)));
  } else {
    annotate_info(x, IncompleteCheck(type));
  }
  return true;
}

// pt is either (a) incomplete, or (b) complete and computed.
func check_expr_ai(es *exprscope, ai allow_incomplete, x *ast_expr, pt *te_typeexpr) bool {
  if case &CompleteCheck(t ast_expr_complete_info) = &x->info {
    return true;
  }

  switch &x->u {
    case &NameExpr(a ast_name_expr): {
      parms genparms;
      if !replaced_name_parms(es->ds, &a, &parms) {
        return false;
      }
      match_res es_match_res;
      if !ds_lookup_name(es->ds, a.ident.value, &parms, pt, &match_res) {
        return false;
      }
      switch &match_res {
        case &NoMatch(v void): {
          ERR(_u8("Name lookup for '"), lookup(es->im, a.ident.value), _u8("', maybe with parms, not found, matching type '"), to_u8str(es->im, *pt), _u8("'"));
          return false;
        }
        case &AmbigGlobalMatch(v void): {
          if ai == AllowIncompleteYes(void) {
            // NOTE: We could annotate this more precisely in ambiguous-single-match cases.
            annotate_info(x, IncompleteCheck(TeUnknown(void)));
            return true;
          } else {
            ERR(_u8("Name lookup for '"), lookup(es->im, a.ident.value), _u8("', maybe with parms, matches ambiguously."));
            return false;
          }
        }
        case &OneEnumConstructorMatch(ci constructor_info): {
          annotate_info(x, CompleteCheck(mk(wholeRval(add_temporary(es, ci.type)), ci.type)));
          return true;
        }
        case &OneGlobalMatch(gi global_info): {
          if !ensure_def_inst_type_computed(es->cs, es->clq, ref_def_entry(es->cs, gi.ent), gi.inst) {
            return false;
          }
          inst *def_inst = ref_inst(es->cs, gi.inst);
          annotate_info(x, CompleteCheck(mk(wholeRval(add_temporary(es, inst->computed_type)), inst->computed_type)));
          return true;
        }
        case &OneLocalMatch(v local_info): {
          vi *var_info = ref_var(es->ds, v.varnum);
          annotate_info(x, CompleteCheck(mk(IsLvalYes(void), vi->type)));
          return true;
        }
      }
    }

    case &ParenExpr(a ast_paren_expr): {
      if !check_expr_ai(es, ai, oo(&a.expr), pt) {
        return false;
      }
      if expr_type_complete(oo(&a.expr)) {
        annotate_disposal(oo(&a.expr), DisposeIgnore(void));
      }
      annotate_info(x, inner_info(&oo(&a.expr)->info));
      return true;
    }

    case &NumericLiteral(a ast_numeric_literal): {
      return check_numeric_literal(es, ai, pt, numeric_literal_value(&a), x);
    }

    case &BoolLiteral(a ast_bool_literal): {
      return help_check_simple_literal(es, pt, primitive_bool_type(es->cs), _u8("bool"), x);
    }

    case &VoidLiteral(a ast_void_literal): {
      return help_check_simple_literal(es, pt, primitive_void_type(es->cs), _u8("void"), x);
    }

    case &NullLiteral(a ast_null_literal): {
      return help_check_simple_literal(es, pt, pointer_to(es->cs, TeUnknown(void)), _u8("null"), x);
    }

    case &CharLiteral(a ast_char_literal): {
      return check_numeric_literal(es, ai, pt, ~a.charspec.value, x);
    }

    case &StringLiteral(a ast_string_literal): {
      type cu_typeexpr = compute_prim(es->ds, primitive_string_literal_type(es->cs, count(&a.charspecs)));
      unified te_typeexpr;
      if !unify_types(pt, &type.~, &unified) {
        ERR(_u8("string literal in bad place"));
        return false;
      }
      annotate_info(x, CompleteCheck(mk(wholeRval(add_temporary(es, type)), type)));
      return true;
    }
    case &Funcall(a ast_funcall): {
      return check_expr_funcall(es, ai, x, &a, pt);
    }
    case &Assignment(a ast_assignment): {
      // We check the lhs independently of the rhs, deliberately, to ensure clarity.
      if !check_expr_ai(es, AllowIncompleteNo(void), oo(&a.lhs), pt) {
        return false;
      }
      lhs_info *ast_expr_complete_info = expr_complete_info(oo(&a.lhs));
      if isNo(lhs_info->lval) {
        ERR(_u8("Assigning to non-lvalue"));
        return false;
      }
      annotate_disposal(oo(&a.lhs), DisposeIgnore(void));
      if !check_expr_ai(es, AllowIncompleteNo(void), oo(&a.rhs), &lhs_info->cu.~) {
        return false;
      }
      if !annotate_disposal_for_assignment(es, oo(&a.rhs)) {
        return false;
      }
      annotate_info(x, CompleteCheck(mk(lhs_info->lval, lhs_info->cu)));
      return true;
    }
    case &AddressOf(a ast_addressof): {
      ptr_unknown te_typeexpr = pointer_to(es->cs, TeUnknown(void));
      unif_pt te_typeexpr;
      if !unify_types(pt, &ptr_unknown, &unif_pt) {
        ERR(_u8("AddressOf expr in non-pointer context"));
      }
      param *te_typeexpr;
      if !decompose_typeapp(&unif_pt, primitive_pointer_puretype(es->cs), &param) {
        ice(_u8("AddressOf sees non-pointer after unifying with pointer."));
      }
      // We require complete matching, because, meh, the rhs should be some crystal clear lvalue anyway.
      if !check_expr_ai(es, AllowIncompleteNo(void), oo(&a.rhs), param) {
        return false;
      }
      rhs_info *ast_expr_complete_info = expr_complete_info(oo(&a.rhs));
      if isNo(rhs_info->lval) {
        ERR(_u8("Taking address of a non-lvalue"));
        return false;
      }
      annotate_disposal(oo(&a.rhs), DisposeIgnore(void));

      ptr_type te_typeexpr = pointer_to(es->cs, rhs_info->cu.~);
      ptr_computed cac_typeexpr;
      if !noscoped_check_and_compute_typeexpr(es->cs, es->clq, &ptr_type, &ptr_computed) {
        return false;
      }
      check(ptr_computed.complete);
      annotate_info(x, CompleteCheck(mk(wholeRval(add_temporary(es, ~ptr_computed.te)), ~ptr_computed.te)));
      return true;
    }
    case &Deref(a ast_deref): {
      // TODO: Shouldn't have to do this traversal.  Make pt carry such flags.
      pt_cc bool = is_complete_computed(pt).computed;
      ptr_pt te_typeexpr = pointer_to(es->cs, *pt);
      ptr_cac cac_typeexpr;
      if !noscoped_check_and_compute_typeexpr(es->cs, es->clq, &ptr_pt, &ptr_cac) {
        return false;
      }
      // Seems like no point to allowing an incomplete rhs.
      if !check_expr_ai(es, AllowIncompleteNo(void), oo(&a.rhs), &ptr_cac.te) {
        return false;
      }
      if !annotate_disposal_for_consume(es, oo(&a.rhs)) {
        return false;
      }
      param *te_typeexpr;
      if !decompose_typeapp(&expr_complete_type(oo(&a.rhs))->~, primitive_pointer_puretype(es->cs), &param) {
        ice(_u8("Deref sees rhs type being non-pointer."));
      }
      annotate_info(x, CompleteCheck(mk(IsLvalYes(void), ~ *param)));
      return true;
    }
    case &IndexExpr(a ast_index_expr): {
      return check_expr_index(es, x, &a, pt);
    }
    case &Lambda(a ast_lambda): {
      return check_expr_lambda(es, &a, pt, x);
    }
    case &LocalField(a ast_local_field): {
      unknown te_typeexpr = TeUnknown(void);
      if !check_expr_ai(es, AllowIncompleteNo(void), oo(&a.lhs), &unknown) {
        return false;
      }
      annotate_disposal_for_field(oo(&a.lhs));
      info *ast_expr_complete_info = expr_complete_info(oo(&a.lhs));
      fieldtype cu_typeexpr;
      inherits_lval bool;
      if !check_field(es, &info->cu, &a.fieldname, pt, &fieldtype, &inherits_lval) {
        return false;
      }
      lval is_lval;
      if inherits_lval {
        switch &info->lval {
          case &IsLvalYes(v void): {
            lval = IsLvalYes(void);
          }
          case &IsLvalNo(desc rval_description): {
            lval = IsLvalNo({desc.num, false});
          }
        }
      } else {
        lval = wholeRval(add_temporary(es, fieldtype));
      }
      annotate_info(x, CompleteCheck(mk(lval, fieldtype)));
      return true;
    }
    case &DerefField(a ast_deref_field): {
      // The fact that our partial type isn't a pointer type is deliberate.
      unknown te_typeexpr = TeUnknown(void);
      if !check_expr_ai(es, AllowIncompleteNo(void), oo(&a.lhs), &unknown) {
        return false;
      }
      if !annotate_disposal_for_consume(es, oo(&a.lhs)) {
        return false;
      }
      info *ast_expr_complete_info = expr_complete_info(oo(&a.lhs));
      param *te_typeexpr;
      if !decompose_typeapp(&info->cu.~, primitive_pointer_puretype(es->cs), &param) {
        ERR(_u8("Expected pointer for lhs of deref field"));
        return false;
      }
      cu_param cu_typeexpr = ~ *param;
      fieldtype cu_typeexpr;
      inherits_lval bool;
      if !check_field(es, &cu_param, &a.fieldname, pt, &fieldtype, &inherits_lval) {
        return false;
      }
      lval is_lval;
      if inherits_lval {
        // We deref, so it's always an lval.
        lval = IsLvalYes(void);
      } else {
        lval = wholeRval(add_temporary(es, fieldtype));
      }
      annotate_info(x, CompleteCheck(mk(lval, fieldtype)));
      return true;
    }
    case &TypedExpr(a ast_typed_expr): {
      // TODO: Cache converted.
      converted te_typeexpr;
      if !convert_typeexpr(es->cs, &a.type, &converted) {
        return false;
      }
      // We call check_and_compute_typeexpr to disallow totally bogus typeexprs more directly than the eventual type error that would happen.
      computed cac_typeexpr;
      if !check_and_compute_typeexpr(es->cs, es->clq, es->ds->generics, es->ds->parms, &converted, &computed) {
        return false;
      }
      unified te_typeexpr;
      if !unify_types(pt, &computed.te, &unified) {
        ERR(_u8("TypedExpr is incompatible with contextual type."));
        return false;
      }
      unified_computed cac_typeexpr;
      if computed.complete {
        unified_computed = computed;
      } else {
        if !noscoped_check_and_compute_typeexpr(es->cs, es->clq, &unified, &unified_computed) {
          ERR(_u8("TypedExpr encounters un-computable unified type."));
          return false;
        }
      }
      if !check_expr_ai(es, ai, oo(&a.expr), &unified_computed.te) {
        return false;
      }
      if expr_type_complete(oo(&a.expr)) {
        annotate_disposal(oo(&a.expr), DisposeIgnore(void));
      }
      annotate_info(x, inner_info(&oo(&a.expr)->info));
      return true;
    }
    case &Strinit(a ast_strinit): {
      return check_expr_strinit(es, ai, &a, pt, x);
    }
  }
}

// TODO:  Implement these.
func get_copy_constructor(ds *defscope, t *cu_typeexpr, out *instpair) bool {
  return true;
  return TODO();
}

func get_move_constructor(ds *defscope, t *cu_typeexpr, out *instpair) bool {
  return true;
  return TODO();
}

func get_destroy_constructor(ds *defscope, t *cu_typeexpr, out *instpair) bool {
  return true;
  return TODO();
}

// Annotates the disposal to "consume" the value -- i.e. what happens if it's a function param or otherwise a "use-once" value (i.e. to be copied/moved into a param list, or whatever).
func annotate_disposal_for_consume(es *exprscope, a *ast_expr) bool {
  info *ast_expr_complete_info = expr_complete_info(a);
  switch &info->lval {
    case &IsLvalNo(desc rval_description): {
      if desc.whole_temporary {
        annotate_disposal(a, DisposeMoveInPlace(void));
      } else {
        copy instpair;
        if !get_copy_constructor(es->ds, &info->cu, &copy) {
          return false;
        }
        destroy instpair;
        if !get_destroy_constructor(es->ds, &ref_temporary(es, desc.num)->type, &destroy) {
          return false;
        }
        annotate_disposal(a, DisposeCopyAndDestroy({copy, destroy}));
      }
    }
    case &IsLvalYes(v void): {
      copy instpair;
      if !get_copy_constructor(es->ds, &info->cu, &copy) {
        return false;
      }
      annotate_disposal(a, DisposeCopy(copy));
    }
  }
  return true;
}

// Annotates the disposal of the expr for local field access -- depends on whether it's an lvalue/rvalue.
func annotate_disposal_for_field(a *ast_expr) void {
  annotate_disposal(a, DisposeIgnore(void));
}

// Annotates the disposal of an Expr statement's expr, or some other value we are done using.
func annotate_disposal_for_discard(es *exprscope, a *ast_expr) bool {
  info *ast_expr_complete_info = expr_complete_info(a);
  switch &info->lval {
    case &IsLvalNo(desc rval_description): {
      destroy instpair;
      if !get_destroy_constructor(es->ds, &ref_temporary(es, desc.num)->type, &destroy) {
        return false;
      }
      annotate_disposal(a, DisposeDestroy(destroy));
    }
    case &IsLvalYes(v void): {
      annotate_disposal(a, DisposeIgnore(void));
    }
  }
  return true;
}

// Annotates the disposal for a value we'll use but then discard.
func annotate_disposal_for_consume_then_discard(es *exprscope, a *ast_expr) bool {
  info *ast_expr_complete_info = expr_complete_info(a);
  switch &info->lval {
    case &IsLvalNo(desc rval_description): {
      destroy instpair;
      if !get_destroy_constructor(es->ds, &ref_temporary(es, desc.num)->type, &destroy) {
        return false;
      }
      if desc.whole_temporary {
        annotate_disposal(a, DisposeMoveInPlaceThenDestroy(destroy));
      } else {
        copy instpair;
        if !get_copy_constructor(es->ds, &info->cu, &copy) {
          return false;
        }
        destroy_the_copy instpair;
        if !get_destroy_constructor(es->ds, &info->cu, &destroy_the_copy) {
          return false;
        }
        annotate_disposal(a, DisposeCopyAndDestroyThenDestroy({copy, destroy, destroy_the_copy}));
      }
    }
    case &IsLvalYes(v void): {
      copy instpair;
      if !get_copy_constructor(es->ds, &info->cu, &copy) {
        return false;
      }
      destroy_the_copy instpair;
      if !get_destroy_constructor(es->ds, &info->cu, &destroy_the_copy) {
        return false;
      }
      annotate_disposal(a, DisposeCopyThenDestroy({copy, destroy_the_copy}));
    }
  }
  return true;
}


func annotate_disposal_for_assignment(es *exprscope, a *ast_expr) bool {
  info *ast_expr_complete_info = expr_complete_info(a);
  switch &info->lval {
    case &IsLvalNo(desc rval_description): {
      if desc.whole_temporary {
        move instpair;
        if !get_move_constructor(es->ds, &info->cu, &move) {
          return false;
        }
        annotate_disposal(a, DisposeMove(move));
      } else {
        // TODO: This dups code with other makers of DisposeCopyAndDestroy.
        copy instpair;
        if !get_copy_constructor(es->ds, &info->cu, &copy) {
          return false;
        }
        destroy instpair;
        if !get_destroy_constructor(es->ds, &ref_temporary(es, desc.num)->type, &destroy) {
          return false;
        }
        annotate_disposal(a, DisposeCopyAndDestroy({copy, destroy}));
      }
    }
    case &IsLvalYes(v void): {
      copy instpair;
      if !get_copy_constructor(es->ds, &info->cu, &copy) {
        return false;
      }
      annotate_disposal(a, DisposeCopy(copy));
    }
  }
  return true;
}

func check_expr_strinit(es *exprscope, ai allow_incomplete, a *ast_strinit, pt *te_typeexpr, x *ast_expr) bool {
  if !is_complete(pt) {
    if ai == AllowIncompleteYes(void) {
      // NOTE: We could have more specific info, like number of fields and their incomplete types.
      annotate_info(x, IncompleteCheck(TeUnknown(void)));
      return true;
    } else {
      ERR(_u8("Structure literal used ambiguously."));
      return false;
    }
  }

  // Since pt is complete, and since it's a pt, it's computed.
  if !is_complete_computed(pt).computed {
    ice(_u8("check_expr_strinit has non-computed pt"));
  }
  cu_pt cu_typeexpr = ~ *pt;
  structural_type *cu_typeexpr;
  if !structural_rhs(es->ds, &cu_pt, &structural_type) {
    return false;
  }

  // NOTE: We could allow arrays, especially if ambig matching returns number of fields and their type.
  if case &TeStruct(b te_struct) = &structural_type->~ {
    n size = count(&b.fields);
    if n != count(&a->exprs) {
      ERR(_u8("Structure literal has wrong number of fields."));
      return false;
    }

    for i size = 0; i < n; i = i + 1 {
      x_i *ast_expr = ref(&a->exprs, i);
      if !check_expr_ai(es, AllowIncompleteNo(void), x_i, &ref(&b.fields, i)->type) {
        return false;
      }
      if !annotate_disposal_for_consume(es, x_i) {
        return false;
      }
    }

    // We checked is_computed(pt).
    annotate_info(x, CompleteCheck(mk(wholeRval(add_temporary(es, ~ *pt)), ~ *pt)));
    return true;
  } else {
    ERR(_u8("Structure literal used on non-struct type."));
    return false;
  }
}

// TODO: Compute destruction of lambda params... not to mention var statement variables (and default-initialization).
func check_expr_lambda(es *exprscope, a *ast_lambda, pt *te_typeexpr, x *ast_expr) bool {
  // TODO: Cache type.
  type ast_typeexpr = lambda_declared_type(es->im, a);
  // TODO: Cache converted.
  converted te_typeexpr;
  if !convert_typeexpr(es->cs, &type, &converted) {
    return false;
  }
  // TODO: I see some duplicated logic with the TypedExpr case.
  computed cac_typeexpr;
  if !check_and_compute_typeexpr(es->cs, es->clq, es->ds->generics, es->ds->parms, &converted, &computed) {
    return false;
  }
  // Lambda exprs can't have partial types (yet!).
  check(computed.complete);
  unified te_typeexpr;
  if !unify_types(pt, &computed.te, &unified) {
    ERR(_u8("Lambda is incompatible with contextual type."));
    return false;
  }

  computed_params *array[te_typeexpr];
  if !decompose_typeapp(&computed.te, primitive_function_puretype(es->cs), &computed_params) {
    ice(_u8("lambda type is not a function type"));
  }
  vp varpopper;
  nargs size = count(&a->args);
  for i size = 0; i < nargs; i = i + 1 {
    cu_param cu_typeexpr = ~get(computed_params, i);
    // AutoInitYes means a goto from "outside" the lambda could ostensibly construct the variable and initialize it.  That's complete haberdash, of course.
    if !ds_push_var(es->ds, &vp, &ref(&a->args, i)->name, &cu_param, AutoInitYes(void)) {
      return false;
    }
  }

  return_type cu_typeexpr = ~get(computed_params, nargs);

  bs bodystate = mk(es->ds, &return_type);
  ee entryexit;
  if !check_body(&bs, &a->body, &ee) {
    return false;
  }

  if !finish_lambda_body(&bs, ee) {
    return false;
  }

  annotate_info(x, CompleteCheck(mk(wholeRval(add_temporary(es, ~computed.te)), ~computed.te)));
  return true;
}

func numeric_literal_value(a *ast_numeric_literal) bigint {
  switch a {
    case &HexLiteral(b ast_hex_literal): {
      return convert_to_bigint(16, &b.digits);
    }
    case &DecLiteral(b ast_dec_literal): {
      return convert_to_bigint(10, &b.digits);
    }
  }
}

func check_numeric_literal(es *exprscope, ai allow_incomplete, pt *te_typeexpr, n bigint, x *ast_expr) bool {
  if case &TeUnknown(v void) = pt {
    if ai == AllowIncompleteYes(void) {
      annotate_info(x, IncompleteCheck(TeUnknown(void)));
      return true;
    } else {
      ERR(_u8("Numeric literal usage is ambiguous."));
      return false;
    }
  }

  facts numeric_traits;
  if !is_numeric_type(es->cs, pt, &facts) {
    ERR(_u8("Numeric literal in bad place."));
    return false;
  }
  if n < facts.minval || n > facts.maxval {
    ERR(_u8("Numeric literal out of range."));
    return false;
  }
  // It's a pt, and it's a numeric type, which means it must be a complete pt, which means it's computed.
  check(is_complete_computed(pt).computed);
  annotate_info(x, CompleteCheck(mk(wholeRval(add_temporary(es, ~ *pt)), ~ *pt)));
  return true;
}

func decompose_typeapp(t *te_typeexpr, expected_puretype te_puretype, params_out **array[te_typeexpr]) bool {
  // This could be implemented in terms of unify_under_generics, you know.
  if case &TeApp(app te_typeapp) = t {
    unified te_puretype;
    if !unify_puretypes(oo(&app.typefunc), &expected_puretype, &unified) {
      return false;
    }
    *params_out = &app.params;
    return true;
  } else {
    return false;
  }
}

func decompose_typeapp(t *te_typeexpr, expected_puretype te_puretype, oneparam_out **te_typeexpr) bool {
  params *array[te_typeexpr];
  if !decompose_typeapp(t, expected_puretype, &params) {
    return false;
  }
  if count(params) != 1 {
    return false;
  }
  *oneparam_out = ref(params, 0);
  return true;
}

func decompose_typeapp(t *te_typeexpr, expected_puretype te_puretype, oneparam_out **te_typeexpr, twoparam_out **te_typeexpr) bool {
  params *array[te_typeexpr];
  if !decompose_typeapp(t, expected_puretype, &params) {
    return false;
  }
  if count(params) != 2 {
    return false;
  }
  *oneparam_out = ref(params, 0);
  *twoparam_out = ref(params, 1);
  return true;
}

func check_field(es *exprscope, t *cu_typeexpr, a *ast_fieldname, pt *te_typeexpr, fieldtype_out *cu_typeexpr, inherits_lval_out *bool) bool {
  fieldtype cu_typeexpr;
  inherits_lval bool;
  if !lookup_field(es, t, a, &fieldtype, &inherits_lval) {
    return false;
  }
  unified te_typeexpr;
  if !unify_types(pt, &fieldtype.~, &unified) {
    ERR(_u8("field has wrong type."));
    return false;
  }
  *fieldtype_out = fieldtype;
  *inherits_lval_out = inherits_lval;
  return true;
}

func deftype_rhs_accessible(ds *defscope, id deftype_entry_id, result_out *bool) bool {
  ent *deftype_entry = ref_deftype_entry(ds->cs, id);
  switch ent->accessibility {
    case RhsPublic(v void): {
      *result_out = true;
      return true;
    }
    case RhsPrivate(v void): {
      n size = count(&ds->accessible);
      for i size = 0; i < n; i = i + 1 {
        aid access_entry_id = get(&ds->accessible, i);
        dti deftype_entry_id;
        if !get_accessible_deftype(ds->cs, aid, &dti) {
          return false;
        }
        if dti == id {
          *result_out = true;
          return true;
        }
      }
      *result_out = false;
      return true;
    }
    case RhsImpossible(v void): {
      *result_out = false;
      return true;
    }
  }
}

// t must be complete.
func complete_structural_rhs(ds *defscope, t *te_typeexpr, rhs_type_out **te_typeexpr) bool {
  switch t {
    case &TeName(a te_name): {
      cu_rhs *cu_typeexpr;
      if !help_structural_rhs(ds, &a.pack, &cu_rhs) {
        return false;
      }
      *rhs_type_out = &cu_rhs->~;
      return true;
    }
    case &TeApp(a te_typeapp): {
      cu_rhs *cu_typeexpr;
      if !help_structural_rhs(ds, &a.pack, &cu_rhs) {
        return false;
      }
      *rhs_type_out = &cu_rhs->~;
      return true;
    }
    default: {
      if case &TeUnknown(v void) = t {
        ice(_u8("structural_rhs called on incomplete type"));
      }
      *rhs_type_out = t;
      return true;
    }
  }
}

func structural_rhs(ds *defscope, t *cu_typeexpr, rhs_type_out **cu_typeexpr) bool {
  switch &t->~ {
    case &TeName(a te_name): {
      return help_structural_rhs(ds, &a.pack, rhs_type_out);
    }
    case &TeApp(a te_typeapp): {
      return help_structural_rhs(ds, &a.pack, rhs_type_out);
    }
    default: {
      if case &TeUnknown(v void) = &t->~ {
        ice(_u8("structural_rhs called on incomplete type"));
      }
      *rhs_type_out = t;
      return true;
    }
  }
}

func help_structural_rhs(ds *defscope, mbpack *opt[te_instpack], rhs_type_out **cu_typeexpr) bool {
  if case &Has(pack te_instpack) = mbpack {
    accessible_result bool;
    if !deftype_rhs_accessible(ds, pack.ent_id, &accessible_result) {
      return false;
    }
    if !accessible_result {
      ERR(_u8("Looking for structural type information on inaccessible defclass type"));
      return false;
    }
    if !ensure_deftype_inst_checked(ds->cs, ds->clq, pack.ent_id, pack.inst_id) {
      return false;
    }
    inst *deftype_inst = ref_deftype_inst(ds->cs, pack.inst_id);
    if case &Has(info deftype_inst_info) = &inst->info {
      if case &Has(t cu_typeexpr) = &info.rhs {
        *rhs_type_out = &t;
        return true;
      } else {
        ice(_u8("deftype_rhs_accessible permitted a primitive type."));
        return fake();
      }
    } else {
      ice(_u8("inst checked, info still None()"));
      return fake();
    }
  } else {
    ice(_u8("lhs type in type_structural_rhs is not computed."));
    return fake();
  }
}

func lookup_whole_field(es *exprscope, mbpack *opt[te_instpack], fieldtype_out *cu_typeexpr) bool {
  p *cu_typeexpr;
  if !help_structural_rhs(es->ds, mbpack, &p) {
    return false;
  }
  *fieldtype_out = *p;
  return true;
}

func lookup_name_field(es *exprscope, mbpack *opt[te_instpack], fieldname *ast_ident, fieldtype_out *cu_typeexpr, inherits_lval_out *bool) bool {
  p *cu_typeexpr;
  if !help_structural_rhs(es->ds, mbpack, &p) {
    return false;
  }
  return help_lookup_name_field(es, p, fieldname, fieldtype_out, inherits_lval_out);
}

func help_lookup_name_field(es *exprscope, t *cu_typeexpr, fieldname *ast_ident, fieldtype_out *cu_typeexpr, inherits_lval_out *bool) bool {
  switch &t->~ {
    case &TeName(a te_name): {
      return lookup_name_field(es, &a.pack, fieldname, fieldtype_out, inherits_lval_out);
    }
    case &TeApp(a te_typeapp): {
      return lookup_name_field(es, &a.pack, fieldname, fieldtype_out, inherits_lval_out);
    }
    case &TeStruct(a te_struct): {
      if !lookup_field_from_list(es->cs, &a.fields, fieldname->value, fieldtype_out) {
        return false;
      }
      *inherits_lval_out = true;
      return true;
    }
    case &TeEnum(a te_enum): {
      ERR(_u8("field lookup on an enum type"));
      return false;
    }
    case &TeUnion(a te_union): {
      if !lookup_field_from_list(es->cs, &a.fields, fieldname->value, fieldtype_out) {
        return false;
      }
      *inherits_lval_out = true;
      return true;
    }
    case &TeArraytype(a te_arraytype): {
      if fieldname->value != es->im->cym.lengthsym {
        ERR(_u8("field lookup (not .length) on array type"));
        return false;
      }
      *fieldtype_out = compute_prim(es->ds, primitive_size_type(es->cs));
      *inherits_lval_out = false;
      return true;
    }
    case &TeUnknown(v void): {
      ice(_u8("lookup_field sees incomplete type"));
      return fake();
    }
  }
}

func lookup_field(es *exprscope, t *cu_typeexpr, f *ast_fieldname, fieldtype_out *cu_typeexpr, inherits_lval_out *bool) bool {
  switch f {
    case &WholeField(v void): {
      switch &t->~ {
        case &TeName(a te_name): {
          if !lookup_whole_field(es, &a.pack, fieldtype_out) {
            return false;
          }
          *inherits_lval_out = true;
          return true;
        }
        case &TeApp(a te_typeapp): {
          if !lookup_whole_field(es, &a.pack, fieldtype_out) {
            return false;
          }
          *inherits_lval_out = true;
          return true;
        }
        default: {
          ERR(_u8("whole field lookup on 'bare' type"));
          return false;
        }
        case &TeUnknown(u void): {
          ice(_u8("lookup_field sees incomplete type."));
          return fake();
        }
      }
    }
    case &NameField(b ast_ident): {
      return help_lookup_name_field(es, t, &b, fieldtype_out, inherits_lval_out);
    }
  }
}

func find_vardecl(a *array[te_vardecl], name sym, out **te_typeexpr) bool {
  n size = count(a);
  for i size = 0; i < n; i = i + 1 {
    d *te_vardecl = ref(a, i);
    if d->name == name {
      *out = &d->type;
      return true;
    }
  }
  return false;
}

// fields is supposed to be complete.
func lookup_field_from_list(cs *checkstate, fields *array[te_vardecl], fieldname sym, fieldtype_out *cu_typeexpr) bool {
  fieldtype *te_typeexpr;
  if !find_vardecl(fields, fieldname, &fieldtype) {
    ERR(_u8("fieldname '"), lookup(cs->im, fieldname), _u8("' not found"));
    return false;
  }
  *fieldtype_out = ~ *fieldtype;
  return true;
}

func ai_incomplete(yes bool) allow_incomplete {
  if yes {
    return AllowIncompleteYes(void);
  } else {
    return AllowIncompleteNo(void);
  }
}

func check_expr_funcall(es *exprscope, ai allow_incomplete, x *ast_expr, a *ast_funcall, pt *te_typeexpr) bool {
  a_param_incomplete bool;
  if !check_funcall_params_firsttime(es, &a->params, &a_param_incomplete) {
    return false;
  }

  func_pt te_typeexpr = make_fn_partial_type(es->cs, pt, &a->params);
  if !check_expr_ai(es, ai_incomplete(!a_param_incomplete && ai == AllowIncompleteYes(void)), oo(&a->fun), &func_pt) {
    return false;
  }

  if expr_type_incomplete(oo(&a->fun)) {
    check(ai == AllowIncompleteYes(void));
    annotate_info(x, IncompleteCheck(TeUnknown(void)));
    return true;
  }

  if a_param_incomplete {
    if !check_funcall_params_secondtime(es, expr_complete_type(oo(&a->fun)), &a->params) {
      return false;
    }
  }

  if !annotate_disposal_for_consume(es, oo(&a->fun)) {
    return false;
  }

  return_type *te_typeexpr = fn_return_type(es->cs, &expr_complete_type(oo(&a->fun))->~);
  annotate_info(x, CompleteCheck(mk(wholeRval(add_temporary(es, ~ *return_type)), ~ *return_type)));
  return true;
}

func check_funcall_params_firsttime(es *exprscope, params *array[ast_expr], a_param_incomplete_out *bool) bool {
  n size = count(params);
  unknown te_typeexpr = TeUnknown(void);
  all_params_complete bool = true;
  for i size = 0; i < n; i = i + 1 {
    expr *ast_expr = ref(params, i);
    if !check_expr_ai(es, AllowIncompleteYes(void), expr, &unknown) {
      return false;
    }
    complete bool = expr_type_complete(expr);
    if complete {
      if !annotate_disposal_for_consume(es, expr) {
        return false;
      }
    }
    all_params_complete = all_params_complete & complete;
  }
  *a_param_incomplete_out = !all_params_complete;
  return true;
}

func check_funcall_params_secondtime(es *exprscope, functype *cu_typeexpr, params *array[ast_expr]) bool {
  n size = count(params);

  type_params *array[te_typeexpr];
  if !decompose_typeapp(&functype->~, primitive_function_puretype(es->cs), &type_params) {
    ice(_u8("Expecting a TeApp for fn-type."));
  }
  check(count(type_params) == n + 1);

  for i size = 0; i < n; i = i + 1 {
    expr *ast_expr = ref(params, i);
    if !check_expr_ai(es, AllowIncompleteNo(void), expr, ref(type_params, i)) {
      return false;
    }
    if !annotate_disposal_for_consume(es, expr) {
      return false;
    }
  }
  return true;
}

func compute_prim(ds *defscope, t te_typeexpr) cu_typeexpr {
  cac cac_typeexpr;
  if !noscoped_check_and_compute_typeexpr(ds->cs, ds->clq, &t, &cac) {
    ice(_u8("compute_prim encounters uncomputable type"));
  }
  check(cac.complete);
  return ~cac.te;
}

func check_expr_index(es *exprscope, x *ast_expr, a *ast_index_expr, pt *te_typeexpr) bool {
  unknown te_typeexpr = TeUnknown(void);
  if !check_expr_ai(es, AllowIncompleteNo(void), oo(&a->lhs), &unknown) {
    return false;
  }
  sizetype cu_typeexpr = compute_prim(es->ds, primitive_size_type(es->cs));

  if !check_expr_ai(es, AllowIncompleteNo(void), oo(&a->rhs), &sizetype.~) {
    return false;
  }

  if !annotate_disposal_for_consume(es, oo(&a->rhs)) {
    return false;
  }

  lhs_info *ast_expr_complete_info = expr_complete_info(oo(&a->lhs));

  ixtype *te_typeexpr;
  is_arraytype bool;
  if !decompose_indexable(es->cs, &lhs_info->cu.~, &ixtype, &is_arraytype) {
    ERR(_u8("indexing on non-indexable type"));
    return false;
  }

  unified te_typeexpr;
  if !unify_types(pt, ixtype, &unified) {
    ERR(_u8("index expr returns wrong type"));
    return false;
  }

  lval is_lval;
  if is_arraytype {
    lval = lhs_info->lval;
    // Just like field access.
    annotate_disposal_for_field(oo(&a->lhs));
  } else {
    // Dereferencing a pointer always makes an lvalue.
    lval = IsLvalYes(void);
    if !annotate_disposal_for_consume(es, oo(&a->lhs)) {
      return false;
    }
  }
  annotate_info(x, CompleteCheck(mk(lval, ~ *ixtype)));
  return true;
}

func decompose_indexable(cs *checkstate, t *te_typeexpr, out **te_typeexpr, is_arraytype_out *bool) bool {
  if decompose_typeapp(t, primitive_pointer_puretype(cs), out) {
    *is_arraytype_out = false;
    return true;
  }
  if decompose_arraytype(t, out) {
    *is_arraytype_out = true;
    return true;
  }
  return false;
}

func decompose_arraytype(t *te_typeexpr, out **te_typeexpr) bool {
  if case &TeArraytype(a te_arraytype) = t {
    *out = oo(&a.param);
    return true;
  } else {
    return false;
  }
}

func expr_type(a *ast_expr) te_typeexpr {
  switch &a->info {
    case &NoInfo(v void): {
      ice(_u8("expr_type sees NoInfo"));
      return fake();
    }
    case &IncompleteCheck(t te_typeexpr): {
      return t;
    }
    case &CompleteCheck(t ast_expr_complete_info): {
      return t.cu.~;
    }
  }
}

func expr_complete_info(a *ast_expr) *ast_expr_complete_info {
  if case &CompleteCheck(inf ast_expr_complete_info) = &a->info {
    return &inf;
  } else {
    ice(_u8("expr_complete_info sees... not a complete type"));
    return fake();
  }
}

func expr_complete_type(a *ast_expr) *cu_typeexpr {
  return &expr_complete_info(a)->cu;
}

func expr_type_complete(a *ast_expr) bool {
  switch &a->info {
    case &NoInfo(v void): {
      ice(_u8("expr_type_complete sees NoInfo"));
      return fake();
    }
    case &IncompleteCheck(t te_typeexpr): { return false; }
    case &CompleteCheck(t ast_expr_complete_info): { return true; }
  }
}


func expr_type_incomplete(a *ast_expr) bool {
  return !expr_type_complete(a);
}

func make_fn_partial_type(cs *checkstate, return_type *te_typeexpr, params *array[ast_expr]) te_typeexpr {
  type_params array[te_typeexpr];
  n size = count(params);
  for i size = 0; i < n; i = i + 1 {
    push(&type_params, expr_type(ref(params, i)));
  }
  push(&type_params, *return_type);
  return TeApp({embox(primitive_function_puretype(cs)), type_params, None()});
}

func fn_return_type(cs *checkstate, func_type *te_typeexpr) *te_typeexpr {
  params *array[te_typeexpr];
  if !decompose_typeapp(func_type, primitive_function_puretype(cs), &params) {
    ice(_u8("Expected TeApp for fn-type in fn_return_type."));
  }
  n size = count(params);
  check(n > 0);
  return ref(params, n - 1);
}
