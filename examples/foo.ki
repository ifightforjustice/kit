import bar;

export def foo i32 = ~(1u);

def fac func[i32, i32] = fn(x i32) i32 {
  var acc i32 = 1;
  for var i i32 = x; i > 0; i = i - 1 {
    acc = acc * i;
  }
  return acc;
};

deftype ty struct {
  x i32;
  y i32;
};

def[T] getsize func[u32] = fn() u32 {
  return sizeof@[T];
};

defclass kla struct {
  x u32;
  y u32;
};

access kla {
  def destroy func[*kla, void] = fn(p *kla) void {
    p->x = 0u;
    p->y = 0u;
    var ret void;
    return ret;
  };
  def init func[*kla, void] = fn(p *kla) void {
    p->x = 37u;
    p->y = 47u;
    var ret void;
    return ret;
  };

  def expose func[*kla, struct { x u32; y u32; }] = fn (p *kla) struct { x u32; y u32; } {
    return ~ *p;
  };
}

def try_kla func[void] = fn() void {
  var k kla;
  var l struct { x u32; y u32; } = expose(&k);
  print(l.x);
  putchar(32);
  print(l.y);
  putchar(10);
  var ret void;
  return ret;
};

export def showfacs func[*ty, *u16, ty] = fn(p *ty, num *u16) ty {
  try_kla();
  var ret ty;
  p->x = -5;
  p->y = fac(7);
  p->x = -p->x;

  var tmp u32 = ~fac(p->x);
  var y u32 = ~(*p).y;
  print(tmp);
  putchar(10);
  print(y);
  putchar(10);

  var yptr * i32 = &p->y;
  *yptr = 77;
  var xptr * i32 = &p->x;
  xptr[0] = 99;

  p[1].x = 33;
  *num = (~29 :: u16);
  p[1].y = (~((~22 :: u16) + (~44 :: u16)) :: i32);

  var heh [2]ty;
  heh[0] = p[1];
  heh[0].x = ^34;
  p[1] = heh[0];

  var void_value void;

  var naked struct { x i32; y i32; };
  naked.x = p->x;
  naked.y = (~getsize@[ty]() :: i32);

  ret = (~naked :: ty);
  return ret;
};

def u8_value u8 = ~3;
