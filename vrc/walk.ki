import ast;
import expr;

// We have a set of lifetimes that pop in and out of existence over time.  They all have interesting state that needs to be tracked.  We want to chase state through everything.

// How should we represent state?  We've got facts.  A big bag of facts.  Okay then.  I hope they aren't self-contradictory!

defclass walk_hold {
  wm *ast_walk_marking;
};

access walk_hold {
  func do_init(wh *walk_hold) void {
    init(&wh->wm);
  }
  func do_destroy(wh *walk_hold) void {
    wm *_ = wh->wm;
    if wm != null {
      wm->cycle_back = false;
      check(wm->walking);
      wm->walking = false;
    }
  }

  func wh_init(wh *walk_hold, wm *ast_walk_marking) void {
    check(wh->wm == null);
    check(!wm->walking);
    wm->walking = true;
    wh->wm = wm;
  }
}

struct walkdesc {
  facts array[te_statedesc];
};

// TODO(): Have some counter for 'number of dirty markings made' and 'number of dirty markings walked from', have an assertion that these numbers match.
// There's just one of these (for any given walk).
struct walkstate {
  bs *bodystate;
  es *framescope;
  ds *defscope;
  clq *clqueue;
  cs *checkstate;
  im *identmap;

  current_desc walkdesc;
  // True if we shouldn't be maintaining state -- we're cycling back.
  // NOTE(): We could/should replace current_desc/cyclic with an opt[walkdesc].
  cycling bool;
};

func mk(bs *bodystate) walkstate {
  ret walkstate = {bs, &bs->es, bs->ds, bs->clq, bs->cs, bs->im, {mk_array()}, false};
  return ret;
}

// computed_params is the fn[...] params (including return type and transdesc)
func walk_lambda_state(bs *bodystate, computed_params *shray[te_typeexpr], a *ast_lambda) np {
  ws walkstate = mk(bs);

  nargs size = count(&a->args);
  for i size = 0; i < nargs; i++ {
    vn var_number = *un(&ref(&a->args, i)->vn);
    vi *var_info = ref_var(&bs->es, vn);
    // Okay, and?
  }

  if case Printed(pm) = walk_bracebody(&ws, &a->body.bb) {
    return Printed(pm);
  }

  // TODO(): Do return statements already walk these destructions?  Is this redundant?  Only useful when the body falls off the end?  When is it?
  if case Printed(pm) = walk_var_destructions(&ws, &un(&a->body.info)->parameter_destructions) {
    return Printed(pm);
  }

  // TODO(): Something must be done.  Tie return state down?
  return NoFail;
}

func walk_bracebody(ws *walkstate, a *ast_bracebody) np {
  wh walk_hold;
  wh_init(&wh, &a->walk_marking);

  again bool = true;
  while again {
    a->walk_marking.cycle_back = false;

    nstatements size = count(&a->statements);
    for i size = 0; i < nstatements; i++ {
      s *ast_statement = ref(&a->statements, i);
      if case Printed(pm) = walk_statement(ws, s) {
        return Printed(pm);
      }
    }
    if case Printed(pm) = walk_var_destructions(ws, &un(&a->info)->destructions) {
      return Printed(pm);
    }

    again = cycle_again(ws, &a->walk_marking);
  }

  return NoFail;
}

func walk_statement(ws *walkstate, a *ast_statement) np {
  switch &a->u {
  case &Expr(b ast_expr_discard):
    if case Printed(pm) = walk_discard_expr(ws, &b) {
      return Printed(pm);
    }

  case &Return(b ast_return_statement):
    if case Printed(pm) = walk_return_statement(ws, &b) {
      return Printed(pm);
    }

  case &Var(b ast_var_statement):
    if case Printed(pm) = walk_var_statement(ws, &b) {
      return Printed(pm);
    }

  case &IfThen(b ast_ifthen_statement):
    if case Printed(pm) = walk_ifthen_statement(ws, &b) {
      return Printed(pm);
    }

  case &IfThenElse(b ast_ifthenelse_statement):
    if case Printed(pm) = walk_ifthenelse_statement(ws, &b) {
      return Printed(pm);
    }

  case &While(b ast_while_statement):
    if case Printed(pm) = walk_while_statement(ws, &b) {
      return Printed(pm);
    }

  case &For(b ast_for_statement):
    if case Printed(pm) = walk_for_statement(ws, &b) {
      return Printed(pm);
    }

  case &Switch(b ast_switch_statement):
    if case Printed(pm) = walk_switch_statement(ws, &b) {
      return Printed(pm);
    }

  case &Break(b ast_break_statement):
    if case Printed(pm) = walk_break_statement(ws, &b) {
      return Printed(pm);
    }

  case &Continue(b ast_continue_statement):
    if case Printed(pm) = walk_continue_statement(ws, &b) {
      return Printed(pm);
    }

  case &Label(b ast_label_statement):
    if case Printed(pm) = walk_label_statement(ws, &b) {
      return Printed(pm);
    }

  case &Goto(b ast_goto_statement):
    if case Printed(pm) = walk_goto_statement(ws, &b) {
      return Printed(pm);
    }
  }

  return NoFail;
}

func walk_goto_statement(ws *walkstate, a *ast_goto_statement) np {
  // TODO(): Should we walk these constructors when cycling?  No.
  info *ast_goto_statement_info = un(&a->info);
  if case Printed(pm) = walk_var_destructions(ws, &info->destructions) {
    return Printed(pm);
  }
  if case Printed(pm) = walk_var_initters(ws, &info->initializations) {
    return Printed(pm);
  }
  // TODO(): Connect state to other end.

  // NOTE(): We should think about how we do our variable unwindings (and in particular, windings).  We could overlap with other variable unwindings/windings, heading towards the same label.  Should we overlap the typestate, too?  For now, the answer is, nah.

  // Just like with return statements, we enter cycling-state.
  ws->cycling = true;

  return TODO();
}

func walk_pattern_assign(ws *walkstate, a *ast_pattern_assign) np {
  if case Printed(pm) = walk_expr_consume(ws, oo(&a->rhs)) {
    return Printed(pm);
  }
  // TODO(): That's it?  Do some tag cell / enum cell / deref cell logic?
  return NoFail;
}

func walk_condition(ws *walkstate, a *ast_condition) np {
  switch a {
  case &ExprCondition(b box[ast_expr_consume]):
    return walk_expr_consume(ws, oo(&b));
  case &PatternCondition(b ast_pattern_assign):
    return walk_pattern_assign(ws, &b);
  }
}

func walk_condition_discard(ws *walkstate, a *ast_condition_discard_info) np {
  if case &Has(c cell_num) = un(&a->virtual_cell_dead) {
    // TODO(): What is this, and how the heck do we handle this?
  }
  if case Printed(pm) = walk_later_discard_info(ws, &a->later) {
    return Printed(pm);
  }
  return NoFail;
}

func walk_ifthen_statement(ws *walkstate, a *ast_ifthen_statement) np {
  // TODO(): Connect condition discard, and body, correctly.
  if case Printed(pm) = walk_condition(ws, &a->condition) {
    return Printed(pm);
  }
  if case Printed(pm) = walk_bracebody(ws, &a->body) {
    return Printed(pm);
  }
  if case Printed(pm) = walk_condition_discard(ws, &a->condition_discard) {
    return Printed(pm);
  }
  return NoFail;
}

func walk_ifthenelse_statement(ws *walkstate, a *ast_ifthenelse_statement) np {
  // TODO(): Connect condition discard, and body, correctly.  (Discard before/after elsebody correctly.)
  // TODO(): Walk condition correctly.
  if case Printed(pm) = walk_condition(ws, &a->condition) {
    return Printed(pm);
  }
  if case Printed(pm) = walk_bracebody(ws, &a->thenbody) {
    return Printed(pm);
  }
  if case Printed(pm) = walk_bracebody(ws, &a->elsebody) {
    return Printed(pm);
  }
  if case Printed(pm) = walk_condition_discard(ws, &a->condition_discard) {
    return Printed(pm);
  }
  return NoFail;
}

func cycle_again(ws *walkstate, a *ast_walk_marking) bool {
  /* ws->cycling could be in either state when we get to cycle_again.  For example, if we have { blah; return 3; } then the return statement will put us in a cycling state, no matter what. */
  if a->cycle_back {
    ws->cycling = true;
    return true;
  } else {
    return false;
  }
}

func walk_while_statement(ws *walkstate, a *ast_while_statement) np {
  wh walk_hold;
  wh_init(&wh, &a->walk_marking);

  again bool = true;
  while again {
    a->walk_marking.cycle_back = false;

    // TODO(): Connect the condition discards, and body, correctly.
    if case Printed(pm) = walk_condition(ws, &a->condition) {
      return Printed(pm);
    }
    if case Printed(pm) = walk_bracebody(ws, &a->body) {
      return Printed(pm);
    }
    if case Printed(pm) = walk_condition_discard(ws, &a->condition_discard_continue) {
      return Printed(pm);
    }

    again = cycle_again(ws, &a->walk_marking);
  }

  if case Printed(pm) = walk_condition_discard(ws, &a->condition_discard_exit) {
    return Printed(pm);
  }
  return NoFail;
}

func walk_for_statement(ws *walkstate, a *ast_for_statement) np {
  // TODO(): Connect the condition discard, body, etc, correctly.
  if case &Has(b box[ast_statement]) = &a->initializer {
    if case Printed(pm) = walk_statement(ws, oo(&b)) {
      return Printed(pm);
    }
  }

  // Scoped so the walk-hold applies to the cycling part of the loop.  This fact has to be kept in sync with the type-checking code in body.ki.
  if true {
    wh walk_hold;
    wh_init(&wh, &a->walk_marking);

    again bool = true;
    while again {
      a->walk_marking.cycle_back = false;

      if case &Has(b ast_expr_condition) = &a->condition {
        // TODO(): Uh.. walk b.discard more properly.
        if case Printed(pm) = walk_expr_consume(ws, oo(&b.expr)) {
          return Printed(pm);
        }
        if case Printed(pm) = walk_later_discard_info(ws, &b.discard) {
          return Printed(pm);
        }
      }
      if case &Has(b box[ast_expr_discard]) = &a->increment {
        if case Printed(pm) = walk_discard_expr(ws, oo(&b)) {
          return Printed(pm);
        }
      }

      if case Printed(pm) = walk_bracebody(ws, &a->body) {
        return Printed(pm);
      }

      again = cycle_again(ws, &a->walk_marking);
    }
  }

  // TODO(): Connect initter destructions properly.
  // TODO(): Is info set when there's no initter?
  if case Printed(pm) = walk_var_destructions(ws, &un(&a->info)->initter_destructions) {
    return Printed(pm);
  }
  return NoFail;
}

func walk_switch_statement(ws *walkstate, a *ast_switch_statement) np {
  // TODO(): Connect switch cases properly, swartch discard.
  // NOTE(): Handle default case/swartch discard properly.
  if case Printed(pm) = walk_expr_consume(ws, oo(&a->swartch)) {
    return Printed(pm);
  }
  // TODO(): Process swartch deconstruction info / tag cell properly?
  ncases size = count(&a->cases);
  for i size = 0; i < ncases; i++ {
    cas *ast_switch_case = ref(&a->cases, i);
    // TODO(): Process case pattern... somehow.
    if case Printed(pm) = walk_bracebody(ws, &cas->body) {
      return Printed(pm);
    }
  }

  if case Printed(pm) = walk_later_discard_info(ws, &a->swartch_discard) {
    return Printed(pm);
  }

  return NoFail;
}

func walk_break_statement(ws *walkstate, a *ast_break_statement) np {
  // TODO(): Connect to the right place.  Also treat subsequent statements like after a return -- look for marked labels.
  if case Printed(pm) = walk_var_destructions(ws, &un(&a->info)->destructions) {
    return Printed(pm);
  }
  return NoFail;
}

func walk_continue_statement(ws *walkstate, a *ast_continue_statement) np {
  // TODO(): Connect to the right place.  Also treat subsequent statements like after a return -- look for marked labels.
  if case Printed(pm) = walk_var_destructions(ws, &un(&a->info)->destructions) {
    return Printed(pm);
  }
  return NoFail;
}

func walk_label_statement(ws *walkstate, a *ast_label_statement) np {
  return TODO();
}

func walk_discard_expr(ws *walkstate, a *ast_expr_discard) np {
  if case Printed(pm) = walk_expr(ws, &a->expr) {
    return Printed(pm);
  }
  if case Printed(pm) = walk_expr_after_discard(ws, un(&a->after)) {
    return Printed(pm);
  }
  // TODO(): Something must be done?
  return NoFail;
}

func walk_expr(ws *walkstate, a *ast_expr) np {
  switch &a->u {
  case &NameExpr(b ast_name_expr):
    return TODO();
  case &ParenExpr(b ast_paren_expr):
    return walk_expr(ws, oo(&b.expr));
  case &NumericLiteral(b ast_numeric_literal):
    return TODO();
  case &BoolLiteral(b ast_bool_literal):
    return TODO();
  case &VoidLiteral(b ast_void_literal):
    return TODO();
  case &NullLiteral(b ast_null_literal):
    return TODO();
  case &CharLiteral(b ast_char_literal):
    return TODO();
  case &StringLiteral(b ast_string_literal):
    return TODO();
  case &Funcall(b ast_funcall):
    nparams size = count(&b.params);
    for i size = 0; i < nparams; i++ {
      if case Printed(pm) = walk_expr_consume(ws, ref(&b.params, i)) {
        return Printed(pm);
      }
    }
    // TODO: Handle funcall state.
    return TODO();
  case &LogicalConjunction(b ast_logical_conjunction):
    // TODO(): Connect premature return/postmature return.  (And isn't there a lhs discard / move op?)
    if case Printed(pm) = walk_expr_consume(ws, oo(&b.lhs)) {
      return Printed(pm);
    }
    if case Printed(pm) = walk_expr_consume(ws, oo(&b.rhs)) {
      return Printed(pm);
    }
    return TODO();
  case &Assignment(b ast_assignment):
    return walk_assignment(ws, &b);
  case &RefOf(b ast_refof):
    if case Printed(pm) = walk_expr(ws, oo(&b.rhs)) {
      return Printed(pm);
    }
    // TODO: idk.
    return TODO();
  case &AddressOf(b ast_addressof):
    if case Printed(pm) = walk_expr(ws, oo(&b.rhs)) {
      return Printed(pm);
    }
    // TODO: idk.
    return TODO();
  case &Deref(b ast_deref):
    if case Printed(pm) = walk_expr_consume(ws, oo(&b.rhs)) {
      return Printed(pm);
    }
    if case Printed(pm) = walk_later_discard_info(ws, &b.ptr_discard) {
      return Printed(pm);
    }
    // TODO(): Process... the act of dereffing?
    return TODO();
  case &IndexExpr(b ast_index_expr):
    if case Printed(pm) = walk_expr(ws, oo(&b.lhs)) {
      return Printed(pm);
    }
    info *ast_index_expr_info = un(&b.info);
    if case &Has(p tup[ast_expr_after_consume, ast_later_discard_info]) = &info->lhs_after {
      if case Printed(pm) = walk_expr_after_consume(ws, &p.car) {
        return Printed(pm);
      }
    }

    if case Printed(pm) = walk_expr_consume(ws, oo(&b.rhs)) {
      return Printed(pm);
    }

    // TODO(): Do index expr walkstate stuff.

    // TODO(): This assumes we discard lhs before discarding rhs -- do we?
    if case &Has(p tup[ast_expr_after_consume, ast_later_discard_info]) = &info->lhs_after {
      if case Printed(pm) = walk_later_discard_info(ws, &p.cdr) {
        return Printed(pm);
      }
    }
    if case Printed(pm) = walk_later_discard_info(ws, &info->rhs_later) {
      return Printed(pm);
    }

    return NoFail;
  case &Lambda(b ast_lambda):
    return TODO();
  case &LocalField(b ast_local_field):
    if case Printed(pm) = walk_expr(ws, oo(&b.lhs)) {
      return Printed(pm);
    }
    // TODO: idk.
    return TODO();
  case &DerefField(b ast_deref_field):
    if case Printed(pm) = walk_expr_consume(ws, oo(&b.lhs)) {
      return Printed(pm);
    }
    if case Printed(pm) = walk_later_discard_info(ws, &b.ptr_discard) {
      return Printed(pm);
    }
    // TODO(): Process... the act of dereffing?
    // TODO(): Handle pointer discard.
    return TODO();
  case &TypedExpr(b ast_typed_expr):
    return walk_expr(ws, oo(&b.expr));
  case &Strinit(b ast_strinit):
    nexprs size = count(&b.exprs);
    for i size = 0; i < nexprs; i++ {
      if case Printed(pm) = walk_strinit_param(ws, ref(&b.exprs, i)) {
        return Printed(pm);
      }
    }
    // TODO: idk.  Activate something?
    return TODO();
  case &Ternary(b ast_ternary):
    // TODO(): Connect entry and exit of cases properly.
    if case Printed(pm) = walk_expr_consume(ws, oo(&oo(&b.condition)->expr)) {
      return Printed(pm);
    }
    if case Printed(pm) = walk_expr_consume(ws, oo(&b.then_clause)) {
      return Printed(pm);
    }
    if case Printed(pm) = walk_expr_consume(ws, oo(&b.else_clause)) {
      return Printed(pm);
    }
    // TODO(): Make sure condition discard happens before/after then/else clauses, correctly.
    if case Printed(pm) = walk_later_discard_info(ws, &oo(&b.condition)->discard) {
      return Printed(pm);
    }
    return TODO();
  }
}

func walk_assignment_info(ws *walkstate, a *ast_assignment_info) np {
  // NOTE(): This all makes sense, right?
  switch a {
  case &StaticSelfAssignment:
    return NoFail;
  case &SimpleMoveAssignment(b ast_simple_move_assignment_info):
    if case Printed(pm) = walk_destroy_action(ws, &b.target_destroy) {
      return Printed(pm);
    }
    if case Printed(pm) = walk_move_action(ws, &b.rhs_move) {
      return Printed(pm);
    }
    return NoFail;
  case &SimpleCopyDestroyAssignment(b ast_simple_copydestroy_assignment_info):
    if case Printed(pm) = walk_destroy_action(ws, &b.target_destroy) {
      return Printed(pm);
    }
    if case Printed(pm) = walk_copy_action(ws, &b.rhs_copy) {
      return Printed(pm);
    }
    if case Printed(pm) = walk_destroy_action(ws, &b.rhs_cleanup) {
      return Printed(pm);
    }
    return NoFail;
  case &SimpleCopyAssignment(b ast_simple_copy_assignment_info):
    if case Printed(pm) = walk_destroy_action(ws, &b.target_destroy) {
      return Printed(pm);
    }
    if case Printed(pm) = walk_copy_action(ws, &b.rhs_copy) {
      return Printed(pm);
    }
    // TODO(): Do we do anything with rhs_deadme?  No?
    return NoFail;
  case &ConditionalAssignment(b ast_conditional_assignment_info):
    // TODO(): We're missing the conditional operation entirely.  This needs to get celled and lifetimed out like anything else (the way it used to be, instead of just being an instpair).

    if case Printed(pm) = walk_destroy_action(ws, &b.conditional_destroy) {
      return Printed(pm);
    }
    if case Printed(pm) = walk_copy_action(ws, &b.conditional_copy) {
      return Printed(pm);
    }
    // TODO(): Do we do anything with rhs_deadme?  No?
    return TODO();
  }
}

func walk_assignment(ws *walkstate, a *ast_assignment) np {
  if case Printed(pm) = walk_expr(ws, oo(&a->lhs)) {
    return Printed(pm);
  }
  if case Printed(pm) = walk_expr(ws, oo(&a->rhs)) {
    return Printed(pm);
  }
  if case Printed(pm) = walk_assignment_info(ws, un(&a->info)) {
    return Printed(pm);
  }
  return NoFail;
}

func walk_later_discard_info(ws *walkstate, a *ast_later_discard_info) np {
  return walk_destroy_action(ws, un(&a->action));
}

func walk_strinit_param(ws *walkstate, a *ast_strinit_param) np {
  return walk_expr_consume(ws, &a->ec);
}

func walk_expr_consume(ws *walkstate, a *ast_expr_consume) np {
  if case Printed(pm) = walk_expr(ws, &a->expr) {
    return Printed(pm);
  }
  if case Printed(pm) = walk_expr_after_consume(ws, un(&a->after)) {
    return Printed(pm);
  }
  // TODO: idk.
  return TODO();
}

func walk_expr_after_discard(ws *walkstate, a *ast_expr_after_discard) np {
  switch a {
  case &DiscardTemporary(act destroy_action):
    return walk_destroy_action(ws, &act);
  case &DiscardVirtualDead(c cell_num):
    // TODO: idk.
    return TODO();
  case &DiscardNothing:
    // TODO(): How does this case exist?
    return NoFail;
  }
}

func walk_expr_after_consume(ws *walkstate, a *ast_expr_after_consume) np {
  switch &a->actions {
  case &ConsumeByInPlace:
    return NoFail;
  case &ConsumeByCopyDestroy(act copy_destroy_action):
    if case Printed(pm) = walk_copy_action(ws, &act.copy) {
      return Printed(pm);
    }
    if case Printed(pm) = walk_destroy_action(ws, &act.destroy) {
      return Printed(pm);
    }
    return NoFail;
  case &ConsumeByCopy(act tup[copy_action, lval_deadme]):
    if case Printed(pm) = walk_copy_action(ws, &act.car) {
      return Printed(pm);
    }
    // TODO(): Handle lval_deadme.
    return TODO();
  }
}

func walk_return_statement(ws *walkstate, a *ast_return_statement) np {
  if case &Has(b box[ast_expr_consume]) = &a->expr {
    if case Printed(pm) = walk_expr_consume(ws, oo(&b)) {
      return Printed(pm);
    }
  } else {
    // TODO(): Model assignment of void to return cell.
  }

  // TODO(): Tie walkstate to end-of-function walkstate.
  if case Printed(pm) = walk_var_destructions(ws, &un(&a->info)->destructions) {
    return Printed(pm);
  }

  // We continue walking the bracebody, but in a cycling state.
  ws->cycling = true;

  return NoFail;
}

func walk_var_statement(ws *walkstate, a *ast_var_statement) np {
  switch &a->rhs {
  case &HasExpr(b box[ast_expr_consume]):
    if case Printed(pm) = walk_expr_consume(ws, oo(&b)) {
      return Printed(pm);
    }
  case &AutoInit(act opt[init_action]):
    // TODO(): Why is act optional?  Should it be nc?
    return TODO();
  }

  // TODO: idk.
  return TODO();
}

func walk_init_action(ws *walkstate, a *init_action) np {
  return TODO();
}

func walk_copy_action(ws *walkstate, a *copy_action) np {
  return TODO();
}

func walk_move_action(ws *walkstate, a *move_action) np {
  return TODO();
}

func walk_destroy_action(ws *walkstate, a *destroy_action) np {
  return TODO();
}

// "a" is in variable declaration order -- the _opposite_ of destruction order.
func walk_var_destructions(ws *walkstate, a *array[var_destruction]) np {
  n size = count(a);
  for i size = count(a); i > 0; {
    i--;
    if case Printed(pm) = walk_var_destruction(ws, ref(a, i)) {
      return Printed(pm);
    }
  }
  return NoFail;
}

func walk_var_initters(ws *walkstate, a *array[init_action]) np {
  n size = count(a);
  for i size = 0; i < n; i++ {
    if case Printed(pm) = walk_init_action(ws, ref(a, i)) {
      return Printed(pm);
    }
  }
  return NoFail;
}

func walk_var_destruction(ws *walkstate, a *var_destruction) np {
  switch a {
  case &VarSelfContainedDestruction(da destroy_action):
    return walk_destroy_action(ws, &da);
  case &VarVirtualCellDead(c cell_num):
    // TODO(): Mark cell/lifetime deceased?
    return TODO();
  }
}
