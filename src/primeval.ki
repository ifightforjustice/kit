import eval;

func st_eval_prim_fn_body(clq *clqueue, env *st_env, paramorefs *array[st_obj_ref], retvalref st_obj_ref, prent *prim_fn_body) bool {
  switch &prent->op {
  case &PrimNum(a primitive_numeric_op):
    return st_eval_prim_num(clq, env, paramorefs, retvalref, &a);
  case &PrimNumCompare(a primitive_numeric_comparison_op):
    return TODO();
  case &PrimLogical(a primitive_logical_op):
    return TODO();
  case &PrimPtrCompare(a primitive_ptr_comparison_op):
    return TODO();
  case &PrimConversion(a primitive_conversion_op):
    return TODO();
  }
}

func st_eval_prim_num(clq *clqueue, env *st_env, paramorefs *array[st_obj_ref], retvalref st_obj_ref, op *primitive_numeric_op) bool {
  ps array[bigint];
  if !st_nums(env, paramorefs, op, &ps) {
    return false;
  }
  if retvalref.count != op->op_size {
    ice(_u8("st_eval_prim_num bad retvalref size"));
  }

  switch op->op_action {
  case NumAdd(void):
    return st_num_rangechecked_output(clq, env, retvalref, get(&ps, 0) + get(&ps, 1), op);
  default:
    return TODO();
  }
}

func st_num_rangechecked_output(clq *clqueue, env *st_env, retvalref st_obj_ref, num bigint, op *primitive_numeric_op) bool {
  if num < op->op_numtraits.minval || num > op->op_numtraits.maxval {
    if op->op_numtraits.trap_overflow {
      ERR(_u8("Result out of range."));
      return false;
    }
    // Make sure we know to handle some weird reprs later when we have them.
    switch op->op_numtraits.repr {
    case Unsigned(void):
      // do nothing
    case SignedTwos(void):
      // do nothing
    }
    addand bigint = incr(op->op_numtraits.maxval - op->op_numtraits.minval);
    num = ((num - op->op_numtraits.minval) % addand) + op->op_numtraits.minval;
  }

  val st_value;
  if !st_bigint_to_value_twos(&env->plat, op->op_size, num, &val) {
    ice(_u8("st_num_rangechecked_input just rangechecked bigint, could not convert to st_value."));
  }
  obj_write(env, retvalref, &val);
  return true;
}

func st_nums(env *st_env, paramorefs *array[st_obj_ref], op *primitive_numeric_op, out *array[bigint]) bool {
  nparams size = count(paramorefs);
  if op_arity(op->op_action) != ~nparams {
    ice(_u8("st_nums numeric op bad arity"));
  }
  ret array[bigint];
  for i size = 0; i < nparams; i = i + 1 {
    oref st_obj_ref = get(paramorefs, i);
    if oref.count != op->op_size {
      ice(_u8("st_nums bad operand size"));
    }
    val st_value;
    if !obj_read(env, oref, &val) {
      return false;
    }

    num bigint;
    switch op->op_numtraits.repr {
    case Unsigned(void):
      if !st_value_unsigned_as_bigint(&env->plat, &val, &num) {
        return false;
      }
    case SignedTwos(void):
      if !st_value_signed_twos_as_bigint(&env->plat, &val, &num) {
        return false;
      }
    }
    push(&ret, num);
  }
  *out = ret;
  return true;
}
