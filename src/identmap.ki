import hash;
import string;
import stdlib;

deftype ident_value size;

def `~` fn[size, ident_value] = wrapconvert;

func `==`(x ident_value, y ident_value) bool {
  return x.~ == y.~;
}
func `!=`(x ident_value, y ident_value) bool {
  return x.~ != y.~;
}

func hash_compute_hash(x *ident_value) osize {
  return ~x->~;
}

func hash_equal(x *ident_value, y *ident_value) bool {
  return *x == *y;
}

defclass[T] copy symmap struct {
  // A map from T's to ident values.
  table hash[T, ident_value];
  // A map from ident values to T's.
  backmap array[T];
};

access symmap[_] {
  func[T] do_init(im *symmap[T]) void {
    init(&im->table);
    init(&im->backmap);
  }

  func[T] intern(im *symmap[T], s T) ident_value {
    val size = count(&im->backmap);
    if try_insert(&im->table, s, ~val) {
      push(&im->backmap, s);
      return ~val;
    } else {
      switch lookup(&im->table, s) {
        case Has(value): {
          return value;
        }
      }
    }
  }

  func[T] is_interned(im *symmap[T], s T) opt[ident_value] {
    return lookup(&im->table, s);
  }

  func[T] lookup(im *symmap[T], ident ident_value) T {
    return get(&im->backmap, ident.~);
  }
}

deftype identmap symmap[string];

func intern(im *identmap, s string) ident_value {
  return intern(&im->~, s);
}

func is_interned(im *identmap, s string) opt[ident_value] {
  return is_interned(&im->~, s);
}

func lookup(im *identmap, ident ident_value) string {
  return lookup(&im->~, ident);
}
