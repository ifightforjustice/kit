import check;

deftype frame_graph struct {
  cells array[cell_info];
  ops array[gr_node];
};

deftype gr_num size;

func add_node(gr *frame_graph, node gr_node) gr_num {
  ret gr_num;
  ret.~ = count(&gr->ops);
  push(&gr->ops, node);
  return ret;
}

// To "evaluate" an op, first we evaluate its precs (in unspecified order), then we ealuate the op.
deftype gr_node struct {
  precs array[gr_num];
  op gr_op;
};

func node(precs array[gr_num], op gr_op) gr_node {
  return {precs, op};
}

defenum gr_op {
  GrApply gr_apply;
  GrMemCopy gr_memcopy;
  GrWriteConst gr_writeconst;
  GrAddressof gr_addressof;
  GrDeref gr_deref;
  GrStrinit gr_strinit;
  GrBranch gr_branch;
  GrSequence gr_sequence;
  GrDead gr_dead;
  GrNop void;
};

deftype gr_apply struct {
  funcell cell_num;
  params array[cell_num];
  retcell cell_num;
};

deftype gr_memcopy struct {
  dest cell_num;
  src cell_num;
};

deftype gr_addressof struct {
  dest cell_num;
  addressee cell_num;
};

deftype gr_deref struct {
  name cell_num;
  pointer cell_num;
  offset gr_offset;
};

defenum gr_offset {
  OffsetConst u32;
  OffsetComputed tup[u32, cell_num];
};

deftype gr_writeconst struct {
  dest cell_num;
  value gr_const;
};

deftype gr_strinit struct {
  dest cell_num;
  parts array[tup[u32, cell_num]];
};

deftype gr_branch struct {
  src cell_num;
  cases array[tup[gr_const, gr_num]];
  default_case opt[gr_num];
};

deftype gr_sequence struct {
  first gr_num;
  second gr_num;
};

deftype gr_dead struct {
  cell cell_num;
};

defenum gr_const {
  ConstInt bigint;
  ConstDef instpair;
  ConstBytes array[u8];
};

func gr_expr_consume(cs *checkstate, gr *frame_graph, x *ast_expr_consume, out *gr_num) bool {
  expr_gn gr_num;
  if !gr_expr(cs, gr, &x->expr, &expr_gn) {
    return false;
  }
  if case &Has(aft ast_expr_after) = &x->after {
    after_gn gr_num;
    if !gr_after_actions(cs, gr, expr_gn, &aft.actions, &after_gn) {
      return false;
    }
    *out = after_gn;
    return true;
  } else {
    ice(_u8("gr_expr_consume missing after"));
    return fake();
  }
}

func gr_expr(cs *checkstate, gr *frame_graph, x *ast_expr, out *gr_num) bool {
  switch &x->u {
    case &NameExpr(a ast_name_expr): {
      return gr_name_expr(cs, gr, x, &a, out);
    }
    case &ParenExpr(a ast_paren_expr): {
      return gr_expr(cs, gr, oo(&a.expr), out);
    }
    case &NumericLiteral(a ast_numeric_literal): {
      return gr_literal(cs, gr, x, numeric_literal_value(&a), out);
    }
    case &BoolLiteral(a ast_bool_literal): {
      value bigint;
      if a.value {
        value = ~ @[u32] 1;
      } else {
        value = ~ @[u32] 0;
      }
      return gr_literal(cs, gr, x, value, out);
    }
    case &VoidLiteral(a ast_void_literal): {
      value bigint = ~ @[u32] 0;
      return gr_literal(cs, gr, x, value, out);
    }
    case &NullLiteral(a ast_null_literal): {
      value bigint = ~ @[u32] 0;
      return gr_literal(cs, gr, x, value, out);
    }
    case &CharLiteral(a ast_char_literal): {
      value bigint = ~ a.charspec.value;
      return gr_literal(cs, gr, x, value, out);
    }

    case &StringLiteral(a ast_string_literal): {
      return gr_string_literal(cs, gr, x, &a, out);
    }
    case &Funcall(a ast_funcall): {
      return gr_funcall(cs, gr, x, &a, out);
    }
    case &Assignment(a ast_assignment): {
      return gr_assignment(cs, gr, x, &a, out);
    }
    case &AddressOf(a ast_addressof): {
      return gr_mk_addressof(cs, gr, x, &a, out);
    }
    case &Deref(a ast_deref): {
      return gr_mk_deref(cs, gr, x, &a, out);
    }

    default: {
      return TODO();
    }
  }
}

func gr_mk_deref(cs *checkstate, gr *frame_graph, x *ast_expr, a *ast_deref, out *gr_num) bool {
  rp gr_num;
  if !gr_expr_consume(cs, gr, oo(&a->rhs), &rp) {
    return false;
  }
  var dp = add_node(gr, node(mk_array(rp), GrDeref({rval_cell(x), result_cell(oo(&a->rhs)), OffsetConst(0)})));
  *out = dp;
  return true;
}

func gr_mk_addressof(cs *checkstate, gr *frame_graph, x *ast_expr, a *ast_addressof, out *gr_num) bool {
  rp gr_num;
  if !gr_expr(cs, gr, oo(&a->rhs), &rp) {
    return false;
  }
  ap gr_num = add_node(gr, node(mk_array(rp), GrAddressof({rval_cell(x), ellval_cell(oo(&a->rhs))})));
  *out = ap;
  return true;
}

func gr_assignment(cs *checkstate, gr *frame_graph, x *ast_expr, a *ast_assignment, out *gr_num) bool {
  lp gr_num;
  if !gr_expr(cs, gr, oo(&a->lhs), &lp) {
    return false;
  }
  rp gr_num;
  if !gr_expr(cs, gr, oo(&a->rhs), &rp) {
    return false;
  }
  switch assignment_info(a) {
    case &StaticSelfAssignment(v void): {
      var nop = add_node(gr, node(mk_array(lp, rp), GrNop(void)));
      *out = nop;
      return true;
    }
    case &ConditionalAssignment(ci ast_conditional_assignment_info): {
      var fc = add_node(gr, node(mk_array(), GrWriteConst({ci.comparecells.funcell, ConstDef(ci.comparecells.ip)})));
      var dp = add_node(gr, node(mk_array(), GrAddressof({ci.comparecells.destptr, value_cell(oo(&a->lhs))})));
      var sp = add_node(gr, node(mk_array(), GrAddressof({ci.comparecells.srcptr, value_cell(oo(&a->rhs))})));
      var ap = add_node(gr, node(mk_array(fc, dp, sp), GrApply({ci.comparecells.funcell, mk_array(ci.comparecells.destptr, ci.comparecells.srcptr), ci.comparecells.cmp_result})));

      var nop = add_node(gr, node(mk_array(), GrNop(void)));
      var assignnop = add_node(gr, node(mk_array(), GrNop(void)));
      assign gr_num;
      if !gr_after_actions(cs, gr, assignnop, &ci.conditional_actions, &assign) {
        return false;
      }
      cases array[tup[gr_const, gr_num]] = mk_array(cons(ConstInt(~ @[u32] 0), assign), cons(ConstInt(~ @[u32] 1), nop));

      var br = add_node(gr, node(mk_array(ap), GrBranch({ci.comparecells.cmp_result, cases, None()})));
      unc gr_num;
      if !gr_after_actions(cs, gr, br, &ci.unconditional_actions, &unc) {
        return false;
      }
      *out = unc;
      return true;
    }
  }
}

func gr_funcall(cs *checkstate, gr *frame_graph, x *ast_expr, a *ast_funcall, out *gr_num) bool {
  precs array[gr_num];
  dep gr_num;
  if !gr_expr_consume(cs, gr, oo(&a->fun), &dep) {
    return false;
  }
  push(&precs, dep);
  paramcells array[cell_num];
  nparams size = count(&a->params);
  for i size = 0; i < nparams; i = i + 1 {
    param *ast_expr_consume = ref(&a->params, i);
    if !gr_expr_consume(cs, gr, param, &dep) {
      return false;
    }
    push(&precs, dep);
    push(&paramcells, result_cell(param));
  }
  var ap = add_node(gr, node(precs, GrApply({result_cell(oo(&a->fun)), paramcells, rval_cell(x)})));
  *out = ap;
  return true;
}

func gr_string_literal(cs *checkstate, gr *frame_graph, x *ast_expr, a *ast_string_literal, out *gr_num) bool {
  bytes array[u8];
  nchars size = count(&a->charspecs);
  for i size = 0; i < nchars; i = i + 1 {
    ch i32 = get(&a->charspecs, i).value;
    if ch < 0 || ch > 255 {
      ice(_u8("gr_string_literal char values out of range"));
    }
    push(&bytes, ~ch);
  }
  var gn = add_node(gr, node(mk_array(), GrWriteConst({rval_cell(x), ConstBytes(bytes)})));
  *out = gn;
  return true;
}

func gr_literal(cs *checkstate, gr *frame_graph, x *ast_expr, value bigint, out *gr_num) bool {
  var gn = add_node(gr, node(mk_array(), GrWriteConst({rval_cell(x), ConstInt(value)})));
  *out = gn;
  return true;
}

func gr_name_expr(cs *checkstate, gr *frame_graph, x *ast_expr, a *ast_name_expr, out *gr_num) bool {
  switch name_info(a) {
    case &LocalResolve(li local_info): {
      *out = add_node(gr, node(mk_array(), GrNop(void)));
      return true;
    }
    case &GlobalResolve(gi global_info): {
      *out = add_node(gr, node(mk_array(), GrWriteConst({rval_cell(x), ConstDef({gi.ent, gi.inst})})));
      return true;
    }
    case &EnumConstructor(v void): {
      return TODO();
    }
  }
}

func ellval_cell(x *is_lval) cell_num {
  switch x {
    case &IsLvalYes(desc lval_description): { return desc.num; }
    case &IsLvalNo(desc rval_description): {
      ice(_u8("lvalue_value_cell expects lvalue"));
      return fake();
    }
  }
}

func ellval_cell(a *ast_expr) cell_num {
  return ellval_cell(&expr_complete_info(a)->lval);
}

func rval_cell(x *ast_expr) cell_num {
  return rval_cell(&expr_complete_info(x)->lval);
}

func rval_cell(x *is_lval) cell_num {
  switch x {
    case &IsLvalNo(desc rval_description): {
      return desc.whole_num;
    }
    case &IsLvalYes(desc lval_description): {
      ice(_u8("rval_cell sees lvalue"));
      return fake();
    }
  }
}

func gr_after_actions(cs *checkstate, gr *frame_graph, prec gr_num, x *array[after_action], out *gr_num) bool {
  nacts size = count(x);
  for i size = 0; i < nacts; i = i + 1 {
    dep gr_num;
    if !gr_after_action(cs, gr, ref(x, i), &dep) {
      return false;
    }
    prec = add_node(gr, node(mk_array(), GrSequence({prec, dep})));
  }
  *out = prec;
  return true;
}

func gr_after_action(cs *checkstate, gr *frame_graph, x *after_action, out *gr_num) bool {
  switch x {
    case &CopyAfter(ca copy_action): {
      return gr_bi_action(cs, gr, &ca.~, out);
    }
    case &MoveAfter(ma move_action): {
      dep gr_num;
      if !gr_bi_action(cs, gr, &ma.~, &dep) {
        return false;
      }
      *out = add_node(gr, node(mk_array(dep), GrDead({ma.src})));
      return true;
    }
    case &DestroyAfter(da destroy_action): {
      switch &da.ctor {
        case &UniTrivialCtor(v void): {
          var dp = add_node(gr, node(mk_array(), GrDead({da.arg})));
          *out = dp;
          return true;
        }
        case &UniFunCtor(desc uni_fun_ctor_desc): {
          var fc = add_node(gr, node(mk_array(), GrWriteConst({desc.funcell, ConstDef(desc.ip)})));
          var arp = add_node(gr, node(mk_array(), GrAddressof({desc.argptr, da.arg})));
          var ap = add_node(gr, node(mk_array(fc, arp), GrApply({desc.funcell, mk_array(desc.argptr), desc.retvoid})));
          var deadret = add_node(gr, node(mk_array(ap), GrDead({desc.retvoid})));
          var dp = add_node(gr, node(mk_array(deadret), GrDead({da.arg})));
          *out = dp;
          return true;
        }
      }
    }
  }
}

func gr_bi_action(cs *checkstate, gr *frame_graph, x *bi_action, out *gr_num) bool {
  switch &x->ctor {
    case &BiTrivialCtor(v void): {
      var cp = add_node(gr, node(mk_array(), GrMemCopy({x->dest, x->src})));
      *out = cp;
      return true;
    }
    case &BiFunCtor(desc bi_fun_ctor_desc): {
      var fc = add_node(gr, node(mk_array(), GrWriteConst({desc.funcell, ConstDef(desc.ip)})));
      var dp = add_node(gr, node(mk_array(), GrAddressof({desc.destptr, x->dest})));
      var sp = add_node(gr, node(mk_array(), GrAddressof({desc.srcptr, x->src})));
      var ap = add_node(gr, node(mk_array(fc, dp, sp), GrApply({desc.funcell, mk_array(desc.destptr, desc.srcptr), desc.retvoid})));
      var deadret = add_node(gr, node(mk_array(ap), GrDead({desc.retvoid})));
      *out = deadret;
      return true;
    }
  }
}
