import ast;
import identmap;
import pos;

deftype ps struct {
  data *u8;
  length size;
  pos size;

  im *identmap;

  stack array[ptree];
};

func make_ps(im *identmap, data *u8, length size) ps {
  p ps;
  p.data = data;
  p.length = length;
  p.pos = 0;
  p.im = im;
  return p;
}

func ps_pos(p *ps) pos {
  ret pos;
  ret.~ = p->pos;
  return ret;
}

func ps_restore_pos(p *ps, pos pos) void {
  p->pos = pos.~;
}

func ps_peek(p *ps) i32 {
  check(p->pos <= p->length);
  if p->pos == p->length {
    return -1;
  }
  return ~p->data[p->pos];
}

func ps_step(p *ps) void {
  check(p->pos < p->length);
  p->pos = p->pos + 1;
}



defenum keyw {
  Case void;
  Def void;
  Defclass void;
  Defenum void;
  Deftype void;
  Else void;
  False void;
  For void;
  Func void;
  If void;
  Null void;
  Return void;
  Struct void;
  Switch void;
  True void;
  Underscore void;
  Union void;
  Var void;
  While void;
};

defenum numlit {
  DecNum array[i8];
  HexNum array[i8];
};

defenum grouper {
  LParen void;
  RParen void;
  LBracket void;
  RBracket void;
  LBrace void;
  RBrace void;
};

defenum tokval {
  Keyw keyw;
  Num numlit;
  Oper array[i32];
  Ident array[i32];
  Grouper grouper;
};

deftype tok struct {
  interval interval;
  val tokval;
};

func mk_tok(left pos, right pos, val tokval) tok {
  ret tok;
  ret.val = val;
  ret.interval = mk_interval(left, right);
  return ret;
}

defenum treesym {
  Token tok;
};

deftype ptree struct {
  sym treesym;
  childs array[uniq[ptree]];
};

defenum grab_tok_res {
  BadToken interval;
  EofToken void;
  TokToken tok;
};

func is_lower(x i32) bool {
  // TODO: Statically assert 'z' - 'a' == 25.
  return x >= 'a' && x <= 'z';
}

func is_upper(x i32) bool {
  // TODO: Statically assert 'Z' - 'A' == 25.
  return x >= 'A' && x <= 'Z';
}

func is_alpha(x i32) bool {
  return is_lower(x) || is_upper(x);
}

func is_digit(x i32) bool {
  // TODO: Statically assert '9' - '0' == 9.
  return x >= '0' && x <= '9';
}

func is_alnum(x i32) bool {
  return is_alpha(x) || is_digit(x);
}

func is_hexdigit(x i32, val_out *i8) bool {
  // TODO: Statically assert 'f' - 'a', 'F' - 'A', '9' - '0'.
  if is_digit(x) {
    *val_out = ~(x - '0');
    return true;
  }
  if 'A' <= x && x <= 'F' {
    *val_out = ~(x - 'A');
    return true;
  }
  if 'a' <= x && x <= 'f' {
    *val_out = ~(x - 'a');
    return true;
  }
  return false;
}

func is_numeric_postchar(x i32) bool {
  // TODO: Implement for real.
  return !is_alnum(x);
}

func is_ident_firstchar(x i32) bool {
  return is_alpha(x) || x == '_';
}

func is_ident_midchar(x i32) bool {
  return is_ident_firstchar(x) || is_digit(x);
}

func is_ident_postchar(x i32) bool {
  // TODO: Implement for real.
  return !is_ident_midchar(x);
}

func grab_tok(p *ps) grab_tok_res {
  left pos = ps_pos(p);
  ch i32 = ps_peek(p);
  if ch == @[i32]-1 {
    return EofToken(void);
  }
  if ch == '0' {
    ps_step(p);
    ch = ps_peek(p);
    if ch == 'x' {
      ps_step(p);
      ch = ps_peek(p);
      digits array[i8];
      val i8;
      while is_hexdigit(ch, &val) {
        append(&digits, val);
        ps_step(p);
        ch = ps_peek(p);
      }

      if is_numeric_postchar(ch) {
        return mk_res(p, left, Num(HexNum(digits)));
      } else {
        return BadToken(mk_interval(left, ps_pos(p)));
      }
    } else {
      if is_numeric_postchar(ch) {
        digits array[i8];
        append(&digits, 0);
        return mk_res(p, left, Num(DecNum(digits)));
      } else {
        return BadToken(mk_interval(left, ps_pos(p)));
      }
    }
  } else if is_digit(ch) {
    digits array[i8];
    append(&digits, @[i8]~(ch - '0'));
    ps_step(p);
    ch = ps_peek(p);
    while is_digit(ch) {
      append(&digits, @[i8]~(ch - '0'));
      ps_step(p);
      ch = ps_peek(p);
    }
    if is_numeric_postchar(ch) {
      return mk_res(p, left, Num(DecNum(digits)));
    } else {
      return BadToken(mk_interval(left, ps_pos(p)));
    }
  } else if is_ident_firstchar(ch) {
    ret tok;
    if (grab_keyword(p, "case", Case(void), &ret)
        || grab_keyword(p, "def", Def(void), &ret)
        || grab_keyword(p, "defclass", Defclass(void), &ret)
        || grab_keyword(p, "defenum", Defenum(void), &ret)
        || grab_keyword(p, "deftype", Deftype(void), &ret)
        || grab_keyword(p, "else", Else(void), &ret)
        || grab_keyword(p, "false", False(void), &ret)
        || grab_keyword(p, "for", For(void), &ret)
        || grab_keyword(p, "func", Func(void), &ret)
        || grab_keyword(p, "if", If(void), &ret)
        || grab_keyword(p, "null", Null(void), &ret)
        || grab_keyword(p, "return", Return(void), &ret)
        || grab_keyword(p, "struct", Struct(void), &ret)
        || grab_keyword(p, "switch", Switch(void), &ret)
        || grab_keyword(p, "true", True(void), &ret)
        || grab_keyword(p, "_", Underscore(void), &ret)
        || grab_keyword(p, "union", Union(void), &ret)
        || grab_keyword(p, "var", Var(void), &ret)
        || grab_keyword(p, "while", While(void), &ret)) {
      return TokToken(ret);
    }

    arr array[i32];
    append(&arr, ch);
    ps_step(p);
    ch = ps_peek(p);
    while is_ident_midchar(ch) {
      append(&arr, ch);
      ps_step(p);
      ch = ps_peek(p);
    }
    if !is_ident_postchar(ch) {
      return BadToken(mk_interval(left, ps_pos(p)));
    }
    return mk_res(p, left, Ident(arr));
  } else if ch == '(' {
    ps_step(p);
    return mk_res(p, left, Grouper(LParen(void)));
  } else if ch == ')' {
    ps_step(p);
    return mk_res(p, left, Grouper(RParen(void)));
  } else if ch == '[' {
    ps_step(p);
    return mk_res(p, left, Grouper(LBracket(void)));
  } else if ch == ']' {
    ps_step(p);
    return mk_res(p, left, Grouper(RBracket(void)));
  } else if ch == '{' {
    ps_step(p);
    return mk_res(p, left, Grouper(LBrace(void)));
  } else if ch == '}' {
    ps_step(p);
    return mk_res(p, left, Grouper(RBrace(void)));
  } else if ch == '~' {
    ps_step(p);
    return mk_res(p, left, Oper(mk_array(ch)));
  } else if ch == '!' {
    return grab_oper2(p, left, ch, '=');
  } else if ch == '%' {
    return grab_oper2(p, left, ch, '=');
  } else if ch == '^' {
    return grab_oper2(p, left, ch, '=');
  } else if ch == '&' {
    return grab_oper2(p, left, ch, '=', '&');
  } else if ch == '*' {
    return grab_oper2(p, left, ch, '=');
  } else if ch == '-' {
    return grab_oper2(p, left, ch, '=', '-', '>');
  } else if ch == '=' {
    return grab_oper2(p, left, ch, '=');
  } else if ch == '+' {
    return grab_oper2(p, left, ch, '=', '+');
  } else if ch == '|' {
    return grab_oper2(p, left, ch, '=', '|');
  } else if ch == ':' {
    ps_step(p);
    return mk_res(p, left, Oper(mk_array(ch)));
  } else if ch == ';' {
    ps_step(p);
    return mk_res(p, left, Oper(mk_array(ch)));
  } else if ch == ',' {
    ps_step(p);
    return mk_res(p, left, Oper(mk_array(ch)));
  } else if ch == '<' {
    return grab_angly(p, left, ch);
  } else if ch == '.' {
    ps_step(p);
    return mk_res(p, left, Oper(mk_array(ch)));
  } else if ch == '>' {
    return grab_angly(p, left, ch);
  } else if ch == '/' {
    return grab_oper2(p, left, ch, '=');
  } else {
    return BadToken(mk_interval(left, ps_pos(p)));
  }
}

func grab_angly(p *ps, left pos, ch i32) grab_tok_res {
  arr array[i32] = mk_array(ch);
  ps_step(p);
  dh i32 = ps_peek(p);
  if dh == ch {
    append(&arr, dh);
    ps_step(p);
    dh = ps_peek(p);
  }
  if dh == '=' {
    append(&arr, dh);
    ps_step(p);
  }
  return mk_res(p, left, Oper(arr));
}

func grab_oper2(p *ps, left pos, ch i32, n0 i32) grab_tok_res {
  return grab_oper2(p, left, ch, n0, n0, n0);
}

func grab_oper2(p *ps, left pos, ch i32, n0 i32, n1 i32) grab_tok_res {
  return grab_oper2(p, left, ch, n0, n1, n1);
}

func grab_oper2(p *ps, left pos, ch i32, n0 i32, n1 i32, n2 i32) grab_tok_res {
  arr array[i32] = mk_array(ch);
  ps_step(p);
  ch = ps_peek(p);
  if ch == n0 || ch == n1 || ch == n2 {
    append(&arr, ch);
    ps_step(p);
  }
  return mk_res(p, left, Oper(arr));
}

func mk_res(p *ps, left pos, v tokval) grab_tok_res {
  return TokToken(mk_tok(left, ps_pos(p), v));
}

func[T] mk_array(x0 T) array[T] {
  ret array[T];
  append(&ret, x0);
  return ret;
}

func[String] grab_keyword(p *ps, s String, k keyw, out *tok) bool {
  left pos = ps_pos(p);
  for i size = 0; i < s.length; i = i + 1 {
    si u8 = s[i];
    if ps_peek(p) != ~si {
      ps_restore_pos(p, left);
      return false;
    }
    ps_step(p);
  }

  if !is_ident_postchar(ps_peek(p)) {
    return false;
  }

  *out = mk_tok(left, ps_pos(p), Keyw(k));
  return true;
}
