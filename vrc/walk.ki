import ast;
import expr;
import transtrack;

// We have a set of lifetimes that pop in and out of existence over time.  They all have interesting state that needs to be tracked.  We want to chase state through everything.

// How should we represent state?  We've got facts.  A big bag of facts.  Okay then.  I hope they aren't self-contradictory!

/* A general description of walking:

We have an AST we need to "walk" over, calculating a "walkdesc," which contains facts about stuff, as we execute the function, at the current point in time, i.e. the current point in the AST.  The computed walkdesc becomes a function of your location within the AST.

We do this by propogating the walkdesc *forward* through the AST, along lines of control flow.  Whenever we branch, we have to note down what the walkdesc is, go down the other branch, and then continue back from the marking later.  When we revisit a previously traversed marking, we need to update it with new information, and then consider whether we need to retraverse forward from that marking.

We update markings with new information by _combining_ the information with the old information.

We could maintain a list of points in the AST and their associated markings, that we need to walk forward from.  Instead, we mark the AST itself, and we traverse the AST in the following order:  We walk from top to bottom, occasionally retraversing certain sub-trees repeatedly.  We call a retraversal "cycling back," where we look for markings that we need to walk forward from.  If we see one, we exit "cycling back" mode, and walk forward from it, tracing its state.  We also need to make markings for the end of any sub-AST that we could cycle back over, so that when we continue forward, we have a state to continue forward from.

That means we don't chase through gotos (even though it's not a branch).  We mark the label, and hit it when cycling back (or in non-cycling mode) later.

*/

defclass walk_hold {
  wm *ast_walk_marking;
};

access walk_hold {
  func do_init(wh *walk_hold) void {
    init(&wh->wm);
  }
  func do_destroy(wh *walk_hold) void {
    wm *_ = wh->wm;
    if wm != null {
      wm->cycle_back = false;
      check(wm->walking);
      wm->walking = false;
    }
  }

  func wh_init(wh *walk_hold, wm *ast_walk_marking) void {
    check(wh->wm == null);
    check(!wm->walking);
    wm->walking = true;
    wh->wm = wm;
  }
}

// TODO(): Have some counter for 'number of dirty markings made' and 'number of dirty markings walked from', have an assertion that these numbers match.
// There's just one of these (for any given walk).
struct walkstate {
  bs *bodystate;
  es *framescope;
  ds *defscope;
  clq *clqueue;
  cs *checkstate;
  im *identmap;

  // NOTE(): This can be null.  This is gross.  (It can't yet be null because we haven't hooked up walking of top-level defs.)
  fb *ast_fullbody_info;

  current_desc walkdesc;
  // True if we shouldn't be maintaining state -- we're cycling back.
  // NOTE(): We could/should replace current_desc/cyclic with an opt[walkdesc].
  cycling bool;
};

func mk_from_bs(bs *bodystate, fb *ast_fullbody) walkstate {
  ret walkstate = {bs, &bs->es, bs->ds, bs->clq, bs->cs, bs->im, un(&fb->info), {mk_array()}, false};
  return ret;
}

func tie_return_state(ws *walkstate) np {
  check(!ws->cycling);
  // NOTE(): Implement in terms of tie_walkstate?  Use an ast_walkstate_recording?
  if case &Has(d walkdesc) = &ws->fb->post_return_unified_desc {
    changed_discard bool;
    if case Printed(pm) = unify_walkdesc(&d, &ws->current_desc, &changed_discard) {
      return Printed(pm);
    }
  } else {
    ws->fb->post_return_unified_desc = Has(ws->current_desc);
  }
  return NoFail;
}

struct walk_descnote {
  // None if we were cycling when we noted the desc.
  saved_desc opt[walkdesc];
};

func note_desc(ws *walkstate) walk_descnote {
  if ws->cycling {
    return {None};
  } else {
    return {Has(ws->current_desc)};
  }
}

// This is supposed to be symmetric w.r.t ws->current_desc's state and descnote's state.
func join_descnote(ws *walkstate, descnote *walk_descnote) np {
  if ws->cycling {
    if case &Has(d) = &descnote->saved_desc {
      ws->current_desc = d;
      ws->cycling = false;
      return NoFail;
    } else {
      // Cycling the whole way, except maybe for some label/goto interlude.  Keep cycling.
      return NoFail;
    }
  } else {
    if case &Has(d) = &descnote->saved_desc {
      // NOTE(): Probably we'll have to output changedness information and use it, for loops and such.
      changed bool;
      if case Printed(pm) = unify_walkdesc(&ws->current_desc, &d, &changed) {
        return Printed(pm);
      }
      return NoFail;
    } else {
      // Retain non-cycling state.
      return NoFail;
    }
  }
}

func mark_cycleback(ws *walkstate, num ast_walk_marking_number) void {
  ix size = num.x;
  // 0 means there's no parent.
  while ix != 0 {
    cur *ast_walk_marking = get(&ws->es->walk_markings, ix);
    cur->cycle_back = true;
    if cur->walking {
      ix = 0;
    } else {
      ix = un(&cur->conn)->parent.x;
    }
  }
}

func tie_walkstate(ws *walkstate, wrec *ast_walkstate_recording) np {
  check(!ws->cycling);
  if case &Has(d walkdesc) = &wrec->unified_desc {
    changed bool;
    if case Printed(pm) = unify_walkdesc(&d, &ws->current_desc, &changed) {
      return Printed(pm);
    }
    if changed {
      mark_cycleback(ws, wrec->parent);
    }
  } else {
    wrec->unified_desc = Has(ws->current_desc);
  }
  return NoFail;
}

// computed_params is the fn[...] params (including return type and transdesc)
func walk_lambda_state(bs *bodystate, computed_params *shray[te_typeexpr], a *ast_lambda) np {
  ws walkstate = mk_from_bs(bs, &a->body);

  nargs size = count(&a->args);
  for i size = 0; i < nargs; i++ {
    vn var_number = *un(&ref(&a->args, i)->vn);
    vi *var_info = ref_var(&bs->es, vn);
    // Okay, and?
  }

  if case Printed(pm) = walk_bracebody(&ws, &a->body.bb) {
    return Printed(pm);
  }

  // NOTE: Hm.  The cycling check seems like it would be usable for dead code / no-return logic.
  if !ws.cycling {
    // Return statements' destructions cover these func params too -- they connect to the end of these destructions.
    if case Printed(pm) = walk_var_destructions(&ws, &un(&a->body.info)->parameter_destructions) {
      return Printed(pm);
    }

    if case Printed(pm) = tie_return_state(&ws) {
      return Printed(pm);
    }
  }

  return NoFail;
}

func walk_bracebody(ws *walkstate, a *ast_bracebody) np {
  wh walk_hold;
  wh_init(&wh, &a->walk_marking);

  again bool = true;
  while again {
    a->walk_marking.cycle_back = false;

    nstatements size = count(&a->statements);
    for i size = 0; i < nstatements; i++ {
      s *ast_statement = ref(&a->statements, i);
      if case Printed(pm) = walk_statement(ws, s) {
        return Printed(pm);
      }
    }
    if case Printed(pm) = walk_var_destructions(ws, &un(&a->info)->destructions) {
      return Printed(pm);
    }

    again = cycle_again(ws, &a->walk_marking);
  }

  return NoFail;
}

func walk_statement(ws *walkstate, a *ast_statement) np {
  switch &a->u {
  case &Expr(b ast_expr_discard):
    if case Printed(pm) = walk_discard_expr(ws, &b) {
      return Printed(pm);
    }

  case &Return(b ast_return_statement):
    if case Printed(pm) = walk_return_statement(ws, &b) {
      return Printed(pm);
    }

  case &Var(b ast_var_statement):
    if case Printed(pm) = walk_var_statement(ws, &b) {
      return Printed(pm);
    }

  case &IfThen(b ast_ifthen_statement):
    if case Printed(pm) = walk_ifthen_statement(ws, &b) {
      return Printed(pm);
    }

  case &IfThenElse(b ast_ifthenelse_statement):
    if case Printed(pm) = walk_ifthenelse_statement(ws, &b) {
      return Printed(pm);
    }

  case &While(b ast_while_statement):
    if case Printed(pm) = walk_while_statement(ws, &b) {
      return Printed(pm);
    }

  case &For(b ast_for_statement):
    if case Printed(pm) = walk_for_statement(ws, &b) {
      return Printed(pm);
    }

  case &Switch(b ast_switch_statement):
    if case Printed(pm) = walk_switch_statement(ws, &b) {
      return Printed(pm);
    }

  case &Break(b ast_break_statement):
    if case Printed(pm) = walk_break_statement(ws, &b) {
      return Printed(pm);
    }

  case &Continue(b ast_continue_statement):
    if case Printed(pm) = walk_continue_statement(ws, &b) {
      return Printed(pm);
    }

  case &Label(b ast_label_statement):
    if case Printed(pm) = walk_label_statement(ws, &b) {
      return Printed(pm);
    }

  case &Goto(b ast_goto_statement):
    if case Printed(pm) = walk_goto_statement(ws, &b) {
      return Printed(pm);
    }
  }

  return NoFail;
}

func walk_goto_statement(ws *walkstate, a *ast_goto_statement) np {
  // There isn't exactly an "expr" to cycle into -- but maybe the destructor/constructor function calls could at some point count.
  if ws->cycling && NO_CYCLE_EXPRS {
    return NoFail;
  }

  info *ast_goto_statement_info = un(&a->info);
  if case Printed(pm) = walk_var_destructions(ws, &info->destructions) {
    return Printed(pm);
  }
  if case Printed(pm) = walk_var_initters(ws, &info->initializations) {
    return Printed(pm);
  }

  wrec *ast_walkstate_recording = &un(&ref(&ws->fb->labels, info->label_number.x)->st->info)->wrec;
  if case Printed(pm) = tie_walkstate(ws, wrec) {
    return Printed(pm);
  }

  // NOTE(): We should think about how we do our variable unwindings (and in particular, windings).  We could overlap with other variable unwindings/windings, heading towards the same label.  Should we overlap the typestate, too?  For now, the answer is, nah.

  // Just like with return statements, we enter cycling-state.
  ws->cycling = true;

  return NoFail;
}

func walk_pattern_assign(ws *walkstate, a *ast_pattern_assign) np {
  if case Printed(pm) = walk_expr_consume(ws, oo(&a->rhs)) {
    return Printed(pm);
  }
  // TODO(): That's it?  Do some tag cell / enum cell / deref cell logic?
  return NoFail;
}

func walk_condition(ws *walkstate, a *ast_condition) np {
  switch a {
  case &ExprCondition(b box[ast_expr_consume]):
    return walk_expr_consume(ws, oo(&b));
  case &PatternCondition(b ast_pattern_assign):
    return walk_pattern_assign(ws, &b);
  }
}

func walk_condition_discard(ws *walkstate, a *ast_condition_discard_info) np {
  if case &Has(c cell_num) = un(&a->virtual_cell_dead) {
    // TODO(): What is this, and how the heck do we handle this?
  }
  if case Printed(pm) = walk_later_discard_info(ws, &a->later) {
    return Printed(pm);
  }
  return NoFail;
}

func walk_ifthen_statement(ws *walkstate, a *ast_ifthen_statement) np {
  // TODO(): Connect condition discard, and body, correctly.
  if case Printed(pm) = walk_condition(ws, &a->condition) {
    return Printed(pm);
  }
  descnote var = note_desc(ws);
  if case Printed(pm) = walk_bracebody(ws, &a->body) {
    return Printed(pm);
  }
  // NOTE(): At some point we'll be chasing which-branch-was-which information.
  if case Printed(pm) = join_descnote(ws, &descnote) {
    return Printed(pm);
  }
  if case Printed(pm) = walk_condition_discard(ws, &a->condition_discard) {
    return Printed(pm);
  }
  return NoFail;
}

func walk_ifthenelse_statement(ws *walkstate, a *ast_ifthenelse_statement) np {
  // TODO(): Connect condition discard, and body, correctly.  (Discard before/after elsebody correctly.)
  // TODO(): Walk condition correctly.
  if case Printed(pm) = walk_condition(ws, &a->condition) {
    return Printed(pm);
  }
  if case Printed(pm) = walk_bracebody(ws, &a->thenbody) {
    return Printed(pm);
  }
  if case Printed(pm) = walk_bracebody(ws, &a->elsebody) {
    return Printed(pm);
  }
  if case Printed(pm) = walk_condition_discard(ws, &a->condition_discard) {
    return Printed(pm);
  }
  return NoFail;
}

// TODO(): Do cycle-forward logic -- if we aren't cycling at the end of a bracebody at any point in the cycle -- we need to continue in a non-cycling state.
func cycle_again(ws *walkstate, a *ast_walk_marking) bool {
  /* ws->cycling could be in either state when we get to cycle_again.  For example, if we have { blah; return 3; } then the return statement will put us in a cycling state, no matter what. */
  if a->cycle_back {
    ws->cycling = true;
    return true;
  } else {
    return false;
  }
}

func walk_while_statement(ws *walkstate, a *ast_while_statement) np {
  wh walk_hold;
  wh_init(&wh, &a->walk_marking);

  again bool = true;
  while again {
    a->walk_marking.cycle_back = false;

    // TODO(): Connect the condition discards, and body, correctly.
    if case Printed(pm) = walk_condition(ws, &a->condition) {
      return Printed(pm);
    }
    if case Printed(pm) = walk_bracebody(ws, &a->body) {
      return Printed(pm);
    }
    if case Printed(pm) = walk_condition_discard(ws, &a->condition_discard_continue) {
      return Printed(pm);
    }

    again = cycle_again(ws, &a->walk_marking);
  }

  if case Printed(pm) = walk_condition_discard(ws, &a->condition_discard_exit) {
    return Printed(pm);
  }
  return NoFail;
}

func walk_for_statement(ws *walkstate, a *ast_for_statement) np {
  // TODO(): Connect the condition discard, body, etc, correctly.
  if case &Has(b box[ast_statement]) = &a->initializer {
    if case Printed(pm) = walk_statement(ws, oo(&b)) {
      return Printed(pm);
    }
  }

  // Scoped so the walk-hold applies to the cycling part of the loop.  This fact has to be kept in sync with the type-checking code in body.ki.
  if true {
    wh walk_hold;
    wh_init(&wh, &a->walk_marking);

    again bool = true;
    while again {
      a->walk_marking.cycle_back = false;

      if case &Has(b ast_expr_condition) = &a->condition {
        // TODO(): Uh.. walk b.discard more properly.
        if case Printed(pm) = walk_expr_consume(ws, oo(&b.expr)) {
          return Printed(pm);
        }
        if case Printed(pm) = walk_later_discard_info(ws, &b.discard) {
          return Printed(pm);
        }
      }
      if case &Has(b box[ast_expr_discard]) = &a->increment {
        if case Printed(pm) = walk_discard_expr(ws, oo(&b)) {
          return Printed(pm);
        }
      }

      if case Printed(pm) = walk_bracebody(ws, &a->body) {
        return Printed(pm);
      }

      again = cycle_again(ws, &a->walk_marking);
    }
  }

  // TODO(): Connect initter destructions properly.
  // TODO(): Is info set when there's no initter?
  if case Printed(pm) = walk_var_destructions(ws, &un(&a->info)->initter_destructions) {
    return Printed(pm);
  }
  return NoFail;
}

func walk_switch_statement(ws *walkstate, a *ast_switch_statement) np {
  // TODO(): Connect switch cases properly, swartch discard.
  // NOTE(): Handle default case/swartch discard properly.
  if case Printed(pm) = walk_expr_consume(ws, oo(&a->swartch)) {
    return Printed(pm);
  }
  // TODO(): Process swartch deconstruction info / tag cell properly?
  ncases size = count(&a->cases);
  for i size = 0; i < ncases; i++ {
    cas *ast_switch_case = ref(&a->cases, i);
    // TODO(): Process case pattern... somehow.
    if case Printed(pm) = walk_bracebody(ws, &cas->body) {
      return Printed(pm);
    }
  }

  if case Printed(pm) = walk_later_discard_info(ws, &a->swartch_discard) {
    return Printed(pm);
  }

  return NoFail;
}

func walk_break_statement(ws *walkstate, a *ast_break_statement) np {
  // TODO(): Connect to the right place.  Also treat subsequent statements like after a return -- look for marked labels.
  if case Printed(pm) = walk_var_destructions(ws, &un(&a->info)->destructions) {
    return Printed(pm);
  }
  return NoFail;
}

func walk_continue_statement(ws *walkstate, a *ast_continue_statement) np {
  // TODO(): Connect to the right place.  Also treat subsequent statements like after a return -- look for marked labels.
  if case Printed(pm) = walk_var_destructions(ws, &un(&a->info)->destructions) {
    return Printed(pm);
  }
  return NoFail;
}

func walk_label_statement(ws *walkstate, a *ast_label_statement) np {
  // TODO(): Uh, check for cycling, notate the current statedesc, and other stuff?
  return NoFail;
}

func walk_discard_expr(ws *walkstate, a *ast_expr_discard) np {
  if case Printed(pm) = walk_expr(ws, &a->expr) {
    return Printed(pm);
  }
  if case Printed(pm) = walk_expr_after_discard(ws, un(&a->after)) {
    return Printed(pm);
  }
  // TODO(): Something must be done?
  return NoFail;
}

// TODO(): Remove all uses of this.
func walk_TODO() np {
  return NoFail;
}

func walk_expr(ws *walkstate, a *ast_expr) np {
  switch &a->u {
  case &NameExpr(b ast_name_expr):
    return walk_TODO();
  case &ParenExpr(b ast_paren_expr):
    return walk_expr(ws, oo(&b.expr));
  case &NumericLiteral(b ast_numeric_literal):
    return walk_TODO();
  case &BoolLiteral(b ast_bool_literal):
    return walk_TODO();
  case &VoidLiteral(b ast_void_literal):
    return walk_TODO();
  case &NullLiteral(b ast_null_literal):
    return walk_TODO();
  case &CharLiteral(b ast_char_literal):
    return walk_TODO();
  case &StringLiteral(b ast_string_literal):
    return walk_TODO();
  case &Funcall(b ast_funcall):
    nparams size = count(&b.params);
    for i size = 0; i < nparams; i++ {
      if case Printed(pm) = walk_expr_consume(ws, ref(&b.params, i)) {
        return Printed(pm);
      }
    }
    // TODO: Handle funcall state.
    return walk_TODO();
  case &LogicalConjunction(b ast_logical_conjunction):
    // TODO(): Connect premature return/postmature return.  (And isn't there a lhs discard / move op?)
    if case Printed(pm) = walk_expr_consume(ws, oo(&b.lhs)) {
      return Printed(pm);
    }
    if case Printed(pm) = walk_expr_consume(ws, oo(&b.rhs)) {
      return Printed(pm);
    }
    return walk_TODO();
  case &Assignment(b ast_assignment):
    return walk_assignment(ws, &b);
  case &RefOf(b ast_refof):
    if case Printed(pm) = walk_expr(ws, oo(&b.rhs)) {
      return Printed(pm);
    }
    // TODO: idk.
    return walk_TODO();
  case &AddressOf(b ast_addressof):
    if case Printed(pm) = walk_expr(ws, oo(&b.rhs)) {
      return Printed(pm);
    }
    // TODO: idk.
    return walk_TODO();
  case &Deref(b ast_deref):
    if case Printed(pm) = walk_expr_consume(ws, oo(&b.rhs)) {
      return Printed(pm);
    }
    if case Printed(pm) = walk_later_discard_info(ws, &b.ptr_discard) {
      return Printed(pm);
    }
    // TODO(): Process... the act of dereffing?
    return walk_TODO();
  case &IndexExpr(b ast_index_expr):
    if case Printed(pm) = walk_expr(ws, oo(&b.lhs)) {
      return Printed(pm);
    }
    info *ast_index_expr_info = un(&b.info);
    if case &Has(p tup[ast_expr_after_consume, ast_later_discard_info]) = &info->lhs_after {
      if case Printed(pm) = walk_expr_after_consume(ws, &p.car) {
        return Printed(pm);
      }
    }

    if case Printed(pm) = walk_expr_consume(ws, oo(&b.rhs)) {
      return Printed(pm);
    }

    // TODO(): Do index expr walkstate stuff.

    // TODO(): This assumes we discard lhs before discarding rhs -- do we?
    if case &Has(p tup[ast_expr_after_consume, ast_later_discard_info]) = &info->lhs_after {
      if case Printed(pm) = walk_later_discard_info(ws, &p.cdr) {
        return Printed(pm);
      }
    }
    if case Printed(pm) = walk_later_discard_info(ws, &info->rhs_later) {
      return Printed(pm);
    }

    return NoFail;
  case &Lambda(b ast_lambda):
    return walk_TODO();
  case &LocalField(b ast_local_field):
    if case Printed(pm) = walk_expr(ws, oo(&b.lhs)) {
      return Printed(pm);
    }
    // TODO: idk.
    return walk_TODO();
  case &DerefField(b ast_deref_field):
    if case Printed(pm) = walk_expr_consume(ws, oo(&b.lhs)) {
      return Printed(pm);
    }
    if case Printed(pm) = walk_later_discard_info(ws, &b.ptr_discard) {
      return Printed(pm);
    }
    // TODO(): Process... the act of dereffing?
    // TODO(): Handle pointer discard.
    return walk_TODO();
  case &TypedExpr(b ast_typed_expr):
    return walk_expr(ws, oo(&b.expr));
  case &Strinit(b ast_strinit):
    nexprs size = count(&b.exprs);
    for i size = 0; i < nexprs; i++ {
      if case Printed(pm) = walk_strinit_param(ws, ref(&b.exprs, i)) {
        return Printed(pm);
      }
    }
    // TODO: idk.  Activate something?
    return walk_TODO();
  case &Ternary(b ast_ternary):
    // TODO(): Connect entry and exit of cases properly.
    if case Printed(pm) = walk_expr_consume(ws, oo(&oo(&b.condition)->expr)) {
      return Printed(pm);
    }
    if case Printed(pm) = walk_expr_consume(ws, oo(&b.then_clause)) {
      return Printed(pm);
    }
    if case Printed(pm) = walk_expr_consume(ws, oo(&b.else_clause)) {
      return Printed(pm);
    }
    // TODO(): Make sure condition discard happens before/after then/else clauses, correctly.
    if case Printed(pm) = walk_later_discard_info(ws, &oo(&b.condition)->discard) {
      return Printed(pm);
    }
    return walk_TODO();
  }
}

func walk_assignment_info(ws *walkstate, a *ast_assignment_info) np {
  // NOTE(): This all makes sense, right?
  switch a {
  case &StaticSelfAssignment:
    return NoFail;
  case &SimpleMoveAssignment(b ast_simple_move_assignment_info):
    if case Printed(pm) = walk_destroy_action(ws, &b.target_destroy) {
      return Printed(pm);
    }
    if case Printed(pm) = walk_move_action(ws, &b.rhs_move) {
      return Printed(pm);
    }
    return NoFail;
  case &SimpleCopyDestroyAssignment(b ast_simple_copydestroy_assignment_info):
    if case Printed(pm) = walk_destroy_action(ws, &b.target_destroy) {
      return Printed(pm);
    }
    if case Printed(pm) = walk_copy_action(ws, &b.rhs_copy) {
      return Printed(pm);
    }
    if case Printed(pm) = walk_destroy_action(ws, &b.rhs_cleanup) {
      return Printed(pm);
    }
    return NoFail;
  case &SimpleCopyAssignment(b ast_simple_copy_assignment_info):
    if case Printed(pm) = walk_destroy_action(ws, &b.target_destroy) {
      return Printed(pm);
    }
    if case Printed(pm) = walk_copy_action(ws, &b.rhs_copy) {
      return Printed(pm);
    }
    // TODO(): Do we do anything with rhs_deadme?  No?
    return NoFail;
  case &ConditionalAssignment(b ast_conditional_assignment_info):
    // TODO(): We're missing the conditional operation entirely.  This needs to get celled and lifetimed out like anything else (the way it used to be, instead of just being an instpair).

    if case Printed(pm) = walk_destroy_action(ws, &b.conditional_destroy) {
      return Printed(pm);
    }
    if case Printed(pm) = walk_copy_action(ws, &b.conditional_copy) {
      return Printed(pm);
    }
    // TODO(): Do we do anything with rhs_deadme?  No?
    return walk_TODO();
  }
}

func walk_assignment(ws *walkstate, a *ast_assignment) np {
  if case Printed(pm) = walk_expr(ws, oo(&a->lhs)) {
    return Printed(pm);
  }
  if case Printed(pm) = walk_expr(ws, oo(&a->rhs)) {
    return Printed(pm);
  }
  if case Printed(pm) = walk_assignment_info(ws, un(&a->info)) {
    return Printed(pm);
  }
  return NoFail;
}

func walk_later_discard_info(ws *walkstate, a *ast_later_discard_info) np {
  return walk_destroy_action(ws, un(&a->action));
}

func walk_strinit_param(ws *walkstate, a *ast_strinit_param) np {
  return walk_expr_consume(ws, &a->ec);
}

func walk_expr_consume(ws *walkstate, a *ast_expr_consume) np {
  if case Printed(pm) = walk_expr(ws, &a->expr) {
    return Printed(pm);
  }
  if case Printed(pm) = walk_expr_after_consume(ws, un(&a->after)) {
    return Printed(pm);
  }
  // TODO(): idk.
  return walk_TODO();
}

func walk_expr_after_discard(ws *walkstate, a *ast_expr_after_discard) np {
  switch a {
  case &DiscardTemporary(act destroy_action):
    return walk_destroy_action(ws, &act);
  case &DiscardVirtualDead(c cell_num):
    // TODO(): idk.
    return walk_TODO();
  case &DiscardNothing:
    // TODO(): How does this case exist?
    return NoFail;
  }
}

func walk_expr_after_consume(ws *walkstate, a *ast_expr_after_consume) np {
  switch &a->actions {
  case &ConsumeByInPlace:
    return NoFail;
  case &ConsumeByCopyDestroy(act copy_destroy_action):
    if case Printed(pm) = walk_copy_action(ws, &act.copy) {
      return Printed(pm);
    }
    if case Printed(pm) = walk_destroy_action(ws, &act.destroy) {
      return Printed(pm);
    }
    return NoFail;
  case &ConsumeByCopy(act tup[copy_action, lval_deadme]):
    if case Printed(pm) = walk_copy_action(ws, &act.car) {
      return Printed(pm);
    }
    // TODO(): Handle lval_deadme.
    return walk_TODO();
  case &ConsumeByMove(act move_action):
    if case Printed(pm) = walk_move_action(ws, &act) {
      return Printed(pm);
    }
    return NoFail;
  }
}

// NOTE(): Used to mark code that assumes there's no reason to cycle into exprs, because there are no "upward" jumps that enter exprs.  This MUST be true.  Don't mark it false, remove it and look at the code that uses it.
def NO_CYCLE_EXPRS bool = true;

func walk_return_statement(ws *walkstate, a *ast_return_statement) np {
  if ws->cycling && NO_CYCLE_EXPRS {
    return NoFail;
  }

  if case &Has(b box[ast_expr_consume]) = &a->expr {
    if case Printed(pm) = walk_expr_consume(ws, oo(&b)) {
      return Printed(pm);
    }
  } else {
    // TODO(): Model assignment of void to return cell.
  }

  if case Printed(pm) = walk_var_destructions(ws, &un(&a->info)->destructions) {
    return Printed(pm);
  }

  if case Printed(pm) = tie_return_state(ws) {
    return Printed(pm);
  }

  // We continue walking the bracebody, but in a cycling state.
  ws->cycling = true;

  return NoFail;
}

func walk_var_statement(ws *walkstate, a *ast_var_statement) np {
  switch &a->rhs {
  case &HasExpr(b box[ast_expr_consume]):
    if case Printed(pm) = walk_expr_consume(ws, oo(&b)) {
      return Printed(pm);
    }
  case &AutoInit(act opt[init_action]):
    // TODO(): Why is act optional?  Should it be nc?
    return walk_TODO();
  }

  // TODO: idk.
  return walk_TODO();
}

func walk_init_action(ws *walkstate, a *init_action) np {
  return walk_TODO();
}

func walk_copy_action(ws *walkstate, a *copy_action) np {
  return walk_TODO();
}

func walk_move_action(ws *walkstate, a *move_action) np {
  return walk_TODO();
}

func walk_destroy_action(ws *walkstate, a *destroy_action) np {
  return walk_TODO();
}

// "a" is in variable declaration order -- the _opposite_ of destruction order.
func walk_var_destructions(ws *walkstate, a *array[var_destruction]) np {
  n size = count(a);
  for i size = count(a); i > 0; {
    i--;
    if case Printed(pm) = walk_var_destruction(ws, ref(a, i)) {
      return Printed(pm);
    }
  }
  return NoFail;
}

func walk_var_initters(ws *walkstate, a *array[init_action]) np {
  n size = count(a);
  for i size = 0; i < n; i++ {
    if case Printed(pm) = walk_init_action(ws, ref(a, i)) {
      return Printed(pm);
    }
  }
  return NoFail;
}

func walk_var_destruction(ws *walkstate, a *var_destruction) np {
  switch a {
  case &VarSelfContainedDestruction(da destroy_action):
    return walk_destroy_action(ws, &da);
  case &VarVirtualCellDead(c cell_num):
    // TODO(): Mark cell/lifetime deceased?
    return walk_TODO();
  }
}
