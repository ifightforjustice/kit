import check;

// Function naming scheme:  Functions started out prefixed gr_.  Those which have been updated to build their arguments in order of evaluation (to be ready for as-we-construct-the-graph liveness/activeness tracing) have been renamed to have sq_.  (They could still call gr_ functions that have not yet been updated.)
// TODO(): Rename the sq_ functions back to gr_ when we're done.

struct frame_graph {
  informal_name sym;
  cells array[cell_info];
  ops array[gr_node];
}

struct cell_num { x size; }

def `~` fn[size, cell_num] = wrapconvert;
def `==` fn[cell_num, cell_num, bool] = wrapequate;
func `!=`(x cell_num, y cell_num) bool { return x.x != y.x; }
func `<`(x cell_num, y cell_num) bool { return x.x < y.x; }
func[H] build_u8str(help H, r *array[u8], c *cell_num) void {
  build_u8str(help, r, &c->x);
}
inline func hash_compute_hash(x *cell_num) osize {
  return hash_compute_hash(&x->x);
}
inline func hash_equal(x *cell_num, y *cell_num) bool {
  return x->x == y->x;
}

/* A cell location is tricky: the location of an expr's return value
is defined both by the expr itself and the context it's found
in. Location should be specified when:

   - for lvalues, whenever we create the cell (by calling add_cell) for the lvalue.
   - for rvalues, when we annotate the disposal for the rvalue.
*/

enum cell_location {
  // The "cell" is actually caused by dereferencing something, or maybe accessing something's field?
  LocationVirtual void;
  LocationStatic void;
}

func `==`(x cell_location, y cell_location) bool {
  return enumnum(&x) == enumnum(&y);
}

func `!=`(x cell_location, y cell_location) bool {
  return enumnum(&x) != enumnum(&y);
}

func isLocationStatic(location cell_location) bool {
  switch location {
  case LocationVirtual: return false;
  case LocationStatic: return true;
  }
}

struct cell_info {
  // Location must be specified by type-checking, but it spends time in an unspecified state.
  location cell_location;
  type cu_typeexpr;
  props type_properties;
}

func location(info *cell_info) cell_location {
  return info->location;
}

enum gr_node {
  XOp gr_xnode;
  QOp gr_qnode;
}

struct gr_xnode {
  op gr_xop;
}

struct gr_qnode {
  op gr_qop;
}

struct gr_num { x size; }
def `~` fn[size, gr_num] = wrapconvert;
func `==`(x gr_num, y gr_num) bool { return x.x == y.x; }
func `!=`(x gr_num, y gr_num) bool { return x.x != y.x; }
func `<`(x gr_num, y gr_num) bool { return x.x < y.x; }
inline func hash_compute_hash(n *gr_num) osize {
  return hash_compute_hash(&n->x);
}
inline func hash_equal(x *gr_num, y *gr_num) bool {
  return x->x == y->x;
}

struct sq_num { x gr_num; }
def `~` fn[gr_num, sq_num] = wrapconvert;

enum gr_xop {
  GrApply gr_apply;
  GrPrimApply gr_prim_apply;
  GrMemCopy gr_memcopy;
  GrWriteConst gr_writeconst;
  GrAddressof gr_addressof;
  GrDeref gr_deref;
  GrSubcell gr_subcell;
  GrLive gr_live;
  GrAssertLive gr_assert_live;
  GrDead gr_dead;
  GrVirtualDead gr_virtual_dead;
  GrXNop void;
  // A debugging xop for compiler devs.
}

enum gr_qop {
  GrBranch gr_branch;
  GrSequence gr_sequence;
  GrJmp gr_jmp;
  GrQNop void;
}

func init_frame_graph_from_incomplete(incomplete_graph *opt[frame_graph]) frame_graph {
  incomplete *frame_graph = unHas(incomplete_graph);
  ret frame_graph = move(incomplete);
  *incomplete_graph = None;
  return ret;
}

func init_frame_graph_empty(informal_name sym) frame_graph {
  return {informal_name, mk_array@[cell_info](), mk_array@[gr_node]()};
}

func add_cellp(gr *frame_graph, info *cell_info) cell_num {
  num cell_num = ~count(&gr->cells);
  pushref(&gr->cells, info);
  return num;
}

inline func add_cell(gr *frame_graph, info cell_info) cell_num {
  return add_cellp(gr, &info);
}

func help_add_node(gr *frame_graph, node gr_node) gr_num {
  ret gr_num = ~count(&gr->ops);
  pushref(&gr->ops, &node);
  return ret;
}

func addx(gr *frame_graph, op gr_xop) gr_num {
  return help_add_node(gr, @[gr_node]XOp({op}));
}

func add(bu *sq_builder, op gr_xop) void {
  num gr_num = addx(bu->gr, op);
  add(bu, num);
}

func addx(gr *frame_graph, prec gr_num, op gr_xop) gr_num {
  return seq2(gr, prec, addx(gr, op)).x;
}

func addq(gr *frame_graph, op gr_qop) sq_num {
  return ~help_add_node(gr, @[gr_node]QOp({op}));
}

func mut_qnop_node(gr *frame_graph, ix sq_num, newnode gr_qnode) void {
  node *gr_node = ref_node(gr, ix.x);
  switch node {
  case &XOp(xn gr_xnode):
    ice(_u8("mut_qnop_node sees XOp"));
  case &QOp(qn gr_qnode):
    if case &GrQNop = &qn.op {
      *node = QOp(newnode);
    } else {
      ice(_u8("mut_qnop_node sees non-nop node"));
    }
  }
}

func mut_qnop_node(gr *frame_graph, ix sq_num, op gr_num, outflow sq_num) void {
  mut_qnop_node(gr, ix, {@[gr_qop]GrSequence({op, outflow})});
}

func jmp_qnop_node(gr *frame_graph, ix sq_num, outflow sq_num) void {
  mut_qnop_node(gr, ix, {@[gr_qop]GrJmp({outflow})});
}

struct sq_builder {
  // Stored here mostly because if it's null we know we didn't use mk_builder.
  gr *frame_graph;
  first sq_num;
  last sq_num;
}

func mk_builder(gr *frame_graph) sq_builder {
  sq sq_num = nopq(gr);
  return {gr, sq, sq};
}

func add(bu *sq_builder, gn gr_num) void {
  gr *frame_graph = bu->gr;
  check(gr != null);
  next sq_num = nopq(gr);
  mut_qnop_node(gr, bu->last, gn, next);
  bu->last = next;
}

func addo(bu *sq_builder, ogn opt[gr_num]) void {
  if case Has(gn gr_num) = ogn {
    add(bu, gn);
  }
}

func append(bu *sq_builder, rhs *sq_builder) void {
  gr *frame_graph = bu->gr;
  rhs_gr *frame_graph = rhs->gr;
  check(bu != rhs);
  check(gr != null && rhs_gr != null && gr == rhs_gr);
  mut_qnop_node(gr, bu->last, {@[gr_qop]GrJmp({rhs->first})});
  bu->last = rhs->last;
  rhs->gr = null;
}

func append(bu *sq_builder, enter_rhs sq_num, rhs_nopq sq_num) void {
  gr *frame_graph = bu->gr;
  check(gr != null);
  mut_qnop_node(gr, bu->last, {@[gr_qop]GrJmp({enter_rhs})});
  bu->last = rhs_nopq;
}

// TODO(): Any use of this is a mix of old-style vs. new-style.
func mut_connect(bu *sq_builder, outflow sq_num) sq_num {
  gr *frame_graph = bu->gr;
  check(gr != null);
  mut_qnop_node(gr, bu->last, {@[gr_qop]GrJmp({outflow})});
  ret sq_num = bu->first;
  bu->gr = null;
  return ret;
}

func done(bu *sq_builder) gr_num {
  return doneq(bu).x;
}

func doneq(bu *sq_builder) sq_num {
  bu->gr = null;
  return bu->first;
}

func front(bu *sq_builder) sq_num {
  return bu->first;
}

func last(bu *sq_builder) sq_num {
  return bu->last;
}

inline func ref_cell(gr *frame_graph, c cell_num) *cell_info {
  return ref(&gr->cells, c.x);
}

inline func ref_node(gr *frame_graph, gn gr_num) *gr_node {
  return ref(&gr->ops, gn.x);
}

struct gr_apply {
  funcell cell_num;
  params shray[cell_num];
  retcell cell_num;
}

struct gr_prim_apply {
  primop primitive_op;
  params shray[cell_num];
  retcell cell_num;
}

struct gr_memcopy {
  dest cell_num;
  src cell_num;
}

struct gr_writeconst {
  dest cell_num;
  value gr_const;
}

struct gr_addressof {
  dest cell_num;
  addressee cell_num;
}

struct gr_deref {
  name cell_num;
  pointer cell_num;
  offset gr_offset;
}

struct gr_subcell {
  name cell_num;
  partof cell_num;
  offset gr_offset;
}

enum gr_offset {
  OffsetConst u32;
  OffsetComputed tup[u32, cell_num];
}

struct gr_branch {
  src cell_num;
  cases shray[tup[gr_const, sq_num]];
  default_case opt[sq_num];
}

struct gr_sequence {
  first gr_num;
  second sq_num;
}

struct gr_jmp {
  next sq_num;
}

// Declares a cell to be live.  The cell may not have previously been live.  The cell location must be static -- otherwise, gr_deref or gr_subcell will make the cell live.
struct gr_live {
  cell cell_num;
}

struct gr_assert_live {
  cell cell_num;
}

struct gr_dead {
  cell cell_num;
}

struct gr_virtual_dead {
  cell cell_num;
}

enum gr_const {
  ConstInt bigint;
  ConstDef instpair;
  ConstFnBody fn_body_id;
  ConstBytes shray[u8];
}

struct gr_celltrack {
  liveset lives;
}

func mk_celltrack() gr_celltrack {
  liveset lives;
  return {liveset};
}

struct gr_statep {
  clq *clqueue;
  gr *frame_graph;
  celltrack *gr_celltrack;
}

struct fullbody_state {
  // all_vars and labels is from the ast_fullbody_info.
  // We use the cell field, to know the name of the var's cell.
  all_vars array[var_info];

  final_node sq_num;
  // count(&label_gn) == count(&info->labels), they start off as nop nodes until we see the label.
  label_gn array[sq_num];
  return_cell cell_num;
}

func nopq(gr *frame_graph) sq_num {
  return addq(gr, GrQNop);
}

func seqq(gr *frame_graph, gsq gr_sequence) sq_num {
  return addq(gr, GrSequence(gsq));
}

func seq1(gr *frame_graph, gn gr_num) sq_num {
  return seqq(gr, {gn, nopq(gr)});
}

func seq2(gr *frame_graph, gn1 gr_num, gn2 gr_num) sq_num {
  return seqq(gr, {gn1, seq1(gr, gn2)});
}

func seq3(gr *frame_graph, gn1 gr_num, gn2 gr_num, gn3 gr_num) sq_num {
  return seqq(gr, {gn1, seq2(gr, gn2, gn3)});
}

func seq4(gr *frame_graph, gn1 gr_num, gn2 gr_num, gn3 gr_num, gn4 gr_num) sq_num {
  return seqq(gr, {gn1, seq3(gr, gn2, gn3, gn4)});
}

func seqN(gr *frame_graph, arr *array[gr_num]) sq_num {
  build sq_num = nopq(gr);
  n size = count(arr);
  for i size = n; i > 0; {
    i = i - 1;
    build = seqq(gr, {get(arr, i), build});
  }
  return build;
}

func sq_fullbody(gs gr_statep, x *ast_fullbody, out *gr_num) np {
  final_node sq_num = nopq(gs.gr);

  info *ast_fullbody_info = un(&x->info);

  label_gn array[sq_num];
  n size = count(&info->labels);
  for i size = 0; i < n; i = i + 1 {
    ngn sq_num = nopq(gs.gr);
    push(&label_gn, ngn);
  }

  fb fullbody_state = {info->all_vars, final_node, label_gn, info->return_cell};

  bu sq_builder = mk_builder(gs.gr);
  if case Printed(pm) = sq_bracebody(gs, &fb, None, &x->bb, &bu) {
    return Printed(pm);
  }

  parameter_unwinding gr_num;
  if case Printed(pm) = sq_unwinding(gs, &info->parameter_destructions, &parameter_unwinding) {
    return Printed(pm);
  }
  add(&bu, parameter_unwinding);

  gn sq_num = mut_connect(&bu, final_node);

  *out = gn.x;
  return NoFail;
}

// TODO: Stop needing this -- make label_info and goto_info more general and use that, or make some other sort of annotation.  The use of breakgrack duplicates the usage of breakpack in body.ki.  It's not _particularly_ unsafe though.
struct breakgrack {
  break_target sq_num;
  continue_target sq_num;
}

func sq_bracebody(gs gr_statep, fb *fullbody_state, obg opt[breakgrack], x *ast_bracebody, bu *sq_builder) np {
  n size = count(&x->statements);
  for i size = 0; i < n; i = i + 1 {
    if case Printed(pm) = sq_statement(gs, fb, obg, ref(&x->statements, i), bu) {
      return Printed(pm);
    }
  }

  uw gr_num;
  if case Printed(pm) = sq_unwinding(gs, &un(&x->info)->destructions, &uw) {
    return Printed(pm);
  }

  add(bu, uw);
  return NoFail;
}

func sq_statement(gs gr_statep, fb *fullbody_state, obg opt[breakgrack], x *ast_statement, bu *sq_builder) np {
  switch &x->u {
  case &Expr(a ast_expr_discard):
    if case Printed(pm) = sq_expr_discard(gs, &a, bu) {
      return Printed(pm);
    }
    return NoFail;
  case &Return(a ast_return_statement):
    if case Printed(pm) = sq_return_statement(gs, fb, &a, bu) {
      return Printed(pm);
    }
    return NoFail;
  case &Var(a ast_var_statement):
    gn gr_num;
    if case Printed(pm) = sq_var_statement(gs, fb, &a, &gn) {
      return Printed(pm);
    }
    add(bu, gn);
    return NoFail;
  case &IfThen(a ast_ifthen_statement):
    outflow sq_num = nopq(gs.gr);
    gn sq_num;
    if case Printed(pm) = sq_ifthen_statement(gs, fb, obg, &a, outflow, &gn) {
      return Printed(pm);
    }
    append(bu, gn, outflow);
    return NoFail;

  case &IfThenElse(a ast_ifthenelse_statement):
    outflow sq_num = nopq(gs.gr);
    gn sq_num;
    if case Printed(pm) = sq_ifthenelse_statement(gs, fb, obg, &a, outflow, &gn) {
      return Printed(pm);
    }
    append(bu, gn, outflow);
    return NoFail;
  case &While(a ast_while_statement):
    outflow sq_num = nopq(gs.gr);
    gn sq_num;
    if case Printed(pm) = sq_while_statement(gs, fb, &a, outflow, &gn) {
      return Printed(pm);
    }
    append(bu, gn, outflow);
    return NoFail;
  case &For(a ast_for_statement):
    outflow sq_num = nopq(gs.gr);
    gn sq_num;
    if case Printed(pm) = gr_for_statement(gs, fb, &a, outflow, &gn) {
      return Printed(pm);
    }
    append(bu, gn, outflow);
    return NoFail;
  case &Switch(a ast_switch_statement):
    outflow sq_num = nopq(gs.gr);
    gn sq_num;
    if case Printed(pm) = sq_switch_statement(gs, fb, obg, &a, outflow, &gn) {
      return Printed(pm);
    }
    append(bu, gn, outflow);
    return NoFail;

  case &Break(a ast_break_statement):
    if case Printed(pm) = sq_break_statement(gs, fb, obg, &a, bu) {
      return Printed(pm);
    }
    return NoFail;
  case &Continue(a ast_continue_statement):
    if case Printed(pm) = sq_continue_statement(gs, fb, obg, &a, bu) {
      return Printed(pm);
    }
    return NoFail;
  case &Label(a ast_label_statement):
    if case Printed(pm) = sq_label_statement(gs, fb, &a, bu) {
      return Printed(pm);
    }
    return NoFail;
  case &Goto(a ast_goto_statement):
    if case Printed(pm) = sq_goto_statement(gs, fb, &a, bu) {
      return Printed(pm);
    }
    return NoFail;
  }
}

func sq_break_statement(gs gr_statep, fb *fullbody_state, obg opt[breakgrack], a *ast_break_statement, bu *sq_builder) np {
  info *ast_break_statement_info = un(&a->info);
  uw gr_num;
  if case Printed(pm) = sq_unwinding(gs, &info->destructions, &uw) {
    return Printed(pm);
  }
  add(bu, uw);
  append(bu, unHas(&obg)->break_target, nopq(gs.gr));
  return NoFail;
}

func sq_continue_statement(gs gr_statep, fb *fullbody_state, obg opt[breakgrack], a *ast_continue_statement, bu *sq_builder) np {
  info *ast_continue_statement_info = un(&a->info);
  uw gr_num;
  if case Printed(pm) = sq_unwinding(gs, &info->destructions, &uw) {
    return Printed(pm);
  }
  add(bu, uw);
  append(bu, unHas(&obg)->continue_target, nopq(gs.gr));
  return NoFail;
}

func sq_goto_statement(gs gr_statep, fb *fullbody_state, a *ast_goto_statement, bu *sq_builder) np {
  info *ast_goto_statement_info = un(&a->info);
  jmp sq_num = get(&fb->label_gn, info->label_number.x);
  ww gr_num;
  if case Printed(pm) = sq_winding(gs, &info->initializations, &ww) {
    return Printed(pm);
  }
  uw gr_num;
  if case Printed(pm) = sq_unwinding(gs, &info->destructions, &uw) {
    return Printed(pm);
  }
  add(bu, seq2(gs.gr, uw, ww).x);
  append(bu, jmp, nopq(gs.gr));
  return NoFail;
}

func sq_label_statement(gs gr_statep, fb *fullbody_state, a *ast_label_statement, bu *sq_builder) np {
  gn sq_num = get(&fb->label_gn, un(&a->info)->label_number.x);
  mut_qnop_node(gs.gr, gn, {@[gr_qop]GrJmp({last(bu)})});
  return NoFail;
}

func sq_switch_statement(gs gr_statep, fb *fullbody_state, obg opt[breakgrack], a *ast_switch_statement, outflow sq_num, out *sq_num) np {
  param_discard *te_typeexpr;
  is_ptr bool = decompose_typeapp(&expr_complete_type(&oo(&a->swartch)->expr)->x, primitive_pointer_puretype(gs.clq->cs), &param_discard);

  switch_bu sq_builder = mk_builder(gs.gr);
  swartch_gn gr_num;
  if case Printed(pm) = sq_live_and_expr_consume(gs, oo(&a->swartch), &swartch_gn) {
    return Printed(pm);
  }
  add(&switch_bu, swartch_gn);

  info *ast_enum_deconstruction_info = un(&a->info);
  if is_ptr {
    add(&switch_bu, @[gr_xop]GrDeref({info->tag_cell, result_cell(oo(&a->swartch)), OffsetConst(enum_tag_offset)}));
  } else {
    add(&switch_bu, @[gr_xop]GrSubcell({info->tag_cell, result_cell(oo(&a->swartch)), OffsetConst(enum_tag_offset)}));
  }

  exitseq sq_num = nopq(gs.gr);

  cases array[opt[sq_num]] = repeat(info->num_enum_constructors, None);
  default_case opt[sq_num] = None;
  ncases size = count(&a->cases);
  reserve(&cases, ncases);
  for i size = 0; i < ncases; i = i + 1 {
    sc *ast_switch_case = ref(&a->cases, i);

    switch &sc->pattern {
      case &Case(cp ast_constructor_pattern): {
        cp_info *ast_cp_info = un(&cp.cp_info);
        if case Has(vn var_number) = cp_info->ovn {
          vi *var_info = ref(&fb->all_vars, vn.x);

          bu sq_builder = mk_builder(gs.gr);
          add(&bu, @[gr_xop]GrVirtualDead({info->tag_cell}));
          if is_ptr {
            add(&bu, @[gr_xop]GrDeref({vi->cell, result_cell(oo(&a->swartch)), OffsetConst(cp_info->field_offset)}));
          } else {
            add(&bu, @[gr_xop]GrSubcell({vi->cell, result_cell(oo(&a->swartch)), OffsetConst(cp_info->field_offset)}));
          }

          if case Printed(pm) = sq_bracebody(gs, fb, obg, &sc->body, &bu) {
            return Printed(pm);
          }
          add(&bu, @[gr_xop]GrVirtualDead({vi->cell}));

          gn sq_num = mut_connect(&bu, exitseq);
          set(ref(&cases, unmk_enum_tag_value(cp_info->tag_value)), gn);
        } else {
          bu sq_builder = mk_builder(gs.gr);
          add(&bu, @[gr_xop]GrVirtualDead({info->tag_cell}));
          if case Printed(pm) = sq_bracebody(gs, fb, obg, &sc->body, &bu) {
            return Printed(pm);
          }
          gn sq_num = mut_connect(&bu, exitseq);
          set(ref(&cases, unmk_enum_tag_value(cp_info->tag_value)), gn);
        }
      }
      case &Default: {
        bu sq_builder = mk_builder(gs.gr);
        add(&bu, @[gr_xop]GrVirtualDead({info->tag_cell}));
        if case Printed(pm) = sq_bracebody(gs, fb, obg, &sc->body, &bu) {
          return Printed(pm);
        }

        gn var = mut_connect(&bu, exitseq);
        set(&default_case, gn);
      }
    }
  }

  swartch_discard_gn gr_num;
  if case Printed(pm) = sq_later_discard(gs, &a->swartch_discard, &swartch_discard_gn) {
    return Printed(pm);
  }

  mut_qnop_node(gs.gr, exitseq, swartch_discard_gn, outflow);

  branch_cases array[tup[gr_const, sq_num]];
  nconstructors size = count(&cases);
  for i size = 0; i < nconstructors; i = i + 1 {
    if case Has(sq sq_num) = get(&cases, i) {
      push(&branch_cases, {ConstInt(bigu(mk_enum_tag_value(i).x)), sq});
    } else {
      if case Has(dq sq_num) = default_case {
        push(&branch_cases, {ConstInt(bigu(mk_enum_tag_value(i).x)), dq});
      }
    }
  }

  br_point sq_num = addq(gs.gr, @[gr_qop]GrBranch({info->tag_cell, freeze(&branch_cases), None}));
  br sq_num = mut_connect(&switch_bu, br_point);

  *out = br;
  return NoFail;
}

func gr_for_statement(gs gr_statep, fb *fullbody_state, a *ast_for_statement, outflow sq_num, out *sq_num) np {
  init_bu sq_builder = mk_builder(gs.gr);
  if case &Has(bi box[ast_statement]) = &a->initializer {
    if case Printed(pm) = sq_statement(gs, fb, None, oo(&bi), &init_bu) {
      return Printed(pm);
    }
  }

  topgn var = nopq(gs.gr);

  loopcleanupgn gr_num;
  if case &Has(cond ast_expr_condition) = &a->condition {
    if case Printed(pm) = sq_later_discard(gs, &cond.discard, &loopcleanupgn) {
      return Printed(pm);
    }
  } else {
    loopcleanupgn = addx(gs.gr, @[gr_xop]GrXNop);
  }

  continue_target sq_num;

  continuegn sq_num;
  if case &Has(increment box[ast_expr_discard]) = &a->increment {
    incr_bu sq_builder = mk_builder(gs.gr);
    if case Printed(pm) = sq_expr_discard(gs, oo(&increment), &incr_bu) {
      return Printed(pm);
    }
    totopgn sq_num = mut_connect(&incr_bu, topgn);
    continue_target = totopgn;
    continuegn = seqq(gs.gr, {loopcleanupgn, totopgn});
  } else {
    continuegn = seqq(gs.gr, {loopcleanupgn, topgn});
    continue_target = continuegn;
  }

  bp breakgrack = {outflow, continue_target};

  body_bu sq_builder = mk_builder(gs.gr);
  if case Printed(pm) = sq_bracebody(gs, fb, Has(bp), &a->body, &body_bu) {
    return Printed(pm);
  }
  thengn sq_num = mut_connect(&body_bu, continuegn);

  gn sq_num;
  if case &Has(cond ast_expr_condition) = &a->condition {
    // TODO: This would be using the same cells in different nodes.
    loopexitgn gr_num;
    if case Printed(pm) = sq_later_discard(gs, &cond.discard, &loopexitgn) {
      return Printed(pm);
    }

    initter_uw gr_num;
    if case Printed(pm) = sq_unwinding(gs, &un(&a->info)->initter_destructions, &initter_uw) {
      return Printed(pm);
    }
    initseq sq_num = seqq(gs.gr, {initter_uw, outflow});

    exitseq var = seqq(gs.gr, {loopexitgn, initseq});

    if case Printed(pm) = sq_expr_condition(gs, oo(&cond.expr), thengn, exitseq, &gn) {
      return Printed(pm);
    }
  } else {
    gn = thengn;
  }

  mut_qnop_node(gs.gr, topgn, {@[gr_qop]GrJmp({gn})});

  fingn sq_num = mut_connect(&init_bu, topgn);
  *out = fingn;
  return NoFail;
}

func sq_condition_discard(gs gr_statep, a *ast_condition_discard_info, out *gr_num) np {
  disc gr_num;
  if case Printed(pm) = sq_later_discard(gs, &a->later, &disc) {
    return Printed(pm);
  }
  *out = disc;
  return NoFail;
}

func sq_while_statement(gs gr_statep, fb *fullbody_state, a *ast_while_statement, outflow sq_num, out *sq_num) np {
  topgn var = nopq(gs.gr);

  then_nop sq_num;
  else_nop sq_num;
  gn sq_num;
  if case Printed(pm) = sq_condition(gs, fb, &a->condition, &then_nop, &else_nop, &gn) {
    return Printed(pm);
  }

  bp breakgrack = {outflow, topgn};

  body_bu sq_builder = mk_builder(gs.gr);
  if case Printed(pm) = sq_condition_body(gs, fb, Has(bp), &a->condition_discard_continue, &a->body, &body_bu) {
    return Printed(pm);
  }

  loopcleanupgn gr_num;
  if case Printed(pm) = sq_condition_discard(gs, &a->condition_discard_continue, &loopcleanupgn) {
    return Printed(pm);
  }

  add(&body_bu, loopcleanupgn);
  thengn sq_num = mut_connect(&body_bu, topgn);

  loopexitgn gr_num;
  if case Printed(pm) = sq_condition_discard(gs, &a->condition_discard_exit, &loopexitgn) {
    return Printed(pm);
  }

  exitseq var = seqq(gs.gr, {loopexitgn, outflow});

  jmp_qnop_node(gs.gr, then_nop, thengn);
  jmp_qnop_node(gs.gr, else_nop, exitseq);

  jmp_qnop_node(gs.gr, topgn, gn);
  *out = topgn;
  return NoFail;
}

func sq_ifthenelse_statement(gs gr_statep, fb *fullbody_state, obg opt[breakgrack], a *ast_ifthenelse_statement, outflow sq_num, out *sq_num) np {
  join_target sq_num = nopq(gs.gr);

  then_nop sq_num;
  else_nop sq_num;
  gn sq_num;
  if case Printed(pm) = sq_condition(gs, fb, &a->condition, &then_nop, &else_nop, &gn) {
    return Printed(pm);
  }

  then_bu sq_builder = mk_builder(gs.gr);
  if case Printed(pm) = sq_condition_body(gs, fb, obg, &a->condition_discard, &a->thenbody, &then_bu) {
    return Printed(pm);
  }
  thengn sq_num = mut_connect(&then_bu, join_target);
  else_bu sq_builder = mk_builder(gs.gr);
  if case Printed(pm) = sq_bracebody(gs, fb, obg, &a->elsebody, &else_bu) {
    return Printed(pm);
  }
  elsegn sq_num = mut_connect(&else_bu, join_target);

  jmp_qnop_node(gs.gr, then_nop, thengn);
  jmp_qnop_node(gs.gr, else_nop, elsegn);

  condition_discard_gn gr_num;
  if case Printed(pm) = sq_condition_discard(gs, &a->condition_discard, &condition_discard_gn) {
    return Printed(pm);
  }

  mut_qnop_node(gs.gr, join_target, condition_discard_gn, outflow);
  *out = gn;
  return NoFail;
}

func sq_condition_body(gs gr_statep, fb *fullbody_state, obg opt[breakgrack], cd *ast_condition_discard_info, body *ast_bracebody, bu *sq_builder) np {
  if case Printed(pm) = sq_bracebody(gs, fb, obg, body, bu) {
    return Printed(pm);
  }
  if case &Has(c cell_num) = un(&cd->virtual_cell_dead) {
    add(bu, @[gr_xop]GrVirtualDead({c}));
  }
  return NoFail;
}

func sq_ifthen_statement(gs gr_statep, fb *fullbody_state, obg opt[breakgrack], a *ast_ifthen_statement, outflow sq_num, out *sq_num) np {
  join_target sq_num = nopq(gs.gr);

  then_nop sq_num;
  else_nop sq_num;
  gn sq_num;
  if case Printed(pm) = sq_condition(gs, fb, &a->condition, &then_nop, &else_nop, &gn) {
    return Printed(pm);
  }

  then_bu sq_builder = mk_builder(gs.gr);
  if case Printed(pm) = sq_condition_body(gs, fb, obg, &a->condition_discard, &a->body, &then_bu) {
    return Printed(pm);
  }
  bodygn sq_num = mut_connect(&then_bu, join_target);

  jmp_qnop_node(gs.gr, then_nop, bodygn);
  jmp_qnop_node(gs.gr, else_nop, join_target);

  condition_discard_gn gr_num;
  if case Printed(pm) = sq_condition_discard(gs, &a->condition_discard, &condition_discard_gn) {
    return Printed(pm);
  }
  mut_qnop_node(gs.gr, join_target, condition_discard_gn, outflow);

  *out = gn;
  return NoFail;
}

func sq_expr_condition(gs gr_statep, a *ast_expr_consume, thengn_out *sq_num, elsegn_out *sq_num, out *sq_num) np {
  thengn sq_num = nopq(gs.gr);
  elsegn sq_num = nopq(gs.gr);
  gn sq_num;
  if case Printed(pm) = sq_expr_condition(gs, a, thengn, elsegn, &gn) {
    return Printed(pm);
  }
  *thengn_out = thengn;
  *elsegn_out = elsegn;
  *out = gn;
  return NoFail;
}

// TODO(): Probably get rid of this.
func sq_expr_condition(gs gr_statep, a *ast_expr_consume, thengn sq_num, elsegn sq_num, out *sq_num) np {
  congn gr_num;
  if case Printed(pm) = sq_live_and_expr_consume(gs, a, &congn) {
    return Printed(pm);
  }
  cases shray[tup[gr_const, sq_num]] = mk_shray({@[gr_const]ConstInt(~ @[u32] 0), elsegn});
  br var = seqq(gs.gr, {congn,
    addq(gs.gr, @[gr_qop]GrBranch({result_cell(a), cases, Has(thengn)}))});

  *out = br;
  return NoFail;
}

func sq_condition(gs gr_statep, fb *fullbody_state, a *ast_condition, thengn_out *sq_num, elsegn_out *sq_num, out *sq_num) np {
  thengn sq_num = nopq(gs.gr);
  elsegn sq_num = nopq(gs.gr);
  gn sq_num;
  if case Printed(pm) = sq_condition(gs, fb, a, thengn, elsegn, &gn) {
    return Printed(pm);
  }
  *thengn_out = thengn;
  *elsegn_out = elsegn;
  *out = gn;
  return NoFail;
}

func sq_condition(gs gr_statep, fb *fullbody_state, a *ast_condition, thengn sq_num, elsegn sq_num, out *sq_num) np {
  switch a {
    case &ExprCondition(bec box[ast_expr_consume]): {
      return sq_expr_condition(gs, oo(&bec), thengn, elsegn, out);
    }

    case &PatternCondition(pa ast_pattern_assign): {
      bef_bu sq_builder = mk_builder(gs.gr);
      rhs gr_num;
      if case Printed(pm) = sq_live_and_expr_consume(gs, oo(&pa.rhs), &rhs) {
        return Printed(pm);
      }
      add(&bef_bu, rhs);

      info *ast_pattern_assign_info = un(&pa.info);
      // TODO: Avoid the duplicate checks for addressof_constructor, only do one GrDeref.
      if isHas(&pa.pattern.addressof_constructor) {
        add(&bef_bu, @[gr_xop]GrDeref({info->deconstruct.tag_cell, result_cell(oo(&pa.rhs)), OffsetConst(enum_tag_offset)}));
      } else {
        add(&bef_bu, @[gr_xop]GrSubcell({info->deconstruct.tag_cell, result_cell(oo(&pa.rhs)), OffsetConst(enum_tag_offset)}));
      }
      cases array[tup[gr_const, sq_num]];
      n size = info->deconstruct.num_enum_constructors;
      reserve(&cases, n);
      for i size = 0; i < n; i = i + 1 {
        tag enum_tag_value = mk_enum_tag_value(i);
        if info->matching_tag_value.x == tag.x {
          case_bu sq_builder = mk_builder(gs.gr);
          cp_info *ast_cp_info = un(&pa.pattern.cp_info);
          add(&case_bu, @[gr_xop]GrVirtualDead({info->deconstruct.tag_cell}));
          if case Has(vn var_number) = cp_info->ovn {
            vi *var_info = ref(&fb->all_vars, vn.x);
            vcgn gr_num;
            if isHas(&pa.pattern.addressof_constructor) {
              vcgn = addx(gs.gr, @[gr_xop]GrDeref({vi->cell, result_cell(oo(&pa.rhs)), OffsetConst(cp_info->field_offset)}));
            } else {
              vcgn = addx(gs.gr, @[gr_xop]GrSubcell({vi->cell, result_cell(oo(&pa.rhs)), OffsetConst(cp_info->field_offset)}));
            }
            add(&case_bu, vcgn);
          }
          thenseq sq_num = mut_connect(&case_bu, thengn);
          push(&cases, {@[gr_const]ConstInt(~tag.x), thenseq});
        } else {
          tagdead gr_num = addx(gs.gr, @[gr_xop]GrVirtualDead({info->deconstruct.tag_cell}));
          elseseq sq_num = seqq(gs.gr, {tagdead, elsegn});
          push(&cases, {@[gr_const]ConstInt(~tag.x), elseseq});
        }
      }
      br_point sq_num = addq(gs.gr, @[gr_qop]GrBranch({info->deconstruct.tag_cell, freeze(&cases), None}));
      br sq_num = mut_connect(&bef_bu, br_point);

      *out = br;
      return NoFail;
    }
  }
}

func sq_var_statement(gs gr_statep, fb *fullbody_state, a *ast_var_statement, out *gr_num) np {
  switch &a->rhs {
    case &HasExpr(be box[ast_expr_consume]): {
      return sq_live_and_expr_consume(gs, oo(&be), out);
    }
    case &AutoInit(x opt[init_action]): {
      if case &Has(ia init_action) = &x {
        return sq_init_action(gs, &ia, out);
      } else {
        ice(_u8("AutoInit action not annotated"));
        return fake();
      }
    }
  }
}

func sq_return_statement(gs gr_statep, fb *fullbody_state, a *ast_return_statement, bu *sq_builder) np {
  if case &Has(b box[ast_expr_consume]) = &a->expr {
    sub_bu sq_builder = mk_builder(gs.gr);
    subcell cell_num = result_cell(oo(&b));
    add(&sub_bu, @[gr_xop]GrSubcell({subcell, fb->return_cell, OffsetConst(0)}));
    expr_gn gr_num;
    if case Printed(pm) = sq_expr_consume(gs, oo(&b), &expr_gn) {
      return Printed(pm);
    }
    add(&sub_bu, expr_gn);
    add(&sub_bu, @[gr_xop]GrVirtualDead({subcell}));
    add(bu, done(&sub_bu));
  }
  info *ast_return_statement_info = un(&a->info);
  uw_op gr_num;
  if case Printed(pm) = sq_unwinding(gs, &info->destructions, &uw_op) {
    return Printed(pm);
  }
  add(bu, uw_op);
  append(bu, fb->final_node, nopq(gs.gr));
  return NoFail;
}

// "initializations" is in variable declaration order -- the _same_ order as evaluation.
func sq_winding(gs gr_statep, initializations *array[init_action], out *gr_num) np {
  bu sq_builder = mk_builder(gs.gr);
  n size = count(initializations);
  for i size = 0; i < n; i = i + 1 {
    gn gr_num;
    if case Printed(pm) = sq_init_action(gs, ref(initializations, i), &gn) {
      return Printed(pm);
    }
    add(&bu, gn);
  }
  *out = done(&bu);
  return NoFail;
}

// "destructions" is in variable declaration order -- the _opposite_ order of evaluation.
func sq_unwinding(gs gr_statep, destructions *array[var_destruction], out *gr_num) np {
  bu sq_builder = mk_builder(gs.gr);
  n size = count(destructions);
  for i size = n; i > 0; {
    i = i - 1;
    gn gr_num;
    switch get(destructions, i) {
    case VarSelfContainedDestruction(da destroy_action):
      if case Printed(pm) = sq_destroy_action(gs, &da, DeadAfterDestroyYes, &gn) {
        return Printed(pm);
      }
    case VarVirtualCellDead(c cell_num):
      gn = addx(gs.gr, @[gr_xop]GrVirtualDead({c}));
    }
    add(&bu, gn);
  }
  *out = done(&bu);
  return NoFail;
}

func sq_expr_discard(gs gr_statep, x *ast_expr_discard, bu *sq_builder) np {
  if case Printed(pm) = sq_expr_after_discard_before(gs, &x->expr, un(&x->after), bu) {
    return Printed(pm);
  }
  if case Printed(pm) = sq_expr(gs, &x->expr, bu) {
    return Printed(pm);
  }
  if case Printed(pm) = sq_expr_after_discard(gs, &x->expr, un(&x->after), bu) {
    return Printed(pm);
  }
  return NoFail;
}

func sq_expr_after_discard_before(gs gr_statep, x *ast_expr, aft *ast_expr_after_discard, bu *sq_builder) np {
  switch aft {
  case &DiscardTemporary(da destroy_action):
    add(bu, @[gr_xop]GrLive({whole_cell(x)}));
  case &DiscardVirtualDead(c cell_num): { }
  case &DiscardNothing: { }
  }
  return NoFail;
}

func sq_expr_after_discard(gs gr_statep, x *ast_expr, aft *ast_expr_after_discard, bu *sq_builder) np {
  switch aft {
  case &DiscardTemporary(da destroy_action):
    if whole_cell(x) != partial_cell(x) {
      add(bu, @[gr_xop]GrVirtualDead({partial_cell(x)}));
    }
    gn gr_num;
    if case Printed(pm) = sq_destroy_action(gs, &da, DeadAfterDestroyYes, &gn) {
      return Printed(pm);
    }
    add(bu, gn);
  case &DiscardVirtualDead(c cell_num):
    add(bu, @[gr_xop]GrVirtualDead({c}));
  case &DiscardNothing: { }
  }
  return NoFail;
}

func sq_live_and_expr_consume(gs gr_statep, x *ast_expr_consume, bu *sq_builder) np {
  add(bu, @[gr_xop]GrLive({result_cell(x)}));
  if case Printed(pm) = sq_expr_consume(gs, x, bu) {
    return Printed(pm);
  }
  return NoFail;
}

// TODO(): Remove this.
func sq_live_and_expr_consume(gs gr_statep, x *ast_expr_consume, out *gr_num) np {
  bu sq_builder = mk_builder(gs.gr);
  if case Printed(pm) = sq_live_and_expr_consume(gs, x, &bu) {
    return Printed(pm);
  }
  *out = done(&bu);
  return NoFail;
}

func sq_expr_consume(gs gr_statep, x *ast_expr_consume, bu *sq_builder) np {
  return sq_expr_and_consume(gs, &x->expr, un(&x->after), bu);
}

// TODO(): Remove this.
func sq_expr_consume(gs gr_statep, x *ast_expr_consume, out *gr_num) np {
  bu sq_builder = mk_builder(gs.gr);
  if case Printed(pm) = sq_expr_and_consume(gs, &x->expr, un(&x->after), &bu) {
    return Printed(pm);
  }
  *out = done(&bu);
  return NoFail;
}

func sq_expr_and_consume(gs gr_statep, x *ast_expr, aft *ast_expr_after_consume, bu *sq_builder) np {
  if case Printed(pm) = sq_consume_actions_before(gs, x, aft, bu) {
    return Printed(pm);
  }
  if case Printed(pm) = sq_expr(gs, x, bu) {
    return Printed(pm);
  }
  if case Printed(pm) = sq_consume_actions(gs, x, aft, bu) {
    return Printed(pm);
  }

  return NoFail;
}

// TODO(): Use bigu.
func sq_expr(gs gr_statep, x *ast_expr, bu *sq_builder) np {
  cs *checkstate = gs.clq->cs;
  switch &x->u {
  case &NameExpr(a ast_name_expr):
    return sq_name_expr(gs, x, &a, bu);
  case &ParenExpr(a ast_paren_expr):
    return sq_expr(gs, oo(&a.expr), bu);
  case &NumericLiteral(a ast_numeric_literal):
    return sq_literal(gs, x, numeric_literal_value(&a), bu);
  case &BoolLiteral(a ast_bool_literal):
    value bigint;
    if a.value {
      value = ~ @[u32] 1;
    } else {
      value = ~ @[u32] 0;
    }
    return sq_literal(gs, x, value, bu);
  case &VoidLiteral(a ast_void_literal):
    value bigint = ~ @[u32] 0;
    return sq_literal(gs, x, value, bu);
  case &NullLiteral(a ast_null_literal):
    value bigint = ~ @[u32] 0;
    return sq_literal(gs, x, value, bu);
  case &CharLiteral(a ast_char_literal):
    value bigint = ~ a.charspec.value;
    return sq_literal(gs, x, value, bu);
  case &StringLiteral(a ast_string_literal):
    return sq_string_literal(gs, x, &a, bu);
  case &Funcall(a ast_funcall):
    return sq_funcall(gs, x, &a, bu);
  case &LogicalConjunction(a ast_logical_conjunction):
    return sq_logical_conjunction(gs, x, &a, bu);
  case &Assignment(a ast_assignment):
    return sq_assignment(gs, x, &a, bu);
  case &RefOf(a ast_refof):
    return sq_mk_refof(gs, x, &a, bu);
  case &AddressOf(a ast_addressof):
    return sq_mk_addressof(gs, x, &a, bu);
  case &Deref(a ast_deref):
    return sq_mk_deref(gs, x, &a, bu);
  case &IndexExpr(a ast_index_expr):
    return sq_index_expr(gs, x, &a, bu);
  case &Lambda(a ast_lambda):
    gn gr_num;
    if case Printed(pm) = sq_lambda_expr(gs, x, &a, &gn) {
      return Printed(pm);
    }
    add(bu, gn);
    return NoFail;
  case &LocalField(a ast_local_field):
    return sq_local_field(gs, x, &a, bu);
  case &DerefField(a ast_deref_field):
    return sq_deref_field(gs, x, &a, bu);
  case &TypedExpr(a ast_typed_expr):
    return sq_expr(gs, oo(&a.expr), bu);
  case &Strinit(a ast_strinit):
    return sq_mk_strinit(gs, x, &a, bu);
  case &Ternary(a ast_ternary):
    return sq_mk_ternary(gs, x, &a, bu);
  case &QuickReturn(a ast_quickreturn):
    // TODO(): Implement quick-return graphing.
    return ERR(_u8("ICE: quick-return expressions not fully implemented"));
  }
}

func sq_mk_ternary(gs gr_statep, x *ast_expr, a *ast_ternary, bu *sq_builder) np {
  join_target sq_num = nopq(gs.gr);

  conjoined cell_num = rval_cell(x);

  then_nop sq_num;
  else_nop sq_num;
  cond_sn sq_num;
  if case Printed(pm) = sq_expr_condition(gs, oo(&oo(&a->condition)->expr), &then_nop, &else_nop, &cond_sn) {
    return Printed(pm);
  }

  then_bu sq_builder = mk_builder(gs.gr);
  add(&then_bu, @[gr_xop]GrSubcell({result_cell(oo(&a->then_clause)), conjoined, OffsetConst(0)}));
  if case Printed(pm) = sq_expr_consume(gs, oo(&a->then_clause), &then_bu) {
    return Printed(pm);
  }
  add(&then_bu, @[gr_xop]GrVirtualDead({result_cell(oo(&a->then_clause))}));
  then_sn sq_num = mut_connect(&then_bu, join_target);

  else_bu sq_builder = mk_builder(gs.gr);
  add(&else_bu, @[gr_xop]GrSubcell({result_cell(oo(&a->else_clause)), conjoined, OffsetConst(0)}));
  if case Printed(pm) = sq_expr_consume(gs, oo(&a->else_clause), &else_bu) {
    return Printed(pm);
  }
  add(&else_bu, @[gr_xop]GrVirtualDead({result_cell(oo(&a->else_clause))}));
  else_sn sq_num = mut_connect(&else_bu, join_target);

  jmp_qnop_node(gs.gr, then_nop, then_sn);
  jmp_qnop_node(gs.gr, else_nop, else_sn);
  append(bu, cond_sn, join_target);

  // TODO: We do the condcleanup at the end instead of repeating it twice right after the branch... do it right after the branch.
  condcleanupgn gr_num;
  if case Printed(pm) = sq_later_discard(gs, &oo(&a->condition)->discard, &condcleanupgn) {
    return Printed(pm);
  }
  add(bu, condcleanupgn);

  return NoFail;
}

func sq_mk_strinit(gs gr_statep, x *ast_expr, a *ast_strinit, bu *sq_builder) np {
  build gr_num = addx(gs.gr, @[gr_xop]GrXNop);
  nparams size = count(&a->exprs);
  for i size = 0; i < nparams; i = i + 1 {
    param *ast_strinit_param = ref(&a->exprs, i);
    add(bu, @[gr_xop]GrSubcell({result_cell(&param->ec), rval_cell(x), OffsetConst(un(&param->info)->offset)}));
    if case Printed(pm) = sq_expr_consume(gs, &param->ec, bu) {
      return Printed(pm);
    }
  }
  // We declare the virtual cells dead after we're done the whole thing -- because we'll need them for unwinding.
  for i size = nparams; i > 0; {
    i = i - 1;
    param *ast_strinit_param = ref(&a->exprs, i);
    add(bu, @[gr_xop]GrVirtualDead({result_cell(&param->ec)}));
  }
  return NoFail;
}

func sq_deref_field(gs gr_statep, x *ast_expr, a *ast_deref_field, bu *sq_builder) np {
  if case Printed(pm) = sq_live_and_expr_consume(gs, oo(&a->lhs), bu) {
    return Printed(pm);
  }
  info *ast_deref_field_info = un(&a->info);
  switch info {
  case &DerefArrayLength(count u32):
    add(bu, @[gr_xop]GrWriteConst({rval_cell(x), ConstInt(~count)}));
  case &DerefFieldName(offset u32):
    name cell_num = ellval_cell(x);
    add(bu, @[gr_xop]GrDeref({name, result_cell(oo(&a->lhs)), OffsetConst(offset)}));
  }
  ap gr_num;
  if case Printed(pm) = sq_later_discard(gs, &a->ptr_discard, &ap) {
    return Printed(pm);
  }
  add(bu, ap);
  return NoFail;
}

func sq_local_field(gs gr_statep, x *ast_expr, a *ast_local_field, bu *sq_builder) np {
  info *ast_local_field_info = un(&a->info);

  switch info {
    case &ArrayLength(alinfo ast_arraylength_info): {
      if case Printed(pm) = sq_expr_after_discard_before(gs, oo(&a->lhs), &alinfo.after, bu) {
        return Printed(pm);
      }

      if case Printed(pm) = sq_expr(gs, oo(&a->lhs), bu) {
        return Printed(pm);
      }

      if case Printed(pm) = sq_expr_after_discard(gs, oo(&a->lhs), &alinfo.after, bu) {
        return Printed(pm);
      }

      add(bu, @[gr_xop]GrWriteConst({rval_cell(x), ConstInt(~alinfo.count)}));
      return NoFail;
    }
    case &FieldName(offset u32): {
      if case Printed(pm) = sq_expr(gs, oo(&a->lhs), bu) {
        return Printed(pm);
      }

      add(bu, @[gr_xop]GrSubcell({value_cell(x), value_cell(oo(&a->lhs)), OffsetConst(offset)}));
      gn gr_num;
      switch &expr_complete_info(oo(&a->lhs))->lval {
      case &IsLvalYes(desc lval_description):
        if case DeadMe = desc.deadme {
          add(bu, @[gr_xop]GrVirtualDead({desc.num}));
        }
      case &IsLvalNo(desc rval_description):
        addo(bu, sq_maybe_virtualdead(gs, desc.partial_num));
      }
      return NoFail;
    }
  }
}

// NOTE(): gr_statep wasteful.
func gr_create(gs gr_statep, c cell_num) void {
  return gr_create(&gs.celltrack->liveset, c);
}

func gr_deaden(gs gr_statep, c cell_num) void {
  return deaden(&gs.celltrack->liveset, c);
}

func sq_lambda_expr(gs gr_statep, x *ast_expr, a *ast_lambda, out *gr_num) np {
  info *ast_fullbody_info = un(&a->body.info);
  lambda_gr frame_graph = init_frame_graph_from_incomplete(&info->incomplete_graph);
  lambda_celltrack gr_celltrack = mk_celltrack();
  lambda_gs gr_statep = {gs.clq, &lambda_gr, &lambda_celltrack};

  gr_create(lambda_gs, info->return_cell);
  nargs size = count(&info->arg_cells);
  for i size = 0; i < nargs; i = i + 1 {
    gr_create(lambda_gs, get(&info->arg_cells, i));
  }

  fullbody_gn gr_num;
  if case Printed(pm) = sq_fullbody(lambda_gs, &a->body, &fullbody_gn) {
    return Printed(pm);
  }

  gr_deaden(lambda_gs, info->return_cell);
  if count(&lambda_celltrack.liveset.all) != 0 {
    // TODO(): At some point this should become an ice().
    // Not worth mentioning right now.
    // DBG(_u8("gr_lambda_expr sees leftover live cells"));
  }

  id fn_body_id = add_fn_body(gs.clq->cs, {gs.gr->informal_name, NotComputed, NotComputed, @[fn_body_entry_enum]GraphedFnBody({FnBodyLambda(a), {lambda_gr, fullbody_gn, info->return_cell}, info->arg_cells, parsed_inline_to_state_inline(a->is_inline), NotComputed})});
  gn var = addx(gs.gr, @[gr_xop]GrWriteConst({rval_cell(x), ConstFnBody(id)}));
  *out = gn;
  return NoFail;
}

func parsed_inline_to_state_inline(a ast_isinline) should_inline {
  switch a {
  case IsInline: return InlineMust;
  case IsNotInline: return InlineYawn;
  }
}

func sq_index_expr(gs gr_statep, x *ast_expr, a *ast_index_expr, bu *sq_builder) np {
  info *ast_index_expr_info = un(&a->info);
  if case &Has(aft tup[ast_expr_after_consume, ast_later_discard_info]) = &info->lhs_after {
    // It's a pointer.
    name cell_num = ellval_cell(x);
    flat_size u32 = ref_cell(gs.gr, name)->props.flat_size;
    add(bu, @[gr_xop]GrLive({result_cell(&aft.car)}));
    if case Printed(pm) = sq_consume_actions_before(gs, oo(&a->lhs), &aft.car, bu) {
      return Printed(pm);
    }

    if case Printed(pm) = sq_expr(gs, oo(&a->lhs), bu) {
      return Printed(pm);
    }

    if case Printed(pm) = sq_consume_actions(gs, oo(&a->lhs), &aft.car, bu) {
      return Printed(pm);
    }
    if case Printed(pm) = sq_live_and_expr_consume(gs, oo(&a->rhs), bu) {
      return Printed(pm);
    }
    add(bu, @[gr_xop]GrDeref({name, result_cell(&aft.car), OffsetComputed({flat_size, result_cell(oo(&a->rhs))})}));
    rhs_later gr_num;
    if case Printed(pm) = sq_later_discard(gs, &info->rhs_later, &rhs_later) {
      return Printed(pm);
    }
    add(bu, rhs_later);
    lhs_later gr_num;
    if case Printed(pm) = sq_later_discard(gs, &aft.cdr, &lhs_later) {
      return Printed(pm);
    }
    add(bu, lhs_later);
  } else {
    if case Printed(pm) = sq_expr(gs, oo(&a->lhs), bu) {
      return Printed(pm);
    }
    if case Printed(pm) = sq_live_and_expr_consume(gs, oo(&a->rhs), bu) {
      return Printed(pm);
    }
    name cell_num = value_cell(x);
    flat_size u32 = ref_cell(gs.gr, name)->props.flat_size;
    add(bu, @[gr_xop]GrSubcell({name, value_cell(oo(&a->lhs)), OffsetComputed({flat_size, result_cell(oo(&a->rhs))})}));
    gp gr_num;
    // TODO: Dedup with local_field code?
    switch &expr_complete_info(oo(&a->lhs))->lval {
    case &IsLvalYes(desc lval_description):
      if case DeadMe = desc.deadme {
        add(bu, @[gr_xop]GrVirtualDead({desc.num}));
      }
    case &IsLvalNo(desc rval_description):
      addo(bu, sq_maybe_virtualdead(gs, desc.partial_num));
    }
    rhs_later gr_num;
    if case Printed(pm) = sq_later_discard(gs, &info->rhs_later, &rhs_later) {
      return Printed(pm);
    }
    add(bu, rhs_later);
  }
  return NoFail;
}

func sq_later_discard(gs gr_statep, a *ast_later_discard_info, out *gr_num) np {
  da *destroy_action = un(&a->action);
  return sq_destroy_action(gs, da, DeadAfterDestroyYes, out);
}

func sq_mk_deref(gs gr_statep, x *ast_expr, a *ast_deref, bu *sq_builder) np {
  if case Printed(pm) = sq_live_and_expr_consume(gs, oo(&a->rhs), bu) {
    return Printed(pm);
  }
  add(bu, @[gr_xop]GrDeref({ellval_cell(x), result_cell(oo(&a->rhs)), OffsetConst(0)}));
  ap gr_num;
  if case Printed(pm) = sq_later_discard(gs, &a->ptr_discard, &ap) {
    return Printed(pm);
  }
  add(bu, ap);
  return NoFail;
}

func sq_mk_addressof(gs gr_statep, x *ast_expr, a *ast_addressof, bu *sq_builder) np {
  // This is a total copy/paste of gr_mk_refof.
  if case Printed(pm) = sq_expr(gs, oo(&a->rhs), bu) {
    return Printed(pm);
  }
  desc *lval_description = ellval_desc(oo(&a->rhs));
  add(bu, @[gr_xop]GrAddressof({rval_cell(x), desc->num}));
  if case DeadMe = desc->deadme {
    add(bu, @[gr_xop]GrVirtualDead({ellval_cell(oo(&a->rhs))}));
  }
  return NoFail;
}

func sq_mk_refof(gs gr_statep, x *ast_expr, a *ast_refof, bu *sq_builder) np {
  // This is a total copy/paste of gr_mk_addressof.
  if case Printed(pm) = sq_expr(gs, oo(&a->rhs), bu) {
    return Printed(pm);
  }
  desc *lval_description = ellval_desc(oo(&a->rhs));
  add(bu, @[gr_xop]GrAddressof({rval_cell(x), desc->num}));
  if case DeadMe = desc->deadme {
    add(bu, @[gr_xop]GrVirtualDead({ellval_cell(oo(&a->rhs))}));
  }
  return NoFail;
}

func sq_assignment(gs gr_statep, x *ast_expr, a *ast_assignment, bu *sq_builder) np {
  // The lhs is an lvalue.  If the rhs is an rvalue, we need to make its cell live.
  // The lhs is evaluated before the rhs.  For now.

  if case Printed(pm) = sq_expr(gs, oo(&a->lhs), bu) {
    return Printed(pm);
  }
  switch un(&a->info) {
  case &StaticSelfAssignment: { }
  case &SimpleMoveAssignment(smi ast_simple_move_assignment_info):
    // rhs is an rvalue.
    add(bu, @[gr_xop]GrLive({whole_cell(oo(&a->rhs))}));
  case &SimpleCopyDestroyAssignment(scdi ast_simple_copydestroy_assignment_info):
    // rhs is an rvalue.
    add(bu, @[gr_xop]GrLive({whole_cell(oo(&a->rhs))}));
  case &SimpleCopyAssignment(sci ast_simple_copy_assignment_info): { }
  case &ConditionalAssignment(ci ast_conditional_assignment_info): { }
  }

  if case Printed(pm) = sq_expr(gs, oo(&a->rhs), bu) {
    return Printed(pm);
  }

  // We can't early-exit out of these ops (yet?) so we use a sub-bu.
  assign_bu sq_builder = mk_builder(gs.gr);
  switch un(&a->info) {
    case &StaticSelfAssignment: {
      // Do nothing.
    }
    case &SimpleMoveAssignment(smi ast_simple_move_assignment_info): {
      // rhs is an rvalue.
      dgn gr_num;
      if case Printed(pm) = sq_destroy_action(gs, &smi.target_destroy, DeadAfterDestroyNo, &dgn) {
        return Printed(pm);
      }
      add(&assign_bu, dgn);
      mgn gr_num;
      if case Printed(pm) = sq_move_action(gs, &smi.rhs_move, &mgn) {
        return Printed(pm);
      }
      add(&assign_bu, mgn);
    }
    case &SimpleCopyDestroyAssignment(scdi ast_simple_copydestroy_assignment_info): {
      dgn gr_num;
      if case Printed(pm) = sq_destroy_action(gs, &scdi.target_destroy, DeadAfterDestroyNo, &dgn) {
        return Printed(pm);
      }
      add(&assign_bu, dgn);
      mgn1 gr_num;
      if case Printed(pm) = sq_copy_action(gs, &scdi.rhs_copy, &mgn1) {
        return Printed(pm);
      }
      add(&assign_bu, mgn1);
      addo(&assign_bu, sq_maybe_virtualdead(gs, scdi.rhs_copy.x.src));
      drgn gr_num;
      if case Printed(pm) = sq_destroy_action(gs, &scdi.rhs_cleanup, DeadAfterDestroyYes, &drgn) {
        return Printed(pm);
      }
      add(&assign_bu, drgn);
    }
    case &SimpleCopyAssignment(sci ast_simple_copy_assignment_info): {
      dgn gr_num;
      if case Printed(pm) = sq_destroy_action(gs, &sci.target_destroy, DeadAfterDestroyNo, &dgn) {
        return Printed(pm);
      }
      add(&assign_bu, dgn);
      mgn gr_num;
      if case Printed(pm) = sq_copy_action(gs, &sci.rhs_copy, &mgn) {
        return Printed(pm);
      }
      add(&assign_bu, mgn);
      if case DeadMe = sci.rhs_deadme {
        addo(&assign_bu, sq_maybe_virtualdead(gs, sci.rhs_copy.x.src));
      }
    }
    case &ConditionalAssignment(ci ast_conditional_assignment_info): {
      destcell cell_num = value_cell(oo(&a->lhs));
      valuetype *cu_typeexpr = &ref_cell(gs.gr, destcell)->type;
      ptrtype cu_typrop = computed_ptr_type(gs.clq, valuetype);
      booltype cu_typrop = compute_prim(gs.clq, primitive_bool_type(gs.clq->cs));
      fntype cu_typrop = compute_prim(gs.clq, fn_type(gs.clq->cs, ptrtype.cu.x, ptrtype.cu.x, booltype.cu.x));

      funcell cell_num = add_cell(gs.gr, {LocationStatic, fntype.cu, fntype.props});
      destptr cell_num = add_cell(gs.gr, {LocationStatic, ptrtype.cu, ptrtype.props});
      srcptr cell_num = add_cell(gs.gr, {LocationStatic, ptrtype.cu, ptrtype.props});
      cmp_result cell_num = add_cell(gs.gr, {LocationStatic, booltype.cu, booltype.props});

      add(&assign_bu, @[gr_xop]GrLive({cmp_result}));
      add(&assign_bu, @[gr_xop]GrLive({funcell}));
      add(&assign_bu, @[gr_xop]GrWriteConst({funcell, ConstDef(ci.comparecells)}));
      add(&assign_bu, @[gr_xop]GrLive({destptr}));
      add(&assign_bu, @[gr_xop]GrAddressof({destptr, destcell}));
      add(&assign_bu, @[gr_xop]GrLive({srcptr}));
      add(&assign_bu, @[gr_xop]GrAddressof({srcptr, value_cell(oo(&a->rhs))}));
      add(&assign_bu, @[gr_xop]GrApply({funcell, mk_shray(destptr, srcptr), cmp_result}));

      exit_nopq sq_num = nopq(gs.gr);

      just_dead_bu sq_builder = mk_builder(gs.gr);
      add(&just_dead_bu, @[gr_xop]GrDead({cmp_result}));

      do_assign_bu sq_builder = mk_builder(gs.gr);
      add(&do_assign_bu, @[gr_xop]GrDead({cmp_result}));
      assign_destroy gr_num;
      if case Printed(pm) = sq_destroy_action(gs, &ci.conditional_destroy, DeadAfterDestroyNo, &assign_destroy) {
        return Printed(pm);
      }
      add(&do_assign_bu, assign_destroy);
      assign_copy gr_num;
      if case Printed(pm) = sq_copy_action(gs, &ci.conditional_copy, &assign_copy) {
        return Printed(pm);
      }
      add(&do_assign_bu, assign_copy);
      cases shray[tup[gr_const, sq_num]] = mk_shray({@[gr_const]ConstInt(~ @[u32] 0), mut_connect(&do_assign_bu, exit_nopq)}, {@[gr_const]ConstInt(~ @[u32] 1), mut_connect(&just_dead_bu, exit_nopq)});

      br sq_num = addq(gs.gr, @[gr_qop]GrBranch({cmp_result, cases, None}));

      // br is an expression node -- the cases attach to nopq's -- they're made by seq1 just above.
      append(&assign_bu, br, exit_nopq);
      if case DeadMe = ci.rhs_deadme {
        addo(&assign_bu, sq_maybe_virtualdead(gs, ci.conditional_copy.x.src));
      }
    }
  }

  add(bu, done(&assign_bu));

  // TODO: Dedup with local_field code and the other one?
  switch &expr_complete_info(oo(&a->lhs))->lval {
  case &IsLvalNo(desc rval_description):
    ice(_u8("gr_assignment into rvalue wtf"));
  case &IsLvalYes(desc lval_description):
    if case DeadMe = desc.deadme {
      add(bu, @[gr_xop]GrVirtualDead({desc.num}));
    }
  }

  // TODO: Having to set this void cell is grotesque -- assignment should be a statement.
  add(bu, @[gr_xop]GrWriteConst({rval_cell(x), ConstInt(bigu(0))}));
  return NoFail;
}

func sq_logical_conjunction(gs gr_statep, x *ast_expr, a *ast_logical_conjunction, bu *sq_builder) np {
  end_nopq sq_num = nopq(gs.gr);

  if case Printed(pm) = sq_live_and_expr_consume(gs, oo(&a->lhs), bu) {
    return Printed(pm);
  }

  rhs_bu sq_builder = mk_builder(gs.gr);
  add(&rhs_bu, @[gr_xop]GrDead({result_cell(oo(&a->lhs))}));

  if case Printed(pm) = sq_live_and_expr_consume(gs, oo(&a->rhs), &rhs_bu) {
    return Printed(pm);
  }

  add(&rhs_bu, @[gr_xop]GrMemCopy({rval_cell(x), result_cell(oo(&a->rhs))}));
  add(&rhs_bu, @[gr_xop]GrDead({result_cell(oo(&a->rhs))}));

  lhs_bu sq_builder = mk_builder(gs.gr);
  add(&lhs_bu, @[gr_xop]GrMemCopy({rval_cell(x), result_cell(oo(&a->lhs))}));
  add(&lhs_bu, @[gr_xop]GrDead({result_cell(oo(&a->lhs))}));

  cases array[tup[gr_const, gr_num]];
  short_circuit_case gr_const;
  eval_rhs_case gr_const;
  if a->is_logical_or {
    short_circuit_case = ConstInt(~ @[u32] 1);
    eval_rhs_case = ConstInt(~ @[u32] 0);
  } else {
    short_circuit_case = ConstInt(~ @[u32] 0);
    eval_rhs_case = ConstInt(~ @[u32] 1);
  }
  bn sq_num = addq(gs.gr, @[gr_qop]GrBranch({result_cell(oo(&a->lhs)), mk_shray({short_circuit_case, mut_connect(&lhs_bu, end_nopq)}, {eval_rhs_case, mut_connect(&rhs_bu, end_nopq)}), None}));
  append(bu, bn, end_nopq);
  return NoFail;
}

func sq_funcall(gs gr_statep, x *ast_expr, a *ast_funcall, bu *sq_builder) np {
  nparams size = count(&a->params);
  if case Printed(pm) = sq_live_and_expr_consume(gs, oo(&a->fun), bu) {
    return Printed(pm);
  }
  paramcells array[cell_num];
  reserve(&paramcells, nparams);
  for i size = 0; i < nparams; i = i + 1 {
    param *ast_expr_consume = ref(&a->params, i);
    if case Printed(pm) = sq_live_and_expr_consume(gs, param, bu) {
      return Printed(pm);
    }
    push(&paramcells, result_cell(param));
  }
  add(bu, @[gr_xop]GrApply({result_cell(oo(&a->fun)), freeze(&paramcells), rval_cell(x)}));
  return NoFail;
}

func sq_string_literal(gs gr_statep, x *ast_expr, a *ast_string_literal, bu *sq_builder) np {
  bytes array[u8];
  nchars size = count(&a->charspecs);
  reserve(&bytes, nchars);
  for i size = 0; i < nchars; i = i + 1 {
    ch i32 = get(&a->charspecs, i).value;
    if ch < 0 || ch > 255 {
      ice(_u8("gr_string_literal char values out of range"));
    }
    push(&bytes, ~ch);
  }
  add(bu, @[gr_xop]GrWriteConst({rval_cell(x), ConstBytes(freeze(&bytes))}));
  return NoFail;
}

func sq_literal(gs gr_statep, x *ast_expr, value bigint, bu *sq_builder) np {
  add(bu, @[gr_xop]GrWriteConst({rval_cell(x), ConstInt(value)}));
  return NoFail;
}

func sq_name_expr(gs gr_statep, x *ast_expr, a *ast_name_expr, bu *sq_builder) np {
  switch un(&a->name_info) {
  case &LocalResolve(li local_info): { }
  case &GlobalResolve(gi global_info):
    add(bu, @[gr_xop]GrWriteConst({rval_cell(x), ConstDef({gi.ent, gi.inst})}));
  case &EnumConstructor(ei enum_constructor_info):
    add(bu, @[gr_xop]GrWriteConst({rval_cell(x), ConstDef(ei.ip)}));
  case &EnumVoidConstructed(vi enum_voidconstructed_info):
    sub_bu sq_builder = mk_builder(gs.gr);
    info *ast_expr_complete_info = expr_complete_info(x);
    x_cell cell_num = rval_cell(x);
    cu cu_typeexpr;
    props type_properties;
    compute_prim(gs.clq, enum_tag_type(gs.clq->cs, &vi.et), &cu, &props);
    tag_cell cell_num = add_cell(gs.gr, {LocationVirtual, cu, props});
    field_offset u32 = enum_field_offset(gs.clq->cs, &vi.et, vi.constructor_tag);
    add(&sub_bu, @[gr_xop]GrSubcell({tag_cell, x_cell, OffsetConst(enum_tag_offset)}));
    add(&sub_bu, @[gr_xop]GrWriteConst({tag_cell, ConstInt(~vi.constructor_tag.x)}));
    tag_end u32 = enum_tag_offset + props.flat_size;
    postpadding_ogn opt[gr_num]
      = gr_bzero_subcell(gs, x_cell, tag_end, info->cu_props.flat_size - tag_end);
    addo(&sub_bu, postpadding_ogn);
    add(&sub_bu, @[gr_xop]GrVirtualDead({tag_cell}));
    add(bu, done(&sub_bu));
  }
  return NoFail;
}

func ellval_desc(x *is_lval) *lval_description {
  switch x {
    case &IsLvalYes(desc lval_description): { return &desc; }
    case &IsLvalNo(desc rval_description): {
      ice(_u8("lvalue_value_cell expects lvalue"));
      return fake();
    }
  }
}

func ellval_cell(x *is_lval) cell_num {
  return ellval_desc(x)->num;
}

func ellval_cell(a *ast_expr) cell_num {
  return ellval_desc(a)->num;
}

func ellval_desc(a *ast_expr) *lval_description {
  return ellval_desc(&expr_complete_info(a)->lval);
}

func rval_cell(x *ast_expr) cell_num {
  return rval_cell(&expr_complete_info(x)->lval);
}

func rval_cell(x *is_lval) cell_num {
  switch x {
    case &IsLvalNo(desc rval_description): {
      if desc.whole_num != desc.partial_num {
        ice(_u8("rval_cell on non-whole"));
      }
      return desc.whole_num;
    }
    case &IsLvalYes(desc lval_description): {
      ice(_u8("rval_cell sees lvalue"));
      return fake();
    }
  }
}

func whole_cell(x *ast_expr) cell_num {
  return whole_cell(&expr_complete_info(x)->lval);
}

func whole_cell(x *is_lval) cell_num {
  switch x {
  case &IsLvalNo(desc rval_description):
    return desc.whole_num;
  case &IsLvalYes(desc lval_description):
    ice(_u8("whole_cell sees lvalue"));
    return fake();
  }
}

func partial_cell(x *ast_expr) cell_num {
  return partial_cell(&expr_complete_info(x)->lval);
}

func partial_cell(x *is_lval) cell_num {
  switch x {
  case &IsLvalNo(desc rval_description):
    return desc.partial_num;
  case &IsLvalYes(desc lval_description):
    ice(_u8("partial_cell sees lvalue"));
    return fake();
  }
}

enum dead_after_destroy {
  DeadAfterDestroyYes void;
  DeadAfterDestroyNo void;
}

func sq_maybe_virtualdead(gs gr_statep, c cell_num) opt[gr_num] {
  switch location(ref_cell(gs.gr, c)) {
  case LocationVirtual:
    return Has(addx(gs.gr, @[gr_xop]GrVirtualDead({c})));
  case LocationStatic:
    return None;
  }
}

func sq_consume_actions_before(gs gr_statep, expr *ast_expr, aft *ast_expr_after_consume, bu *sq_builder) np {
  add(bu, @[gr_xop]GrAssertLive({result_cell(aft)}));
  switch &aft->actions {
  case &ConsumeByInPlace: { }
  case &ConsumeByCopyDestroy(cd copy_destroy_action):
    // It's an rvalue, we make the whole cell live before evaling.
    add(bu, @[gr_xop]GrLive({whole_cell(expr)}));
  case &ConsumeByCopy(cc tup[copy_action, lval_deadme]): { }
  case &ConsumeByMove(m move_action): { }
  }
  return NoFail;
}

func sq_consume_actions(gs gr_statep, expr *ast_expr, aft *ast_expr_after_consume, bu *sq_builder) np {
  switch &aft->actions {
  case &ConsumeByInPlace: { }
  case &ConsumeByCopyDestroy(cd copy_destroy_action):
    dep gr_num;
    if case Printed(pm) = sq_copy_action(gs, &cd.copy, &dep) {
      return Printed(pm);
    }
    add(bu, dep);
    addo(bu, sq_maybe_virtualdead(gs, cd.copy.x.src));
    destroy_gn gr_num;
    if case Printed(pm) = sq_destroy_action(gs, &cd.destroy, DeadAfterDestroyYes, &destroy_gn) {
      return Printed(pm);
    }
    add(bu, destroy_gn);
  case &ConsumeByCopy(cc tup[copy_action, lval_deadme]):
    dep gr_num;
    if case Printed(pm) = sq_copy_action(gs, &cc.car, &dep) {
      return Printed(pm);
    }
    add(bu, dep);
    if case DeadMe = cc.cdr {
      addo(bu, sq_maybe_virtualdead(gs, cc.car.x.src));
    }
  case &ConsumeByMove(m move_action):
    dep gr_num;
    if case Printed(pm) = sq_move_action(gs, &m, &dep) {
      return Printed(pm);
    }
    add(bu, dep);
  }
  return NoFail;
}

func sq_copy_action(gs gr_statep, x *copy_action, out *gr_num) np {
  return sq_bi_action(gs, &x->x, out);
}

func sq_move_action(gs gr_statep, x *move_action, out *gr_num) np {
  dep gr_num;
  if case Printed(pm) = sq_bi_action(gs, &x->x, &dep) {
    return Printed(pm);
  }
  *out = addx(gs.gr, dep, @[gr_xop]GrDead({x->x.src}));
  return NoFail;
}

func sq_uni_fun(gs gr_statep, ip instpair, arg cell_num) gr_num {
  argptr cu_typrop = computed_ptr_type(gs.clq, &ref_cell(gs.gr, arg)->type);
  voidret cu_typrop = compute_prim(gs.clq, primitive_void_type(gs.clq->cs));
  fnptr cu_typrop = compute_prim(gs.clq, fn_type(gs.clq->cs, argptr.cu.x, voidret.cu.x));
  funcell cell_num = add_cell(gs.gr, {LocationStatic, fnptr.cu, fnptr.props});
  argptrcell cell_num = add_cell(gs.gr, {LocationStatic, argptr.cu, argptr.props});
  retvoid cell_num = add_cell(gs.gr, {LocationStatic, voidret.cu, voidret.props});

  bu sq_builder = mk_builder(gs.gr);
  add(&bu, @[gr_xop]GrLive({retvoid}));

  add(&bu, @[gr_xop]GrLive({funcell}));
  add(&bu, @[gr_xop]GrWriteConst({funcell, ConstDef(ip)}));

  add(&bu, @[gr_xop]GrLive({argptrcell}));
  add(&bu, @[gr_xop]GrAddressof({argptrcell, arg}));

  add(&bu, @[gr_xop]GrApply({funcell, mk_shray(argptrcell), retvoid}));
  add(&bu, @[gr_xop]GrDead({retvoid}));
  return done(&bu);
}

func sq_init_action(gs gr_statep, x *init_action, out *gr_num) np {
  bu sq_builder = mk_builder(gs.gr);
  add(&bu, @[gr_xop]GrLive({x->x.arg}));
  switch &x->x.ctor {
  case &TrivialCtor:
    add(&bu, @[gr_xop]GrWriteConst({x->x.arg, ConstInt(bigu(0))}));
  case &FunCtor(ip instpair):
    dp gr_num = sq_uni_fun(gs, ip, x->x.arg);
    add(&bu, dp);
  }
  *out = done(&bu);
  return NoFail;
}

func sq_destroy_action(gs gr_statep, x *destroy_action, dad dead_after_destroy, out *gr_num) np {
  bu sq_builder = mk_builder(gs.gr);
  switch &x->x.ctor {
  case &TrivialCtor: { }
  case &FunCtor(ip instpair):
    gn gr_num = sq_uni_fun(gs, ip, x->x.arg);
    add(&bu, gn);
  }
  if case DeadAfterDestroyYes = dad {
    add(&bu, @[gr_xop]GrDead({x->x.arg}));
  }

  *out = done(&bu);
  return NoFail;
}

func sq_bi_fun(gs gr_statep, ip instpair, dest cell_num, src cell_num) gr_num {
  // In our "bi_fun" uses the dest and src have the same type.  It seems wrong for this menial code to know that, though.
  destptr cu_typrop = computed_ptr_type(gs.clq, &ref_cell(gs.gr, dest)->type);
  srcptr cu_typrop = computed_ptr_type(gs.clq, &ref_cell(gs.gr, src)->type);
  voidret cu_typrop = compute_prim(gs.clq, primitive_void_type(gs.clq->cs));
  fnptr cu_typrop = compute_prim(gs.clq, fn_type(gs.clq->cs, destptr.cu.x, srcptr.cu.x, voidret.cu.x));
  funcell cell_num = add_cell(gs.gr, {LocationStatic, fnptr.cu, fnptr.props});
  destptrcell cell_num = add_cell(gs.gr, {LocationStatic, destptr.cu, destptr.props});
  srcptrcell cell_num = add_cell(gs.gr, {LocationStatic, srcptr.cu, srcptr.props});
  retvoid cell_num = add_cell(gs.gr, {LocationStatic, voidret.cu, voidret.props});

  bu sq_builder = mk_builder(gs.gr);
  add(&bu, @[gr_xop]GrLive({retvoid}));

  add(&bu, @[gr_xop]GrLive({funcell}));
  add(&bu, @[gr_xop]GrWriteConst({funcell, ConstDef(ip)}));

  add(&bu, @[gr_xop]GrLive({destptrcell}));
  add(&bu, @[gr_xop]GrAddressof({destptrcell, dest}));

  add(&bu, @[gr_xop]GrLive({srcptrcell}));
  add(&bu, @[gr_xop]GrAddressof({srcptrcell, src}));

  add(&bu, @[gr_xop]GrApply({funcell, mk_shray(destptrcell, srcptrcell), retvoid}));

  add(&bu, @[gr_xop]GrDead({retvoid}));

  return done(&bu);
}

func sq_bi_action(gs gr_statep, x *bi_action, out *gr_num) np {
  switch &x->ctor {
    case &TrivialCtor: {
      cp var = addx(gs.gr, @[gr_xop]GrMemCopy({x->dest, x->src}));
      *out = cp;
      return NoFail;
    }
    case &FunCtor(ip instpair): {
      *out = sq_bi_fun(gs, ip, x->dest, x->src);
      return NoFail;
    }
  }
}

// TODO: There's a lot of duplicated code in the splay-out of this function.
func sq_magic(clq *clqueue, mag *def_magic, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num], inline_out *should_inline) np {
  switch mag {
  case &MagicBzero(mb magic_bzero):
    if case Printed(pm) = sq_magic_bzero(clq, &mb, gr_out, gn_out, return_cell_out, arg_cells_out) {
      return Printed(pm);
    }
    *inline_out = InlineMust;
    return NoFail;
  case &MagicMemcopy(mm magic_memcopy):
    if case Printed(pm) = sq_magic_memcopy(clq, &mm, gr_out, gn_out, return_cell_out, arg_cells_out) {
      return Printed(pm);
    }
    *inline_out = InlineMust;
    return NoFail;
  case &MagicNopdestroy:
    if case Printed(pm) = sq_magic_nopdestroy(clq, gr_out, gn_out, return_cell_out, arg_cells_out) {
      return Printed(pm);
    }
    *inline_out = InlineMust;
    return NoFail;
  case &MagicCtor(wmc which_magic_ctor):
    if case Printed(pm) = sq_magic_ctor(clq, wmc.wc, &wmc.mc, gr_out, gn_out, return_cell_out, arg_cells_out) {
      return Printed(pm);
    }
    *inline_out = InlineYawn;
    return NoFail;
  case &MagicEnumConstruct(mec magic_enum_construct):
    arg_cell cell_num;
    if case Printed(pm) = gr_magic_enum_construct(clq, &mec, gr_out, gn_out, return_cell_out, &arg_cell) {
      return Printed(pm);
    }
    *arg_cells_out = mk_array(arg_cell);
    *inline_out = InlineMust;
    return NoFail;
  }
}

struct gr_minimal_basics {
  return_cell cell_num;
  argcells array[cell_num];
}

struct gr_basics {
  minimal gr_minimal_basics;
  pointeecells array[cell_num];
}

func add_minimal_basics(gs gr_statep, size u32, arity size, out *gr_minimal_basics) void {
  cs *checkstate = gs.clq->cs;
  pointee_tp cu_typrop = compute_prim(gs.clq, primitive_padding_type(cs, size));
  argtp cu_typrop = compute_prim(gs.clq, ptr_type(cs, pointee_tp.cu.x));
  voidtp cu_typrop = compute_prim(gs.clq, primitive_void_type(cs));
  ret gr_minimal_basics;
  ret.return_cell = add_cell(gs.gr, {LocationStatic, voidtp.cu, voidtp.props});
  for i size = 0; i < arity; i = i + 1 {
    ac cell_num = add_cell(gs.gr, {LocationStatic, argtp.cu, argtp.props});
    push(&ret.argcells, ac);
  }
  *out = ret;
}

func sq_add_basics(gs gr_statep, size u32, arity size, out *gr_basics, bu *sq_builder) void {
  cs *checkstate = gs.clq->cs;
  ret gr_basics;
  add_minimal_basics(gs, size, arity, &ret.minimal);

  pointee_tp cu_typrop = compute_prim(gs.clq, primitive_padding_type(cs, size));
  for i size = 0; i < arity; i = i + 1 {
    pc cell_num = add_cell(gs.gr, {LocationVirtual, pointee_tp.cu, pointee_tp.props});
    push(&ret.pointeecells, pc);
    dn gr_num = addx(gs.gr, @[gr_xop]GrDeref({pc, get(&ret.minimal.argcells, i), OffsetConst(0)}));
    add(bu, dn);
  }
  *out = ret;
}

func sq_minimal_basics_cleanup(gr *frame_graph, bas *gr_minimal_basics, bu *sq_builder) void {
  for i size = count(&bas->argcells); i > 0; {
    i = i - 1;
    add(bu, @[gr_xop]GrDead({get(&bas->argcells, i)}));
  }
  add(bu, @[gr_xop]GrWriteConst({bas->return_cell, ConstInt(bigu(0))}));
}

func sq_basics_cleanup(gs gr_statep, bas *gr_basics, bu *sq_builder) void {
  for i size = count(&bas->pointeecells); i > 0; {
    i = i - 1;
    add(bu, @[gr_xop]GrVirtualDead({get(&bas->pointeecells, i)}));
  }
  sq_minimal_basics_cleanup(gs.gr, &bas->minimal, bu);
}

func sq_magic_nopdestroy(clq *clqueue, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num]) np {
  gr frame_graph = init_frame_graph_empty(intern(clq->im, _s("magic_nopdestroy")));
  celltrack gr_celltrack = mk_celltrack();
  gs gr_statep = {clq, &gr, &celltrack};
  bas gr_minimal_basics;
  // TODO: How about make the size parameter opt[u32], don't deref if no size.
  add_minimal_basics(gs, 0 /* Pass a made-up size. */, 1, &bas);
  bu sq_builder = mk_builder(gs.gr);
  sq_minimal_basics_cleanup(gs.gr, &bas, &bu);
  *gn_out = done(&bu);
  *gr_out = *gs.gr;
  *return_cell_out = bas.return_cell;
  *arg_cells_out = bas.argcells;
  return NoFail;
}

func sq_magic_memcopy(clq *clqueue, mm *magic_memcopy, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num]) np {
  gr frame_graph = init_frame_graph_empty(intern(clq->im, _s("magic_memcopy")));
  celltrack gr_celltrack = mk_celltrack();
  gs gr_statep = {clq, &gr, &celltrack};
  bas gr_basics;
  bu sq_builder = mk_builder(gs.gr);
  sq_add_basics(gs, *un(&mm->size), 2, &bas, &bu);
  add(&bu, @[gr_xop]GrMemCopy({get(&bas.pointeecells, 0), get(&bas.pointeecells, 1)}));
  sq_basics_cleanup(gs, &bas, &bu);
  *gn_out = done(&bu);
  *gr_out = *gs.gr;
  *return_cell_out = bas.minimal.return_cell;
  *arg_cells_out = bas.minimal.argcells;
  return NoFail;
}

func sq_magic_bzero(clq *clqueue, mb *magic_bzero, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num]) np {
  gr frame_graph = init_frame_graph_empty(intern(clq->im, _s("magic_bzero")));
  celltrack gr_celltrack = mk_celltrack();
  gs gr_statep = {clq, &gr, &celltrack};
  bas gr_basics;
  bu sq_builder = mk_builder(gs.gr);
  sq_add_basics(gs, *un(&mb->size), 1, &bas, &bu);
  add(&bu, @[gr_xop]GrWriteConst({get(&bas.pointeecells, 0), ConstInt(bigu(0))}));
  sq_basics_cleanup(gs, &bas, &bu);
  *gn_out = done(&bu);
  *gr_out = *gs.gr;
  *return_cell_out = bas.minimal.return_cell;
  *arg_cells_out = bas.minimal.argcells;
  return NoFail;
}

func sq_magic_ctor(clq *clqueue, wc which_ctor, mc *magic_ctor, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num]) np {
  info *magic_ctor_info = un(&mc->info);
  switch info {
  case &MagicStructInfo(msi magic_struct_info):
    return sq_magic_struct_info(clq, wc, &msi, gr_out, gn_out, return_cell_out, arg_cells_out);
  case &MagicEnumInfo(mei magic_enum_info):
    return gr_magic_enum_info(clq, wc, &mei, gr_out, gn_out, return_cell_out, arg_cells_out);
  case &MagicArraytypeInfo(mai magic_arraytype_info):
    return sq_magic_arraytype_info(clq, wc, &mai, gr_out, gn_out, return_cell_out, arg_cells_out);
  }
}

func sq_magic_arraytype_info(clq *clqueue, wc which_ctor, mai *magic_arraytype_info, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num]) np {
  cs *checkstate = clq->cs;
  gr frame_graph = init_frame_graph_empty(intern(clq->im, _s("magic_arraytype")));
  argtp cu_typrop = compute_prim(clq, ptr_type(cs, mai->cu_type.x));

  voidtp cu_typrop = compute_prim(clq, primitive_void_type(cs));

  param *te_typeexpr;
  arraycount u32;
  if case &TeArraytype(at te_arraytype) = &mai->cu_type.x {
    param = oo(&at.param);
    if case Has(atcount u32) = at.count {
      arraycount = atcount;
    } else {
      ice(_u8("gr_magic_arraytype_info missing count"));
    }
  } else {
    ice(_u8("gr_magic_arraytype_info sees non-array type"));
  }

  param_props type_properties;
  if case Printed(pm) = compute_complete_type_properties(clq, param, &param_props) {
    return Printed(pm);
  }

  elemptrtype cu_typeexpr;
  elemptrtype_props type_properties;
  compute_prim(clq, ptr_type(cs, *param), &elemptrtype, &elemptrtype_props);

  nargs size = num_args(wc);

  fntype cu_typeexpr;
  fntype_props type_properties;
  compute_prim(clq, fn_type(cs, @[shray[_]]repeat(nargs, elemptrtype.x), voidtp.cu.x), &fntype, &fntype_props);

  size_type cu_typeexpr;
  size_type_props type_properties;
  compute_prim(clq, primitive_size_type(cs), &size_type, &size_type_props);

  argcells array[cell_num];
  pointeecells array[cell_num];
  deref_bu sq_builder = mk_builder(&gr);
  for i size = 0; i < nargs; i = i + 1 {
    ac cell_num = add_cell(&gr, {LocationStatic, argtp.cu, argtp.props});
    push(&argcells, ac);
    pc cell_num = add_cell(&gr, {LocationVirtual, mai->cu_type, mai->cu_props});
    push(&pointeecells, pc);

    add(&deref_bu, @[gr_xop]GrDeref({pc, ac, OffsetConst(0)}));
    add(&deref_bu, @[gr_xop]GrDead({ac}));
  }

  bu sq_builder = mk_builder(&gr);
  add(&bu, done(&deref_bu));

  terminal_case u32;
  init_value u32;
  if case CtorDestroy = wc {
    init_value = arraycount;
    terminal_case = 0;
  } else {
    init_value = 0;
    terminal_case = arraycount;
  }

  indexcell cell_num = add_cell(&gr, {LocationStatic, size_type, size_type_props});
  add(&bu, @[gr_xop]GrLive({indexcell}));
  add(&bu, @[gr_xop]GrWriteConst({indexcell, ConstInt(bigu(init_value))}));

  return_cell cell_num = add_cell(&gr, {LocationStatic, voidtp.cu, voidtp.props});

  deadseq_nopq sq_num = nopq(&gr);

  topgn sq_num = nopq(&gr);

  loop_bu sq_builder = mk_builder(&gr);
  for i size = 0; i < 2; i = i + 1 {
    if (CtorDestroy == wc) == (i == 0) {
      incr_bu sq_builder = mk_builder(&gr);
      ic2cell cell_num = add_cell(&gr, {LocationStatic, size_type, size_type_props});
      add(&incr_bu, @[gr_xop]GrLive({ic2cell}));
      add(&incr_bu, @[gr_xop]GrMemCopy({ic2cell, indexcell}));
      onecell cell_num = add_cell(&gr, {LocationStatic, size_type, size_type_props});
      add(&incr_bu, @[gr_xop]GrLive({onecell}));
      add(&incr_bu, @[gr_xop]GrWriteConst({onecell, ConstInt(bigu(1))}));
      op_action primitive_numeric_op_action;
      if case CtorDestroy = wc {
        op_action = NumSub;
      } else {
        op_action = NumAdd;
      }
      add(&incr_bu, @[gr_xop]GrPrimApply({PrimNum({cs->plat.sizetraits.flat.size, cs->plat.sizetraits.numeric, op_action}), mk_shray(ic2cell, onecell), indexcell}));
      incrgn gr_num = done(&incr_bu);
      add(&loop_bu, incrgn);
    } else {
      vd_bu sq_builder = mk_builder(&gr);

      elemretcell cell_num = add_cell(&gr, {LocationStatic, voidtp.cu, voidtp.props});
      // Order here doesn't matter, but we do ret cell before the others.
      add(&vd_bu, @[gr_xop]GrLive({elemretcell}));

      func_cell cell_num = add_cell(&gr, {LocationStatic, fntype, fntype_props});

      add(&vd_bu, @[gr_xop]GrLive({func_cell}));
      add(&vd_bu, @[gr_xop]GrWriteConst({func_cell, ConstDef(mai->ip)}));

      elemptrcells array[cell_num];
      for j size = 0; j < nargs; j = j + 1 {
        ec cell_num = add_cell(&gr, {LocationVirtual, ~ *param, param_props});
        indexcopycell cell_num = add_cell(&gr, {LocationStatic, size_type, size_type_props});
        add(&vd_bu, @[gr_xop]GrLive({indexcopycell}));
        add(&vd_bu, @[gr_xop]GrMemCopy({indexcopycell, indexcell}));
        add(&vd_bu, @[gr_xop]GrSubcell({ec, get(&pointeecells, j), OffsetComputed({param_props.flat_size, indexcopycell})}));
        add(&vd_bu, @[gr_xop]GrDead({indexcopycell}));
        epc cell_num = add_cell(&gr, {LocationStatic, elemptrtype, elemptrtype_props});
        push(&elemptrcells, epc);
        add(&vd_bu, @[gr_xop]GrLive({epc}));
        add(&vd_bu, @[gr_xop]GrAddressof({epc, ec}));
        add(&vd_bu, @[gr_xop]GrVirtualDead({ec}));
      }

      add(&vd_bu, @[gr_xop]GrApply({func_cell, freeze(&elemptrcells), elemretcell}));
      add(&vd_bu, @[gr_xop]GrDead({elemretcell}));
      vd gr_num = done(&vd_bu);
      add(&loop_bu, vd);
    }
  }

  tie_gn sq_num = mut_connect(&loop_bu, topgn);

  branch_gn sq_num = addq(&gr, @[gr_qop]GrBranch({indexcell, mk_shray({@[gr_const]ConstInt(bigu(terminal_case)), deadseq_nopq}), Has(tie_gn)}));

  mut_qnop_node(&gr, topgn, {@[gr_qop]GrJmp({branch_gn})});

  deadprec_bu sq_builder = mk_builder(&gr);
  for i size = nargs; i > 0; {
    i = i - 1;
    add(&deadprec_bu, @[gr_xop]GrVirtualDead({get(&pointeecells, i)}));
  }
  add(&deadprec_bu, @[gr_xop]GrDead({indexcell}));
  add(&deadprec_bu, @[gr_xop]GrWriteConst({return_cell, ConstInt(bigu(0))}));

  mut_qnop_node(&gr, deadseq_nopq, done(&deadprec_bu), nopq(&gr));

  add(&bu, topgn.x);
  *gr_out = gr;
  *gn_out = done(&bu);
  *return_cell_out = return_cell;
  *arg_cells_out = argcells;
  return NoFail;
}

func gr_magic_enum_info(clq *clqueue, wc which_ctor, mei *magic_enum_info, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num]) np {
  cs *checkstate = clq->cs;
  init_padding bool = false;
  switch wc {
  case CtorInit:
    ice(_u8("Magic CtorInit on enum type"));
  case CtorCopy:
    init_padding = true;
  case CtorMove:
    init_padding = true;
  case CtorDestroy: { /* don't init padding. */ }
  }
  gr frame_graph = init_frame_graph_empty(intern(cs->im, _s("magic_enum_info")));
  celltrack gr_celltrack = mk_celltrack();
  gs gr_statep = {clq, &gr, &celltrack};

  argtp cu_typrop = compute_prim(clq, ptr_type(cs, mei->cu_type.x));

  voidtp cu_typrop = compute_prim(clq, primitive_void_type(cs));

  et *enumspec = &mei->et;

  tagtype cu_typeexpr;
  tagtype_props type_properties;
  compute_prim(clq, enum_tag_type(cs, et), &tagtype, &tagtype_props);

  argcells array[cell_num];
  pointeecells array[cell_num];
  tagcells array[cell_num];

  deref_bu sq_builder = mk_builder(&gr);
  nargs size = num_args(wc);
  for i size = 0; i < nargs; i = i + 1 {
    ac cell_num = add_cell(&gr, {LocationStatic, argtp.cu, argtp.props});
    push(&argcells, ac);
    pc cell_num = add_cell(&gr, {LocationVirtual, mei->cu_type, mei->cu_props});
    push(&pointeecells, pc);
    tc cell_num = add_cell(&gr, {LocationVirtual, tagtype, tagtype_props});
    push(&tagcells, tc);

    add(&deref_bu, @[gr_xop]GrDeref({pc, ac, OffsetConst(0)}));
    add(&deref_bu, @[gr_xop]GrDead({ac}));
    add(&deref_bu, @[gr_xop]GrSubcell({tc, pc, OffsetConst(enum_tag_offset)}));
  }

  bu sq_builder = mk_builder(&gr);
  add(&bu, done(&deref_bu));

  return_cell cell_num = add_cell(&gr, {LocationStatic, voidtp.cu, voidtp.props});

  deadseq_nopq sq_num = nopq(&gr);

  cases_gn array[tup[gr_const, sq_num]];
  nconstructors size = count(&et->constructors);
  for i size = 0; i < nconstructors; i = i + 1 {
    tagval enum_tag_value = mk_enum_tag_value(i);

    fieldtype cu_typeexpr = ~ref(&et->constructors, i)->type;
    fieldtype_props type_properties;
    if case Printed(pm) = compute_type_properties(clq, &fieldtype, &fieldtype_props) {
      return Printed(pm);
    }

    field_offset u32 = enum_field_offset(cs, et, tagval);
    field_end u32 = field_offset + fieldtype_props.flat_size;
    tag_end u32 = enum_tag_offset + tagtype_props.flat_size;
    prepadding_ogn opt[gr_num]
      = gr_bzero_subcell(gs, get(&pointeecells, 0), tag_end, field_offset - tag_end);
    postpadding_ogn opt[gr_num]
      = gr_bzero_subcell(gs, get(&pointeecells, 0), field_end, mei->cu_props.flat_size - field_end);

    fieldcella array[cell_num];
    fieldcellgn array[gr_num];
    for j size = 0; j < nargs; j = j + 1 {
      fc cell_num = add_cell(&gr, {LocationVirtual, fieldtype, fieldtype_props});
      push(&fieldcella, fc);
      sn gr_num = addx(&gr, @[gr_xop]GrSubcell({get(&fieldcella, j), get(&pointeecells, j), OffsetConst(field_offset)}));
      push(&fieldcellgn, sn);
    }

    last_ogn gr_num;
    if case &Has(ip instpair) = ref(&mei->cips, i) {
      fieldptrtype cu_typeexpr;
      fieldptrtype_props type_properties;
      compute_prim(clq, ptr_type(cs, fieldtype.x), &fieldptrtype, &fieldptrtype_props);

      fieldptrcella array[cell_num];
      prec gr_num = nopq(&gr).x;
      for j size = 0; j < nargs; j = j + 1 {
        fpc cell_num = add_cell(&gr, {LocationStatic, fieldptrtype, fieldptrtype_props});
        push(&fieldptrcella, fpc);
        fpc_live gr_num = addx(&gr, @[gr_xop]GrLive({fpc}));
        an1 gr_num = addx(&gr, seq2(&gr, fpc_live, get(&fieldcellgn, j)).x, @[gr_xop]GrAddressof({fpc, get(&fieldcella, j)}));
        an gr_num = addx(&gr, an1, @[gr_xop]GrVirtualDead({get(&fieldcella, j)}));
        prec = seq2(&gr, prec, an).x;
      }

      fntype cu_typeexpr;
      fntype_props type_properties;
      compute_prim(clq, fn_type(cs, @[shray[_]]repeat(nargs, fieldptrtype.x), voidtp.cu.x), &fntype, &fntype_props);

      func_cell cell_num = add_cell(&gr, {LocationStatic, fntype, fntype_props});
      func_cell_live gr_num = addx(&gr, @[gr_xop]GrLive({func_cell}));
      func_gn gr_num = addx(&gr, func_cell_live, @[gr_xop]GrWriteConst({func_cell, ConstDef(ip)}));
      prec = seq2(&gr, func_gn, prec).x;

      fieldretcell cell_num = add_cell(&gr, {LocationStatic, voidtp.cu, voidtp.props});
      prec = seq2(&gr, addx(&gr, @[gr_xop]GrLive({fieldretcell})), prec).x;

      ap gr_num = addx(&gr, prec, @[gr_xop]GrApply({func_cell, freeze(&fieldptrcella), fieldretcell}));
      vd gr_num = addx(&gr, ap, @[gr_xop]GrDead({fieldretcell}));
      last_ogn = vd;
    } else {
      ogn opt[gr_num];
      switch wc {
      case CtorInit:
        ice(_u8("CtorInit on enum type"));
      case CtorCopy:
        cgn var = addx(&gr, seqN(&gr, &fieldcellgn).x, @[gr_xop]GrMemCopy({get(&fieldcella, 0), get(&fieldcella, 1)}));
        ogn = Has(cgn);
      case CtorMove:
        cgn var = addx(&gr, seqN(&gr, &fieldcellgn).x, @[gr_xop]GrMemCopy({get(&fieldcella, 0), get(&fieldcella, 1)}));
        ogn = Has(cgn);
      case CtorDestroy:
        ogn = None;
        // do nothing.
      }
      if case Has(gn gr_num) = ogn {
        dfcprec gr_num = nopq(&gr).x;
        for j size = 0; j < nargs; j = j + 1 {
          dfc var = addx(&gr, @[gr_xop]GrVirtualDead({get(&fieldcella, j)}));
          dfcprec = seq2(&gr, dfc, dfcprec).x;
        }
        last_ogn = seq2(&gr, gn, dfcprec).x;
      } else {
        // The nodes that create fieldcella were never added to the graph, so we don't dead them.
        last_ogn = nopq(&gr).x;
      }
    }

    tagset_ogn opt[gr_num];
    switch wc {
    case CtorInit:
      ice(_u8("CtorInit on wc type"));
    case CtorCopy:
      tgn var = addx(&gr, @[gr_xop]GrWriteConst({get(&tagcells, 0), ConstInt(~ tagval.x)}));
      tagset_ogn = Has(tgn);
    case CtorMove:
      tgn var = addx(&gr, @[gr_xop]GrWriteConst({get(&tagcells, 0), ConstInt(~ tagval.x)}));
      tagset_ogn = Has(tgn);
    case CtorDestroy:
      tagset_ogn = None;
    }

    finalgn gr_num = addx(&gr, seq(&gr, tagset_ogn, prepadding_ogn, @[opt[gr_num]]Has(last_ogn), postpadding_ogn).x, @[gr_xop]GrXNop);

    finalseqgn sq_num = seqq(&gr, {finalgn, deadseq_nopq});
    push(&cases_gn, {@[gr_const]ConstInt(~ tagval.x), finalseqgn});
  }

  if true {
    if case CtorDestroy = wc {
      push(&cases_gn, {@[gr_const]ConstInt(bigu(0)), deadseq_nopq});
    } else {
      ztgn gr_num = addx(&gr, @[gr_xop]GrWriteConst({get(&pointeecells, 0), ConstInt(bigu(0))}));
      ztseq sq_num = seqq(&gr, {ztgn, deadseq_nopq});
      push(&cases_gn, {@[gr_const]ConstInt(bigu(0)), ztseq});
    }
  }

  br sq_num = addq(&gr, @[gr_qop]GrBranch({get(&tagcells, nargs - 1), freeze(&cases_gn), None}));
  append(&bu, br, deadseq_nopq);
  for i size = nargs; i > 0; {
    i = i - 1;
    add(&bu, @[gr_xop]GrVirtualDead({get(&pointeecells, i)}));
    add(&bu, @[gr_xop]GrVirtualDead({get(&tagcells, i)}));
  }
  add(&bu, @[gr_xop]GrWriteConst({return_cell, ConstInt(~ @[u32] 0)}));
  *gr_out = gr;
  *gn_out = done(&bu);
  *return_cell_out = return_cell;
  *arg_cells_out = argcells;
  return NoFail;
}

func seqqo(gr *frame_graph, a opt[gr_num], onto sq_num) sq_num {
  if case Has(gn gr_num) = a {
    return seqq(gr, {gn, onto});
  } else {
    return onto;
  }
}

func seq(gr *frame_graph, a opt[gr_num], b opt[gr_num], c opt[gr_num], d opt[gr_num]) sq_num {
  build sq_num = nopq(gr);
  build = seqqo(gr, d, build);
  build = seqqo(gr, c, build);
  build = seqqo(gr, b, build);
  build = seqqo(gr, a, build);
  return build;
}

func seq(gr *frame_graph, a opt[gr_num], b opt[gr_num], c opt[gr_num]) sq_num {
  build sq_num = nopq(gr);
  build = seqqo(gr, c, build);
  build = seqqo(gr, b, build);
  build = seqqo(gr, a, build);
  return build;
}

func seq(gr *frame_graph, a opt[gr_num], b opt[gr_num]) sq_num {
  build sq_num = nopq(gr);
  build = seqqo(gr, b, build);
  build = seqqo(gr, a, build);
  return build;
}

func sq_magic_struct_info(clq *clqueue, wc which_ctor, msi *magic_struct_info, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num]) np {
  cs *checkstate = clq->cs;
  // Destructors go in reverse order (which means we prepend them in the reverse of reverse order).
  reverse_order bool = false;
  // Init, copy, and move requires initializing intervening padding.
  init_padding bool = true;
  if case CtorDestroy = wc {
    reverse_order = true;
    init_padding = false;
  }

  gr frame_graph = init_frame_graph_empty(intern(cs->im, _s("magic_struct_info")));
  celltrack gr_celltrack = mk_celltrack();
  gs gr_statep = {clq, &gr, &celltrack};

  argtp cu_typrop = compute_prim(clq, ptr_type(cs, msi->cu_type.x));

  voidtp cu_typrop = compute_prim(clq, primitive_void_type(cs));

  st *structspec = &msi->st;

  psd partial_struct_data;
  if case Printed(pm) = compute_partial_struct_data(clq, &st->fields, None, &psd) {
    return Printed(pm);
  }

  argcells array[cell_num];
  pointeecells array[cell_num];
  deref_bu sq_builder = mk_builder(&gr);
  nargs size = num_args(wc);
  for i size = 0; i < nargs; i = i + 1 {
    ac cell_num = add_cell(&gr, {LocationStatic, argtp.cu, argtp.props});
    push(&argcells, ac);
    pc cell_num = add_cell(&gr, {LocationVirtual, msi->cu_type, msi->cu_props});
    push(&pointeecells, pc);

    add(&deref_bu, @[gr_xop]GrDeref({pc, ac, OffsetConst(0)}));
    add(&deref_bu, @[gr_xop]GrDead({ac}));
  }

  return_cell cell_num = add_cell(&gr, {LocationStatic, voidtp.cu, voidtp.props});

  bu sq_builder = mk_builder(&gr);
  add(&bu, done(&deref_bu));

  nfields size = count(&msi->fips);
  check(nfields == count(&st->fields));
  for i2 size = 0; i2 < nfields; i2 = i2 + 1 {
    i size;
    if reverse_order {
      i = nfields - i2 - 1;
    } else {
      i = i2;
    }

    fieldcella array[cell_num];
    fieldcellops array[gr_xop];
    for j size = 0; j < nargs; j = j + 1 {
      fc cell_num = add_cell(&gr, {LocationVirtual, ~ ref(&st->fields, i)->type, ref(&psd.fields, i)->props});
      push(&fieldcella, fc);

      push(&fieldcellops, @[gr_xop]GrSubcell({fc, get(&pointeecells, j), OffsetConst(ref(&psd.fields, i)->offset)}));
    }

    sub_bu sq_builder = mk_builder(&gr);
    if case Has(ip instpair) = get(&msi->fips, i) {
      fieldptrtype cu_typeexpr;
      fieldptrtype_props type_properties;
      compute_prim(clq, ptr_type(cs, ref(&st->fields, i)->type), &fieldptrtype, &fieldptrtype_props);

      fieldretcell cell_num = add_cell(&gr, {LocationStatic, voidtp.cu, voidtp.props});
      add(&sub_bu, @[gr_xop]GrLive({fieldretcell}));

      fntype cu_typeexpr;
      fntype_props type_properties;
      compute_prim(clq, fn_type(cs, @[shray[_]]repeat(nargs, fieldptrtype.x), voidtp.cu.x), &fntype, &fntype_props);

      func_cell cell_num = add_cell(&gr, {LocationStatic, fntype, fntype_props});

      add(&sub_bu, @[gr_xop]GrLive({func_cell}));
      add(&sub_bu, @[gr_xop]GrWriteConst({func_cell, ConstDef(ip)}));

      fieldptrcella array[cell_num];
      prec gr_num = nopq(&gr).x;
      for j size = 0; j < nargs; j = j + 1 {
        fpc cell_num = add_cell(&gr, {LocationStatic, fieldptrtype, fieldptrtype_props});
        push(&fieldptrcella, fpc);
        add(&sub_bu, @[gr_xop]GrLive({fpc}));
        add(&sub_bu, get(&fieldcellops, j));
        add(&sub_bu, @[gr_xop]GrAddressof({fpc, get(&fieldcella, j)}));
        add(&sub_bu, @[gr_xop]GrVirtualDead({get(&fieldcella, j)}));
      }

      add(&sub_bu, @[gr_xop]GrApply({func_cell, freeze(&fieldptrcella), fieldretcell}));
      add(&sub_bu, @[gr_xop]GrDead({fieldretcell}));
    } else {
      evaled_fieldcellops bool = true;
      if case CtorDestroy = wc {
        evaled_fieldcellops = false;
      } else {
        for j size = 0; j < nargs; j = j + 1 {
          add(&sub_bu, get(&fieldcellops, j));
        }
        switch wc {
        case CtorInit:
          // zero-initialize.
          add(&sub_bu, @[gr_xop]GrWriteConst({get(&fieldcella, 0), ConstInt(~ @[u32] 0)}));
        case CtorCopy:
          add(&sub_bu, @[gr_xop]GrMemCopy({get(&fieldcella, 0), get(&fieldcella, 1)}));
        case CtorMove:
          add(&sub_bu, @[gr_xop]GrMemCopy({get(&fieldcella, 0), get(&fieldcella, 1)}));
        }
      }

      if evaled_fieldcellops {
        for j size = nargs; j > 0; {
          j = j - 1;
          add(&sub_bu, @[gr_xop]GrVirtualDead({get(&fieldcella, j)}));
        }
      }
    }

    // There is no particular reason why we bzero the padding _after_ we do the fields.
    if init_padding {
      padding_offset u32;
      padding_count u32;
      postpadding_offset_and_count(&psd, i, &padding_offset, &padding_count);
      if case Has(bzero_gn gr_num) = gr_bzero_subcell(gs, get(&pointeecells, 0), padding_offset, padding_count) {
        add(&sub_bu, bzero_gn);
      }
    }

    add(&bu, done(&sub_bu));
  }

  for i size = nargs; i > 0; {
    i = i - 1;
    add(&bu, @[gr_xop]GrVirtualDead({get(&pointeecells, i)}));
  }
  add(&bu, @[gr_xop]GrWriteConst({return_cell, ConstInt(~ @[u32] 0)}));

  gn gr_num = done(&bu);

  *gr_out = gr;
  *gn_out = gn;
  *return_cell_out = return_cell;
  *arg_cells_out = argcells;
  return NoFail;
}

func gr_bzero_subcell(gs gr_statep, c cell_num, offset u32, size u32) opt[gr_num] {
  if size == 0 {
    return None;
  }
  padtype cu_typrop = compute_prim(gs.clq, primitive_padding_type(gs.clq->cs, size));
  pad_cell cell_num = add_cell(gs.gr, {LocationVirtual, padtype.cu, padtype.props});
  subcell_gn var = addx(gs.gr, @[gr_xop]GrSubcell({pad_cell, c, OffsetConst(offset)}));
  bzero_gn var = addx(gs.gr, subcell_gn, @[gr_xop]GrWriteConst({pad_cell, ConstInt(bigu(0))}));
  vd_gn var = addx(gs.gr, bzero_gn, @[gr_xop]GrVirtualDead({pad_cell}));
  return Has(vd_gn);
}

func postpadding_offset_and_count(psd *partial_struct_data, i size, offset_out *u32, count_out *u32) void {
  check(i < psd_index(psd));
  begin u32 = ref(&psd->fields, i)->offset + ref(&psd->fields, i)->props.flat_size;
  end u32;
  if i + 1 < psd_index(psd) {
    end = ref(&psd->fields, i + 1)->offset;
  } else {
    end = psd->offset;
  }
  *offset_out = begin;
  *count_out = end - begin;
}

func gr_magic_enum_construct(clq *clqueue, mec *magic_enum_construct, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cell_out *cell_num) np {
  gr frame_graph = init_frame_graph_empty(intern(clq->im, _s("magic_enum_construct")));
  celltrack gr_celltrack = mk_celltrack();
  gs gr_statep = {clq, &gr, &celltrack};

  retnum cell_num = add_cell(&gr, {LocationStatic, mec->return_type, mec->return_type_props});

  tagval enum_tag_value = mk_enum_tag_value(mec->constructor_index);

  argtype *te_typeexpr = &ref(&mec->et.constructors, mec->constructor_index)->type;
  field_offset u32 = enum_field_offset(clq->cs, &mec->et, tagval);
  tag_end u32;
  tag_cell cell_num;
  if true {
    cu cu_typeexpr;
    props type_properties;
    compute_prim(clq, enum_tag_type(clq->cs, &mec->et), &cu, &props);
    tag_end = props.flat_size;
    tag_cell = add_cell(&gr, {LocationVirtual, cu, props});
  }

  prepadding_ogn opt[gr_num]
    = gr_bzero_subcell(gs, retnum, tag_end, field_offset - tag_end);
  field_end u32 = field_offset + mec->rhs_props.flat_size;
  postpadding_ogn opt[gr_num]
    = gr_bzero_subcell(gs, retnum, field_end, mec->return_type_props.flat_size - field_end);

  argnum cell_num = add_cell(&gr, {LocationStatic, ~ *argtype, mec->rhs_props});
  retpart cell_num = add_cell(&gr, {LocationVirtual, ~ *argtype, mec->rhs_props});

  retpart_gn var = addx(&gr, @[gr_xop]GrSubcell({retpart, retnum, OffsetConst(field_offset)}));

  ctor_gn gr_num;
  switch &mec->operational {
  case &EnumConstructMove(cd ctor_desc):
    bi_ctor_gn1 gr_num;
    if case Printed(pm) = sq_bi_ctor(gs, argtype, retpart, argnum, &cd, &bi_ctor_gn1) {
      return Printed(pm);
    }
    bi_ctor_gn gr_num = addx(&gr, bi_ctor_gn1, @[gr_xop]GrVirtualDead({retpart}));
    ctor_gn = addx(&gr, bi_ctor_gn, @[gr_xop]GrDead({argnum}));

  case &EnumConstructCopyDestroy(cdd copy_destroy_desc):
    cpgn1 gr_num;
    if case Printed(pm) = sq_bi_ctor(gs, argtype, retpart, argnum, &cdd.copy_desc, &cpgn1) {
      return Printed(pm);
    }
    cpgn gr_num = addx(&gr, cpgn1, @[gr_xop]GrVirtualDead({retpart}));
    destgn gr_num;
    if case Printed(pm) = sq_destroy_ctor(gs, argtype, argnum, &cdd.destroy_desc, &destgn) {
      return Printed(pm);
    }
    ctor_gn = seq2(&gr, cpgn, destgn).x;
  }

  assign_gn var = seq2(&gr, retpart_gn, ctor_gn);

  tagcell_gn var = addx(&gr, @[gr_xop]GrSubcell({tag_cell, retnum, OffsetConst(enum_tag_offset)}));
  tag_gn1 var = addx(&gr, tagcell_gn, @[gr_xop]GrWriteConst({tag_cell, ConstInt(~tagval.x)}));
  tag_gn var = addx(&gr, tag_gn1, @[gr_xop]GrVirtualDead({tag_cell}));
  gn var = addx(&gr, seq(&gr, @[opt[gr_num]]Has(tag_gn), prepadding_ogn, @[opt[gr_num]]Has(assign_gn.x), postpadding_ogn).x, @[gr_xop]GrXNop);
  *gr_out = gr;
  *gn_out = gn;
  *return_cell_out = retnum;
  *arg_cell_out = argnum;
  return NoFail;
}

func sq_bi_ctor(gs gr_statep, ty *te_typeexpr, destnum cell_num, srcnum cell_num, cd *ctor_desc, gn_out *gr_num) np {
  switch cd {
  case &TrivialCtor:
    *gn_out = addx(gs.gr, @[gr_xop]GrMemCopy({destnum, srcnum}));
  case &FunCtor(ip instpair):
    *gn_out = sq_bi_fun(gs, ip, destnum, srcnum);
  }
  return NoFail;
}

func sq_destroy_ctor(gs gr_statep, ty *te_typeexpr, argnum cell_num, cd *ctor_desc, gn_out *gr_num) np {
  switch cd {
  case &TrivialCtor:
    dp var = addx(gs.gr, @[gr_xop]GrDead({argnum}));
    *gn_out = dp;
  case &FunCtor(ip instpair):
    gn gr_num = sq_uni_fun(gs, ip, argnum);
    dp var = addx(gs.gr, gn, @[gr_xop]GrDead({argnum}));
    *gn_out = dp;
  }
  return NoFail;
}

func add_prim_fn_body(clq *clqueue, informal_name sym, type *cu_typeexpr, op primitive_op) fn_body_id {
  gr frame_graph = init_frame_graph_empty(informal_name);
  typarams *shray[te_typeexpr];
  if !decompose_typeapp(&type->x, primitive_function_puretype(clq->cs), &typarams) {
    ice(_u8("add_prim_fn_body called with non-fn type"));
  }
  argcells array[cell_num];
  ntyparams size = count(typarams);
  nfn_params size = ntyparams - 1;
  for i size = 0; i < nfn_params; i = i + 1 {
    ty *te_typeexpr = ref(typarams, i);
    props type_properties;
    if case Printed(pm) = compute_complete_type_properties(clq, ty, &props) {
      ice(_u8("add_prim_fn_body typrops"));
    }
    c cell_num = add_cell(&gr, {LocationStatic, ~ *ty, props});
    push(&argcells, c);
  }
  retty *te_typeexpr = ref(typarams, ntyparams - 1);
  retprops type_properties;
  if case Printed(pm) = compute_complete_type_properties(clq, retty, &retprops) {
    ice(_u8("add_prim_fn_body retprops"));
  }
  retcell cell_num = add_cell(&gr, {LocationStatic, ~ *retty, retprops});

  argcells_copy array[cell_num] = argcells;
  argshray shray[cell_num] = freeze(&argcells_copy);
  gn gr_num = addx(&gr, @[gr_xop]GrPrimApply({op, argshray, retcell}));
  return add_fn_body(clq->cs, {informal_name, NotComputed, NotComputed, @[fn_body_entry_enum]GraphedFnBody({FnBodyPrim(op), {gr, gn, retcell}, argcells, InlineMust, NotComputed})});
}

func ensure_def_inst_graphed(clq *clqueue, ent_id def_entry_id, inst_id def_inst_id) np {
  if case Printed(pm) = ensure_def_inst_checked(clq->cs, clq, ent_id, inst_id) {
    return Printed(pm);
  }

  ent *def_entry = ref_def_entry(clq->cs, ent_id);
  inst *def_inst = ref_inst(clq->cs, inst_id);
  inst_typrop *cu_typrop = un(&inst->typrop);
  switch &inst->graph {
    case &NotComputed: {
      inst->graph = BeganComputing;
      switch &inst->rhs {
        case &InstRhsPrim(op primitive_op): {
          id fn_body_id = add_prim_fn_body(clq, ent->def_name, &inst_typrop->cu, op);
          frg frame_regraphed = mk_const_frame_regraphed(ent->def_name, &inst_typrop->cu, &inst_typrop->props, ConstFnBody(id));
          inst->graph = Computed(Has(frg));
          return NoFail;
        }
        case &InstRhsExtern: {
          id fn_body_id = add_fn_body(clq->cs, {ent->def_name, NotComputed, NotComputed, @[fn_body_entry_enum]ExternFnBody({ent->def_name})});
          frg frame_regraphed = mk_const_frame_regraphed(ent->def_name, &inst_typrop->cu, &inst_typrop->props, ConstFnBody(id));
          inst->graph = Computed(Has(frg));
          return NoFail;
        }
        case &InstRhsExpr(dire def_inst_rhs_expr): {
          info *frame_info;
          if case &Computed(finfo) = &dire.frame_info {
            info = &finfo;
          } else {
            ice(_u8("ensure_def_inst_graphed missing 'dire' info"));
          }
          gr frame_graph = init_frame_graph_from_incomplete(&info->incomplete_graph);
          celltrack gr_celltrack = mk_celltrack();
          gn gr_num;
          if case Printed(pm) = sq_live_and_expr_consume({clq, &gr, &celltrack}, &dire.ec, &gn) {
            inst->graph = FailedComputation;
            return Printed(pm);
          }
          inst->graph = Computed(Has(@[frame_regraphed]{gr, gn, result_cell(&dire.ec)}));
          return NoFail;
        }

        case &InstRhsNonMagic(nonmag def_non_magic): {
          switch &nonmag {
          case &NonMagicCtor(wnmc which_non_magic_ctor):
            info *non_magic_ctor_info = un(&wnmc.nmc.info);
            frg frame_regraphed = mk_const_frame_regraphed(ent->def_name, &inst_typrop->cu, &inst_typrop->props, ConstDef(info->ip));
            inst->graph = Computed(Has(frg));
            return NoFail;
          case &NonMagicProp(nmp non_magic_prop):
            info u32 = *un(&nmp.info);
            frg frame_regraphed = mk_const_frame_regraphed(ent->def_name, &inst_typrop->cu, &inst_typrop->props, @[gr_const]ConstInt(~info));
            inst->graph = Computed(Has(frg));
            return NoFail;
          }
        }

        case &InstRhsMagic(mag def_magic): {
          id fn_body_id;
          if true {
            body_gr frame_graph;
            body_gn gr_num;
            return_cell cell_num;
            arg_cells array[cell_num];
            inline should_inline;
            if case Printed(pm) = sq_magic(clq, &mag, &body_gr, &body_gn, &return_cell, &arg_cells, &inline) {
              return Printed(pm);
            }
            id = add_fn_body(clq->cs, {ent->def_name, NotComputed, NotComputed, @[fn_body_entry_enum]GraphedFnBody({FnBodyMagic(&mag), {body_gr, body_gn, return_cell}, arg_cells, inline, NotComputed})});
          }

          frg frame_regraphed = mk_const_frame_regraphed(ent->def_name, &inst_typrop->cu, &inst_typrop->props, ConstFnBody(id));
          inst->graph = Computed(Has(frg));
          return NoFail;
        }
      }
    }
    case &BeganComputing: {
      ice(_u8("ensure_def_inst_graphed recursively computing"));
      return fake();
    }
    case &FailedComputation: {
      return ERR(_u8("ensure_def_inst_graphed fails again on same def"));
    }
    case &Computed(odr opt[frame_regraphed]): {
      return NoFail;
    }
  }
}

func mk_const_frame_regraphed(informal_name sym, type *cu_typeexpr, props *type_properties, c gr_const) frame_regraphed {
  gr frame_graph = init_frame_graph_empty(informal_name);
  cell cell_num = add_cell(&gr, {LocationStatic, *type, *props});
  cell_live gr_num = addx(&gr, @[gr_xop]GrLive({cell}));
  gn gr_num = addx(&gr, cell_live, @[gr_xop]GrWriteConst({cell, c}));
  return {gr, gn, cell};
}
