import state;

func[H] build_u8str(help H, r *array[u8], x *lives) void {
  build_u8str(help, r, &x->all);
}

func dumbly_analyze_returning_expression(h *frame, gr *frame_graph, liveset *lives, gn gr_num) bool {
  mbmut genexpr_result;
  if !dumbly_analyze_expression(h, gr, liveset, gn, &mbmut) {
    return false;
  }
  switch &mbmut {
  case &Terminal(v void):
    return true;
  case &NonTerminal(v void):
    ERR(_u8("ICE: Expecting terminal expression, for gn "), gn.~, _u8(" in "), lookup(h->im, gr->informal_name));
    return false;
  }
}

defenum genexpr_result {
  Terminal void;
  NonTerminal void;
};


func dumbly_analyze_expression(h *frame, gr *frame_graph, liveset *lives, gn gr_num, out *genexpr_result) bool {
  gnc *gn_annot = ref_annot(h, gn);
  if case &Computed(live lives_checksum) = &gnc->plainly_live {
    // TODO: We should also check that we're part of the same sequential _family_ of exprs.
    if !(liveset->xored == live.xored && liveset->summed == live.summed) {
      ERR(_u8("ICE: Inconsistent liveness state when revisiting node, liveset="), *liveset);
      return false;
    }
    *out = NonTerminal(void);
    return true;
  }

  annotate(&gnc->plainly_live, {liveset->xored, liveset->summed});

  node *gr_node = ref_node(gr, gn);
  switch node {
  case &XOp(xn gr_xnode):
    nprecs size = count(&xn.precs);
    for i size = 0; i < nprecs; i = i + 1 {
      if !dumbly_analyze_returning_expression(h, gr, liveset, get(&xn.precs, i)) {
        return false;
      }
    }
  case &QOp(qn gr_qnode): { }
  }

  switch node_op(node) {
  case &GrApply(a gr_apply):
    // Retcell is activated _before_ the param cells are dead -- though we shouldn't be generating graphs where this matters for the purposes of this analysis _except_ that we need it for computing lower param lists.
    output(h, liveset, a.retcell);

    note_lower_paramlists(h, gn, liveset);
    annotate_ref(&gnc->app_time_live, liveset);

    deaden(liveset, a.funcell);
    nparams size = count(&a.params);
    for i size = 0; i < nparams; i = i + 1 {
      deaden(liveset, get(&a.params, i));
    }
    *out = Terminal(void);
    return true;

  case &GrPrimApply(a gr_prim_apply):
    output(h, liveset, a.retcell);

    nparams size = count(&a.params);
    for i size = 0; i < nparams; i = i + 1 {
      deaden(liveset, get(&a.params, i));
    }
    *out = Terminal(void);
    return true;

  case &GrMemCopy(a gr_memcopy):
    output(h, liveset, a.dest);
    input(liveset, a.src);
    *out = Terminal(void);
    return true;

  case &GrWriteConst(a gr_writeconst):
    output(h, liveset, a.dest);
    *out = Terminal(void);
    return true;

  case &GrAddressof(a gr_addressof):
    // Yes, addressee is an _output_ -- if it is not live -- we make it live.
    output(h, liveset, a.addressee);
    output(h, liveset, a.dest);
    *out = Terminal(void);
    return true;

  case &GrDeref(a gr_deref):
    input(liveset, a.pointer);
    check(!isLocationStatic(ref_cell(gr, a.name)->location));
    create(h, liveset, a.name);
    *out = Terminal(void);
    return true;

  case &GrSubcell(a gr_subcell):
    input(liveset, a.partof);
    check(!isLocationStatic(ref_cell(gr, a.name)->location));
    create(h, liveset, a.name);
    *out = Terminal(void);
    return true;

  case &GrBranch(a gr_branch):
    input(liveset, a.src);

    end_lives lives;
    combined_mut genexpr_result = NonTerminal(void);
    ncases size = count(&a.cases);
    for i size = 0; i < ncases; i = i + 1 {
      cas *tup[gr_const, sq_num] = ref(&a.cases, i);
      new_live lives = *liveset;
      casmut genexpr_result;
      if !dumbly_analyze_expression(h, gr, &new_live, cas->cdr.~, &casmut) {
        return false;
      }
      combine_branch_mut(&new_live, &combined_mut, casmut, &end_lives);
    }

    if case Has(def_gn sq_num) = a.default_case {
      new_live lives = *liveset;
      defcasmut genexpr_result;
      if !dumbly_analyze_expression(h, gr, &new_live, def_gn.~, &defcasmut) {
        return false;
      }
      combine_branch_mut(&new_live, &combined_mut, defcasmut, &end_lives);
    }

    // Yes this is empty of it's NonTerminal -- it doesn't matter.
    *liveset = end_lives;
    *out = combined_mut;
    return true;

  case &GrSequence(a gr_sequence):
    if !dumbly_analyze_returning_expression(h, gr, liveset, a.first) {
      return false;
    }
    return dumbly_analyze_expression(h, gr, liveset, a.second.~, out);

  case &GrJmp(a gr_jmp):
    return dumbly_analyze_expression(h, gr, liveset, a.next.~, out);

  case &GrWriteNothing(a gr_writenothing):
    output(h, liveset, a.dest);
    *out = Terminal(void);
    return true;

  case &GrDead(a gr_dead):
    deaden(liveset, a.cell);
    *out = Terminal(void);
    return true;

  case &GrVirtualDead(a gr_virtual_dead):
    deaden(liveset, a.cell);
    *out = Terminal(void);
    return true;

  case &GrXNop(v void):
    *out = Terminal(void);
    return true;

  case &GrQNop(v void):
    *out = Terminal(void);
    return true;
  }
}

func note_lower_paramlists(h *frame, our_gn gr_num, live_at_app_time *lives) void {
  paramlists array[gr_num];
  it hash_iter[cell_num, void] = iter(&live_at_app_time->all);
  while case Has(p *tup[cell_num, void]) = next(&it) {
    if case Has(gn gr_num) = ref(&h->bas->celldisp, p->car.~)->paramlist {
      if gn != our_gn {
        push(&paramlists, gn);
        discard bool = try_insert(&ref_annot(h, gn)->higher_paramlists, &our_gn, void);
      }
    }
  }

  sort(&paramlists);
  dedup_sorted(&paramlists);
  annotate_move(&ref_annot(h, our_gn)->lower_paramlists, &paramlists);
}

func combine_branch_mut(new_live *lives, onto *genexpr_result, case_mut genexpr_result, end_lives *lives) void {
  switch case_mut {
  case Terminal(v void):
    switch *onto {
    case Terminal(v2 void):
      if new_live->xored != end_lives->xored || new_live->summed != end_lives->summed {
        ice(_u8("terminal/terminal new_live not equal, end_lives="), *end_lives, _u8(", new_live="), *new_live);
      }
    case NonTerminal(v2 void):
      *onto = Terminal(void);
      *end_lives = *new_live;
    }
  case NonTerminal(v void): { }
  }
}

// For deaden and other functions, prelive shows what was alive _before_ prec_muts modified it.
func deaden(liveset *lives, c cell_num) void {
  if !try_remove(&liveset->all, &c) {
    ice(_u8("deaden on unlive cell "), c.~);
  }
  liveset->xored = liveset->xored ^ ~c.~;
  liveset->summed = liveset->summed - ~c.~;
}

// input requires that the cell already be live.
func input(liveset *lives, c cell_num) void {
  if case None(v void) = lookup_ref(&liveset->all, &c) {
    ice(_u8("input on unlive cell "), c.~);
  }
}

// output either makes the cell live, if it wasn't already, or it means we use the cell.
// (Yes, that's so lame -- we should add GrMakeLive.)
func output(h *frame, liveset *lives, c cell_num) void {
  if try_insert(&liveset->all, &c, void) {
    liveset->xored = liveset->xored ^ ~c.~;
    liveset->summed = liveset->summed + ~c.~;
    note_conflicting(h, &liveset->all, c);
  }
}

func create(h *frame, liveset *lives, c cell_num) void {
  // Both these places define the virtual cell.  So it should not be live.
  if !try_insert(&liveset->all, &c, void) {
    ice(_u8("virtual on live cell "), c.~);
  }
  liveset->xored = liveset->xored ^ ~c.~;
  liveset->summed = liveset->summed + ~c.~;
  note_conflicting(h, &liveset->all, c);
}

func note_conflicting(h *frame, all *hash[cell_num, void], c cell_num) void {
  // This also means conflicting is set to non-empty for any cell that's made live.
  c_disp *cell_disp = ref(&h->bas->celldisp, c.~);
  it hash_iter[cell_num, void] = iter(all);
  while case Has(p *tup[cell_num, void]) = next(&it) {
    d cell_num = p->car;
    d_disp *cell_disp = ref(&h->bas->celldisp, d.~);
    push(&c_disp->conflicting, d);
    push(&d_disp->conflicting, c);
  }
}

func ref_annot(h *frame, gn gr_num) *gn_annot {
  return ref(&h->by_gn, gn.~);
}
