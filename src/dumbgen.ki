import state;

deftype gn_annot struct {
  // Which cells are guaranteed to be live when the gn starts.
  live array[cell_num];
};

deftype frame struct {
  cs *checkstate;
  gr *frame_graph;
  bas *basic_analyze_state;
  // by_gn[i].fs shows what the state must is _before_ evaluating node i.  (All incoming nodes must agree!)
  by_gn array[opt[gn_annot]];
};

func dumbly_gen_graphed_fn_body(cs *checkstate, f *objfile, bas *basic_analyze_state, g *graphed_fn_body) bool {
  h frame = {cs, &g->graph.gr, bas, repeat(count(&g->graph.gr.ops), None())};

  prelive array[cell_num] = g->argcells;
  push(&prelive, g->graph.cell);
  sort(&prelive);

  mut exprmut;
  if !dumbly_gen_expression(&mut, cs, f, &h, &g->graph.gr, g->graph.gn, &prelive) {
    return false;
  }

  return true;
}

deftype exprmut struct {
  used array[cell_num];
  made_dead array[cell_num];
};

func dumbly_gen_expression(exprmut_append *exprmut, cs *checkstate, f *objfile, h *frame, gr *frame_graph, gn gr_num, prelive *array[cell_num]) bool {
  gnc *opt[gn_annot] = ref(&h->by_gn, gn.~);
  if case &Has(annot gn_annot) = gnc {
    if !array_equal(prelive, &annot.live) {
      ERR(_u8("Inconsistent liveness state when revisiting node."));
      return false;
    }
    return true;
  }

  prec_muts exprmut;

  node *gr_node = ref_node(gr, gn);
  nprecs size = count(&node->precs);
  for i size = 0; i < nprecs; i = i + 1 {
    if !dumbly_gen_expression(&prec_muts, cs, f, h, gr, get(&node->precs, i), prelive) {
      return false;
    }
  }

  if !collapse_combomut(&prec_muts) {
    return false;
  }

  switch &node->op {
  case &GrApply(a gr_apply):
  case &GrMemCopy(a gr_memcopy):
  case &GrWriteConst(a gr_writeconst):
  case &GrAddressof(a gr_addressof):
  case &GrDeref(a gr_deref):
  case &GrSubcell(a gr_subcell):
  case &GrBranch(a gr_branch):
  case &GrSequence(a gr_sequence):
  case &GrJmp(a gr_jmp):
  case &GrWriteNothing(a gr_writenothing):
  case &GrDead(a gr_dead):
  case &GrNop(v void):
  }
  return true;
}

func collapse_combomut(mut *exprmut) bool {
  sort(&mut->made_dead);
  if sorted_has_dups(&mut->made_dead) {
    ERR(_u8("ICE: multiple prec-exprs made the same cell dead"));
    return false;
  }

  sort(&mut->used);
  dedup_sorted(&mut->used);
  if sorted_intersect(&mut->made_dead, &mut->used) {
    ERR(_u8("ICE: One prec-expr marks cell dead that another uses"));
  }

  return true;
}

func ref_annot(h *frame, gn gr_num) *opt[gn_annot] {
  return ref(&h->by_gn, gn.~);
}
